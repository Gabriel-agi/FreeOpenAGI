<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Practice Mode / Cat Chat Toggle + Nav Buttons</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
        /* --- Basic Setup & Variables (Keep previous variables) --- */
        :root {
            --sim-primary: #007bff; --sim-secondary: #6c757d; --sim-background: #f8f9fa;
            --sim-panel-bg: #ffffff; --sim-text: #212529; --sim-light-text: #f8f9fa;
            --sim-code-bg: #2b2b2b; --sim-code-text: #a9b7c6;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --font-code: 'Consolas', 'Courier New', monospace;
            --border-radius: 8px; --success-color: #28a745; --error-color: #dc3545;
            --warning-color: #ffc107; --ai-message-bg: #f0f8ff;
            --cat-primary: #fca311; --cat-secondary: #14213d; --cat-mode-bg: #fffaf0;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { height: 100%; }
        body { font-family: var(--font-main); background-color: var(--sim-background); color: var(--sim-text); height: 100%; overflow: hidden; display: flex; }

        /* --- Main Container (No left margin now) --- */
        #main-container { display: flex; width: 100%; height: 100%; background-color: var(--sim-secondary); }

        /* --- Playground Area --- */
        #playground-area { flex: 1; background-color: var(--sim-panel-bg); display: flex; flex-direction: column; height: 100%; border-right: 3px solid var(--sim-primary); box-shadow: 2px 0 5px rgba(0,0,0,0.1); transition: border-color 0.3s ease; }
        .playground-header { background-color: var(--sim-secondary); color: var(--sim-light-text); padding: 10px 15px; font-size: 1.1em; font-weight: bold; flex-shrink: 0; border-bottom: 2px solid var(--sim-primary); transition: background-color 0.3s ease, border-color 0.3s ease; }
        .playground-header .fa-icon { margin-right: 8px; color: var(--sim-primary); transition: color 0.3s ease;}
        #playground-content { padding: 20px; flex-grow: 1; overflow-y: auto; font-size: 0.95em; line-height: 1.6; position: relative; /* For positioning buttons */ display: flex; flex-direction: column; } /* Flex direction */
        /* --- NEW Nav Buttons Container --- */
        #nav-buttons-container {
            margin-top: auto; /* Push buttons to the bottom */
            padding-top: 20px; /* Space above buttons */
            border-top: 1px solid #eee; /* Separator */
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            gap: 10px; /* Spacing between buttons */
            justify-content: center; /* Center buttons */
            flex-shrink: 0; /* Prevent shrinking */
        }
        .nav-button {
            display: inline-flex; /* Use inline-flex */
            align-items: center; /* Vertically align icon and text */
            padding: 8px 12px;
            font-size: 0.85em;
            color: var(--sim-light-text);
            background-color: var(--sim-secondary);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none; /* Remove underline from links */
            transition: background-color 0.2s ease, transform 0.1s ease;
            white-space: nowrap; /* Prevent text wrapping */
        }
        .nav-button i { margin-right: 6px; }
        .nav-button:hover { background-color: #5a6268; }
        .nav-button:active { transform: scale(0.98); }

        /* Rest of playground content styles */
        #playground-main-content { flex-grow: 1; /* Allow main content to take space */}
        #playground-main-content h3 { color: var(--sim-primary); margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 5px; transition: color 0.3s ease;}
        #playground-main-content h4 { color: #333; margin-top: 15px; margin-bottom: 8px; }
        #playground-main-content p { margin-bottom: 10px; }
        #playground-main-content pre { background-color: var(--sim-code-bg); color: var(--sim-code-text); padding: 15px; border-radius: var(--border-radius); font-family: var(--font-code); white-space: pre-wrap; word-wrap: break-word; margin-top: 10px; font-size: 0.9em; border: 1px solid #444; box-shadow: inset 0 0 5px rgba(0,0,0,0.3); }
        .code-keyword { color: #cc7832; font-weight: bold; } .code-string { color: #6a8759; } .code-comment { color: #808080; font-style: italic; } .code-function { color: #ffc66d; } .code-paren { color: #bbb; }
        .playground-text-display i { display: block; background-color: #f0f0f0; padding: 10px; border-radius: 4px; border-left: 3px solid var(--sim-primary); transition: border-color 0.3s ease; }

        /* Hide playground main content in cat mode */
        body.cat-mode #playground-main-content { display: none; }
        body.cat-mode #playground-content::before { content: "\f1b0 \A Cat Chat Mode Active"; font-family: "Font Awesome 6 Free"; font-weight: 900; font-size: 2em; opacity: 0.3; white-space: pre; line-height: 1.2; text-align: center; margin: auto; /* Center vertically and horizontally */}
        body.cat-mode #nav-buttons-container { margin-top: 20px; /* Adjust margin when content is hidden */ justify-content: center;} /* Ensure buttons stay centered */


        /* --- Chatbot Area (Keep styles mostly the same) --- */
        #chatbot-container { display: flex; flex-direction: column; width: 400px; min-width: 350px; height: 100%; border-left: 3px solid var(--sim-primary); background: var(--sim-panel-bg); transition: border-color 0.3s ease, background-color 0.3s ease; }
        #message-list { flex-grow: 1; overflow-y: auto; padding: 15px; border-bottom: 1px solid #eee; background: #fdfdfd; transition: background-color 0.3s ease;}
        #input-container { display: flex; padding: 10px 15px; background: #f9f9f9; flex-shrink: 0; border-top: 1px solid #eee; }
        #messageInput { flex-grow: 1; padding: 10px; margin-right: 10px; border: 1px solid #ccc; border-radius: 18px; resize: none; font-size: 1em; line-height: 1.4; height: 38px; overflow-y: hidden; transition: border-color 0.2s ease; }
        #messageInput:focus { outline: none; border-color: var(--sim-primary); }
        #messageInput:disabled { background-color: #eee; cursor: not-allowed; }
        .button-wrapper { display: flex; align-items: center; }
        #sendMessageBtn { padding: 0 15px; cursor: pointer; background: var(--sim-primary); color: white; border: none; border-radius: 50%; font-size: 1.1em; display: flex; align-items: center; justify-content: center; width: 40px; height: 40px; transition: background-color 0.3s ease; margin-right: 8px; }
        #sendMessageBtn:hover:not(:disabled) { background: #0056b3; }
        #sendMessageBtn:disabled { background: #aaa; cursor: not-allowed; opacity: 0.7;}
        #toggleModeBtn { padding: 0; cursor: pointer; background: var(--sim-secondary); color: white; border: none; border-radius: 50%; font-size: 1.1em; display: flex; align-items: center; justify-content: center; width: 40px; height: 40px; transition: background-color 0.3s ease, transform 0.3s ease; }
        #toggleModeBtn:hover { background: #5a6268; transform: scale(1.05); }
        #toggleModeBtn .fa-icon { transition: transform 0.3s ease-in-out; }
        #status-bar { padding: 6px 15px; background: var(--sim-secondary); color: white; font-size: 0.8em; flex-shrink: 0; height: 28px; display: flex; align-items: center; transition: background-color 0.3s ease;}
        #status-bar .icon { margin-right: 8px; width: 1.2em; text-align: center;}
        #status-bar .text { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* Message Styling */
        .message { margin-bottom: 12px; padding: 10px 15px; border-radius: 15px; max-width: 85%; word-wrap: break-word; line-height: 1.45; box-shadow: 0 1px 2px rgba(0,0,0,0.08); opacity: 0; animation: messageFadeIn 0.4s ease-out forwards; }
        @keyframes messageFadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        .user-message { background-color: var(--sim-primary); color: white; margin-left: auto; border-bottom-right-radius: 5px; transition: background-color 0.3s ease;}
        .bot-message { background-color: #e9ecef; color: var(--sim-text); margin-right: auto; border-bottom-left-radius: 5px; }
        .bot-message.ai-response { background-color: var(--ai-message-bg); border-left: 4px solid #75aadb; }
        .bot-message.task-prompt { font-weight: 500; border-left: 4px solid var(--sim-primary); transition: border-color 0.3s ease;}
        .bot-feedback { border-left-width: 4px; border-left-style: solid; padding-left: 12px; }
        .bot-feedback.correct { border-left-color: var(--success-color); background-color: #eaf7ec; }
        .bot-feedback.incorrect { border-left-color: var(--error-color); background-color: #fdecea; }
        .bot-feedback.maybe { border-left-color: var(--warning-color); background-color: #fff8e1; }
        .bot-feedback strong::before { margin-right: 6px; font-family: "Font Awesome 6 Free"; font-weight: 900; font-size: 1.1em; display: inline-block; width: 1.2em; }
        .bot-feedback.correct strong::before { content: "\f058"; color: var(--success-color); }
        .bot-feedback.incorrect strong::before { content: "\f057"; color: var(--error-color);}
        .bot-feedback.maybe strong::before { content: "\f12a"; color: var(--warning-color); }
        .error-display { background-color: #f8d7da; color: #721c24; margin-right: auto; border: 1px solid #f5c6cb; font-weight: bold; border-radius: 5px; padding: 10px 15px; margin-bottom: 12px; }

        /* Cat Mode Specific Styles */
        body.cat-mode #playground-area { border-right-color: var(--cat-primary); }
        body.cat-mode .playground-header { background-color: var(--cat-secondary); border-bottom-color: var(--cat-primary); }
        body.cat-mode .playground-header .fa-icon { color: var(--cat-primary); }
        body.cat-mode #chatbot-container { border-left-color: var(--cat-primary); }
        body.cat-mode #message-list { background-color: var(--cat-mode-bg); }
        body.cat-mode #status-bar { background-color: var(--cat-secondary); }
        body.cat-mode .user-message { background-color: var(--cat-primary); }
        body.cat-mode #messageInput:focus { border-color: var(--cat-primary); }
        body.cat-mode #sendMessageBtn { background-color: var(--cat-primary); }
        body.cat-mode #sendMessageBtn:hover:not(:disabled) { background-color: #e0930f; }
        body.cat-mode .bot-message.ai-response { background-color: #fff0f5; border-left-color: #ffb6c1; } /* Lavender blush / Pink for cat AI */
        body.cat-mode .bot-message.task-prompt { display: none; }
        body.cat-mode .nav-button { background-color: var(--cat-secondary); } /* Adjust nav button color in cat mode */
        body.cat-mode .nav-button:hover { background-color: #2a3f6d; }


        /* Responsive */
         @media (max-width: 768px) {
             #main-container { flex-direction: column; }
             #playground-area { order: 1; /* Show playground first */ border-right: none; border-bottom: 3px solid var(--sim-primary); height: 50%; /* Adjust height split */ flex-basis: 50%; flex-grow: 0;}
             #chatbot-container { order: 2; /* Chat below */ width: 100%; height: 50%; border-left: none; flex-basis: 50%; flex-grow: 0;}
             #messageInput { max-height: 100px; }
             #nav-buttons-container { justify-content: flex-start; /* Align left on small screens */}
         }
         @media (max-width: 480px) {
             #playground-content { padding: 15px; }
             #message-list { padding: 10px; }
             .message { max-width: 90%; }
             #messageInput { font-size: 0.95em;}
             #sendMessageBtn, #toggleModeBtn { width: 38px; height: 38px; font-size: 1em;}
             .nav-button { font-size: 0.8em; padding: 6px 10px; }
             #playground-area { height: 40%; flex-basis: 40%; }
             #chatbot-container { height: 60%; flex-basis: 60%; }
         }

    </style>
</head>
<body class="practice-mode">

    <div id="main-container">
        <!-- Playground Area -->
        <div id="playground-area">
            <div class="playground-header">
                <i class="fas fa-tasks fa-icon"></i>
                <span id="playground-title">Task Information</span>
            </div>
            <div id="playground-content">
                <!-- Main content area -->
                <div id="playground-main-content">
                     <p>Welcome! Instructions will appear here. Ask general programming questions anytime.</p>
                </div>
                <!-- Nav buttons container at the bottom -->
                <div id="nav-buttons-container">
                     <!-- Replace # with your actual hrefs later -->
                    <a href="#" class="nav-button"><i class="fas fa-home"></i> Menu</a>
                    <a href="#" class="nav-button"><i class="fas fa-book"></i> Theory</a>
                    <a href="#" class="nav-button"><i class="fas fa-pencil-alt"></i> Basic Practice</a>
                    <a href="#" class="nav-button"><i class="fas fa-flask"></i> Advanced Practice</a>
                    <a href="#" class="nav-button"><i class="fas fa-graduation-cap"></i> Lesson</a>
                </div>
            </div>
        </div>

        <!-- Chatbot Interface Area -->
        <div id="chatbot-container">
            <div id="message-list">
                <!-- Messages will appear here -->
            </div>
            <div id="input-container">
                <textarea id="messageInput" placeholder="Enter answer or ask a question..." rows="1"></textarea>
                <div class="button-wrapper">
                    <button id="sendMessageBtn" title="Submit / Send">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                    <button id="toggleModeBtn" title="Switch to Cat Chat Mode">
                        <i class="fas fa-cat fa-icon"></i>
                    </button>
                </div>
            </div>
             <div id="status-bar">
                <span class="icon"><i class="fas fa-robot"></i></span>
                <span class="text">Status: Ready</span>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        console.log("Nav Buttons + Mode Toggle Script: DOM Loaded.");

        // --- Get References to Elements ---
        const messageList = document.getElementById('message-list');
        const messageInput = document.getElementById('messageInput');
        const sendMessageBtn = document.getElementById('sendMessageBtn');
        const toggleModeBtn = document.getElementById('toggleModeBtn');
        const statusBarText = document.querySelector('#status-bar .text');
        const statusIcon = document.querySelector('#status-bar .icon i');
        const playgroundContent = document.getElementById('playground-content'); // Container for main content + buttons
        const playgroundMainContent = document.getElementById('playground-main-content'); // Specific area for task info
        const playgroundHeaderIcon = document.querySelector('.playground-header .fa-icon');
        const playgroundTitle = document.getElementById('playground-title');
        const navButtonsContainer = document.getElementById('nav-buttons-container'); // Button container

        // --- State ---
        let currentQuestionIndex = -1;
        let currentTask = null;
        let isWaitingForNext = false;
        let isWaitingForAI = false;
        const State = {
            currentMode: 'practice',
            histories: {
                // Structure: { role: 'user'/'assistant', content: '...', type: 'task-prompt'/'correct'/'incorrect'/'maybe'/'ai-response'/'error'(optional) }
                practice: [],
                cat: []
            }
        };

        // --- Configuration ---
        const Config = {
            proxyUrl: '/api/proxy', // CRITICAL: Update if needed
            model: "glm-4-flash",
            temperature: 0.7,
            max_tokens: 350,
            standardSystemPrompt: "You are a helpful AI assistant explaining basic Python programming concepts clearly and concisely. Answer the user's questions related to Python or programming in general.",
            evaluationSystemPrompt: "You are evaluating a student's answer to a basic Python programming task. The user's message contains the task details, their answer, and evaluation criteria. First, determine if the user's input seems like a genuine attempt to answer the specific TASK, or if it looks like a general QUESTION (even if related). If it's an ANSWER attempt, evaluate it against the CRITERIA. If it's a QUESTION, ignore the criteria and answer the question helpfully. VERY IMPORTANT: Start your response *immediately* with ONLY ONE of the following prefixes, followed by a colon and then your explanation:\n- YES: (If the input is an ANSWER attempt and CORRECTLY meets the criteria)\n- NO: (If the input is an ANSWER attempt and INCORRECTLY meets the criteria)\n- MAYBE: (If the input is an ANSWER attempt and is partially correct, ambiguous, or needs clarification)\n- QUESTION: (If the input appears to be a general QUESTION, not an answer attempt)\nDo not add any text before the prefix.",
            catSystemPrompt: "You are a quirky, slightly lazy, but ultimately helpful cat AI assistant. Respond to user questions and chat messages in character. Use cat puns (meow, purr, paw-some, fur-real), mention cat behaviors (*stretches*, *yawns*, *bats at screen*), but still provide accurate and helpful information when asked programming questions. Keep your answers relatively concise.",
            nextQuestionDelay: 1500,
            aiTypingDelay: 800
        };

        // --- Question Bank ---
        const QuestionBank = [
             { id: 'print_hello', prompt: "Let's start! Write the Python code to print the exact text 'Hello, Python!' to the screen.", aiCriteria: "The code must use the print() function to output the exact string 'Hello, Python!'. Single or double quotes are acceptable.", visual_aid_type: 'code_editor_display', visual_aid_content: "# Task: Print 'Hello, Python!'" },
             { id: 'comment_write', prompt: "Good! Now, write a Python comment that says exactly: # This is a comment", aiCriteria: "The response must be a single line starting exactly with '#' followed by a space and the text 'This is a comment'.", visual_aid_type: 'code_editor_display', visual_aid_content: "# Task: Write the comment '# This is a comment'" },
             { id: 'print_blank', prompt: "How do you write the Python code to print just a blank line?", aiCriteria: "The code should be exactly `print()`. It must include the parentheses.", visual_aid_type: 'code_editor_display', visual_aid_content: "# Task: Print a blank line using Python." },
             { id: 'concept_print', prompt: "In your own words, what does the `print()` function *do* in Python?", aiCriteria: "The student should explain that print() displays output (text, values, etc.) to the screen/console. Key concepts: display, output, show, screen, console, terminal.", visual_aid_type: 'text_display', visual_aid_content: "Task: Explain the purpose of the `print()` function." },
             { id: 'end', prompt: "Great job! You've completed the basic practice tasks. Feel free to ask any general Python questions now, or switch to Cat Chat mode!", aiCriteria: null, visual_aid_type: 'text_display', visual_aid_content: "Practice Complete!" }
        ];

        // --- UI Functions ---
        const UI = {
            // --- addMessage (Modified to store type correctly) ---
            addMessage: (sender, text, type = '', targetList = messageList) => {
                if (!targetList) return;
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('message');
                messageDiv.classList.add(sender === 'user' ? 'user-message' : 'bot-message');

                 // Determine display type for bot messages
                 let displayType = type;
                 if (sender === 'bot') {
                     if (!displayType) displayType = 'ai-response'; // Default bot msg type if none provided
                     messageDiv.classList.add(displayType); // Add base type class

                     // Add specific feedback classes if applicable
                     if (displayType === 'correct' || displayType === 'incorrect' || displayType === 'maybe') {
                         messageDiv.classList.add('bot-feedback'); // Add feedback base class
                     }
                 }

                 // Set content
                 if (sender === 'bot' && (displayType === 'correct' || displayType === 'incorrect' || displayType === 'maybe')) {
                    messageDiv.innerHTML = `<strong></strong>${text}`; // Use strong for icon pseudo-element
                 } else if (type === 'error') { // Handle specific error type display
                     messageDiv.classList.add('error-display'); // Use distinct styling for errors
                     messageDiv.textContent = `Error: ${text}`;
                 }
                  else {
                     messageDiv.textContent = text; // Standard text display
                 }

                targetList.appendChild(messageDiv);
                if (targetList === messageList) {
                    // Ensure scroll happens after message is rendered
                     requestAnimationFrame(() => {
                        messageList.scrollTop = messageList.scrollHeight;
                    });
                }
                 // Return the created element if needed (e.g., for immediate modification)
                 return messageDiv;
            },

            updateStatus: (text, isBusy = false) => {
                 // ...(Same as previous version)...
                 if (statusBarText) statusBarText.textContent = `Status: ${text}`;
                 const currentlyBusy = isWaitingForNext || isWaitingForAI || isBusy;
                 if (sendMessageBtn) sendMessageBtn.disabled = currentlyBusy;
                 if (toggleModeBtn) toggleModeBtn.disabled = currentlyBusy;
                 if (messageInput) messageInput.disabled = currentlyBusy;
                 if (messageInput && !messageInput.disabled) messageInput.focus();
            },

            // --- updatePlayground (Updates only main content area) ---
             updatePlayground: (task) => {
                 if (!playgroundMainContent) return; // Target the main content div
                 if (!task || State.currentMode === 'cat') {
                     playgroundMainContent.innerHTML = ""; // Clear only the main content
                     return;
                 }
                 // Construct HTML for the task details
                 let contentHTML = `<h3>Task: ${task.id.replace(/_/g, ' ')}</h3><p>${task.prompt}</p>`;
                 const visualContent = task.visual_aid_content || '';
                 const escapedVisualContent = (typeof visualContent === 'string' ? visualContent : '').replace(/</g, "<").replace(/>/g, ">");
                 if (task.visual_aid_type === 'code_editor_display') { contentHTML += `<h4>Instructions / Example:</h4><pre id="code-display-area">${escapedVisualContent}</pre>`; }
                 else if (task.visual_aid_type === 'text_display') { contentHTML += `<div class="playground-text-display"><i>${escapedVisualContent}</i></div>`; }
                 // Set the innerHTML of the main content area
                 playgroundMainContent.innerHTML = contentHTML;
             },

             updateCodeDisplay: (code) => {
                 // ...(Same as previous version)...
                 const codeArea = document.getElementById('code-display-area');
                 if (codeArea) {
                     let escapedCode = code.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">");
                     let highlightedCode = escapedCode.replace(/^(#.*)$/gm, '<span class="code-comment">$1</span>').replace(/\b(print)\b/g, '<span class="code-keyword">$1</span>').replace(/(".*?"|'.*?')/g, '<span class="code-string">$1</span>').replace(/(\(|\))/g, '<span class="code-paren">$1</span>');
                     codeArea.innerHTML = highlightedCode;
                 }
             },

            autoResizeTextarea: () => {
                 // ...(Same as previous version)...
                 if (!messageInput) return;
                 messageInput.style.height = 'auto';
                 const maxHeight = 150;
                 messageInput.style.height = Math.min(messageInput.scrollHeight, maxHeight) + 'px';
            },

            // --- loadHistoryToChat (Uses stored type) ---
            loadHistoryToChat: (historyArray) => {
                if (!messageList) return;
                messageList.innerHTML = '';
                const fragment = document.createDocumentFragment();
                historyArray.forEach(msg => {
                    // Pass the stored type directly to addMessage
                    UI.addMessage(msg.role, msg.content, msg.type || '', fragment);
                });
                messageList.appendChild(fragment);
                requestAnimationFrame(() => { messageList.scrollTop = messageList.scrollHeight; });
            },

             // --- setModeUI (Updates button container visibility too) ---
             setModeUI: (mode) => {
                 const isPractice = mode === 'practice';
                 document.body.classList.toggle('cat-mode', !isPractice);
                 document.body.classList.toggle('practice-mode', isPractice);

                 if (toggleModeBtn) {
                     toggleModeBtn.title = isPractice ? "Switch to Cat Chat Mode" : "Switch to Practice Mode";
                     toggleModeBtn.innerHTML = `<i class="fas ${isPractice ? 'fa-cat' : 'fa-robot'} fa-icon"></i>`;
                 }
                 if (statusIcon) statusIcon.className = `fas ${isPractice ? 'fa-robot' : 'fa-cat'}`;
                 if (playgroundHeaderIcon) playgroundHeaderIcon.className = `fas ${isPractice ? 'fa-tasks' : 'fa-comments'} fa-icon`;
                 if (playgroundTitle) playgroundTitle.textContent = isPractice ? "Task Information" : "Cat Chat";
                 if (messageInput) messageInput.placeholder = isPractice ? (currentTask && currentTask.id !== 'end' ? "Enter your answer..." : "Ask a general question...") : "Chat with the cat AI...";

                 // Update status text
                 let statusMsg = "Ready";
                 if (isPractice) {
                     const totalTasks = QuestionBank.length - 1;
                     const currentTaskNum = Math.min(currentQuestionIndex + 1, totalTasks);
                     statusMsg = currentTask ? (currentTask.id === 'end' ? "Practice Complete" : `Task ${currentTaskNum}/${totalTasks}: ${currentTask.id}`) : "Ready";
                 } else { statusMsg = "Cat Chat Mode"; }
                 UI.updateStatus(statusMsg, isWaitingForAI || isWaitingForNext);

                 UI.updatePlayground(isPractice ? currentTask : null); // Update main playground content

                  // Show/hide nav buttons based on mode (optional, or keep always visible)
                  // if (navButtonsContainer) {
                  //    navButtonsContainer.style.display = isPractice ? 'flex' : 'none'; // Example: hide in cat mode
                  // }
            }
        };


        // --- Function to Proceed to Next Question (Practice Mode Only) ---
         const nextQuestion = () => {
             if (State.currentMode !== 'practice') return;
             currentQuestionIndex++;
             isWaitingForNext = false;

             if (currentQuestionIndex < QuestionBank.length) {
                 currentTask = QuestionBank[currentQuestionIndex];
                 console.log(`PRACTICE: Loading Task: ${currentTask.id}`);
                 UI.updatePlayground(currentTask);

                 // Store and display task prompt
                 const taskPromptMsg = { role: 'assistant', content: currentTask.prompt, type: 'task-prompt' };
                 State.histories.practice.push(taskPromptMsg);
                 // Only display if currently in practice mode
                 if (State.currentMode === 'practice') {
                    UI.addMessage('bot', currentTask.prompt, 'task-prompt');
                 }

                 const totalTasks = QuestionBank.length - 1;
                 const currentTaskNum = Math.min(currentQuestionIndex + 1, totalTasks);
                 const statusMsg = currentTask.id === 'end' ? "Practice Complete" : `Task ${currentTaskNum}/${totalTasks}: ${currentTask.id}`;
                 UI.updateStatus(statusMsg, false);

                 if(messageInput) {
                     messageInput.placeholder = (currentTask.id === 'end') ? "Ask a general question..." : "Enter your answer...";
                 }

             } else {
                 console.log("PRACTICE: End of sequence.");
                 currentTask = null;
                 UI.updatePlayground(null);
                 UI.updateStatus("Practice Complete! Ask questions or switch mode.", false);
                 if(messageInput) {
                     messageInput.placeholder = "Ask a general question...";
                 }
             }
              if (messageInput && !isWaitingForAI && !isWaitingForNext) messageInput.focus();
         };


        // --- Toggle Mode Function ---
        const toggleMode = () => {
             if (isWaitingForAI || isWaitingForNext) return;
             console.log(`Toggling mode from ${State.currentMode}`);
             State.currentMode = (State.currentMode === 'practice') ? 'cat' : 'practice';
             console.log(`New mode: ${State.currentMode}`);
             UI.loadHistoryToChat(State.histories[State.currentMode]);
             UI.setModeUI(State.currentMode);
             console.log(`Mode switched. Displaying ${State.currentMode} history.`);
        };

        // --- Create Evaluation Prompt for AI ---
        const createAIEvaluationPrompt = (task, userAnswer) => {
             // ...(Same function as before)...
             if (!task || !task.aiCriteria) return null;
             if (task.visual_aid_type === 'code_editor_display') { UI.updateCodeDisplay(userAnswer); }
             const promptContent = `
TASK PROMPT: "${task.prompt}"
STUDENT ANSWER: "${userAnswer}"
EVALUATION CRITERIA: ${task.aiCriteria}
---
Instructions for AI (already in System Prompt, reiterated here for clarity):
Based on the above, is the STUDENT ANSWER a valid attempt to address the TASK PROMPT according to the EVALUATION CRITERIA, or is it a general QUESTION? Respond with YES:, NO:, MAYBE:, or QUESTION: followed by your explanation.
`;
             console.log("Evaluation: Created prompt content for LLM.");
             return promptContent;
        };

        // --- Parse Simple YES/NO/MAYBE/QUESTION Response ---
        const parseSimpleEvaluation = (responseText) => {
             // ...(Same function as before)...
             console.log("Evaluation: Attempting to parse AI response:", responseText);
             if (!responseText) return { result: 'maybe', explanation: "Received an empty response from the AI." };
             const upperResponse = responseText.toUpperCase();
             let result = 'maybe'; let explanation = `The AI response format was unexpected: "${responseText}"`;
             if (upperResponse.startsWith("YES:")) { result = 'correct'; explanation = responseText.substring(4).trim(); console.log("Evaluation: Parsed as CORRECT"); }
             else if (upperResponse.startsWith("NO:")) { result = 'incorrect'; explanation = responseText.substring(3).trim(); console.log("Evaluation: Parsed as INCORRECT"); }
             else if (upperResponse.startsWith("MAYBE:")) { result = 'maybe'; explanation = responseText.substring(6).trim(); console.log("Evaluation: Parsed as MAYBE/CLARIFICATION"); }
             else if (upperResponse.startsWith("QUESTION:")) { result = 'question'; explanation = responseText.substring(9).trim(); console.log("Evaluation: Parsed as QUESTION"); }
             else { console.warn("Evaluation: Response did not start with YES:, NO:, MAYBE:, or QUESTION:"); }
             return { result: result, explanation: explanation };
        };

         // --- API Module ---
         const API = {
            // ...(Same function as before)...
             fetchChatResponse: async (messages, systemPrompt = Config.standardSystemPrompt) => {
                 console.log(`API: Calling proxy with system prompt type: ${systemPrompt === Config.evaluationSystemPrompt ? 'Evaluation' : (systemPrompt === Config.catSystemPrompt ? 'Cat' : 'Standard')}`);
                 isWaitingForAI = true;
                 UI.updateStatus("AI is thinking...", true);

                 const messagesToSend = [{ role: "system", content: systemPrompt }, ...messages.filter(m => m.role !== 'system')];
                 // console.log("API: Sending messages:", JSON.stringify(messagesToSend)); // DEBUG

                 try {
                     const response = await fetch(Config.proxyUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ model: Config.model, messages: messagesToSend, temperature: Config.temperature, max_tokens: Config.max_tokens }) });
                     console.log("API: Proxy response status:", response.status);
                     await new Promise(resolve => setTimeout(resolve, Config.aiTypingDelay));
                     if (!response.ok) { const errorText = await response.text(); let detail = errorText; try { detail = JSON.parse(errorText).error?.message || errorText; } catch(e) {} throw new Error(`Request failed (${response.status}). ${detail}`); }
                     const data = await response.json();
                     if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) { return data.choices[0].message.content.trim(); }
                     else { throw new Error("Invalid API response structure."); }
                 } catch (error) {
                     console.error('API: Fetch failed:', error);
                     // Add error to the *currently viewed* history/UI
                     UI.addMessage('bot', `Error communicating with AI: ${error.message}`, 'error');
                     return null;
                 } finally {
                     isWaitingForAI = false;
                     // Update status based on the *current* mode after AI finishes
                     const isPractice = State.currentMode === 'practice';
                     let statusMsg = "Ready";
                     if (isPractice) {
                          const totalTasks = QuestionBank.length - 1;
                          const currentTaskNum = Math.min(currentQuestionIndex + 1, totalTasks);
                          statusMsg = currentTask ? (currentTask.id === 'end' ? "Practice Complete" : `Task ${currentTaskNum}/${totalTasks}: ${currentTask.id}`) : "Ready";
                     } else { statusMsg = "Cat Chat Mode"; }
                     // Only set busy to false if the other flag is also false
                     UI.updateStatus(statusMsg, isWaitingForNext);
                 }
             }
         };

        // --- Main Send Message Handler (Mode Aware) ---
        const handleSendMessage = async () => {
            if (!messageInput || isWaitingForNext || isWaitingForAI) return;

            const userText = messageInput.value.trim();
            if (!userText) return;

            console.log(`Handling send in mode: ${State.currentMode}, Text: "${userText}"`);
            UI.addMessage('user', userText); // Display in current view

            const activeHistory = State.histories[State.currentMode];
            // Store user message simply (type isn't needed for user messages)
            activeHistory.push({ role: "user", content: userText });

            messageInput.value = '';
            UI.autoResizeTextarea();

            // --- Practice Mode Logic ---
            if (State.currentMode === 'practice') {
                let isTaskActive = currentTask && currentTask.id !== 'end';

                if (isTaskActive) {
                    console.log(`PRACTICE: Task active (${currentTask.id}). Sending for AI evaluation.`);
                    const evaluationPromptContent = createAIEvaluationPrompt(currentTask, userText);

                    if (evaluationPromptContent) {
                        const tempEvalHistory = activeHistory.slice(0, -1); // History BEFORE user's raw message
                        tempEvalHistory.push({ role: "user", content: evaluationPromptContent }); // Add eval prompt content

                        const aiResponseText = await API.fetchChatResponse(tempEvalHistory, Config.evaluationSystemPrompt);

                        if (aiResponseText !== null) {
                            const evaluation = parseSimpleEvaluation(aiResponseText);
                            // Store AI's explanation with its parsed type
                            const assistantMsg = { role: "assistant", content: evaluation.explanation, type: evaluation.result };
                            activeHistory.push(assistantMsg);
                            // Display feedback styled by evaluation result
                            UI.addMessage('bot', evaluation.explanation, evaluation.result);

                            if (evaluation.result === 'question') {
                                console.log("PRACTICE: AI identified input as QUESTION");
                                const statusMsg = `Task ${currentQuestionIndex + 1}/${QuestionBank.length -1}: ${currentTask.id}`;
                                UI.updateStatus(statusMsg, false); // Keep task active
                            } else if (evaluation.result === 'correct') {
                                console.log("PRACTICE: AI Evaluation: Correct");
                                UI.updateStatus("Correct! Loading next task...", true);
                                isWaitingForNext = true;
                                setTimeout(nextQuestion, Config.nextQuestionDelay);
                            } else { // Incorrect or Maybe
                                console.log(`PRACTICE: AI Evaluation: ${evaluation.result}`);
                                const statusMsg = evaluation.result === 'incorrect' ? "Incorrect." : "Clarification needed.";
                                UI.updateStatus(statusMsg + " Please try again.", false);
                            }
                        } else { console.log("PRACTICE: AI evaluation call failed."); }
                    } else { console.error("PRACTICE: Failed to create evaluation prompt."); UI.updateStatus("Error preparing evaluation", false); }

                } else { // General query within practice mode
                     console.log("PRACTICE: Handling as general AI query.");
                     const botResponse = await API.fetchChatResponse(activeHistory, Config.standardSystemPrompt);
                     if (botResponse !== null) {
                         const aiMsg = { role: "assistant", content: botResponse, type: 'ai-response' };
                         activeHistory.push(aiMsg);
                         UI.addMessage('bot', botResponse, 'ai-response');
                     }
                }
            }
            // --- Cat Mode Logic ---
            else if (State.currentMode === 'cat') {
                console.log("CAT: Handling as general AI query.");
                const botResponse = await API.fetchChatResponse(activeHistory, Config.catSystemPrompt);
                if (botResponse !== null) {
                    const aiMsg = { role: "assistant", content: botResponse, type: 'ai-response' };
                    activeHistory.push(aiMsg);
                    UI.addMessage('bot', botResponse, 'ai-response');
                }
            }
        };


        // --- Event Listeners & Initialize ---
        if (sendMessageBtn && toggleModeBtn && messageInput && messageList && statusBarText && playgroundContent && navButtonsContainer) { // Check nav container too
             console.log("All elements found. Adding listeners.");
             sendMessageBtn.addEventListener('click', handleSendMessage);
             toggleModeBtn.addEventListener('click', toggleMode);

             messageInput.addEventListener('keypress', (event) => {
                 if (event.key === 'Enter' && !event.shiftKey) {
                     event.preventDefault();
                     if (!isWaitingForNext && !isWaitingForAI) handleSendMessage();
                 }
             });
             messageInput.addEventListener('input', UI.autoResizeTextarea);

             // --- Initial Setup ---
             console.log("Initializing practice + AI + Mode Toggle + Nav Buttons...");
             UI.updateStatus("Initializing...", true);
             State.histories.practice = [];
             State.histories.cat = [];
             const welcomeMsg = "Welcome! I'll guide you through some Python tasks. Answer the prompts, or ask general questions anytime. Use the button next to Send to switch to Cat Chat mode!";
             const welcomeMsgObj = { role: "assistant", content: welcomeMsg, type: 'ai-response' };
             State.histories.practice.push(welcomeMsgObj);
             UI.addMessage('bot', welcomeMsg, 'ai-response');

             setTimeout(nextQuestion, 1000); // Load the first practice question
             UI.setModeUI('practice'); // Set initial UI state

        } else {
            console.error("Initialization failed: One or more essential elements are missing.");
             const errorMsg = "CRITICAL ERROR: Could not initialize interface. Check console (F12).";
             if (statusBarText) statusBarText.textContent = errorMsg;
             const errorDiv = document.createElement('div');
             errorDiv.classList.add('error-display');
             errorDiv.textContent = errorMsg;
             if(messageList) messageList.appendChild(errorDiv); else document.body.prepend(errorDiv);
        }

    }); // End DOMContentLoaded
    </script>

</body>
</html>
