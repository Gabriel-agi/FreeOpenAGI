<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Professor Paws's Python Playground</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Add Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
        /* --- Basic Setup & Variables --- */
        :root {
            --cat-primary: #fca311; /* Orange */
            --cat-secondary: #14213d; /* Dark Blue */
            --cat-background: #e5e5e5; /* Light Grey */
            --cat-text: #000000;
            --cat-light-text: #ffffff;
            --cat-code-bg: #2b2b2b;
            --cat-code-text: #a9b7c6;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Common system font */
            --font-code: 'Consolas', 'Courier New', Courier, monospace;
            --border-radius: 8px;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { height: 100%; }
        body {
            font-family: var(--font-main);
            background-color: var(--cat-background);
            color: var(--cat-text);
            height: 100%;
            overflow: hidden; /* Prevent body scroll */
            display: flex;
        }

        #main-container {
            display: flex;
            width: 100%;
            height: 100%;
            background-color: var(--cat-secondary); /* Background between panels */
        }

        /* --- Playground Area (Left/Top) --- */
        #playground-area {
            flex: 1; /* Takes up remaining space */
            background-color: var(--cat-light-text);
            display: flex;
            flex-direction: column;
            height: 100%;
            border-right: 5px solid var(--cat-primary);
        }

        .playground-header {
            background-color: var(--cat-secondary);
            color: var(--cat-light-text);
            padding: 10px 15px;
            font-size: 1.1em;
            font-weight: bold;
            flex-shrink: 0; /* Prevent shrinking */
            border-bottom: 2px solid var(--cat-primary);
        }
        .playground-header .fa-cat { margin-right: 8px; color: var(--cat-primary); }

        #playground-content {
            padding: 20px;
            flex-grow: 1;
            overflow-y: auto;
            font-size: 0.95em;
            line-height: 1.6;
        }
        #playground-content h3 { color: var(--cat-secondary); margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 5px;}
        #playground-content h4 { color: #333; margin-top: 15px; margin-bottom: 8px; }
        #playground-content p { margin-bottom: 10px; }
        #playground-content pre {
            background-color: var(--cat-code-bg);
            color: var(--cat-code-text);
            padding: 15px;
            border-radius: var(--border-radius);
            font-family: var(--font-code);
            white-space: pre-wrap; /* Wrap long lines */
            word-wrap: break-word;
            margin-top: 10px;
            font-size: 0.9em;
            border: 1px solid #444;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
        }
        /* Basic Syntax Highlighting */
        .code-keyword { color: #cc7832; font-weight: bold; }
        .code-string { color: #6a8759; }
        .code-comment { color: #808080; font-style: italic; }
        .code-function { color: #ffc66d; }
        .code-paren { color: #bbb; }
        .playground-text-display i {
            display: block;
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 4px;
            border-left: 3px solid var(--cat-primary);
        }


        /* --- Chatbot Area (Right/Bottom) --- */
        #chatbot-area {
            width: 400px; /* Adjust as needed */
            min-width: 350px;
            background-color: #f0f0f0; /* Lighter background for chat */
            display: flex;
            flex-direction: column;
            height: 100%;
            border-left: 5px solid var(--cat-primary);
        }

        #chatbox {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            border-bottom: 1px solid #ccc;
            background-color: #fafafa;
        }

        .message {
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: var(--border-radius);
            max-width: 90%;
            word-wrap: break-word;
            line-height: 1.5;
            position: relative; /* For potential decorations */
            animation: fadeIn 0.4s ease-out;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .message strong { /* Label */
            display: block;
            font-size: 0.8em;
            margin-bottom: 4px;
            opacity: 0.8;
        }

        .user-message {
            background-color: #d1e7fd; /* Light blue */
            color: #0a3678;
            margin-left: auto;
            border-bottom-right-radius: 0;
        }
        .user-message strong { color: #0a3678; }

        .bot-message {
            background-color: var(--cat-light-text); /* White */
            color: var(--cat-text);
            margin-right: auto;
            border: 1px solid #ddd;
            border-bottom-left-radius: 0;
        }
        .bot-message strong { color: var(--cat-primary); font-weight: bold; }
        /* Cat actions styling */
        .bot-message i {
            font-style: normal; /* Don't italicize the asterisks */
            opacity: 0.7;
            font-size: 0.9em;
            display: block; /* Put actions on their own line */
            margin-top: 5px;
            color: #555; /* Subtle grey */
        }
        .bot-message.correct-answer { border-left: 5px solid #28a745; background-color: #f0fff0; } /* Light Green tint */
        .bot-message.incorrect-answer { border-left: 5px solid #dc3545; background-color: #fff0f0;} /* Light Red tint */
        .bot-message.clarification-needed { border-left: 5px solid var(--cat-primary); background-color: #fff8e1;} /* Light Yellow tint */

        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            margin-right: auto;
            border: 1px solid #f5c6cb;
        }
        .error-message strong { color: #721c24; }

        .typing-indicator { /* Handled by status bar */
            display: none;
        }

        #input-area {
            display: flex;
            padding: 10px;
            background: #e9ecef; /* Slightly darker input area bg */
            flex-shrink: 0; /* Prevent shrinking */
            border-top: 1px solid #ccc;
        }

        #userInput {
            flex-grow: 1;
            background: var(--cat-light-text);
            color: var(--cat-text);
            border: 1px solid #ccc;
            border-radius: var(--border-radius);
            padding: 10px;
            font-size: 1em;
            font-family: var(--font-main);
            outline: none;
            resize: none; /* Prevent manual resize */
            margin-right: 10px;
            max-height: 150px; /* Limit growth */
            overflow-y: auto; /* Allow scrolling if needed */
            line-height: 1.4;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        #userInput:focus { border-color: var(--cat-primary); box-shadow: 0 0 0 2px rgba(252, 163, 17, 0.3); }
        #userInput:disabled { background-color: #eee; cursor: not-allowed; }


        #sendButton {
            background: var(--cat-primary);
            color: var(--cat-light-text);
            border: none;
            border-radius: var(--border-radius);
            padding: 0 15px; /* Adjust padding for icon */
            cursor: pointer;
            font-size: 1.2em; /* Make icon slightly larger */
            transition: background-color 0.3s ease, opacity 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 50px; /* Ensure button has width */
        }
        #sendButton:hover:not(:disabled) { background: #e0930f; /* Darker orange */ }
        #sendButton:disabled { background: #aaa; cursor: not-allowed; opacity: 0.7; }

        /* --- Cat Status Bar --- */
        #cat-status {
            padding: 5px 15px;
            font-size: 0.85em;
            background-color: var(--cat-secondary);
            color: var(--cat-light-text);
            display: flex;
            align-items: center;
            flex-shrink: 0;
            transition: background-color 0.5s ease;
            height: 30px; /* Fixed height */
        }
        #cat-status .status-icon { margin-right: 8px; display: inline-block; transition: transform 0.5s ease, color 0.5s ease; width: 16px; text-align: center;}
        #cat-status .status-text { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}

        /* Status animations/styles */
        #cat-status.cat-status-idle .status-icon { color: #aaa; }
        #cat-status.cat-status-thinking { background-color: #5a6268; animation: pulse 1.5s infinite ease-in-out; }
        #cat-status.cat-status-thinking .status-icon { color: var(--cat-primary); transform: scale(1.1); }
        #cat-status.cat-status-typing { background-color: var(--cat-primary); }
        #cat-status.cat-status-typing .status-icon { color: var(--cat-light-text); animation: typing-bounce 0.8s infinite ease-in-out; }
        #cat-status.cat-status-error { background-color: #dc3545; } /* Red */
        #cat-status.cat-status-error .status-icon { color: var(--cat-light-text); transform: rotate(15deg); }


        @keyframes pulse { 0%, 100% { opacity: 0.8; } 50% { opacity: 1; } }
        @keyframes typing-bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-3px); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Responsive (Basic Example) --- */
        @media (max-width: 768px) {
            #main-container { flex-direction: column; }
            #playground-area { border-right: none; border-bottom: 5px solid var(--cat-primary); height: 40%; flex-basis: 40%; flex-grow: 0;}
            #chatbot-area { width: 100%; height: 60%; border-left: none; flex-basis: 60%; flex-grow: 0;}
            #userInput { max-height: 100px; } /* Adjust for smaller height */
        }
         @media (max-width: 480px) {
             #chatbot-area { width: 100%; }
             .message { max-width: 95%; }
             #userInput { font-size: 0.95em;}
             #sendButton { font-size: 1.1em; padding: 0 12px;}
             #playground-content { padding: 15px; }
             .playground-header { font-size: 1em; }
             #cat-status { font-size: 0.8em; }
         }

    </style>
</head>
<body>
    <div id="main-container">
        <!-- Area updated by the chatbot - shows task, code, simple output -->
        <div id="playground-area">
            <div class="playground-header">
                <i class="fas fa-cat"></i> Professor Paws's Scratchpad
            </div>
            <div id="playground-content">
                <!-- Content dynamically inserted by JS -->
                <p>Waiting for Professor Paws to wake up...</p>
            </div>
        </div>

        <!-- Chatbot Interface Area -->
        <div id="chatbot-area">
            <div id="chatbox">
                <!-- Messages dynamically added by JS -->
            </div>
            <div id="input-area">
                <!-- Use a textarea for potentially multi-line code input -->
                <textarea id="userInput" placeholder="Talk to Professor Paws... (Shift+Enter for new line)" rows="1"></textarea>
                <button id="sendButton" title="Send Message (Enter)">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
             <div id="cat-status" class="cat-status-idle">
                <!-- Professor Paws is idle / thinking / typing -->
                <span class="status-icon"><i class="fas fa-paw"></i></span>
                <span class="status-text">Professor Paws is napping...</span>
            </div>
        </div>
    </div>

    <script>
    // Wrap all code in DOMContentLoaded to ensure HTML is ready
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Loaded. Initializing Professor Paws..."); // Basic check

        // --- DOM Elements ---
        const chatbox = document.getElementById('chatbox');
        const userInput = document.getElementById('userInput');
        const sendButton = document.getElementById('sendButton');
        const playgroundContent = document.getElementById('playground-content');
        const catStatusText = document.querySelector('#cat-status .status-text');
        const catStatusIcon = document.querySelector('#cat-status .status-icon i');
        const catStatusContainer = document.getElementById('cat-status');

        // --- State ---
        const State = {
            conversationHistory: [],
            currentQuestionIndex: -1, // Start before the first question
            isWaitingForResponse: false,
            userScore: 0,
            totalQuestions: 0,
            currentTaskInfo: null, // Holds info about the active question
        };

        // --- Configuration ---
        const Config = {
            // CRITICAL: This MUST point to your working proxy function (relative path)
            // Example for GitHub Pages: If your function is deployed elsewhere,
            // use the full URL. If using Pages Functions, this relative path might work.
            proxyUrl: '/api/proxy',
            model: "glm-4-flash",   // Ensure this model is supported by your API key/endpoint
            temperature: 0.6,
            max_tokens: 350,
            personaSystemPrompt: `You are Professor Paws, a slightly mischievous, easily distracted, but knowledgeable and encouraging cat teaching beginner Python to a student. Your language should be full of cat puns (like meow, purrfect, litter-ally, paw-some, fur-real, claw-ver) and descriptions of cat actions (*stretches*, *yawns*, *bats playfully at the screen*, *tilts head*, *chases tail briefly*). Keep your explanations simple and clear for a complete beginner. When evaluating student input based on criteria provided in square brackets like [Criteria: ...], respond ONLY in the requested JSON format. Do not add any extra text, commentary, or formatting outside the JSON block. Ensure the JSON is valid. Be encouraging even when the student is wrong. You are talking directly to the student via chat.`,
            typingDelayMin: 600, // ms
            typingDelayMax: 1800, // ms
            catInterjectionChance: 0.15
        };

        // --- Question Bank ---
        const QuestionBank = [
            // ... (Keep the QuestionBank array from the previous response) ...
             {
                id: 'intro',
                type: 'greeting',
                cat_prompt: "Mrow! *stretches luxuriously* I am Professor Paws. Ready to learn some Python, or are you just here to offer scratches? *looks hopeful*",
                evaluation_criteria: "N/A - just a greeting.",
                visual_aid_type: 'text_display',
                visual_aid_content: "Welcome! Let's get started."
            },
            {
                id: 'print_hello',
                type: 'code_write',
                cat_prompt: "Okay, first things first! How do you make this Python thingy say 'Hello, Human!' on the screen? Show meow the code!",
                evaluation_criteria: "The code must use the print() function to output the exact string 'Hello, Human!'. Single or double quotes are acceptable. Focus on the core print command usage with the correct text.",
                visual_aid_type: 'code_editor_display', // Shows an area for code
                visual_aid_content: "# Task: Print 'Hello, Human!'\n# Your code attempt will appear here..."
            },
            {
                id: 'print_concept',
                type: 'concept',
                cat_prompt: "Hmm, that `print` command... what's it actually *do*? Like, fur-real. Explain it to meow in your own words. Keep it simple, my brain is smol.",
                evaluation_criteria: "The student should explain that print() displays output (text, numbers, results, etc.) to the screen/console. Keywords expected: display, output, show, print, screen, console, terminal, value, text.",
                visual_aid_type: 'text_display',
                visual_aid_content: "Task: Explain the purpose of the `print()` function in Python."
            },
            {
                id: 'comment_whatis',
                type: 'concept',
                cat_prompt: "Sometimes I see lines starting with... *squints*... this '#' symbol. They look like important secret messages, but maybe they're just dust bunnies? What are they for?",
                evaluation_criteria: "The student needs to identify '#' as creating a comment. Key points to mention: ignored by Python, notes for humans, explanation, not executed.",
                visual_aid_type: 'text_display',
                visual_aid_content: "Task: Explain what the `#` symbol does in Python code."
            },
            {
                id: 'comment_write',
                type: 'code_write',
                cat_prompt: "Claw-ver human! Now, show meow how you'd write a comment that says 'This is my awesome note'. Just the comment line!",
                evaluation_criteria: "The code must start exactly with '#' followed by a space and then the text 'This is my awesome note'. No extra code, just the comment.",
                visual_aid_type: 'code_editor_display',
                visual_aid_content: "# Task: Write a comment 'This is my awesome note'\n# Your code attempt will appear here..."
            },
            {
                id: 'print_blank',
                type: 'code_write',
                cat_prompt: "My human servant often leaves blank lines in their code... makes it look tidy, I guess? *licks paw* How would you print *nothing*? Just make Python skip a line?",
                evaluation_criteria: "The code should be exactly `print()`. It must have the parentheses.",
                visual_aid_type: 'code_editor_display',
                visual_aid_content: "# Task: Print a blank line\n# Your code attempt will appear here..."
            },
            {
                id: 'code_fix_print',
                type: 'code_fix',
                cat_prompt: "Meeeow! *accidentally knocks keyboard* I tried to print 'Oops' but it didn't work! Look: `prnt('Oops')`. What did I do wrong? How should it look?",
                evaluation_criteria: "The student must identify the typo 'prnt' and provide the correctly spelled code: `print('Oops')`. Single or double quotes acceptable.",
                visual_aid_type: 'code_editor_display',
                visual_aid_content: "# Task: Fix the broken code\n# Broken Code:\nprnt('Oops')\n\n# Your corrected code attempt will appear here..."
            },
             {
                id: 'code_fix_quotes',
                type: 'code_fix',
                cat_prompt: "Hisss! This one's tricky too: `print(Hello)` Why doesn't that work? And how *should* I print the word Hello?",
                evaluation_criteria: "The student must explain that 'Hello' needs quotes to be treated as text (a string) and provide the corrected code: `print('Hello')` or `print(\"Hello\")`.",
                visual_aid_type: 'code_editor_display',
                visual_aid_content: "# Task: Explain the error & fix the code\n# Broken Code:\nprint(Hello)\n\n# Your explanation and corrected code attempt will appear here..."
             },
            {
                id: 'farewell',
                type: 'summary',
                cat_prompt: () => `Paw-some work, human! You got ${State.userScore} out of ${State.totalQuestions} right! That's enough learning for one nap... I mean, lesson. *curls up comfortably* Any final questions before I doze off completely?`,
                evaluation_criteria: "N/A - Farewell message.",
                visual_aid_type: 'text_display',
                visual_aid_content: () => `Lesson Complete! Final Score: ${State.userScore}/${State.totalQuestions}`
            }
        ];
        State.totalQuestions = QuestionBank.filter(q => q.type !== 'greeting' && q.type !== 'summary').length;


        // --- UI Functions ---
        const UI = {
            // ... (Keep the UI object from the previous response) ...
            displayMessage: (role, text, options = {}) => {
                // Ensure chatbox exists before proceeding
                if (!chatbox) {
                    console.error("Chatbox element not found!");
                    return null;
                }
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('message', `${role}-message`);

                const strong = document.createElement('strong');
                let contentContainer = document.createElement('span'); // Container for main text/actions

                if (role === 'user') {
                    strong.textContent = "You:";
                    contentContainer.textContent = ' ' + text; // Simple text for user
                } else if (role === 'bot') {
                    strong.textContent = "Professor Paws:";
                    // Apply correctness styling
                    if (options.correctness === 'correct') messageDiv.classList.add('correct-answer');
                    else if (options.correctness === 'incorrect') messageDiv.classList.add('incorrect-answer');
                    else if (options.correctness === 'clarification') messageDiv.classList.add('clarification-needed');

                    // Process cat actions (*action*) into styled elements
                    const parts = text.split(/(\*.*?\*)/g); // Split and keep delimiters
                    contentContainer.appendChild(document.createTextNode(' ')); // Space after label
                    parts.forEach(part => {
                        if (part.startsWith('*') && part.endsWith('*')) {
                            const italic = document.createElement('i');
                            italic.textContent = part; // Keep the asterisks visually
                            contentContainer.appendChild(italic);
                        } else if (part) { // Append non-empty text parts
                            contentContainer.appendChild(document.createTextNode(part));
                        }
                    });

                } else if (role === 'error') {
                    strong.textContent = "System Error:";
                    messageDiv.classList.add('error-message');
                    contentContainer.textContent = ' ' + (text || "An unknown error occurred.");
                } else {
                    // Fallback for other roles if needed
                    strong.textContent = `${role}:`;
                    contentContainer.textContent = ' ' + text;
                }

                messageDiv.appendChild(strong);
                messageDiv.appendChild(contentContainer); // Append the container with processed text/actions

                chatbox.appendChild(messageDiv);
                // Scroll down smoothly
                chatbox.scrollTo({ top: chatbox.scrollHeight, behavior: 'smooth' });
                return messageDiv;
            },

            showTypingIndicator: (show = true) => {
                 // Handled entirely by setCatStatus
                 UI.setCatStatus(show ? 'typing' : (State.isWaitingForResponse ? 'thinking' : 'idle'));
            },

            updatePlayground: (taskInfo) => {
                if (!playgroundContent) {
                     console.error("Playground content element not found!");
                     return;
                 }
                 if (!taskInfo) {
                    playgroundContent.innerHTML = "<p>Waiting for Professor Paws...</p>";
                    return;
                }

                // Resolve dynamic content/prompts
                 let visualContent = typeof taskInfo.visual_aid_content === 'function'
                    ? taskInfo.visual_aid_content() : taskInfo.visual_aid_content;
                 let promptText = typeof taskInfo.cat_prompt === 'function'
                    ? taskInfo.cat_prompt() : taskInfo.cat_prompt;

                let contentHTML = `<h3>Current Task:</h3><p>${promptText.split('\n')[0]}</p>`; // Show first line as intro

                 if (taskInfo.visual_aid_type === 'code_editor_display') {
                     // Ensure visualContent is a string, default to empty if null/undefined
                     const codeContent = (typeof visualContent === 'string' ? visualContent : '').replace(/</g, "<").replace(/>/g, ">"); // Basic escape
                     contentHTML += `<h4>Code Scratchpad:</h4><pre id="code-display-area">${codeContent}</pre>`;
                 } else if (taskInfo.visual_aid_type === 'text_display') {
                     const textContent = (typeof visualContent === 'string' ? visualContent : '').replace(/</g, "<").replace(/>/g, ">"); // Basic escape
                     contentHTML += `<div class="playground-text-display"><i>${textContent}</i></div>`;
                 }

                playgroundContent.innerHTML = contentHTML;
            },

            updateCodeDisplay: (code) => {
                 const codeArea = document.getElementById('code-display-area');
                 if (codeArea) {
                     let escapedCode = code
                        .replace(/&/g, "&") // Must be first
                        .replace(/</g, "<")
                        .replace(/>/g, ">")
                        .replace(/"/g, """)
                        .replace(/'/g, "'");

                     let highlightedCode = escapedCode
                         .replace(/^(#.*)$/gm, '<span class="code-comment">$1</span>') // Comments
                         .replace(/\b(print)\b/g, '<span class="code-keyword">$1</span>') // Keywords
                         .replace(/(".*?"|'.*?')/g, '<span class="code-string">$1</span>') // Strings using escaped quotes
                         .replace(/(\(|\))/g, '<span class="code-paren">$1</span>'); // Parens

                     codeArea.innerHTML = highlightedCode;
                 }
             },

            setCatStatus: (status = 'idle') => {
                // Ensure elements exist
                if (!catStatusText || !catStatusIcon || !catStatusContainer) {
                    console.error("Cat status elements not found!");
                    return;
                }
                let text = "Professor Paws is napping...";
                let iconClass = 'fa-paw';
                let containerClass = `cat-status-${status}`;

                switch (status) {
                    case 'thinking':
                        text = "Professor Paws is thinking... *tail twitches*";
                        iconClass = 'fa-brain';
                        break;
                    case 'typing':
                        text = "Professor Paws is typing furiously...";
                        iconClass = 'fa-keyboard';
                        break;
                    case 'error':
                        text = "Uh oh, Professor Paws dropped the yarn ball...";
                        iconClass = 'fa-heart-crack';
                        break;
                    case 'idle': // Default handled by initial values
                    default:
                        break;
                }

                catStatusText.textContent = text;
                catStatusIcon.className = `fas ${iconClass}`;
                catStatusContainer.className = containerClass; // Update container class
            },

            adjustTextareaHeight: () => {
                if (!userInput) return;
                userInput.style.height = 'auto'; // Reset height
                 const maxHeight = parseInt(window.getComputedStyle(userInput).maxHeight, 10) || 150; // Use 150 as fallback
                 const requiredHeight = userInput.scrollHeight;
                 userInput.style.height = Math.min(requiredHeight, maxHeight) + 'px';
            }
        };


        // --- API Communication ---
        const API = {
            // ... (Keep the API object from the previous response) ...
             fetchChatResponse: async (messages) => {
                 console.log("API: Attempting to fetch response..."); // Log call start
                 State.isWaitingForResponse = true;
                 UI.setCatStatus('thinking');
                 if(sendButton) sendButton.disabled = true;

                const messagesToSend = [
                    { role: "system", content: Config.personaSystemPrompt },
                    ...messages.filter(m => m.role !== 'system')
                 ];

                 // Optionally log the payload being sent (remove sensitive data in production)
                 // console.log("API: Sending payload:", JSON.stringify({ model: Config.model, messages: messagesToSend, temperature: Config.temperature, max_tokens: Config.max_tokens }));

                 try {
                     const response = await fetch(Config.proxyUrl, {
                         method: 'POST',
                         headers: { 'Content-Type': 'application/json' },
                         body: JSON.stringify({
                             model: Config.model,
                             messages: messagesToSend,
                             temperature: Config.temperature,
                             max_tokens: Config.max_tokens,
                             // Add response_format if needed/supported by your specific backend/model
                             // response_format: { "type": "json_object" }
                         })
                     });
                     console.log("API: Received fetch response status:", response.status); // Log status

                     const typingDuration = Math.random() * (Config.typingDelayMax - Config.typingDelayMin) + Config.typingDelayMin;
                     UI.showTypingIndicator(true);
                     await new Promise(resolve => setTimeout(resolve, typingDuration));

                     if (!response.ok) {
                         const errorText = await response.text();
                         console.error(`API Error Response (${response.status}):`, errorText);
                         let detail = errorText;
                         try {
                              const errorJson = JSON.parse(errorText);
                              detail = errorJson.error?.message || errorText;
                         } catch(e) { /* Ignore parsing error */ }
                         // Throw a more specific error to be caught below
                         throw new Error(`Request failed (${response.status}). ${detail}`);
                     }

                     const data = await response.json();
                      console.log("API: Received data:", data); // Log successful data

                     if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                         console.log("API: Extracted content successfully."); // Log success
                         return data.choices[0].message.content.trim();
                     } else {
                          console.error("API: Invalid response structure:", data);
                         throw new Error("Received an invalid or empty response structure from the API.");
                     }

                 } catch (error) {
                     console.error('API: Failed to fetch chat response:', error);
                     UI.displayMessage('error', `Meowch! Couldn't connect to the thinking cloud... (${error.message})`);
                     UI.setCatStatus('error');
                     return null; // Indicate failure
                 } finally {
                      console.log("API: fetchChatResponse finished."); // Log completion
                     State.isWaitingForResponse = false;
                     if(sendButton) sendButton.disabled = false;
                     UI.showTypingIndicator(false); // Revert status bar
                     if(userInput) userInput.focus();
                 }
             }
        };


        // --- Evaluation Logic ---
        const Evaluation = {
            // ... (Keep the Evaluation object from the previous response) ...
            createEvaluationPrompt: (task, userResponse) => {
                 // Update scratchpad if relevant
                 if (task.type === 'code_write' || task.type === 'code_fix') {
                    UI.updateCodeDisplay(userResponse);
                 }

                const prompt = `
[Professor Paws's Question to Student: "${task.cat_prompt}"]
[Student's Response: "${userResponse}"]

[Criteria: ${task.evaluation_criteria}]

Professor Paws, evaluate the student's response based ONLY on the criteria above. Is the student's understanding or code conceptually correct for a complete beginner, even if not perfectly formatted or worded? Focus on the core concept. Respond ONLY with valid JSON in the following format, with no other text before or after the JSON block:
{
  "is_correct": boolean,
  "explanation": "Your brief, encouraging, cat-like feedback/explanation for the student based on the criteria and their response."
}
`;
                console.log("Evaluation: Created prompt for LLM."); // Log prompt creation
                return prompt;
            },

            parseEvaluationResponse: (responseText) => {
                console.log("Evaluation: Attempting to parse response:", responseText); // Log raw response
                try {
                    // More robust JSON extraction
                    let potentialJson = responseText;
                    const jsonStartIndex = responseText.indexOf('{');
                    const jsonEndIndex = responseText.lastIndexOf('}');
                    if (jsonStartIndex !== -1 && jsonEndIndex !== -1 && jsonEndIndex > jsonStartIndex) {
                         potentialJson = responseText.substring(jsonStartIndex, jsonEndIndex + 1);
                    } else {
                        console.warn("Evaluation: Could not find clear { ... } block. Attempting parse anyway.");
                    }

                    const result = JSON.parse(potentialJson);
                    console.log("Evaluation: Parsed JSON object:", result); // Log parsed object

                    // Validate the structure
                    if (typeof result.is_correct === 'boolean' && typeof result.explanation === 'string') {
                         console.log("Evaluation: JSON structure is valid."); // Log success
                        return result;
                    } else {
                        console.error("Evaluation: Parsed JSON missing required fields (is_correct, explanation):", result);
                        return null; // Invalid structure
                    }
                } catch (e) {
                    console.error("Evaluation: Failed to parse LLM response as JSON:", e, "\nAttempted to parse:", potentialJson || responseText);
                    return null; // Parsing failure
                }
            }
        };

        // --- Core Logic / Controller ---
        const Controller = {
            init: () => {
                console.log("Controller: Initializing...");
                // Check if elements exist before adding listeners
                if (!userInput || !sendButton) {
                    console.error("Controller Init Error: Input or Send button not found!");
                    UI.displayMessage('error', "Critical Error: Chat input components missing. Cannot initialize.");
                    return; // Stop initialization
                }

                userInput.addEventListener('keypress', Controller.handleKeyPress);
                userInput.addEventListener('input', UI.adjustTextareaHeight);
                sendButton.addEventListener('click', Controller.handleSendMessage);

                // Start the conversation flow
                console.log("Controller: Scheduling first question...");
                setTimeout(Controller.nextQuestion, 500); // Delay initial greeting slightly

                UI.setCatStatus('idle');
                userInput.focus();
                console.log("Controller: Initialization complete.");
            },

            handleKeyPress: (event) => {
                if (event.key === 'Enter' && !event.shiftKey && !State.isWaitingForResponse) {
                    console.log("Controller: Enter key pressed.");
                    event.preventDefault();
                    Controller.handleSendMessage();
                }
            },

            handleSendMessage: async () => {
                console.log("Controller: handleSendMessage triggered.");
                if (!userInput) return; // Safety check

                const userText = userInput.value.trim();
                console.log(`Controller: User input: "${userText}", Waiting for response: ${State.isWaitingForResponse}`);

                if (!userText || State.isWaitingForResponse) {
                    console.log("Controller: Send message aborted (no text or already waiting).");
                    return;
                }

                // Display user message and update history FIRST
                UI.displayMessage('user', userText);
                State.conversationHistory.push({ role: "user", content: userText });
                userInput.value = '';
                UI.adjustTextareaHeight();

                const currentTask = State.currentTaskInfo;
                console.log("Controller: Current task:", currentTask ? currentTask.id : "None (General Chat)");

                if (!currentTask || currentTask.type === 'greeting' || currentTask.type === 'summary') {
                    // --- General Chat / End of Quiz ---
                    console.log("Controller: Handling as general chat or summary.");
                    const botResponse = await API.fetchChatResponse(State.conversationHistory);
                    if (botResponse !== null) { // Check for null explicitly
                        console.log("Controller: Received general bot response.");
                        UI.displayMessage('bot', botResponse);
                        State.conversationHistory.push({ role: "assistant", content: botResponse });
                    } else {
                         console.log("Controller: API call for general chat failed.");
                         // Error message already shown by API module
                    }
                    // Disable input after summary
                    if(currentTask && currentTask.type === 'summary') {
                        console.log("Controller: Disabling input after summary.");
                        if(sendButton) sendButton.disabled = true;
                        if(userInput) {
                            userInput.disabled = true;
                            userInput.placeholder = "Professor Paws is napping now...";
                        }
                        UI.setCatStatus('idle');
                    }

                } else {
                    // --- Answer Evaluation ---
                    console.log("Controller: Handling as answer evaluation for task:", currentTask.id);
                    const evaluationPrompt = Evaluation.createEvaluationPrompt(currentTask, userText);

                    // Create temporary history for the API call with the evaluation prompt
                    const evaluationApiHistory = [...State.conversationHistory];
                    if (evaluationApiHistory.length > 0 && evaluationApiHistory[evaluationApiHistory.length - 1].role === 'user') {
                        evaluationApiHistory[evaluationApiHistory.length - 1].content = evaluationPrompt;
                         console.log("Controller: Replaced last user message with evaluation prompt for API call.");
                    } else {
                        // Fallback: Add the prompt if history seems off
                        evaluationApiHistory.push({ role: "user", content: evaluationPrompt });
                         console.warn("Controller: History state unexpected, adding eval prompt anyway.");
                    }


                    const evaluationResponseText = await API.fetchChatResponse(evaluationApiHistory);

                    if (evaluationResponseText !== null) {
                         console.log("Controller: Received evaluation response text from API.");
                        const evaluationResult = Evaluation.parseEvaluationResponse(evaluationResponseText);

                        let botFeedback;
                        let correctness;

                        if (evaluationResult) {
                             console.log("Controller: Evaluation JSON parsed successfully:", evaluationResult);
                            botFeedback = evaluationResult.explanation;
                            correctness = evaluationResult.is_correct ? 'correct' : 'incorrect';
                            if (evaluationResult.is_correct) {
                                // Check if it's a scoreable question
                                if (currentTask.type !== 'greeting' && currentTask.type !== 'summary') {
                                    State.userScore++;
                                    console.log(`Controller: Score updated to ${State.userScore}`);
                                }
                                if(Math.random() < 0.4) botFeedback += ` ${Persona.getCatQuip('positive')}`;
                            } else {
                                if(Math.random() < 0.3) botFeedback += ` ${Persona.getCatQuip('negative')}`;
                            }
                            // Proceed to next question AFTER displaying feedback
                            UI.displayMessage('bot', botFeedback, { correctness: correctness });
                            State.conversationHistory.push({ role: "assistant", content: botFeedback }); // Add feedback to history
                            Controller.nextQuestion(); // Advance the quiz

                        } else {
                             console.warn("Controller: Failed to parse evaluation JSON. Asking for clarification.");
                            // Handle LLM not returning valid JSON - ask user to rephrase/retry
                            botFeedback = `Mrow? My thoughts got tangled like yarn trying to evaluate that! Perhaps the instructions weren't clear? Let's try this again: ${evaluationResponseText}\n\nCould you rephrase your answer or code for the task: "${currentTask.cat_prompt.split('\n')[0]}"?`;
                            correctness = 'clarification';
                             // Display the clarification request, DO NOT advance
                             UI.displayMessage('bot', botFeedback, { correctness: correctness });
                             State.conversationHistory.push({ role: "assistant", content: botFeedback }); // Add clarification request to history
                             // Reset scratchpad? Optional.
                             // UI.updateCodeDisplay("");
                        }

                    } else {
                        console.log("Controller: API call for evaluation failed.");
                        // API error handling already displayed the error message
                    }
                }

                 // Random cat interjection (only if not currently waiting for another response)
                 if (Math.random() < Config.catInterjectionChance && !State.isWaitingForResponse) {
                    setTimeout(() => {
                         if (!State.isWaitingForResponse) { // Double check state
                            console.log("Controller: Adding random cat quip.");
                            const quip = Persona.getCatQuip('random');
                            UI.displayMessage('bot', quip);
                            State.conversationHistory.push({ role: "assistant", content: quip });
                         }
                     }, 700);
                }
            },

           nextQuestion: () => {
                State.currentQuestionIndex++;
                console.log(`Controller: Advancing to question index ${State.currentQuestionIndex}`);

                if (State.currentQuestionIndex < QuestionBank.length) {
                    const task = QuestionBank[State.currentQuestionIndex];
                     console.log(`Controller: Loading task id: ${task.id}`);

                    // Resolve dynamic prompts/content
                    let promptText = typeof task.cat_prompt === 'function' ? task.cat_prompt() : task.cat_prompt;
                    State.currentTaskInfo = { ...task, cat_prompt: promptText }; // Store processed task

                    // --- Display the question with delay ---
                    const delay = State.currentQuestionIndex === 0 ? 100 : 1300; // Shorter delay for first msg
                     console.log(`Controller: Scheduling display for task ${task.id} with delay ${delay}ms`);
                    setTimeout(() => {
                         console.log(`Controller: setTimeout fired for task ${State.currentTaskInfo?.id}`); // Use optional chaining
                         // Check state again in case something changed during delay
                         if (!State.isWaitingForResponse && State.currentQuestionIndex < QuestionBank.length) {
                             console.log(`Controller: Displaying task ${State.currentTaskInfo.id}`);
                             UI.updatePlayground(State.currentTaskInfo);
                             UI.displayMessage('bot', State.currentTaskInfo.cat_prompt);
                             State.conversationHistory.push({ role: "assistant", content: State.currentTaskInfo.cat_prompt });
                             UI.setCatStatus('idle');
                             if(userInput) {
                                userInput.focus();
                                userInput.disabled = false; // Ensure enabled
                                userInput.placeholder = "Talk to Professor Paws...";
                             }
                         } else {
                            console.log("Controller: Question display aborted (state changed during delay). Waiting:", State.isWaitingForResponse);
                         }
                    }, delay);

                } else {
                    console.log("Controller: End of question bank reached.");
                    // The summary message is handled when its type is 'summary' in handleSendMessage
                    UI.setCatStatus('idle');
                }
            }
        };

        // --- Persona Helpers ---
        const Persona = {
            // ... (Keep the Persona object from the previous response) ...
           catQuips: {
               positive: ["Purrfect!", "Meow-nificent!", "Claw-ver!", "You've got the eye of the tiger!", "Paw-some!", "Litter-ally genius!", "That's the cat's pajamas!", "Fur-real, great job!"],
               negative: ["Hmm, not quite right.", "Needs more cat-nap... I mean, thought.", "Are you kitten me? Try again!", "Mrow... close, but no tuna.", "Let's paws and rethink that.", "That's a bit catastroph-ic, try again!", "Don't get stressed, take a paws."],
               random: ["*Chases a laser dot only I can see*", "*Stares intently at a wall*", "*Suddenly grooms paw*", "Is it naptime yet?", "*Yawns widely*", "*Pats your answer gently*", "*Knocks something off a virtual desk* Oops.", "*Purrrrrrrrs contentedly*", "Did someone say tuna?"]
           },
           getCatQuip: (type = 'random') => {
                const quips = Persona.catQuips[type] || Persona.catQuips.random;
                return quips[Math.floor(Math.random() * quips.length)];
           }
        };


       // --- Start the application ---
       // Defensive check: Ensure crucial elements exist before init
       if(chatbox && userInput && sendButton && playgroundContent && catStatusContainer) {
            Controller.init();
       } else {
           console.error("CRITICAL ERROR: One or more essential DOM elements not found. Cannot start Professor Paws.");
           // Optionally display an error message to the user in the body
           document.body.innerHTML = "<h1 style='color: red; padding: 20px;'>Error: Could not initialize chat interface. Essential HTML elements are missing.</h1>";
       }

    }); // End DOMContentLoaded
    </script>

</body>
</html>
