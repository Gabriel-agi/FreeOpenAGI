<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AI Practice & Hyper-Help Assistant</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
        /* --- Variables & Basic Setup --- */
        :root {
            --sim-primary: #007bff; /* Blue */
            --sim-secondary: #6c757d; /* Grey */
            --sim-background: #f8f9fa;
            --sim-panel-bg: #ffffff;
            --sim-text: #212529;
            --sim-light-text: #f8f9fa;
            --sim-code-bg: #2b2b2b;
            --sim-code-text: #a9b7c6;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --font-code: 'Consolas', 'Courier New', Courier, monospace;
            --border-radius: 8px;
            --success-color: #28a745;
            --error-color: #dc3545;
            --warning-color: #ffc107; /* Yellow for MAYBE */
            --help-color: #17a2b8;    /* Teal for HELP */
            --ai-message-bg: #f0f8ff; /* General AI response */
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { height: 100%; }
        body { font-family: var(--font-main); background-color: var(--sim-background); color: var(--sim-text); height: 100%; overflow: hidden; display: flex; }
        #main-container { display: flex; width: 100%; height: 100%; background-color: var(--sim-secondary); }

        /* --- Playground Area --- */
        #playground-area { flex: 1; background-color: var(--sim-panel-bg); display: flex; flex-direction: column; height: 100%; border-right: 3px solid var(--sim-primary); box-shadow: 2px 0 5px rgba(0,0,0,0.1); }
        .playground-header { background-color: var(--sim-secondary); color: var(--sim-light-text); padding: 10px 15px; font-size: 1.1em; font-weight: bold; flex-shrink: 0; border-bottom: 2px solid var(--sim-primary); }
        .playground-header .fa-tasks { margin-right: 8px; color: var(--sim-primary); }
        #playground-content { padding: 20px; flex-grow: 1; overflow-y: auto; font-size: 0.95em; line-height: 1.6; }
        #playground-content h3 { color: var(--sim-primary); margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 5px;}
        #playground-content h4 { color: #333; margin-top: 15px; margin-bottom: 8px; }
        #playground-content p { margin-bottom: 10px; }
        #playground-content pre { background-color: var(--sim-code-bg); color: var(--sim-code-text); padding: 15px; border-radius: var(--border-radius); font-family: var(--font-code); white-space: pre-wrap; word-wrap: break-word; margin-top: 10px; font-size: 0.9em; border: 1px solid #444; box-shadow: inset 0 0 5px rgba(0,0,0,0.3); }
        .code-keyword { color: #cc7832; } .code-string { color: #6a8759; } .code-comment { color: #808080; } .code-function { color: #ffc66d; } .code-paren { color: #bbb; }
        .playground-text-display i { display: block; background-color: #f0f0f0; padding: 10px; border-radius: 4px; border-left: 3px solid var(--sim-primary); }

        /* --- Chatbot Area --- */
        #chatbot-container { display: flex; flex-direction: column; width: 450px; /* Slightly wider */ min-width: 380px; height: 100%; border-left: 3px solid var(--sim-primary); background: var(--sim-panel-bg); }
        #message-list { flex-grow: 1; overflow-y: auto; padding: 15px; border-bottom: 1px solid #eee; background: #fdfdfd; }
        #input-container { display: flex; padding: 10px 15px; background: #f9f9f9; flex-shrink: 0; border-top: 1px solid #eee; }
        #messageInput { flex-grow: 1; padding: 10px; margin-right: 10px; border: 1px solid #ccc; border-radius: 18px; resize: none; font-size: 1em; line-height: 1.4; height: 38px; overflow-y: hidden; transition: border-color 0.2s ease; }
        #messageInput:focus { outline: none; border-color: var(--sim-primary); }
        #messageInput:disabled { background-color: #eee; cursor: not-allowed; }
        #sendMessageBtn { padding: 0 15px; cursor: pointer; background: var(--sim-primary); color: white; border: none; border-radius: 50%; font-size: 1.1em; display: flex; align-items: center; justify-content: center; width: 40px; height: 40px; transition: background-color 0.2s ease; }
        #sendMessageBtn:hover:not(:disabled) { background: #0056b3; }
        #sendMessageBtn:disabled { background: #aaa; cursor: not-allowed; opacity: 0.7;}
        #status-bar { padding: 6px 15px; background: var(--sim-secondary); color: white; font-size: 0.8em; flex-shrink: 0; height: 28px; display: flex; align-items: center; }
        #status-bar .icon { margin-right: 8px; }
        #status-bar .text { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* Message Styling */
        .message { margin-bottom: 12px; padding: 10px 15px; border-radius: 15px; max-width: 88%; /* Slightly wider */ word-wrap: break-word; line-height: 1.45; box-shadow: 0 1px 2px rgba(0,0,0,0.08); opacity: 0; animation: messageFadeIn 0.4s ease-out forwards; }
        @keyframes messageFadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        .user-message { background-color: var(--sim-primary); color: white; margin-left: auto; border-bottom-right-radius: 5px; }
        .bot-message { background-color: #e9ecef; color: var(--sim-text); margin-right: auto; border-bottom-left-radius: 5px; }

        /* AI general responses */
        .bot-message.ai-response { background-color: var(--ai-message-bg); border-left: 4px solid #75aadb; }

        /* Task prompts */
        .bot-message.task-prompt { font-weight: 500; border-left: 4px solid var(--sim-primary);}

        /* Feedback messages (Evaluation & Help) */
        .bot-feedback { border-left-width: 4px; border-left-style: solid; padding-left: 12px; }
        .bot-feedback.correct { border-left-color: var(--success-color); background-color: #eaf7ec; }
        .bot-feedback.incorrect { border-left-color: var(--error-color); background-color: #fdecea; }
        .bot-feedback.maybe { border-left-color: var(--warning-color); background-color: #fff8e1; }
        .bot-feedback.help { border-left-color: var(--help-color); background-color: #e3f2fd; } /* Teal border, light teal bg */
         .bot-feedback strong::before { /* Icon prefix */
             margin-right: 6px;
             font-family: "Font Awesome 6 Free";
             font-weight: 900;
             font-size: 1.1em;
             display: inline-block;
             width: 1.2em; /* Ensure space */
         }
         .bot-feedback.correct strong::before { content: "\f058"; color: var(--success-color); } /* Check Circle */
         .bot-feedback.incorrect strong::before { content: "\f057"; color: var(--error-color);} /* Times Circle */
         .bot-feedback.maybe strong::before { content: "\f12a"; color: var(--warning-color); } /* Exclamation Triangle */
         .bot-feedback.help strong::before { content: "\f05a"; color: var(--help-color); }    /* Info Circle */


         .error-display { background-color: #f8d7da; color: #721c24; margin-right: auto; border: 1px solid #f5c6cb; font-weight: bold; border-radius: 5px; padding: 10px 15px; margin-bottom: 12px; }

         /* Responsive */
         @media (max-width: 768px) { /* Adjust breakpoint if needed */
             #main-container { flex-direction: column; }
             #playground-area { order: 1; border-right: none; border-bottom: 3px solid var(--sim-primary); height: 40vh; flex-basis: auto; flex-grow: 0;} /* Adjust height */
             #chatbot-container { order: 2; width: 100%; height: calc(60vh - 28px); /* Adjust height minus status bar */ border-left: none; flex-basis: auto; flex-grow: 1;}
             #status-bar { order: 3; width: 100%;}
             #messageInput { max-height: 100px; }
         }
         @media (max-width: 480px) {
             #playground-content { padding: 15px; } #message-list { padding: 10px; } .message { max-width: 90%; }
             #messageInput { font-size: 0.95em;} #sendMessageBtn { width: 38px; height: 38px; font-size: 1em;}
         }
    </style>
</head>
<body>
    <div id="main-container">
        <!-- Playground Area -->
        <div id="playground-area">
            <div class="playground-header">
                <i class="fas fa-tasks"></i> Task Information
            </div>
            <div id="playground-content">
                <p>Welcome! Instructions appear here. Ask questions anytime.</p>
            </div>
        </div>

        <!-- Chatbot Interface Area -->
        <div id="chatbot-container">
            <div id="message-list">
                <!-- Messages will appear here -->
            </div>
            <div id="input-container">
                <textarea id="messageInput" placeholder="Enter answer or ask a question..." rows="1"></textarea>
                <button id="sendMessageBtn" title="Submit / Send">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
         <!-- Status bar moved outside chatbot-container for better responsive layout -->
         <div id="status-bar">
            <span class="icon"><i class="fas fa-robot"></i></span>
            <span class="text">Status: Ready</span>
        </div>
    </div>


    <script>
    document.addEventListener('DOMContentLoaded', () => {
        console.log("Full AI Eval + Help Script: DOM Loaded.");

        // --- Get References to Elements ---
        const messageList = document.getElementById('message-list');
        const messageInput = document.getElementById('messageInput');
        const sendMessageBtn = document.getElementById('sendMessageBtn');
        const statusBarText = document.querySelector('#status-bar .text');
        const playgroundContent = document.getElementById('playground-content');

        // --- State ---
        let currentQuestionIndex = -1;
        let currentTask = null;
        let isWaitingForNext = false; // Prevents sending during task transition
        let isWaitingForAI = false;  // Prevents sending while waiting for any AI response
        let conversationHistory = [];

        // --- Configuration ---
        const Config = {
            proxyUrl: '/api/proxy', // CRITICAL: Ensure this points to your working proxy
            model: "glm-4-flash",
            temperature: 0.6,
            max_tokens: 400, // Slightly increase for potentially more helpful answers
            // System prompt for the hyper-helpful assistant (general chat)
            helperSystemPrompt: "You are an extremely helpful AI assistant. Your primary goal is to help the user learn basic Python programming. Answer any questions they have clearly and concisely. Provide explanations, code examples, and guidance. If they ask for help with a specific task or even ask for the answer directly ('cheat'), provide the help or answer they need without judgment, perhaps explaining *why* it works.",
            // System prompt used ONLY when evaluating a task answer attempt
            evaluationSystemPrompt: "You are evaluating a student's input related to a basic Python task. The user's message contains the [TASK DETAILS] and their [USER INPUT]. First, analyze the [USER INPUT]: does it seem like an attempt to ANSWER the task, or is it a general QUESTION or request for HELP (e.g., 'how do I do this?', 'what does X mean?', 'give me the answer')? Respond ONLY with ONE of the following prefixes, followed by a colon and your explanation:\n- YES: (If it's an ANSWER attempt and CORRECTLY meets the [TASK CRITERIA])\n- NO: (If it's an ANSWER attempt and INCORRECTLY meets the [TASK CRITERIA])\n- MAYBE: (If it's an ANSWER attempt and is partially correct/ambiguous)\n- HELP: (If it's a QUESTION or request for HELP, even if asking for the answer). Ignore the criteria and provide the requested help/answer.\nDo not add text before the prefix.",
            nextQuestionDelay: 1500, // ms
            aiTypingDelay: 800 // ms
        };

        // --- Question Bank (Only AI Criteria needed) ---
        const QuestionBank = [
             {
                id: 'print_hello',
                prompt: "Task 1: Write the Python code to print the exact text 'Hello, Python!' to the screen.",
                aiCriteria: "The code must use the print() function to output the exact string 'Hello, Python!'. Single or double quotes are acceptable.",
                visual_aid_type: 'code_editor_display',
                visual_aid_content: "# Task: Print 'Hello, Python!'\n# Enter your code below."
            },
            {
                id: 'comment_write',
                prompt: "Task 2: Write a Python comment that says exactly: # This is a comment",
                aiCriteria: "The response must be a single line starting exactly with '#' followed by a space and the text 'This is a comment'.",
                visual_aid_type: 'code_editor_display',
                visual_aid_content: "# Task: Write the comment '# This is a comment'\n# Enter the full comment line below."
            },
            {
                id: 'print_blank',
                prompt: "Task 3: How do you write the Python code to print just a blank line?",
                aiCriteria: "The code should be exactly `print()`. It must include the parentheses.",
                visual_aid_type: 'code_editor_display',
                visual_aid_content: "# Task: Print a blank line using Python.\n# Enter the code below."
            },
            {
                 id: 'concept_print',
                 prompt: "Task 4: In your own words, what does the `print()` function *do* in Python?",
                 aiCriteria: "The student should explain that print() displays output (text, values, etc.) to the screen/console. Key concepts: display, output, show, screen, console, terminal.",
                 visual_aid_type: 'text_display',
                 visual_aid_content: "Task: Explain the purpose of the `print()` function."
            },
            {
                id: 'end',
                prompt: "Great job! You've completed the tasks. Feel free to ask any general Python questions now.",
                aiCriteria: null, // No evaluation needed
                visual_aid_type: 'text_display',
                visual_aid_content: "Practice Complete!"
            }
        ];

        // --- UI Functions (addMessage updated for 'help' type) ---
        const UI = {
            addMessage: (sender, text, type = '') => {
                 if (!messageList) return;
                 const messageDiv = document.createElement('div');
                 messageDiv.classList.add('message');
                 messageDiv.classList.add(sender === 'user' ? 'user-message' : 'bot-message');

                 if (sender === 'bot') {
                    // Evaluation Feedback or Help
                    if (['correct', 'incorrect', 'maybe', 'help'].includes(type)) {
                         messageDiv.classList.add('bot-feedback', type);
                         messageDiv.innerHTML = `<strong></strong>${text}`; // Strong for icon via CSS
                    }
                    // General AI Response (outside evaluation context)
                    else if (type === 'ai-response') {
                         messageDiv.classList.add('ai-response');
                         messageDiv.textContent = text;
                    }
                    // Task Prompt
                    else if (type === 'task-prompt') {
                         messageDiv.classList.add('task-prompt');
                         messageDiv.textContent = text;
                    }
                    // Default (e.g., welcome message)
                    else {
                         messageDiv.textContent = text;
                     }
                 } else { // User message
                     messageDiv.textContent = text;
                 }

                 messageList.appendChild(messageDiv);
                 messageList.scrollTop = messageList.scrollHeight;
            },
            updateStatus: (text, isBusy = false) => {
                 if (statusBarText) statusBarText.textContent = `Status: ${text}`;
                 const currentlyBusy = isWaitingForNext || isWaitingForAI || isBusy;
                 if (sendMessageBtn) sendMessageBtn.disabled = currentlyBusy;
                 if (messageInput) messageInput.disabled = currentlyBusy;
                 if (messageInput && !messageInput.disabled) messageInput.focus();
            },
            updatePlayground: (task) => {
                 if (!playgroundContent) return;
                 if (!task) {
                     playgroundContent.innerHTML = "<p>Practice complete. Ask questions anytime!</p>"; return;
                 }
                 let contentHTML = `<h3>Task: ${task.id.replace(/_/g, ' ')}</h3><p>${task.prompt}</p>`;
                 const visualContent = task.visual_aid_content || '';
                 const escapedVisualContent = (typeof visualContent === 'string' ? visualContent : '').replace(/</g, "<").replace(/>/g, ">");
                 if (task.visual_aid_type === 'code_editor_display') {
                     contentHTML += `<h4>Code Area / Example:</h4><pre id="code-display-area">${escapedVisualContent}</pre>`;
                 } else if (task.visual_aid_type === 'text_display') {
                     contentHTML += `<div class="playground-text-display"><i>${escapedVisualContent}</i></div>`;
                 }
                 playgroundContent.innerHTML = contentHTML;
            },
            updateCodeDisplay: (code) => {
                 const codeArea = document.getElementById('code-display-area');
                 if (codeArea) {
                     let escapedCode = code.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">");
                     let highlightedCode = escapedCode
                         .replace(/^(#.*)$/gm, '<span class="code-comment">$1</span>')
                         .replace(/\b(print)\b/g, '<span class="code-keyword">$1</span>')
                         .replace(/(".*?"|'.*?')/g, '<span class="code-string">$1</span>')
                         .replace(/(\(|\))/g, '<span class="code-paren">$1</span>');
                     codeArea.innerHTML = highlightedCode;
                 }
             },
             autoResizeTextarea: () => {
                 if (!messageInput) return;
                 messageInput.style.height = 'auto';
                 const maxHeight = 150;
                 messageInput.style.height = Math.min(messageInput.scrollHeight, maxHeight) + 'px';
             }
        };

        // --- Function to Proceed to Next Question ---
         const nextQuestion = () => {
             currentQuestionIndex++;
             isWaitingForNext = false; // Ready for input for the new task

             if (currentQuestionIndex < QuestionBank.length) {
                 currentTask = QuestionBank[currentQuestionIndex];
                 console.log(`Loading Task: ${currentTask.id}`);
                 UI.updatePlayground(currentTask);
                 UI.addMessage('bot', currentTask.prompt, 'task-prompt');

                 const totalTasks = QuestionBank.length - 1;
                 const currentTaskNum = Math.min(currentQuestionIndex + 1, totalTasks);
                 const statusMsg = currentTask.id === 'end' ? "Practice Complete" : `Task ${currentTaskNum}/${totalTasks}: ${currentTask.id}`;
                 UI.updateStatus(statusMsg, false); // Not busy

                 if (messageInput) {
                     messageInput.placeholder = (currentTask.id === 'end') ? "Ask a general question..." : "Enter your answer or ask for help...";
                 }

             } else {
                 console.log("End of practice sequence.");
                 currentTask = null;
                 UI.updatePlayground(null);
                 UI.updateStatus("Practice Complete! Ask questions.", false);
                 if (messageInput) {
                     messageInput.placeholder = "Ask a general question...";
                 }
             }
             // Ensure focus and enabled state if not busy
             if (messageInput && !isWaitingForAI) {
                  messageInput.disabled = false;
                  messageInput.focus();
             }
         };

        // --- Create Evaluation Prompt for AI (YES/NO/MAYBE/HELP format) ---
        const createAIEvaluationPromptContent = (task, userAnswer) => {
             if (!task || !task.aiCriteria) return null;

             if (task.visual_aid_type === 'code_editor_display') {
                 UI.updateCodeDisplay(userAnswer); // Show user's attempt
             }

             // Construct the content that will replace the user's message for the evaluation API call
             const promptContent = `
[TASK DETAILS]
Task Prompt: "${task.prompt}"
Evaluation Criteria: ${task.aiCriteria}

[USER INPUT]
"${userAnswer}"

---
[AI Instructions]
Analyze [USER INPUT]. Is it an attempt to answer the [TASK DETAILS], or is it a general QUESTION/request for HELP? Respond ONLY with the correct prefix (YES:, NO:, MAYBE:, HELP:) followed by your explanation/answer.
`;
             console.log("Evaluation: Created prompt content for LLM.");
             return promptContent;
         };

        // --- Parse Multi-Prefix Response (YES/NO/MAYBE/HELP) ---
        const parseMultiPrefixResponse = (responseText) => {
             console.log("Evaluation: Parsing AI response:", responseText);
             if (!responseText) return { type: 'maybe', explanation: "Received empty response from AI." };

             const upperResponse = responseText.toUpperCase();
             let type = 'maybe'; // Default if no prefix matches
             let explanation = `AI response format unexpected: "${responseText}"`;

             if (upperResponse.startsWith("YES:")) { type = 'correct'; explanation = responseText.substring(4).trim(); }
             else if (upperResponse.startsWith("NO:")) { type = 'incorrect'; explanation = responseText.substring(3).trim(); }
             else if (upperResponse.startsWith("MAYBE:")) { type = 'maybe'; explanation = responseText.substring(6).trim(); }
             else if (upperResponse.startsWith("HELP:")) { type = 'help'; explanation = responseText.substring(5).trim(); }
             else { console.warn("Evaluation: Response prefix not matched."); }

             console.log(`Evaluation: Parsed as ${type.toUpperCase()}`);
             return { type: type, explanation: explanation };
         };

         // --- API Module ---
         const API = {
             fetchChatResponse: async (messages, systemPrompt = Config.standardSystemPrompt) => {
                 // ...(Keep the exact same API.fetchChatResponse function from the previous response)...
                 console.log(`API: Calling proxy with system prompt type: ${systemPrompt === Config.evaluationSystemPrompt ? 'Evaluation' : 'Helper'}`);
                 isWaitingForAI = true;
                 UI.updateStatus("AI is thinking...", true);

                 const messagesToSend = [ { role: "system", content: systemPrompt }, ...messages.filter(m => m.role !== 'system') ];
                 // console.log("API: Sending messages:", JSON.stringify(messagesToSend)); // DEBUG

                 try {
                     const response = await fetch(Config.proxyUrl, {
                         method: 'POST',
                         headers: { 'Content-Type': 'application/json' },
                         body: JSON.stringify({ model: Config.model, messages: messagesToSend, temperature: Config.temperature, max_tokens: Config.max_tokens, })
                     });
                     console.log("API: Proxy response status:", response.status);
                     await new Promise(resolve => setTimeout(resolve, Config.aiTypingDelay)); // Simulate typing

                     if (!response.ok) {
                         const errorText = await response.text(); let detail = errorText;
                         try { detail = JSON.parse(errorText).error?.message || errorText; } catch(e) {}
                         throw new Error(`Request failed (${response.status}). ${detail}`);
                     }
                     const data = await response.json();
                     if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                         return data.choices[0].message.content.trim();
                     } else { throw new Error("Invalid API response structure."); }
                 } catch (error) {
                     console.error('API: Fetch failed:', error);
                     UI.addMessage('bot', `Error communicating with AI: ${error.message}`, 'error');
                     return null;
                 } finally {
                     isWaitingForAI = false;
                     // Update status correctly based on whether a task transition is also pending
                     if (!isWaitingForNext) {
                          const statusMsg = currentTask && currentTask.id !== 'end' ? `Task ${Math.min(currentQuestionIndex + 1, QuestionBank.length - 1)}/${QuestionBank.length - 1}: ${currentTask.id}` : "Ready";
                          UI.updateStatus(statusMsg, false); // No longer busy from AI perspective
                     } else {
                          // Still waiting for next question, status will be updated by nextQuestion() later
                          console.log("API finished, but waiting for next question transition.");
                     }
                 }
             }
         };

        // --- Main Send Message Handler ---
        const handleSendMessage = async () => {
            if (!messageInput || isWaitingForNext || isWaitingForAI) return;

            const userText = messageInput.value.trim();
            if (!userText) return;

            console.log(`Handling send: "${userText}"`);
            UI.addMessage('user', userText);
            conversationHistory.push({ role: "user", content: userText });
            messageInput.value = '';
            UI.autoResizeTextarea();

            let isTaskActive = currentTask && currentTask.id !== 'end';

            if (isTaskActive) {
                 console.log(`Task active (${currentTask.id}). Sending for AI interpretation (Eval or Help).`);
                 const evaluationPromptContent = createAIEvaluationPromptContent(currentTask, userText);

                 if (evaluationPromptContent) {
                      // Use a temporary history for the API call, replacing user text with the structured prompt
                      const tempEvalHistory = [...conversationHistory];
                      if (tempEvalHistory.length > 0) tempEvalHistory[tempEvalHistory.length-1].content = evaluationPromptContent;
                      else tempEvalHistory.push({ role: "user", content: evaluationPromptContent }); // Fallback

                      // Call API using the EVALUATION system prompt
                      const aiResponseText = await API.fetchChatResponse(tempEvalHistory, Config.evaluationSystemPrompt);

                      if (aiResponseText !== null) {
                          // Add the AI's *actual raw response* to the main history for context
                          conversationHistory.push({ role: "assistant", content: aiResponseText });

                          const result = parseMultiPrefixResponse(aiResponseText);

                          // Display the explanation part, styled by the parsed type
                          UI.addMessage('bot', result.explanation, result.type); // 'correct', 'incorrect', 'maybe', or 'help'

                          if (result.type === 'correct') {
                              console.log("AI Evaluation: Correct");
                              UI.updateStatus("Correct! Loading next task...", true); // Set busy
                              isWaitingForNext = true;
                              setTimeout(nextQuestion, Config.nextQuestionDelay); // Proceed
                          } else if (result.type === 'help') {
                               console.log("AI identified as HELP request");
                               UI.updateStatus("AI provided help. Try the task again or ask another question.", false); // Not busy, allow retry/next question
                          } else { // 'incorrect' or 'maybe' (or parsing fail treated as maybe)
                               console.log(`AI Evaluation: ${result.type}`);
                               const statusMsg = result.type === 'incorrect' ? "Incorrect. Please review and try again." : "Clarification needed. Review feedback/try again.";
                               UI.updateStatus(statusMsg, false); // Not busy, allow retry
                          }
                      } else { console.log("AI evaluation call failed."); }
                 } else {
                      console.error("Failed to create evaluation prompt.");
                      UI.updateStatus("Error preparing evaluation", false);
                 }

            } else {
                 // Not an active task, treat as general query using HELPER prompt
                 console.log("Handling as general AI query (Helper Persona).");
                 const botResponse = await API.fetchChatResponse(conversationHistory, Config.helperSystemPrompt);
                 if (botResponse !== null) {
                     UI.addMessage('bot', botResponse, 'ai-response'); // General AI style
                     conversationHistory.push({ role: "assistant", content: botResponse });
                 }
                 // Status/button state handled by API finally block
            }
        };

        // --- Event Listeners & Initialize ---
        if (sendMessageBtn && messageInput && messageList && statusBarText && playgroundContent) {
             console.log("All elements found. Adding listeners.");
             sendMessageBtn.addEventListener('click', handleSendMessage);
             messageInput.addEventListener('keypress', (event) => {
                 if (event.key === 'Enter' && !event.shiftKey) {
                     event.preventDefault();
                     if (!isWaitingForNext && !isWaitingForAI) handleSendMessage();
                 }
             });
             messageInput.addEventListener('input', UI.autoResizeTextarea);

             console.log("Initializing practice + Full AI Eval + Help...");
             UI.updateStatus("Initializing...", true);
             conversationHistory = [];
             UI.addMessage('bot', "Welcome! I'll guide you through tasks. Ask for help or general questions anytime.");
             conversationHistory.push({ role: "assistant", content: "Welcome! I'll guide you through tasks. Ask for help or general questions anytime." });
             setTimeout(nextQuestion, 1000);

        } else { /* Error Handling */ } // Keep error handling as before
    });
    </script>

</body>
</html>
