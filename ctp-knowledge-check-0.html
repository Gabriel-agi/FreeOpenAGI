<!DOCTYPE html>
<!-- Language is set dynamically by JS -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Title is set dynamically by JS -->
    <title data-translate="page_title">Practice / Cat Chat + Nav Buttons v2</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
        /* --- Variables (Keep as before) --- */
        :root {
            --sim-primary: #007bff; --sim-secondary: #6c757d; --sim-background: #f8f9fa;
            --sim-panel-bg: #ffffff; --sim-text: #212529; --sim-light-text: #f8f9fa;
            --sim-code-bg: #2b2b2b; --sim-code-text: #a9b7c6;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --font-code: 'Consolas', 'Courier New', monospace;
            --border-radius: 8px; --success-color: #28a745; --error-color: #dc3545;
            --warning-color: #ffc107; --ai-message-bg: #f0f8ff;
            --cat-primary: #fca311; --cat-secondary: #14213d; --cat-mode-bg: #fffaf0;
        }
        /* --- Base Styles (Keep as before) --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { height: 100%; }
        body { font-family: var(--font-main); background-color: var(--sim-background); color: var(--sim-text); height: 100%; overflow: hidden; display: flex; }
        #main-container { display: flex; width: 100%; height: 100%; background-color: var(--sim-secondary); }

        /* --- Playground Area --- */
        #playground-area { flex: 1; background-color: var(--sim-panel-bg); display: flex; flex-direction: column; height: 100%; border-right: 3px solid var(--sim-primary); box-shadow: 2px 0 5px rgba(0,0,0,0.1); transition: border-color 0.3s ease; }

        /* --- Header with Flex for Title + Buttons + Lang Switcher --- */
        .playground-header {
            background-color: var(--sim-secondary);
            color: var(--sim-light-text);
            padding: 10px 15px;
            font-size: 1.1em;
            font-weight: bold;
            flex-shrink: 0;
            border-bottom: 2px solid var(--sim-primary);
            transition: background-color 0.3s ease, border-color 0.3s ease;
            display: flex; /* Use Flexbox */
            align-items: center; /* Align items vertically */
            justify-content: space-between; /* Space between title and buttons/switcher */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 10px; /* Gap between items */
        }
         .playground-header-title { display: flex; align-items: center; flex-shrink: 0;} /* Group icon and text */
        .playground-header .fa-icon { margin-right: 8px; color: var(--sim-primary); transition: color 0.3s ease;}

        /* --- Nav Buttons Container (Now in Header) --- */
        #nav-buttons-container {
            display: flex;
            flex-wrap: nowrap; /* Prevent wrapping within the container itself */
            gap: 8px; /* Spacing between buttons */
            margin-left: 15px; /* Space from title */
            flex-shrink: 0; /* Prevent shrinking */
        }
        /* --- Discreet Nav Button Style --- */
        .nav-button {
            display: inline-flex;
            align-items: center;
            padding: 5px 10px; /* Smaller padding */
            font-size: 0.8em; /* Smaller font */
            color: var(--sim-light-text); /* Light text on dark header */
            background: none; /* Transparent background */
            border: 1px solid rgba(255, 255, 255, 0.4); /* Light border */
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
            white-space: nowrap;
        }
        .nav-button i { margin-right: 5px; font-size: 0.9em; }
        .nav-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.7);
        }
        .nav-button:active { transform: scale(0.98); }
        /* Hide nav buttons in cat mode (optional) */
        /* body.cat-mode #nav-buttons-container { display: none; } */ /* Keep visible for now */

        /* --- Language Switcher Style --- */
        .language-switcher {
            margin-left: auto; /* Push to the right */
            position: relative;
            flex-shrink: 0; /* Prevent shrinking */
        }
        #languageSelect {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 4px;
            padding: 5px 25px 5px 8px; /* Adjusted padding */
            cursor: pointer;
            font-size: 0.8em; /* Match button size */
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 8px auto;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            height: 29px; /* Match button height approx */
            line-height: 1;
        }
        #languageSelect:hover {
             background-color: rgba(255,255,255,0.15);
             border-color: rgba(255, 255, 255, 0.7);
        }
        #languageSelect option {
             background: var(--sim-code-bg); /* Use a dark background */
             color: var(--sim-light-text);
        }
        /* --- End Lang Switcher --- */

        #playground-content { padding: 20px; flex-grow: 1; overflow-y: auto; font-size: 0.95em; line-height: 1.6; }
        #playground-main-content { /* Renamed this div in HTML */ flex-grow: 1; }
        #playground-main-content h3 { color: var(--sim-primary); margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 5px; transition: color 0.3s ease;}
        #playground-main-content h4 { color: #333; margin-top: 15px; margin-bottom: 8px; }
        #playground-main-content p { margin-bottom: 10px; }
        #playground-main-content pre { background-color: var(--sim-code-bg); color: var(--sim-code-text); padding: 15px; border-radius: var(--border-radius); font-family: var(--font-code); white-space: pre-wrap; word-wrap: break-word; margin-top: 10px; font-size: 0.9em; border: 1px solid #444; box-shadow: inset 0 0 5px rgba(0,0,0,0.3); }
        .code-keyword { color: #cc7832; font-weight: bold; } .code-string { color: #6a8759; } .code-comment { color: #808080; font-style: italic; } .code-function { color: #ffc66d; } .code-paren { color: #bbb; }
        .playground-text-display i { display: block; background-color: #f0f0f0; padding: 10px; border-radius: 4px; border-left: 3px solid var(--sim-primary); transition: border-color 0.3s ease; }
        body.cat-mode #playground-main-content { display: none; }
        /* Updated cat mode placeholder text */
        body.cat-mode #playground-content::before { content: "\f6be \A Cat Chat Active"; font-family: "Font Awesome 6 Free"; font-weight: 900; font-size: 2em; opacity: 0.3; white-space: pre; line-height: 1.2; text-align: center; margin: auto; display: flex; align-items: center; justify-content: center; height: 100%; }


        /* --- Chatbot Area (Styles mostly same) --- */
        #chatbot-container { display: flex; flex-direction: column; width: 400px; min-width: 350px; height: 100%; border-left: 3px solid var(--sim-primary); background: var(--sim-panel-bg); transition: border-color 0.3s ease, background-color 0.3s ease; }
        #message-list { flex-grow: 1; overflow-y: auto; padding: 15px; border-bottom: 1px solid #eee; background: #fdfdfd; transition: background-color 0.3s ease;}
        #input-container { display: flex; padding: 10px 15px; background: #f9f9f9; flex-shrink: 0; border-top: 1px solid #eee; }
        #messageInput { flex-grow: 1; padding: 10px; margin-right: 10px; border: 1px solid #ccc; border-radius: 18px; resize: none; font-size: 1em; line-height: 1.4; height: 38px; overflow-y: hidden; transition: border-color 0.2s ease; }
        #messageInput:focus { outline: none; border-color: var(--sim-primary); }
        #messageInput:disabled { background-color: #eee; cursor: not-allowed; }
        .button-wrapper { display: flex; align-items: center; }
        #sendMessageBtn { padding: 0 15px; cursor: pointer; background: var(--sim-primary); color: white; border: none; border-radius: 50%; font-size: 1.1em; display: flex; align-items: center; justify-content: center; width: 40px; height: 40px; transition: background-color 0.3s ease; margin-right: 8px; }
        #sendMessageBtn:hover:not(:disabled) { background: #0056b3; }
        #sendMessageBtn:disabled { background: #aaa; cursor: not-allowed; opacity: 0.7;}
        #toggleModeBtn { padding: 0; cursor: pointer; background: var(--sim-secondary); color: white; border: none; border-radius: 50%; font-size: 1.1em; display: flex; align-items: center; justify-content: center; width: 40px; height: 40px; transition: background-color 0.3s ease, transform 0.3s ease; }
        #toggleModeBtn:hover { background: #5a6268; transform: scale(1.05); }
        #toggleModeBtn .fa-icon { transition: transform 0.3s ease-in-out; }
        #status-bar { padding: 6px 15px; background: var(--sim-secondary); color: white; font-size: 0.8em; flex-shrink: 0; height: 28px; display: flex; align-items: center; transition: background-color 0.3s ease;}
        #status-bar .icon { margin-right: 8px; width: 1.2em; text-align: center;}
        #status-bar .text { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* Message Styling */
        .message { margin-bottom: 12px; padding: 10px 15px; border-radius: 15px; max-width: 85%; word-wrap: break-word; line-height: 1.45; box-shadow: 0 1px 2px rgba(0,0,0,0.08); opacity: 0; animation: messageFadeIn 0.4s ease-out forwards; }
        @keyframes messageFadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        .user-message { background-color: var(--sim-primary); color: white; margin-left: auto; border-bottom-right-radius: 5px; transition: background-color 0.3s ease;}
        .bot-message { background-color: #e9ecef; color: var(--sim-text); margin-right: auto; border-bottom-left-radius: 5px; }
        .bot-message.ai-response { background-color: var(--ai-message-bg); border-left: 4px solid #75aadb; }
        .bot-message.task-prompt { font-weight: 500; border-left: 4px solid var(--sim-primary); transition: border-color 0.3s ease;}
        .bot-feedback { border-left-width: 4px; border-left-style: solid; padding-left: 12px; }
        .bot-feedback.correct { border-left-color: var(--success-color); background-color: #eaf7ec; }
        .bot-feedback.incorrect { border-left-color: var(--error-color); background-color: #fdecea; }
        .bot-feedback.maybe { border-left-color: var(--warning-color); background-color: #fff8e1; }
        /* Removed ::before for icons to allow direct text from AI */
        .bot-feedback strong { font-weight: bold; }
        /* Optionally add icons back via JS if needed, but primary feedback text is now direct */
        .error-display { background-color: #f8d7da; color: #721c24; margin-right: auto; border: 1px solid #f5c6cb; font-weight: bold; border-radius: 5px; padding: 10px 15px; margin-bottom: 12px; }

        /* Cat Mode Specific Styles */
        body.cat-mode #playground-area { border-right-color: var(--cat-primary); }
        body.cat-mode .playground-header { background-color: var(--cat-secondary); border-bottom-color: var(--cat-primary); }
        body.cat-mode .playground-header .fa-icon { color: var(--cat-primary); }
        body.cat-mode #chatbot-container { border-left-color: var(--cat-primary); }
        body.cat-mode #message-list { background-color: var(--cat-mode-bg); }
        body.cat-mode #status-bar { background-color: var(--cat-secondary); }
        body.cat-mode .user-message { background-color: var(--cat-primary); }
        body.cat-mode #messageInput:focus { border-color: var(--cat-primary); }
        body.cat-mode #sendMessageBtn { background-color: var(--cat-primary); }
        body.cat-mode #sendMessageBtn:hover:not(:disabled) { background-color: #e0930f; }
        body.cat-mode .bot-message.ai-response { background-color: #fff0f5; border-left-color: #ffb6c1; }
        body.cat-mode .bot-message.task-prompt { display: none; }
        body.cat-mode .nav-button { background: none; border-color: rgba(255, 255, 255, 0.4); color: var(--sim-light-text); } /* Adjust nav button color in cat mode header */
        body.cat-mode .nav-button:hover { background-color: rgba(255, 255, 255, 0.1); border-color: rgba(255, 255, 255, 0.7);}
        /* Adjust language switcher for cat mode header */
        body.cat-mode #languageSelect { background: rgba(255,255,255,0.1); border-color: rgba(255, 255, 255, 0.4); color: var(--sim-light-text);}
        body.cat-mode #languageSelect:hover { background-color: rgba(255, 255, 255, 0.15); border-color: rgba(255, 255, 255, 0.7);}


        /* Responsive */
        @media (max-width: 992px) { /* Adjust breakpoint */
             /* #nav-buttons-container { display: none; } */ /* Keep visible */
             .language-switcher { /* Keep pushed right */ }
        }
        @media (max-width: 768px) {
             #main-container { flex-direction: column; }
             #playground-area { order: 1; border-right: none; border-bottom: 3px solid var(--sim-primary); height: 45%; flex-basis: 45%; flex-grow: 0;}
             #chatbot-container { order: 2; width: 100%; height: 55%; border-left: none; flex-basis: 55%; flex-grow: 0;}
             #messageInput { max-height: 100px; }
             #nav-buttons-container { display: flex; justify-content: flex-start; margin-left: 0; flex-grow: 1;} /* Adjust positioning */
             .language-switcher { margin-left: 10px; /* Add some space if needed */ }
             .playground-header { justify-content: space-between; /* Keep space for buttons/switcher */ }
         }
         @media (max-width: 480px) {
             #playground-content { padding: 15px; }
             #message-list { padding: 10px; }
             .message { max-width: 90%; }
             #messageInput { font-size: 0.95em;}
             #sendMessageBtn, #toggleModeBtn { width: 38px; height: 38px; font-size: 1em;}
             .nav-button { font-size: 0.75em; padding: 5px 8px; }
             #languageSelect { font-size: 0.75em; padding: 5px 20px 5px 6px; height: 27px; background-size: 7px auto; background-position: right 6px center;}
             #playground-area { height: 40%; flex-basis: 40%; }
             #chatbot-container { height: 60%; flex-basis: 60%; }
             .playground-header-title > span { display: none; } /* Hide title text */
             .playground-header { justify-content: space-between; /* Allow space for buttons/switcher */ }
             #nav-buttons-container { flex-grow: 1; justify-content: flex-start; } /* Let buttons take space */
             .language-switcher { margin-left: 5px; /* Reduce margin */ }
         }

    </style>
</head>
<body class="practice-mode"> <!-- Class set by JS -->

    <div id="main-container">
        <!-- Playground Area -->
        <div id="playground-area">
            <div class="playground-header">
                <!-- Title Group -->
                <div class="playground-header-title">
                     <i class="fas fa-tasks fa-icon"></i>
                     <!-- Title text set by JS -->
                     <span id="playground-title" data-translate="header_title_practice">Task Information</span>
                </div>
                <!-- Nav buttons container -->
                <div id="nav-buttons-container">
                    <a href="#" class="nav-button" data-translate="nav_title_home" title="Main Menu"><i class="fas fa-home"></i></a>
                    <a href="#" class="nav-button" data-translate="nav_title_theory" title="Theory"><i class="fas fa-book"></i></a>
                    <a href="#" class="nav-button" data-translate="nav_title_basic" title="Basic Practice"><i class="fas fa-pencil-alt"></i></a>
                    <a href="#" class="nav-button" data-translate="nav_title_advanced" title="Advanced Practice"><i class="fas fa-flask"></i></a>
                    <a href="#" class="nav-button" data-translate="nav_title_lesson" title="Lesson"><i class="fas fa-graduation-cap"></i></a>
                </div>
                <!-- Language Switcher Added Here -->
                <div class="language-switcher">
                    <select id="languageSelect" data-translate="lang_select_title" title="Select Language">
                        <option value="en">ðŸ‡¬ðŸ‡§ English</option>
                        <option value="pt">ðŸ‡§ðŸ‡· PortuguÃªs</option>
                        <option value="zh">ðŸ‡¨ðŸ‡³ ä¸­æ–‡</option>
                    </select>
                </div>
            </div>
            <div id="playground-content">
                <!-- Main content area -->
                <div id="playground-main-content">
                     <!-- Initial welcome message set by JS -->
                     <p data-translate="playground_initial_message">Welcome! Instructions will appear here. Ask general programming questions anytime.</p>
                </div>
            </div>
        </div>

        <!-- Chatbot Interface Area -->
        <div id="chatbot-container">
            <div id="message-list">
                <!-- Messages will appear here -->
            </div>
            <div id="input-container">
                <!-- Placeholder set by JS -->
                <textarea id="messageInput" data-translate-placeholder="input_placeholder_practice_answer" placeholder="Enter answer or ask a question..." rows="1"></textarea>
                <div class="button-wrapper">
                    <!-- Title set by JS -->
                    <button id="sendMessageBtn" data-translate="send_button_title" title="Submit / Send">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                    <!-- Title set by JS -->
                    <button id="toggleModeBtn" data-translate="toggle_button_title_practice" title="Switch to Cat Chat Mode">
                        <i class="fas fa-cat fa-icon"></i> <!-- Icon changes via JS -->
                    </button>
                </div>
            </div>
             <div id="status-bar">
                <span class="icon"><i class="fas fa-robot"></i></span> <!-- Icon changes via JS -->
                <!-- Status text set by JS -->
                <span class="text" data-translate="status_prefix">Status:</span> <span class="text-main">Ready</span>
            </div>
        </div>
    </div>

    <script>
    // --- Translations Object ---
    const translations = {
        en: {
            "lang_name": "English", // Added language name
            // Meta / Generic UI
            "page_title": "Practice / Cat Chat + Nav Buttons v2",
            "lang_select_title": "Select Language",
            "status_prefix": "Status:",
            "status_ready": "Ready",
            "status_thinking": "AI is thinking...",
            "status_loading_next": "Correct! Loading next task...",
            "status_incorrect": "Incorrect.",
            "status_maybe": "Clarification needed.",
            "status_try_again": "Please try again.",
            "status_practice_complete": "Practice Complete",
            "status_cat_mode": "Cat Chat Mode",
            "status_initializing": "Initializing...",
            "status_error_prefix": "Error:", // Used in error messages
            "status_eval_error": "Error preparing evaluation (lang issue?)", // Refined error msg
            "send_button_title": "Submit / Send",
            "error_prefix": "Error:", // For general errors added to chat
            "init_critical_error": "CRITICAL ERROR: Could not initialize interface. Check console (F12).",
            "ai_eval_empty": "Received an empty response from the AI.",
            "ai_eval_unexpected": "The AI response format was unexpected: \"${response}\"",
            "ai_fetch_error": "Error communicating with AI: ${message}",
            // Header & Nav
            "header_title_practice": "Task Information",
            "header_title_cat": "Cat Chat",
            "nav_title_home": "Main Menu",
            "nav_title_theory": "Theory",
            "nav_title_basic": "Basic Practice",
            "nav_title_advanced": "Advanced Practice",
            "nav_title_lesson": "Lesson",
            // Playground
            "playground_initial_message": "Welcome! Instructions will appear here. Ask general programming questions anytime.",
            "playground_task_title": "Task:", // Followed by task id/name
            "playground_instructions_title": "Instructions / Example:",
            "playground_text_display_prefix": "Task:", // For text_display visual aid type
            // Input & Buttons
            "input_placeholder_practice_answer": "Enter your answer...",
            "input_placeholder_practice_general": "Ask a general question...",
            "input_placeholder_cat": "Chat with the cat AI...",
            "toggle_button_title_practice": "Switch to Cat Chat Mode",
            "toggle_button_title_cat": "Switch to Practice Mode",
            // Initial Messages / Prompts
            "initial_welcome_message": "Welcome! I'll guide you through some Python tasks. Answer the prompts, or ask general questions anytime. Use the button next to Send to switch to Cat Chat Mode!",
            // Question Bank Keys (Prompts & Visual Aids where applicable)
            "q_print_hello_prompt": "Let's start! Write the Python code to print the exact text 'Hello, Python!' to the screen.",
            "q_print_hello_visual": "# Task: Print 'Hello, Python!'",
            "q_comment_write_prompt": "Good! Now, write a Python comment that says exactly: # This is a comment",
            "q_comment_write_visual": "# Task: Write the comment '# This is a comment'",
            "q_print_blank_prompt": "How do you write the Python code to print just a blank line?",
            "q_print_blank_visual": "# Task: Print a blank line using Python.",
            "q_concept_print_prompt": "In your own words, what does the `print()` function *do* in Python?",
            "q_concept_print_visual": "Task: Explain the purpose of the `print()` function.",
            "q_end_prompt": "Great job! You've completed the basic practice tasks. Feel free to ask any general Python questions now, or switch to Cat Chat mode!",
            "q_end_visual": "Practice Complete!",
            // Dynamic Status in Practice Mode
            "status_task_progress": "Task ${currentTaskNum}/${totalTasks}: ${taskId}",
        },
        pt: {
            "lang_name": "Portuguese", // Added language name
            // Meta / Generic UI
            "page_title": "PrÃ¡tica / Bate-papo Felino + BotÃµes Nav v2",
            "lang_select_title": "Selecionar Idioma",
            "status_prefix": "Status:",
            "status_ready": "Pronto",
            "status_thinking": "IA estÃ¡ pensando...",
            "status_loading_next": "Correto! Carregando prÃ³xima tarefa...",
            "status_incorrect": "Incorreto.",
            "status_maybe": "Esclarecimento necessÃ¡rio.",
            "status_try_again": "Por favor, tente novamente.",
            "status_practice_complete": "PrÃ¡tica ConcluÃ­da",
            "status_cat_mode": "Modo Bate-papo Felino",
            "status_initializing": "Inicializando...",
            "status_error_prefix": "Erro:",
            "status_eval_error": "Erro ao preparar avaliaÃ§Ã£o (problema de idioma?)", // Refined error msg
            "send_button_title": "Enviar / Submeter",
            "error_prefix": "Erro:",
            "init_critical_error": "ERRO CRÃTICO: NÃ£o foi possÃ­vel inicializar a interface. Verifique o console (F12).",
            "ai_eval_empty": "Recebida uma resposta vazia da IA.",
            "ai_eval_unexpected": "O formato da resposta da IA foi inesperado: \"${response}\"",
            "ai_fetch_error": "Erro ao comunicar com a IA: ${message}",
            // Header & Nav
            "header_title_practice": "InformaÃ§Ãµes da Tarefa",
            "header_title_cat": "Bate-papo Felino",
            "nav_title_home": "Menu Principal",
            "nav_title_theory": "Teoria",
            "nav_title_basic": "PrÃ¡tica BÃ¡sica",
            "nav_title_advanced": "PrÃ¡tica AvanÃ§ada",
            "nav_title_lesson": "LiÃ§Ã£o",
            // Playground
            "playground_initial_message": "Bem-vindo! As instruÃ§Ãµes aparecerÃ£o aqui. FaÃ§a perguntas gerais de programaÃ§Ã£o a qualquer momento.",
            "playground_task_title": "Tarefa:",
            "playground_instructions_title": "InstruÃ§Ãµes / Exemplo:",
            "playground_text_display_prefix": "Tarefa:",
            // Input & Buttons
            "input_placeholder_practice_answer": "Digite sua resposta...",
            "input_placeholder_practice_general": "FaÃ§a uma pergunta geral...",
            "input_placeholder_cat": "Converse com a IA felina...",
            "toggle_button_title_practice": "Mudar para Modo Bate-papo Felino",
            "toggle_button_title_cat": "Mudar para Modo de PrÃ¡tica",
            // Initial Messages / Prompts
            "initial_welcome_message": "Bem-vindo! Vou guiÃ¡-lo atravÃ©s de algumas tarefas de Python. Responda aos prompts ou faÃ§a perguntas gerais a qualquer momento. Use o botÃ£o ao lado de Enviar para mudar para o modo Bate-papo Felino!",
            // Question Bank Keys
             "q_print_hello_prompt": "Vamos comeÃ§ar! Escreva o cÃ³digo Python para imprimir o texto exato 'Hello, Python!' na tela.",
             "q_print_hello_visual": "# Tarefa: Imprimir 'Hello, Python!'",
             "q_comment_write_prompt": "Bom! Agora, escreva um comentÃ¡rio Python que diga exatamente: # This is a comment",
             "q_comment_write_visual": "# Tarefa: Escreva o comentÃ¡rio '# This is a comment'",
             "q_print_blank_prompt": "Como vocÃª escreve o cÃ³digo Python para imprimir apenas uma linha em branco?",
             "q_print_blank_visual": "# Tarefa: Imprimir uma linha em branco usando Python.",
             "q_concept_print_prompt": "Em suas prÃ³prias palavras, o que a funÃ§Ã£o `print()` *faz* em Python?",
             "q_concept_print_visual": "Tarefa: Explique o propÃ³sito da funÃ§Ã£o `print()`.",
             "q_end_prompt": "Ã“timo trabalho! VocÃª completou as tarefas bÃ¡sicas de prÃ¡tica. Sinta-se Ã  vontade para fazer perguntas gerais sobre Python agora, ou mude para o modo Bate-papo Felino!",
             "q_end_visual": "PrÃ¡tica ConcluÃ­da!",
            // Dynamic Status in Practice Mode
            "status_task_progress": "Tarefa ${currentTaskNum}/${totalTasks}: ${taskId}",
        },
        zh: {
            "lang_name": "Chinese", // Added language name
            // Meta / Generic UI
            "page_title": "ç»ƒä¹  / çŒ«å’ªèŠå¤© + å¯¼èˆªæŒ‰é’® v2",
            "lang_select_title": "é€‰æ‹©è¯­è¨€",
            "status_prefix": "çŠ¶æ€:",
            "status_ready": "å‡†å¤‡å°±ç»ª",
            "status_thinking": "AI æ­£åœ¨æ€è€ƒ...",
            "status_loading_next": "æ­£ç¡®ï¼æ­£åœ¨åŠ è½½ä¸‹ä¸€ä¸ªä»»åŠ¡...",
            "status_incorrect": "ä¸æ­£ç¡®ã€‚",
            "status_maybe": "éœ€è¦æ¾„æ¸…ã€‚",
            "status_try_again": "è¯·å†è¯•ä¸€æ¬¡ã€‚",
            "status_practice_complete": "ç»ƒä¹ å®Œæˆ",
            "status_cat_mode": "çŒ«å’ªèŠå¤©æ¨¡å¼",
            "status_initializing": "æ­£åœ¨åˆå§‹åŒ–...",
            "status_error_prefix": "é”™è¯¯:",
            "status_eval_error": "å‡†å¤‡è¯„ä¼°æ—¶å‡ºé”™ï¼ˆè¯­è¨€é—®é¢˜ï¼Ÿï¼‰", // Refined error msg
            "send_button_title": "æäº¤ / å‘é€",
            "error_prefix": "é”™è¯¯:",
            "init_critical_error": "ä¸¥é‡é”™è¯¯ï¼šæ— æ³•åˆå§‹åŒ–ç•Œé¢ã€‚è¯·æ£€æŸ¥æŽ§åˆ¶å° (F12)ã€‚",
            "ai_eval_empty": "ä»Ž AI æ”¶åˆ°ç©ºå“åº”ã€‚",
            "ai_eval_unexpected": "AI å“åº”æ ¼å¼æ„å¤–ï¼š\"${response}\"",
            "ai_fetch_error": "ä¸Ž AI é€šä¿¡é”™è¯¯ï¼š${message}",
            // Header & Nav
            "header_title_practice": "ä»»åŠ¡ä¿¡æ¯",
            "header_title_cat": "çŒ«å’ªèŠå¤©",
            "nav_title_home": "ä¸»èœå•",
            "nav_title_theory": "ç†è®º",
            "nav_title_basic": "åŸºç¡€ç»ƒä¹ ",
            "nav_title_advanced": "è¿›é˜¶ç»ƒä¹ ",
            "nav_title_lesson": "è¯¾ç¨‹",
            // Playground
            "playground_initial_message": "æ¬¢è¿Žï¼è¯´æ˜Žå°†æ˜¾ç¤ºåœ¨æ­¤å¤„ã€‚å¯ä»¥éšæ—¶æå‡ºä¸€èˆ¬çš„ç¼–ç¨‹é—®é¢˜ã€‚",
            "playground_task_title": "ä»»åŠ¡ï¼š",
            "playground_instructions_title": "è¯´æ˜Ž / ç¤ºä¾‹ï¼š",
            "playground_text_display_prefix": "ä»»åŠ¡ï¼š",
            // Input & Buttons
            "input_placeholder_practice_answer": "è¾“å…¥ä½ çš„ç­”æ¡ˆ...",
            "input_placeholder_practice_general": "æå‡ºä¸€èˆ¬æ€§é—®é¢˜...",
            "input_placeholder_cat": "ä¸ŽçŒ«å’ª AI èŠå¤©...",
            "toggle_button_title_practice": "åˆ‡æ¢åˆ°çŒ«å’ªèŠå¤©æ¨¡å¼",
            "toggle_button_title_cat": "åˆ‡æ¢åˆ°ç»ƒä¹ æ¨¡å¼",
            // Initial Messages / Prompts
            "initial_welcome_message": "æ¬¢è¿Žï¼æˆ‘å°†å¼•å¯¼æ‚¨å®Œæˆä¸€äº› Python ä»»åŠ¡ã€‚è¯·å›žç­”æç¤ºï¼Œæˆ–éšæ—¶æå‡ºä¸€èˆ¬æ€§é—®é¢˜ã€‚ä½¿ç”¨â€œå‘é€â€æ—è¾¹çš„æŒ‰é’®åˆ‡æ¢åˆ°çŒ«å’ªèŠå¤©æ¨¡å¼ï¼",
            // Question Bank Keys
             "q_print_hello_prompt": "è®©æˆ‘ä»¬å¼€å§‹å§ï¼ç¼–å†™ Python ä»£ç ï¼Œåœ¨å±å¹•ä¸Šæ‰“å°å‡ºç¡®åˆ‡çš„æ–‡æœ¬ 'Hello, Python!'ã€‚",
             "q_print_hello_visual": "# ä»»åŠ¡ï¼šæ‰“å° 'Hello, Python!'",
             "q_comment_write_prompt": "å¾ˆå¥½ï¼çŽ°åœ¨ï¼Œç¼–å†™ä¸€ä¸ª Python æ³¨é‡Šï¼Œå†…å®¹å®Œå…¨æ˜¯ï¼š# This is a comment",
             "q_comment_write_visual": "# ä»»åŠ¡ï¼šç¼–å†™æ³¨é‡Š '# This is a comment'",
             "q_print_blank_prompt": "å¦‚ä½•ç¼–å†™ Python ä»£ç æ¥ä»…æ‰“å°ä¸€ä¸ªç©ºè¡Œï¼Ÿ",
             "q_print_blank_visual": "# ä»»åŠ¡ï¼šä½¿ç”¨ Python æ‰“å°ä¸€ä¸ªç©ºè¡Œã€‚",
             "q_concept_print_prompt": "ç”¨ä½ è‡ªå·±çš„è¯æ¥è¯´ï¼Œ`print()` å‡½æ•°åœ¨ Python ä¸­*åš*ä»€ä¹ˆï¼Ÿ",
             "q_concept_print_visual": "ä»»åŠ¡ï¼šè§£é‡Š `print()` å‡½æ•°çš„ç”¨é€”ã€‚",
             "q_end_prompt": "å¹²å¾—æ¼‚äº®ï¼æ‚¨å·²å®ŒæˆåŸºç¡€ç»ƒä¹ ä»»åŠ¡ã€‚çŽ°åœ¨å¯ä»¥éšæ„æå‡ºä»»ä½•ä¸€èˆ¬çš„ Python é—®é¢˜ï¼Œæˆ–åˆ‡æ¢åˆ°çŒ«å’ªèŠå¤©æ¨¡å¼ï¼",
             "q_end_visual": "ç»ƒä¹ å®Œæˆï¼",
            // Dynamic Status in Practice Mode
            "status_task_progress": "ä»»åŠ¡ ${currentTaskNum}/${totalTasks}: ${taskId}",
        }
    };

    document.addEventListener('DOMContentLoaded', () => {
        console.log("Nav Buttons Header + Mode Toggle + Translation Script: DOM Loaded.");

        // --- Get References to Elements ---
        const messageList = document.getElementById('message-list');
        const messageInput = document.getElementById('messageInput');
        const sendMessageBtn = document.getElementById('sendMessageBtn');
        const toggleModeBtn = document.getElementById('toggleModeBtn');
        const statusBarText = document.querySelector('#status-bar .text-main'); // Target only the main text part
        const statusBarPrefix = document.querySelector('#status-bar .text'); // Target the prefix span
        const statusIcon = document.querySelector('#status-bar .icon i');
        const playgroundContent = document.getElementById('playground-content');
        const playgroundMainContent = document.getElementById('playground-main-content');
        const playgroundHeaderIcon = document.querySelector('.playground-header .fa-icon');
        const playgroundTitle = document.getElementById('playground-title');
        const navButtonsContainer = document.getElementById('nav-buttons-container');
        const languageSelect = document.getElementById('languageSelect'); // Language selector

        // --- State ---
        let currentQuestionIndex = -1;
        let currentTask = null;
        let isWaitingForNext = false;
        let isWaitingForAI = false;
        let currentLanguage = 'en'; // Default language state
        const State = {
            currentMode: 'practice',
            histories: {
                practice: [], cat: []
            }
        };

        // --- Configuration ---
        const Config = {
            proxyUrl: '/api/proxy', // CHANGE THIS to your actual API endpoint if needed
            model: "glm-4-flash", // Or your preferred model
            temperature: 0.7,
            max_tokens: 350,
            standardSystemPrompt: "You are a helpful AI assistant explaining basic Python programming concepts clearly and concisely. Answer the user's questions related to Python or programming in general.",
            // MODIFIED evaluationSystemPrompt
            evaluationSystemPrompt: "You are evaluating a student's answer to a basic Python programming task. The user's message contains the task details, their answer, evaluation criteria, and the required language for your response. First, determine if the user's input seems like a genuine attempt to answer the specific TASK, or if it looks like a general QUESTION (even if related). If it's an ANSWER attempt, evaluate it against the CRITERIA. If it's a QUESTION, ignore the criteria and answer the question helpfully. VERY IMPORTANT: Start your response *immediately* with ONLY ONE of the following prefixes, followed by a colon and then your explanation:\n- YES: (If the input is an ANSWER attempt and CORRECTLY meets the criteria)\n- NO: (If the input is an ANSWER attempt and INCORRECTLY meets the criteria)\n- MAYBE: (If the input is an ANSWER attempt and is partially correct, ambiguous, or needs clarification)\n- QUESTION: (If the input appears to be a general QUESTION, not an answer attempt)\n**CRITICAL REQUIREMENT: Your explanation following the prefix MUST be provided *exclusively* in the language specified in the 'LANGUAGE FOR RESPONSE' field of the user's request.** Do not add any text before the prefix.",
            catSystemPrompt: "You are a quirky, slightly lazy, but ultimately helpful cat AI assistant. Respond to user questions and chat messages in character. Use cat puns (meow, purr, paw-some, fur-real), mention cat behaviors (*stretches*, *yawns*, *bats at screen*), but still provide accurate and helpful information when asked programming questions. Keep your answers relatively concise.",
            nextQuestionDelay: 1500,
            aiTypingDelay: 800
        };

        // --- Question Bank (Using Keys for Prompts/Visuals) ---
        const QuestionBank = [
             { id: 'print_hello', promptKey: "q_print_hello_prompt", aiCriteria: "The code must use the print() function to output the exact string 'Hello, Python!'. Single or double quotes are acceptable.", visual_aid_type: 'code_editor_display', visual_aid_content_key: 'q_print_hello_visual' },
             { id: 'comment_write', promptKey: "q_comment_write_prompt", aiCriteria: "The response must be a single line starting exactly with '#' followed by a space and the text 'This is a comment'.", visual_aid_type: 'code_editor_display', visual_aid_content_key: 'q_comment_write_visual' },
             { id: 'print_blank', promptKey: "q_print_blank_prompt", aiCriteria: "The code should be exactly `print()`. It must include the parentheses.", visual_aid_type: 'code_editor_display', visual_aid_content_key: 'q_print_blank_visual' },
             { id: 'concept_print', promptKey: "q_concept_print_prompt", aiCriteria: "The student should explain that print() displays output (text, values, etc.) to the screen/console. Key concepts: display, output, show, screen, console, terminal.", visual_aid_type: 'text_display', visual_aid_content_key: 'q_concept_print_visual' },
             { id: 'end', promptKey: "q_end_prompt", aiCriteria: null, visual_aid_type: 'text_display', visual_aid_content_key: 'q_end_visual' }
        ];

        // --- Translation Helper Function ---
        function t(key, replacements = {}) {
            const lang = currentLanguage;
            // Prioritize specific language, then English fallback, then key
            let text = translations[lang]?.[key] ?? translations['en']?.[key] ?? `[${key}]`;
            // Handle potential missing keys more gracefully
            if (text === `[${key}]`) {
                 console.warn(`Translation key "${key}" not found for language "${lang}" or English fallback.`);
            }
            for (const placeholder in replacements) {
                const regex = new RegExp(`\\$\\{${placeholder}\\}`, 'g');
                text = text.replace(regex, replacements[placeholder]);
            }
            return text;
        }

        // ADDED: Helper to get full language name
        function getLanguageFullName(langCode) {
             // Use the name stored in translations object, fallback to code or English
             return translations[langCode]?.lang_name || translations['en']?.lang_name || langCode;
        }

        // --- Language Management Functions ---
        function getStoredLanguage() {
             const storedLang = localStorage.getItem('userLanguage');
             if (storedLang && translations[storedLang]) return storedLang;
             const browserLang = navigator.language || navigator.userLanguage;
             if (browserLang.startsWith('pt')) return 'pt';
             if (browserLang.startsWith('zh')) return 'zh';
             return 'en'; // Default
        }

        function setLanguage(lang) {
             if (!translations[lang]) lang = 'en';
             console.log(`Setting language to: ${lang} (${getLanguageFullName(lang)})`);
             currentLanguage = lang; // Update global state
             localStorage.setItem('userLanguage', lang);
             document.documentElement.lang = lang;
             translatePageStaticElements(lang);
             // Re-render dynamic UI parts that depend on language
             UI.setModeUI(State.currentMode); // Updates titles, placeholders, status based on mode AND language
             UI.updatePlayground(State.currentMode === 'practice' ? currentTask : null); // Re-renders playground text if visible
             // Force status bar update if needed (setModeUI usually handles it)
             // UI.updateStatus(...)
        }

        function translatePageStaticElements(lang) {
            if (!translations[lang]) lang = 'en';
            if (languageSelect) languageSelect.value = lang;

            // Translate page title
            const pageTitleElement = document.querySelector('title[data-translate]');
            if (pageTitleElement) {
                 const key = pageTitleElement.getAttribute('data-translate');
                 pageTitleElement.textContent = t(key);
            }

            // Translate elements with data-translate attribute (textContent or title)
            document.querySelectorAll('[data-translate]').forEach(el => {
                if (el.tagName === 'TITLE') return; // Skip title tag here
                const key = el.getAttribute('data-translate');
                const translation = t(key);

                // Check if it's primarily a title translation (like buttons)
                if (el.hasAttribute('title')) {
                    el.setAttribute('title', translation);
                    // If it's *not* the playground title span, don't overwrite icon
                    if (el.id !== 'playground-title') {
                       // Check if it's a button/link where text content shouldn't change vs just title
                       // For nav buttons specifically, let's assume we only translate the title for now
                       if (!el.classList.contains('nav-button') && el.id !== 'languageSelect' && el.id !== 'sendMessageBtn' && el.id !== 'toggleModeBtn') {
                          // Only update textContent for elements like the header span or status prefix
                          el.textContent = translation;
                       }
                    } else {
                        // Always update textContent for the playground title span
                        el.textContent = translation;
                    }
                } else {
                    // Default: update textContent
                    el.textContent = translation;
                }
            });

             // Translate elements with data-translate-placeholder attribute
            document.querySelectorAll('[data-translate-placeholder]').forEach(el => {
                const key = el.getAttribute('data-translate-placeholder');
                el.setAttribute('placeholder', t(key));
            });

             // Translate specific static elements not covered by attributes if needed
             if (statusBarPrefix) statusBarPrefix.textContent = t('status_prefix');
             // Find initial message paragraph and translate it if it exists
             const initialP = playgroundMainContent.querySelector('p[data-translate="playground_initial_message"]');
             if(initialP) initialP.textContent = t('playground_initial_message');
        }


        // --- UI Functions ---
        const UI = {
            addMessage: (sender, text, type = '', targetList = messageList) => {
                 const messageDiv = document.createElement('div');
                 messageDiv.classList.add('message');
                 messageDiv.classList.add(sender === 'user' ? 'user-message' : 'bot-message');

                 let effectiveType = type;
                 if (sender === 'bot') {
                     if (!effectiveType) effectiveType = 'ai-response'; // Default bot message type
                     messageDiv.classList.add(effectiveType);
                     // Apply feedback styling if applicable
                     if (['correct', 'incorrect', 'maybe'].includes(effectiveType)) {
                         messageDiv.classList.add('bot-feedback');
                     }
                 }

                // Handle specific message types
                if (effectiveType === 'error') {
                     messageDiv.classList.add('error-display');
                     // Prepend translated "Error:" prefix to the already possibly translated error message
                     messageDiv.textContent = `${t('error_prefix')} ${text}`;
                 } else {
                    // For all other types (user, bot-response, bot-feedback, task-prompt), just set the text
                    // The text should be correctly translated *before* calling addMessage if needed
                    messageDiv.textContent = text;
                 }

                targetList.appendChild(messageDiv);
                // Delay scroll slightly to allow animation to start
                setTimeout(() => {
                    if (targetList === messageList) {
                        messageList.scrollTop = messageList.scrollHeight;
                    }
                }, 50);
                return messageDiv;
            },

            // updateStatus now takes a key and replacements
            updateStatus: (statusKey, replacements = {}, isBusy = false) => {
                 const translatedText = t(statusKey, replacements);
                 if (statusBarText) statusBarText.textContent = translatedText;
                 if (statusBarPrefix) statusBarPrefix.textContent = t('status_prefix'); // Ensure prefix is translated

                 const currentlyBusy = isWaitingForNext || isWaitingForAI || isBusy;
                 if (sendMessageBtn) sendMessageBtn.disabled = currentlyBusy;
                 if (toggleModeBtn) toggleModeBtn.disabled = currentlyBusy;
                 if (messageInput) messageInput.disabled = currentlyBusy;

                 if (messageInput && !currentlyBusy && document.activeElement !== messageInput) {
                    // Avoid refocusing immediately after sending/toggling if it causes issues
                    // Consider focusing only when transitioning from busy to not busy explicitly
                 }
            },

             updatePlayground: (task) => {
                  if (!playgroundMainContent) return;
                  // Clear previous content
                  playgroundMainContent.innerHTML = "";

                  if (State.currentMode === 'cat') {
                      // Playground is hidden via CSS, but ensure no content is accidentally rendered
                      return;
                  }

                  if (!task) {
                      // Show initial welcome/placeholder if no task is active in practice mode
                      const initialMsgKey = "playground_initial_message";
                      playgroundMainContent.innerHTML = `<p data-translate="${initialMsgKey}">${t(initialMsgKey)}</p>`;
                      return;
                  }

                  // Task details are visible in practice mode
                  const taskName = task.id.replace(/_/g, ' ');
                  const promptText = t(task.promptKey); // Get translated prompt

                  let contentHTML = `<h3>${t('playground_task_title')} ${taskName}</h3><p>${promptText}</p>`;

                  if (task.visual_aid_content_key) {
                      const visualContent = t(task.visual_aid_content_key); // Get translated visual aid content
                      const escapedVisualContent = visualContent.replace(/</g, "<").replace(/>/g, ">"); // Escape HTML

                      if (task.visual_aid_type === 'code_editor_display') {
                          contentHTML += `<h4>${t('playground_instructions_title')}</h4><pre id="code-display-area">${escapedVisualContent}</pre>`;
                      } else if (task.visual_aid_type === 'text_display') {
                           // Add translated prefix for text display type
                          contentHTML += `<div class="playground-text-display"><i>${t('playground_text_display_prefix')} ${escapedVisualContent}</i></div>`;
                      }
                  }
                  playgroundMainContent.innerHTML = contentHTML;

                  // Update code display syntax highlighting if it exists
                  if (task.visual_aid_type === 'code_editor_display') {
                    const codeArea = playgroundMainContent.querySelector('#code-display-area');
                    if (codeArea) {
                         // Use the original (potentially unescaped) visual content for highlighting logic if needed
                        UI.updateCodeDisplay(visualContent);
                    }
                  }
             },

             updateCodeDisplay: (code) => {
                  const codeArea = document.getElementById('code-display-area');
                  if (codeArea) {
                      // Escape HTML entities first to prevent injection
                      let escapedCode = code.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">");
                      // Basic highlighting (apply spans after escaping)
                      let highlightedCode = escapedCode
                          .replace(/^(#.*)$/gm, '<span class="code-comment">$1</span>') // Comments first
                          .replace(/\b(print)\b/g, '<span class="code-keyword">$1</span>') // Keywords
                          .replace(/(".*?"|'.*?')/g, '<span class="code-string">$1</span>') // Strings
                          .replace(/(\(|\))/g, '<span class="code-paren">$1</span>'); // Parentheses
                      codeArea.innerHTML = highlightedCode;
                  }
             },

            autoResizeTextarea: () => {
                 if (!messageInput) return;
                 messageInput.style.height = 'auto'; // Reset height
                 const maxHeight = 150; // Max height in pixels
                 const newHeight = Math.min(messageInput.scrollHeight, maxHeight);
                 messageInput.style.height = newHeight + 'px';
                 messageInput.style.overflowY = (newHeight >= maxHeight) ? 'auto' : 'hidden'; // Show scrollbar if max height reached
            },

            loadHistoryToChat: (historyArray) => {
                if (!messageList) return;
                messageList.innerHTML = ''; // Clear existing messages
                const fragment = document.createDocumentFragment();
                console.log(`Loading history for mode: ${State.currentMode}`, historyArray);
                historyArray.forEach(msg => {
                    // Determine message type for styling, default to 'ai-response' for assistant
                    const messageType = msg.type || (msg.role === 'assistant' ? 'ai-response' : '');
                    // msg.content should already be in the correct language (either user input or AI response)
                    UI.addMessage(msg.role, msg.content, messageType, fragment); // Use fragment for performance
                });
                messageList.appendChild(fragment);
                // Scroll to bottom after history is loaded
                requestAnimationFrame(() => { messageList.scrollTop = messageList.scrollHeight; });
            },

            // setModeUI now uses t() extensively
            setModeUI: (mode) => {
                 const isPractice = mode === 'practice';
                 document.body.classList.toggle('cat-mode', !isPractice);
                 document.body.classList.toggle('practice-mode', isPractice);

                 // Update titles and placeholders using t()
                 if (toggleModeBtn) {
                     const titleKey = isPractice ? "toggle_button_title_practice" : "toggle_button_title_cat";
                     toggleModeBtn.title = t(titleKey);
                     toggleModeBtn.setAttribute('data-translate', titleKey); // Keep data-translate attr for static scan
                     toggleModeBtn.innerHTML = `<i class="fas ${isPractice ? 'fa-cat' : 'fa-robot'} fa-icon"></i>`;
                 }
                 if (statusIcon) statusIcon.className = `fas ${isPractice ? 'fa-robot' : 'fa-cat'}`;
                 if (playgroundHeaderIcon) playgroundHeaderIcon.className = `fas ${isPractice ? 'fa-tasks' : 'fa-comments'} fa-icon`;

                 if (playgroundTitle) {
                     const titleKey = isPractice ? "header_title_practice" : "header_title_cat";
                     playgroundTitle.textContent = t(titleKey);
                     playgroundTitle.setAttribute('data-translate', titleKey); // Keep data-translate attr
                 }

                 if (messageInput) {
                      let placeholderKey;
                      if (isPractice) {
                          placeholderKey = (currentTask && currentTask.id !== 'end') ? "input_placeholder_practice_answer" : "input_placeholder_practice_general";
                      } else {
                          placeholderKey = "input_placeholder_cat";
                      }
                      messageInput.placeholder = t(placeholderKey);
                      messageInput.setAttribute('data-translate-placeholder', placeholderKey); // Keep data-translate attr
                 }

                 // Update status bar text using t()
                 let statusMsgKey = "status_ready"; // Default key
                 let statusReplacements = {};
                 if (isPractice) {
                     const totalTasks = QuestionBank.length - 1; // Total actual tasks before 'end'
                     const currentTaskNum = Math.min(currentQuestionIndex + 1, totalTasks); // Display current task number correctly

                     if (currentTask) {
                         if (currentTask.id === 'end') {
                             statusMsgKey = "status_practice_complete";
                         } else if (currentQuestionIndex >= 0 && currentQuestionIndex < totalTasks) {
                             statusMsgKey = "status_task_progress";
                             statusReplacements = { currentTaskNum: currentTaskNum, totalTasks: totalTasks, taskId: currentTask.id };
                         } else {
                              statusMsgKey = "status_ready"; // Fallback if state is weird
                         }
                     } else {
                          statusMsgKey = "status_ready"; // Or perhaps initializing if index is -1?
                     }
                 } else {
                     statusMsgKey = "status_cat_mode";
                 }
                 // Update status (this calls t() internally now)
                 UI.updateStatus(statusMsgKey, statusReplacements, isWaitingForAI || isWaitingForNext);

                 // Update playground content (which also uses t())
                 UI.updatePlayground(isPractice ? currentTask : null);
                 UI.autoResizeTextarea(); // Ensure textarea resizes correctly on mode switch
            }
        };

        // --- Function to Proceed to Next Question ---
        const nextQuestion = () => {
             if (State.currentMode !== 'practice') return;
             currentQuestionIndex++;
             isWaitingForNext = false;
             const totalTasks = QuestionBank.length - 1; // Index of the 'end' task

             if (currentQuestionIndex < QuestionBank.length) {
                 currentTask = QuestionBank[currentQuestionIndex];
                 console.log(`PRACTICE: Loading Task (${currentQuestionIndex + 1}/${QuestionBank.length}): ${currentTask.id}`);
                 const translatedPrompt = t(currentTask.promptKey); // Get translated prompt

                 // Add task prompt to history *only if it's not the end prompt*
                 // The end prompt text is handled differently (just updates playground/status)
                 if (currentTask.id !== 'end') {
                     const taskPromptMsg = { role: 'assistant', content: translatedPrompt, type: 'task-prompt' };
                     State.histories.practice.push(taskPromptMsg);
                     // Only add to chat display if we are currently in practice mode
                     if (State.currentMode === 'practice') {
                         UI.addMessage('bot', translatedPrompt, 'task-prompt');
                     }
                 } else {
                     // If it's the end prompt, just update playground to show completion message
                     if (State.currentMode === 'practice') {
                         UI.updatePlayground(currentTask); // Display "Practice Complete!" visual
                     }
                 }

                 // Update status bar using keys and replacements
                 const currentTaskNum = Math.min(currentQuestionIndex + 1, totalTasks); // User-facing task number (1 to totalTasks)
                 let statusKey = "status_ready";
                 let replacements = {};
                 let placeholderKey = "input_placeholder_practice_general"; // Default to general

                 if (currentTask.id === 'end') {
                     statusKey = "status_practice_complete";
                 } else if (currentQuestionIndex < totalTasks) {
                     statusKey = "status_task_progress";
                     replacements = { currentTaskNum: currentTaskNum, totalTasks: totalTasks, taskId: currentTask.id };
                     placeholderKey = "input_placeholder_practice_answer"; // Expect an answer
                 }
                 UI.updateStatus(statusKey, replacements, false); // Update status bar text

                 // Update placeholder text
                 if(messageInput) {
                      messageInput.placeholder = t(placeholderKey);
                      messageInput.setAttribute('data-translate-placeholder', placeholderKey);
                 }
                  // Update playground for non-end tasks as well (redundant if called from setModeUI?)
                  // Call it explicitly here ensures it updates after 'end' message handling too
                  if (State.currentMode === 'practice') {
                    UI.updatePlayground(currentTask);
                  }


             } else {
                 // Should technically not be reached if 'end' is the last item handled above
                 console.log("PRACTICE: End of sequence already reached.");
                 currentTask = QuestionBank[QuestionBank.length - 1]; // Keep task as 'end'
                 if (State.currentMode === 'practice') UI.updatePlayground(currentTask);
                 UI.updateStatus("status_practice_complete", {}, false);
                 if(messageInput) {
                      const placeholderKey = "input_placeholder_practice_general";
                      messageInput.placeholder = t(placeholderKey);
                      messageInput.setAttribute('data-translate-placeholder', placeholderKey);
                 }
             }
             // Refocus input only if not busy and element exists
             if (messageInput && !isWaitingForAI && !isWaitingForNext && !messageInput.disabled) {
                 messageInput.focus();
             }
             UI.autoResizeTextarea(); // Adjust size after potential placeholder change
        };

        // --- Toggle Mode Function ---
        const toggleMode = () => {
             if (isWaitingForAI || isWaitingForNext) return;
             console.log(`Toggling mode from ${State.currentMode}`);
             State.currentMode = (State.currentMode === 'practice') ? 'cat' : 'practice';
             console.log(`New mode: ${State.currentMode}`);

             // --- IMPORTANT: Reload History & Update UI BEFORE potential nextQuestion call ---
             UI.loadHistoryToChat(State.histories[State.currentMode]); // Reload history display first
             UI.setModeUI(State.currentMode); // Update rest of UI (handles translation, playground, status, placeholder)

             // If switching *back* to practice mode and the last action was completing a task,
             // ensure the next task prompt is shown correctly if needed.
             // However, nextQuestion() logic already handles displaying the current task prompt/status.
             // setModeUI calls updatePlayground which handles the display state correctly.

             console.log(`Mode switched. Displaying ${State.currentMode} history and UI elements.`);
             if (messageInput && !messageInput.disabled) messageInput.focus();
        };

        // --- Create Evaluation Prompt for AI (MODIFIED) ---
        // Now accepts targetLanguage and includes it in the prompt
        const createAIEvaluationPrompt = (task, userAnswer, targetLanguage) => {
             if (!task || !task.aiCriteria) {
                 console.error("Evaluation Error: Task or AI criteria missing.");
                 return null;
             }
             // Update code display with user's attempt if applicable
             if (task.visual_aid_type === 'code_editor_display') { UI.updateCodeDisplay(userAnswer); }

             // Get the ORIGINAL English prompt text for consistent AI understanding of the task itself
             const originalPromptText = translations['en']?.[task.promptKey];
             if (!originalPromptText) {
                 console.error(`Evaluation Error: Could not find English translation for task prompt key: ${task.promptKey}`);
                 // Send a fallback message or generic key? Let's return null to prevent sending a bad prompt.
                 return null;
             }

             // Get the full name of the target language for the AI's response
             const targetLanguageName = getLanguageFullName(targetLanguage);

             // Construct the prompt for the AI
             const promptContent = `
LANGUAGE FOR RESPONSE: ${targetLanguageName}

TASK PROMPT (Original English): "${originalPromptText}"
STUDENT ANSWER: "${userAnswer}"
EVALUATION CRITERIA: ${task.aiCriteria}
---
Reminder Instructions for AI (already in System Prompt):
Evaluate the STUDENT ANSWER against the EVALUATION CRITERIA based on the TASK PROMPT. Respond ONLY with YES:, NO:, MAYBE:, or QUESTION: followed by your explanation. Your explanation *must* be in the specified 'LANGUAGE FOR RESPONSE' (${targetLanguageName}).
`;
             console.log(`Evaluation: Created prompt content for LLM targeting response language: ${targetLanguageName}.`);
             return promptContent;
        };

        // --- Parse Simple YES/NO/MAYBE/QUESTION Response ---
        // Extracts explanation text, assuming it's now in the target language
        const parseSimpleEvaluation = (responseText) => {
            console.log("Evaluation: Attempting to parse AI response:", responseText);
            if (!responseText || responseText.trim() === '') {
                 // Use t() for the user-facing error message about empty response
                return { result: 'maybe', explanation: t('ai_eval_empty') };
            }
            // Normalize line endings and split, take the first line for prefix check
            const lines = responseText.trim().replace(/\r\n/g, '\n').split('\n');
            const firstLine = lines[0].trim();
            const upperFirstLine = firstLine.toUpperCase();

            let result = 'maybe'; // Default assumption if prefix is invalid
            // Use t() for the default unexpected format message if prefix is wrong
            let explanation = t('ai_eval_unexpected', { response: responseText });

            if (upperFirstLine.startsWith("YES:")) {
                result = 'correct';
                explanation = responseText.substring(firstLine.indexOf(':') + 1).trim(); // Get text after first colon
                console.log("Evaluation: Parsed as CORRECT");
            } else if (upperFirstLine.startsWith("NO:")) {
                result = 'incorrect';
                explanation = responseText.substring(firstLine.indexOf(':') + 1).trim();
                console.log("Evaluation: Parsed as INCORRECT");
            } else if (upperFirstLine.startsWith("MAYBE:")) {
                result = 'maybe';
                explanation = responseText.substring(firstLine.indexOf(':') + 1).trim();
                console.log("Evaluation: Parsed as MAYBE/CLARIFICATION");
            } else if (upperFirstLine.startsWith("QUESTION:")) {
                result = 'question';
                explanation = responseText.substring(firstLine.indexOf(':') + 1).trim();
                console.log("Evaluation: Parsed as QUESTION");
            } else {
                console.warn("Evaluation: Response did not start with YES:, NO:, MAYBE:, or QUESTION:", firstLine);
                 // If prefix is missing or invalid, treat the *entire* response as the explanation, classified as 'maybe'
                 result = 'maybe';
                 explanation = responseText.trim(); // Use the full, original text
            }

            // The 'explanation' is now expected to be in the target language from the AI
            return { result: result, explanation: explanation };
        };

         // --- API Module ---
         const API = {
             fetchChatResponse: async (messages, systemPrompt = Config.standardSystemPrompt) => {
                 console.log(`API: Calling proxy with system prompt type: ${systemPrompt === Config.evaluationSystemPrompt ? 'Evaluation' : (systemPrompt === Config.catSystemPrompt ? 'Cat' : 'Standard')}`);
                 isWaitingForAI = true;
                 UI.updateStatus("status_thinking", {}, true); // Use key, set busy flag

                 // Filter out any potential null/empty messages and ensure role/content exist
                 const validMessages = messages.filter(m => m && m.role && typeof m.content === 'string');
                 const messagesToSend = [{ role: "system", content: systemPrompt }, ...validMessages];

                 // Log the messages being sent (optional, for debugging)
                 // console.log("API: Sending messages:", JSON.stringify(messagesToSend, null, 2));

                 try {
                     // Basic Fetch API call
                     const response = await fetch(Config.proxyUrl, {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({
                              model: Config.model,
                              messages: messagesToSend,
                              temperature: Config.temperature,
                              max_tokens: Config.max_tokens
                          })
                      });

                     console.log("API: Proxy response status:", response.status);

                     // Optional delay to simulate typing
                     await new Promise(resolve => setTimeout(resolve, Config.aiTypingDelay));

                     if (!response.ok) {
                         let errorText = await response.text();
                         let detail = errorText;
                         try {
                             // Attempt to parse JSON error from proxy/API
                             detail = JSON.parse(errorText).error?.message || JSON.parse(errorText).detail || errorText;
                         } catch(e) { /* Ignore parsing error, use raw text */ }
                         // Use t() for the user-facing error message construction
                         throw new Error(t('ai_fetch_error', { message: `Request failed (${response.status}). ${detail}` }));
                     }

                     const data = await response.json();

                     // Check common response structures (adjust if your proxy returns differently)
                     const responseContent = data.choices?.[0]?.message?.content || data.response; // Adapt as needed

                     if (responseContent) {
                         console.log("API: Received response content.");
                         return responseContent.trim();
                     } else {
                         console.error("API: Invalid response structure received:", data);
                         // Use t() for user-facing message about unexpected structure (but generic)
                         throw new Error(t('ai_eval_unexpected', { response: JSON.stringify(data) }));
                     }
                 } catch (error) {
                     console.error('API: Fetch failed:', error);
                     // The error.message should ideally be the translated message from the throw statements above
                     const errorMessageContent = error.message || "An unknown network or API error occurred."; // Fallback
                     // Store and display error in current context's history
                     const errorMsg = { role: "assistant", content: errorMessageContent, type: 'error' };
                     State.histories[State.currentMode].push(errorMsg);
                     // UI.addMessage prepends the translated "Error:" prefix
                     UI.addMessage('bot', errorMessageContent, 'error');
                     return null; // Indicate failure
                 } finally {
                     isWaitingForAI = false;
                     // Crucially, update the UI status based on the *current* state AFTER the AI call finishes or fails
                     // setModeUI handles getting the correct status message (task progress, ready, etc.) and busy state
                     UI.setModeUI(State.currentMode);
                 }
             }
         };

        // --- Main Send Message Handler ---
        const handleSendMessage = async () => {
            if (!messageInput || isWaitingForNext || isWaitingForAI) return; // Prevent sending if busy
            const userText = messageInput.value.trim();
            if (!userText) return; // Ignore empty input

            console.log(`Handling send in mode: ${State.currentMode}, Lang: ${currentLanguage}, Text: "${userText}"`);
            // Add user message to UI immediately
            UI.addMessage('user', userText);

            // Store user message (content is the raw user input) in the correct history
            const activeHistory = State.histories[State.currentMode];
            activeHistory.push({ role: "user", content: userText });

            // Clear input and resize
            messageInput.value = '';
            UI.autoResizeTextarea();
            messageInput.focus(); // Keep focus on input

            // --- Practice Mode Logic ---
            if (State.currentMode === 'practice') {
                let isTaskActive = currentTask && currentTask.id !== 'end';

                if (isTaskActive) {
                    console.log(`PRACTICE: Task active (${currentTask.id}). Sending for AI evaluation in ${getLanguageFullName(currentLanguage)}.`);
                    // MODIFIED CALL: Pass currentLanguage
                    const evaluationPromptContent = createAIEvaluationPrompt(currentTask, userText, currentLanguage);

                    if (evaluationPromptContent) {
                        // Create a temporary history for the evaluation call:
                        // includes history *before* the user's raw answer, plus the special evaluation prompt
                        const tempEvalHistory = activeHistory.slice(0, -1); // History UP TO the user's answer
                        tempEvalHistory.push({ role: "user", content: evaluationPromptContent }); // Add the structured prompt

                        // Call API with evaluation prompt and system prompt
                        const aiResponseText = await API.fetchChatResponse(tempEvalHistory, Config.evaluationSystemPrompt);

                        if (aiResponseText !== null) { // Check if API call was successful
                            const evaluation = parseSimpleEvaluation(aiResponseText); // Gets {result, explanation}
                            // Store AI's explanation (now expected in target lang) WITH its parsed type in main history
                            const assistantMsg = { role: "assistant", content: evaluation.explanation, type: evaluation.result };
                            activeHistory.push(assistantMsg);
                            // Display feedback in UI (explanation is AI's response, now in target lang, type styles it)
                            UI.addMessage('bot', evaluation.explanation, evaluation.result);

                            // Handle outcome
                            if (evaluation.result === 'question') {
                                console.log("PRACTICE: AI identified input as QUESTION, answering helpfully.");
                                // Status is updated automatically in API finally block via setModeUI
                            } else if (evaluation.result === 'correct') {
                                console.log("PRACTICE: AI Evaluation: Correct. Proceeding to next question.");
                                UI.updateStatus("status_loading_next", {}, true); // Show "Loading..." status
                                isWaitingForNext = true; // Set flag to prevent interaction during delay
                                setTimeout(nextQuestion, Config.nextQuestionDelay); // Go to next question after delay
                            } else { // Incorrect or Maybe
                                console.log(`PRACTICE: AI Evaluation: ${evaluation.result}. Awaiting next user input.`);
                                // Status is updated automatically in API finally block via setModeUI
                                // Update placeholder to guide user if needed (e.g., 'Try again...')
                                // const placeholderKey = "input_placeholder_practice_try_again"; // Or keep as 'answer'
                                // if(messageInput) {
                                //      messageInput.placeholder = t(placeholderKey);
                                //      messageInput.setAttribute('data-translate-placeholder', placeholderKey);
                                // }
                            }
                        } else {
                            console.log("PRACTICE: AI evaluation call failed. Error message displayed by API handler.");
                            // Status already updated by API finally block
                        }
                    } else {
                         console.error("PRACTICE: Failed to create evaluation prompt (e.g., missing English key).");
                         UI.updateStatus("status_eval_error", {}, false); // Show specific error status
                    }

                } else { // General query within practice mode (e.g., after 'end' task or asking unrelated question)
                     console.log("PRACTICE: Handling as general AI query.");
                     // Use standard prompt, AI might respond based on user input language or default to English
                     const botResponse = await API.fetchChatResponse(activeHistory, Config.standardSystemPrompt);
                     if (botResponse !== null) {
                         // Store AI response (likely English/based on context) with standard type
                         const aiMsg = { role: "assistant", content: botResponse, type: 'ai-response' };
                         activeHistory.push(aiMsg);
                         UI.addMessage('bot', botResponse, 'ai-response');
                     }
                     // Status updated by API finally block
                }
            }
            // --- Cat Mode Logic ---
            else if (State.currentMode === 'cat') {
                console.log("CAT: Handling as general AI query.");
                // Use cat system prompt
                const botResponse = await API.fetchChatResponse(activeHistory, Config.catSystemPrompt);
                if (botResponse !== null) {
                    // Store AI response (cat-like, language based on context/AI capability)
                    const aiMsg = { role: "assistant", content: botResponse, type: 'ai-response' };
                    activeHistory.push(aiMsg);
                    UI.addMessage('bot', botResponse, 'ai-response');
                }
                 // Status updated by API finally block
            }
        };

        // --- Event Listeners & Initialize ---
        function initializeApp() {
            if (sendMessageBtn && toggleModeBtn && messageInput && messageList && statusBarText && playgroundContent && navButtonsContainer && languageSelect) {
                console.log("All essential elements found. Adding listeners.");
                sendMessageBtn.addEventListener('click', handleSendMessage);
                toggleModeBtn.addEventListener('click', toggleMode);
                languageSelect.addEventListener('change', (e) => setLanguage(e.target.value)); // Language switcher listener

                messageInput.addEventListener('keypress', (event) => {
                    if (event.key === 'Enter' && !event.shiftKey) {
                        event.preventDefault(); // Prevent newline in textarea
                        if (!sendMessageBtn.disabled) { // Check if button is enabled
                           handleSendMessage();
                        }
                    }
                });
                messageInput.addEventListener('input', UI.autoResizeTextarea);

                console.log("Initializing practice + AI + Mode Toggle + Header Nav Buttons + Translation...");
                const initialLang = getStoredLanguage();
                setLanguage(initialLang); // Set initial language and translate static elements

                UI.updateStatus("status_initializing", {}, true); // Show initializing status
                State.histories.practice = [];
                State.histories.cat = [];

                // Get translated welcome message FOR PRACTICE MODE
                const welcomeMsgContent = t('initial_welcome_message');
                const welcomeMsgObj = { role: "assistant", content: welcomeMsgContent, type: 'ai-response' };
                State.histories.practice.push(welcomeMsgObj); // Add to practice history ONLY

                // Display initial message ONLY if starting in practice mode
                if (State.currentMode === 'practice') {
                    UI.addMessage('bot', welcomeMsgContent, 'ai-response');
                }

                // Load the first practice question after a short delay
                // nextQuestion will handle translations for the prompt/status and add to UI if in practice mode
                setTimeout(nextQuestion, 500); // Reduced delay slightly

                // Final UI setup based on initial mode (redundant? setLanguage calls setModeUI)
                // Call explicitly to be sure all elements are set correctly after initialization
                UI.setModeUI(State.currentMode);


            } else {
                console.error("Initialization failed: One or more essential elements are missing.");
                 // Attempt to display error using translation if possible
                 const errorMsg = t('init_critical_error');
                 if (statusBarText) {
                     if(statusBarPrefix) statusBarPrefix.textContent = t('status_error_prefix') || "Error:";
                     statusBarText.textContent = errorMsg;
                 }
                 // Also try adding to message list or body as fallback
                 const errorDiv = document.createElement('div');
                 errorDiv.className = 'message error-display'; // Use existing styles
                 errorDiv.textContent = errorMsg;
                 if(messageList) messageList.appendChild(errorDiv); else document.body.prepend(errorDiv);
            }
        }

        initializeApp(); // Call the initialization function

    }); // End DOMContentLoaded
    </script>

</body>
</html>
