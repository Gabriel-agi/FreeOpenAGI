<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Agent Sim - Arcane Tome UI</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=Georgia&family=Uncial+Antiqua&display=swap" rel="stylesheet">

    <style>
        /* --- Base Styles & Variables --- */
        :root {
            --parchment: #f5e7d0; --parchment-dark: #e3d5b8; --ink: #3a3129;
            --ink-light: #5a4e42; --gold: #c9a227; --crimson: #8b0000;
            --sapphire: #1e3a8a; --amethyst: #6b21a8; --shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            --glow: 0 0 10px rgba(201, 162, 39, 0.7); --fade: all 0.5s ease;
            --skin-tone: #fbe5d6; --default-outline: #222; --swatch-size: 20px;
            --danger-color: var(--crimson); --danger-hover: #6b0000;
            --modal-scrollbar-track: var(--parchment-dark); --modal-scrollbar-thumb: var(--ink-light);
            --modal-scrollbar-thumb-hover: var(--ink); --chat-min-height: 150px;
            --tibia-like-font: 'Uncial Antiqua', cursive;
            --amethyst-light: rgba(107, 33, 168, 0.1); /* For key highlight */
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; width: 100%; overflow: hidden; background-color: var(--parchment); font-family: Georgia, 'Times New Roman', Times, serif; font-size: 1.1rem; line-height: 1.6; color: var(--ink); }
        #ui-container { display: flex; flex-direction: column; width: 100vw; height: 100vh; background-color: transparent; box-sizing: border-box; position: relative; }
        #ui-container::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: url('https://www.transparenttextures.com/patterns/old-map.png'); opacity: 0.15; pointer-events: none; z-index: -1; }

        /* --- Game World & Map --- */
        #game-world { flex-grow: 1; background-color: #333; position: relative; overflow: hidden; image-rendering: pixelated; image-rendering: crisp-edges; min-height: 0; }
        #map-content { position: absolute; top: 0; left: 0; width: 3000px; height: 2000px; background-color: #4a7c2d; background-image: linear-gradient(45deg, rgba(0,0,0,0.04) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.04) 75%, rgba(0,0,0,0.04)), linear-gradient(45deg, rgba(0,0,0,0.04) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.04) 75%, rgba(0,0,0,0.04)); background-size: 12px 12px; background-position: 0 0, 6px 6px; transform: translate3d(0, 0, 0); transition: transform 0.3s linear; }

        /* --- Character Styling --- */
        /* ... (Character CSS remains unchanged - omitted for brevity) ... */
        .character { width: 24px; height: 36px; position: absolute; cursor: pointer; z-index: 5; background-color: transparent; border: none; margin-top: 0; transition: top 0.2s linear, left 0.2s linear, opacity 0.5s ease; transform-origin: center bottom; }
        #player { z-index: 6; }
        .character .part { position: absolute; box-sizing: border-box; transition: background-color 0.1s ease, border-color 0.1s ease; display: none; background-color: transparent; image-rendering: pixelated; image-rendering: crisp-edges; }
        .character .part.head, .character .part.torso, .character .part.legs, .character .part.arm-left, .character .part.arm-right, .character .part.detail1 { border: 1px solid var(--default-outline); }
        .character .part.head { z-index: 10; background-color: var(--skin-tone); } .character .part.torso { z-index: 5; } .character .part.legs { z-index: 4; }
        .character .part.arm-left { z-index: 6; transform-origin: 2px 1px; } .character .part.arm-right { z-index: 6; transform-origin: 1px 1px; }
        .character .part.detail1 { z-index: 7; } .character .part.detail2 { z-index: 11; } .character .part.detail3 { z-index: 3; }
        .character .part.detail4 { z-index: 12; border: none; } .character .part.detail5 { z-index: 12; border: none; }
        .character.gender-male .part.head { top: 1px; left: 7px; width: 10px; height: 9px; border-radius: 2px 2px 0 0; }
        .character.gender-male .part.detail2 { display: block; top: 0px; left: 5px; width: 14px; height: 6px; border-radius: 3px 3px 1px 1px; border: 1px solid var(--default-outline); }
        .character.gender-male .part.detail3 { display: block; top: 5px; left: 6px; width: 12px; height: 6px; border-radius: 0 0 2px 2px; border: 1px solid var(--default-outline); }
        .character.gender-male.outfit-citizen .part.head, .character.gender-male.outfit-citizen .part.torso, .character.gender-male.outfit-citizen .part.legs, .character.gender-male.outfit-citizen .part.detail2, .character.gender-male.outfit-citizen .part.detail3, .character.gender-male.outfit-citizen .part.arm-left, .character.gender-male.outfit-citizen .part.arm-right { display: block; }
        .character.gender-male.outfit-citizen .part.torso { top: 9px; left: 5px; width: 14px; height: 12px; border-top-width: 2px; border-bottom: none;}
        .character.gender-male.outfit-citizen .part.legs { top: 21px; left: 6px; width: 12px; height: 9px; border-bottom-width: 3px; border-top: none; }
        .character.gender-male.outfit-citizen .part.arm-left { top: 10px; left: 2px; width: 3px; height: 10px; border-radius: 1px; }
        .character.gender-male.outfit-citizen .part.arm-right { top: 10px; left: 19px; width: 3px; height: 10px; border-radius: 1px; }
        .character.gender-male.outfit-mage .part.head, .character.gender-male.outfit-mage .part.torso, .character.gender-male.outfit-mage .part.legs, .character.gender-male.outfit-mage .part.detail1, .character.gender-male.outfit-mage .part.detail4, .character.gender-male.outfit-mage .part.arm-left, .character.gender-male.outfit-mage .part.arm-right { display: block; }
        .character.gender-male.outfit-mage .part.detail2, .character.gender-male.outfit-mage .part.detail3 { display: none; }
        .character.gender-male.outfit-mage .part.detail4 { top: -4px; left: 4px; width: 16px; height: 10px; border-radius: 50% 50% 0 0 / 40% 40% 0 0; border: 1px solid var(--default-outline); border-bottom: none; clip-path: polygon(50% 0%, 100% 100%, 0% 100%); }
        .character.gender-male.outfit-mage .part.torso { top: 9px; left: 4px; width: 16px; height: 18px; }
        .character.gender-male.outfit-mage .part.legs { top: 27px; left: 6px; width: 12px; height: 6px; border-bottom-width: 3px; border-top: none; }
        .character.gender-male.outfit-mage .part.detail1 { top: 18px; left: 4px; width: 16px; height: 3px; }
        .character.gender-male.outfit-mage .part.arm-left { top: 11px; left: 1px; width: 4px; height: 10px; }
        .character.gender-male.outfit-mage .part.arm-right { top: 11px; left: 19px; width: 4px; height: 10px; }
        .character.gender-male.outfit-warrior .part.head, .character.gender-male.outfit-warrior .part.torso, .character.gender-male.outfit-warrior .part.legs, .character.gender-male.outfit-warrior .part.detail1, .character.gender-male.outfit-warrior .part.detail2, .character.gender-male.outfit-warrior .part.detail3, .character.gender-male.outfit-warrior .part.detail4, .character.gender-male.outfit-warrior .part.detail5, .character.gender-male.outfit-warrior .part.arm-left, .character.gender-male.outfit-warrior .part.arm-right { display: block; }
        .character.gender-male.outfit-warrior .part.detail4 { top: 0px; left: 1px; width: 7px; height: 10px; border-radius: 3px 0 0 0; border-width: 1px; border-style: outset; }
        .character.gender-male.outfit-warrior .part.detail5 { top: 0px; left: 16px; width: 7px; height: 10px; border-radius: 0 3px 0 0; border-width: 1px; border-style: outset; }
        .character.gender-male.outfit-warrior .part.head { border-radius: 1px; }
        .character.gender-male.outfit-warrior .part.torso { top: 9px; left: 4px; width: 16px; height: 13px; border-width: 2px; border-style: outset; }
        .character.gender-male.outfit-warrior .part.legs { top: 22px; left: 5px; width: 14px; height: 8px; border-bottom-width: 4px; border-style: outset; border-top: none;}
        .character.gender-male.outfit-warrior .part.detail1 { top: 18px; left: 4px; width: 16px; height: 4px; }
        .character.gender-male.outfit-warrior .part.arm-left { top: 11px; left: 1px; width: 4px; height: 10px; }
        .character.gender-male.outfit-warrior .part.arm-right { top: 11px; left: 19px; width: 4px; height: 10px; }
        .character.gender-male.outfit-scifi .part.head, .character.gender-male.outfit-scifi .part.torso, .character.gender-male.outfit-scifi .part.legs, .character.gender-male.outfit-scifi .part.detail1, .character.gender-male.outfit-scifi .part.detail2, .character.gender-male.outfit-scifi .part.detail3, .character.gender-male.outfit-scifi .part.arm-left, .character.gender-male.outfit-scifi .part.arm-right { display: block; }
        .character.gender-male.outfit-scifi .part.head { top: 1px; left: 7px; width: 10px; height: 9px; border-radius: 2px; }
        .character.gender-male.outfit-scifi .part.torso { top: 9px; left: 5px; width: 14px; height: 13px; border-style: solid; border-width: 1px 2px;}
        .character.gender-male.outfit-scifi .part.legs { top: 22px; left: 6px; width: 12px; height: 9px; border-bottom-width: 3px; border-style: solid; border-width: 1px 2px;}
        .character.gender-male.outfit-scifi .part.detail1 { top: 11px; left: 8px; width: 8px; height: 5px; border-radius: 1px; z-index: 7; }
        .character.gender-male.outfit-scifi .part.arm-left { top: 10px; left: 2px; width: 4px; height: 11px; border-radius: 1px;}
        .character.gender-male.outfit-scifi .part.arm-right { top: 10px; left: 18px; width: 4px; height: 11px; border-radius: 1px;}
        .character.gender-male.outfit-ranger .part.head, .character.gender-male.outfit-ranger .part.torso, .character.gender-male.outfit-ranger .part.legs, .character.gender-male.outfit-ranger .part.detail1, .character.gender-male.outfit-ranger .part.detail2, .character.gender-male.outfit-ranger .part.detail3, .character.gender-male.outfit-ranger .part.arm-left, .character.gender-male.outfit-ranger .part.arm-right { display: block; }
        .character.gender-male.outfit-ranger .part.torso { top: 9px; left: 5px; width: 14px; height: 13px; }
        .character.gender-male.outfit-ranger .part.legs { top: 22px; left: 6px; width: 12px; height: 9px; border-bottom-width: 3px; }
        .character.gender-male.outfit-ranger .part.detail1 { top: 18px; left: 5px; width: 14px; height: 4px; }
        .character.gender-male.outfit-ranger .part.arm-left { top: 10px; left: 2px; width: 4px; height: 11px; }
        .character.gender-male.outfit-ranger .part.arm-right { top: 10px; left: 18px; width: 4px; height: 11px; }
        .character.gender-male.outfit-kimono .part.head, .character.gender-male.outfit-kimono .part.torso, .character.gender-male.outfit-kimono .part.legs, .character.gender-male.outfit-kimono .part.detail1, .character.gender-male.outfit-kimono .part.detail2, .character.gender-male.outfit-kimono .part.detail3, .character.gender-male.outfit-kimono .part.arm-left, .character.gender-male.outfit-kimono .part.arm-right { display: block; }
        .character.gender-male.outfit-kimono .part.torso { top: 9px; left: 4px; width: 16px; height: 18px; border-radius: 1px; border-right-width: 2px; border-left-width: 2px;}
        .character.gender-male.outfit-kimono .part.legs { top: 27px; left: 6px; width: 12px; height: 6px; border-bottom-width: 3px; border-top: none; }
        .character.gender-male.outfit-kimono .part.detail1 { top: 16px; left: 4px; width: 16px; height: 5px; z-index: 7; }
        .character.gender-male.outfit-kimono .part.arm-left { top: 10px; left: 0px; width: 6px; height: 15px; border-radius: 0 0 2px 2px; }
        .character.gender-male.outfit-kimono .part.arm-right { top: 10px; left: 18px; width: 6px; height: 15px; border-radius: 0 0 2px 2px; }
        .character.gender-female .part.head { width: 12px; height: 11px; left: 6px; top: 1px; border-radius: 40% 40% 35% 35%; }
        .character.gender-female .part.detail3 { display: block; top: 4px; left: 4px; width: 16px; height: 20px; border-radius: 0 0 10px 10px; border: none; }
        .character.gender-female .part.detail2 { display: block; top: 1px; left: 5px; width: 14px; height: 8px; border-radius: 5px 5px 2px 2px; border: none; border-bottom: 1px solid #111;}
        .character.gender-female.outfit-citizen .part.head, .character.gender-female.outfit-citizen .part.torso, .character.gender-female.outfit-citizen .part.legs, .character.gender-female.outfit-citizen .part.detail1, .character.gender-female.outfit-citizen .part.detail2, .character.gender-female.outfit-citizen .part.detail3, .character.gender-female.outfit-citizen .part.arm-left, .character.gender-female.outfit-citizen .part.arm-right { display: block; }
        .character.gender-female.outfit-citizen .part.torso { top: 10px; left: 7px; width: 10px; height: 11px; border-radius: 2px; }
        .character.gender-female.outfit-citizen .part.detail1 { top: 18px; left: 6px; width: 12px; height: 3px; border-radius: 1px; }
        .character.gender-female.outfit-citizen .part.legs { top: 21px; left: 5px; width: 14px; height: 10px; border-bottom-width: 3px; border-top: none; border-radius: 0 0 5px 5px; }
        .character.gender-female.outfit-citizen .part.arm-left { top: 11px; left: 4px; width: 3px; height: 6px; border-radius: 1px; }
        .character.gender-female.outfit-citizen .part.arm-right { top: 11px; left: 17px; width: 3px; height: 6px; border-radius: 1px; }
        .character.gender-female.outfit-mage .part.head, .character.gender-female.outfit-mage .part.torso, .character.gender-female.outfit-mage .part.legs, .character.gender-female.outfit-mage .part.detail1, .character.gender-female.outfit-mage .part.detail2, .character.gender-female.outfit-mage .part.detail3, .character.gender-female.outfit-mage .part.arm-left, .character.gender-female.outfit-mage .part.arm-right { display: block; }
        .character.gender-female.outfit-mage .part.head { top: 2px; }
        .character.gender-female.outfit-mage .part.detail2 { top: 1px; left: 4px; width: 16px; height: 9px; border-radius: 6px 6px 3px 3px; }
        .character.gender-female.outfit-mage .part.detail3 { top: 5px; left: 4px; width: 16px; height: 22px; border-radius: 0 0 10px 10px;}
        .character.gender-female.outfit-mage .part.torso { top: 11px; left: 5px; width: 14px; height: 18px; border-radius: 2px; }
        .character.gender-female.outfit-mage .part.detail1 { top: 14px; left: 9px; width: 6px; height: 4px; border-radius: 50%; z-index: 7; }
        .character.gender-female.outfit-mage .part.legs { top: 29px; left: 6px; width: 12px; height: 5px; border-bottom-width: 2px; border-top: none; border-radius: 0 0 3px 3px;}
        .character.gender-female.outfit-mage .part.arm-left { top: 12px; left: 1px; width: 5px; height: 15px; border-radius: 0 0 3px 3px; }
        .character.gender-female.outfit-mage .part.arm-right { top: 12px; left: 18px; width: 5px; height: 15px; border-radius: 0 0 3px 3px; }
        .character.gender-female.outfit-warrior .part.head, .character.gender-female.outfit-warrior .part.torso, .character.gender-female.outfit-warrior .part.legs, .character.gender-female.outfit-warrior .part.detail1, .character.gender-female.outfit-warrior .part.detail2, .character.gender-female.outfit-warrior .part.detail3, .character.gender-female.outfit-warrior .part.arm-left, .character.gender-female.outfit-warrior .part.arm-right { display: block; }
        .character.gender-female.outfit-warrior .part.torso { top: 10px; left: 6px; width: 12px; height: 11px; border-radius: 3px 3px 1px 1px; border-style: solid; border-width: 1px; }
        .character.gender-female.outfit-warrior .part.detail1 { top: 20px; left: 4px; width: 16px; height: 7px; border-radius: 0 0 4px 4px; border-style: outset; }
        .character.gender-female.outfit-warrior .part.legs { top: 27px; left: 7px; width: 10px; height: 6px; border-bottom-width: 3px; border-top: none; }
        .character.gender-female.outfit-warrior .part.arm-left { top: 11px; left: 3px; width: 3px; height: 9px; border-radius: 1px; border-style: outset; border-width: 1px; }
        .character.gender-female.outfit-warrior .part.arm-right { top: 11px; left: 18px; width: 3px; height: 9px; border-radius: 1px; border-style: outset; border-width: 1px; }
        .character.gender-female.outfit-warrior .part.detail2 { top: 1px; height: 7px; left: 4px; width: 16px;}
        .character.gender-female.outfit-warrior .part.detail3 { height: 22px;}
        .character.gender-female.outfit-scifi .part.head, .character.gender-female.outfit-scifi .part.torso, .character.gender-female.outfit-scifi .part.legs, .character.gender-female.outfit-scifi .part.detail1, .character.gender-female.outfit-scifi .part.detail2, .character.gender-female.outfit-scifi .part.detail3, .character.gender-female.outfit-scifi .part.arm-left, .character.gender-female.outfit-scifi .part.arm-right { display: block; }
        .character.gender-female.outfit-scifi .part.torso { top: 10px; left: 6px; width: 12px; height: 12px; border-style: solid; border-width: 1px; border-radius: 2px; }
        .character.gender-female.outfit-scifi .part.legs { top: 22px; left: 7px; width: 10px; height: 9px; border-bottom-width: 3px; border-style: solid; border-width: 1px; }
        .character.gender-female.outfit-scifi .part.detail1 { top: 11px; left: 9px; width: 6px; height: 4px; border-radius: 1px; z-index: 7;}
        .character.gender-female.outfit-scifi .part.arm-left { top: 11px; left: 3px; width: 3px; height: 11px; border-radius: 1px; }
        .character.gender-female.outfit-scifi .part.arm-right { top: 11px; left: 18px; width: 3px; height: 11px; border-radius: 1px; }
        .character.gender-female.outfit-ranger .part.head, .character.gender-female.outfit-ranger .part.torso, .character.gender-female.outfit-ranger .part.legs, .character.gender-female.outfit-ranger .part.detail1, .character.gender-female.outfit-ranger .part.detail2, .character.gender-female.outfit-ranger .part.detail3, .character.gender-female.outfit-ranger .part.arm-left, .character.gender-female.outfit-ranger .part.arm-right { display: block; }
        .character.gender-female.outfit-ranger .part.torso { top: 10px; left: 6px; width: 12px; height: 13px; border-radius: 1px; }
        .character.gender-female.outfit-ranger .part.legs { top: 23px; left: 7px; width: 10px; height: 8px; border-bottom-width: 3px;}
        .character.gender-female.outfit-ranger .part.detail1 { top: 19px; left: 6px; width: 12px; height: 4px; z-index: 7;}
        .character.gender-female.outfit-ranger .part.arm-left { top: 11px; left: 3px; width: 3px; height: 11px; }
        .character.gender-female.outfit-ranger .part.arm-right { top: 11px; left: 18px; width: 3px; height: 11px; }
        .character.gender-female.outfit-kimono .part.head, .character.gender-female.outfit-kimono .part.torso, .character.gender-female.outfit-kimono .part.legs, .character.gender-female.outfit-kimono .part.detail1, .character.gender-female.outfit-kimono .part.detail2, .character.gender-female.outfit-kimono .part.detail3, .character.gender-female.outfit-kimono .part.arm-left, .character.gender-female.outfit-kimono .part.arm-right { display: block; }
        .character.gender-female.outfit-kimono .part.torso { top: 10px; left: 4px; width: 16px; height: 17px; border-radius: 1px; border-right-width: 2px; border-left-width: 2px; border-style: solid;}
        .character.gender-female.outfit-kimono .part.legs { top: 27px; left: 7px; width: 10px; height: 7px; border-bottom-width: 2px; border-top: none;}
        .character.gender-female.outfit-kimono .part.detail1 { top: 17px; left: 4px; width: 16px; height: 7px; border-radius: 1px;}
        .character.gender-female.outfit-kimono .part.arm-left { top: 11px; left: 0px; width: 6px; height: 18px; border-radius: 0 0 6px 2px; }
        .character.gender-female.outfit-kimono .part.arm-right { top: 11px; left: 18px; width: 6px; height: 18px; border-radius: 0 0 2px 6px; }
        @keyframes playerBobbing { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-2px); } }
        @keyframes playerWalkArmLeft { 0%, 100% { transform: rotate(-10deg) translateX(0px); } 50% { transform: rotate(8deg) translateX(0px); } }
        @keyframes playerWalkArmRight { 0%, 100% { transform: rotate(8deg) translateX(0px); } 50% { transform: rotate(-10deg) translateX(0px); } }
        @keyframes playerWalkLegs { 0%, 100% { transform: translateX(0px); } 50% { transform: translateX(-0.5px); } }
        #player.is-walking { animation: playerBobbing 0.5s infinite ease-in-out; }
        #player.is-walking .part.arm-left { animation: playerWalkArmLeft 0.5s infinite ease-in-out; }
        #player.is-walking .part.arm-right { animation: playerWalkArmRight 0.5s infinite ease-in-out; }
        #player.is-walking .part.legs { animation: playerWalkLegs 0.5s infinite ease-in-out; }
        .character .character-name-plate { position: absolute; bottom: calc(100% + 10px); left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7); color: #fff; padding: 1px 5px; border-radius: 3px; font-size: 10px; font-weight: bold; white-space: nowrap; text-shadow: 1px 1px 1px #000; z-index: 11; border: 1px solid rgba(255, 255, 255, 0.2); pointer-events: none; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
        .character .speech { display: none; }

        /* --- Environment Zones --- */
        .environment-zone { position: absolute; border: 2px dashed rgba(58, 49, 41, 0.5); background-color: rgba(58, 49, 41, 0.08); border-radius: 8px; display: flex; justify-content: center; align-items: flex-start; padding-top: 8px; pointer-events: none; box-sizing: border-box; z-index: 1; color: var(--ink-light); font-size: 14px; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.2); }
        .environment-name-plate { background-color: rgba(58, 49, 41, 0.6); color: var(--parchment); padding: 3px 8px; border-radius: 4px; white-space: nowrap; border: 1px solid rgba(245, 231, 208, 0.3); }

        /* --- Chat Area & Messages --- */
        #chat-area { flex-basis: 300px; min-height: var(--chat-min-height); display: flex; flex-direction: column; background: var(--parchment-dark); flex-shrink: 0; position: relative; border-top: 2px solid var(--ink-light); transition: flex-basis 0.3s ease-out; }
        /* --- Chat Tabs --- */
        #chat-tabs-container {
            display: flex; flex-wrap: wrap; /* Allow wrapping on small screens */
            padding: 5px 10px; /* Reduced padding */
            gap: 8px; /* Adjusted gap */
            background-color: var(--parchment-dark);
            border-bottom: 1px solid var(--ink-light);
            flex-shrink: 0;
            transition: max-height 0.3s ease, padding 0.3s ease, opacity 0.3s ease, border 0.3s ease;
            max-height: 100px;
            overflow: hidden;
            opacity: 1;
        }
        #chat-tabs-container.hidden {
           max-height: 0; padding-top: 0; padding-bottom: 0; opacity: 0;
           border-bottom: none; pointer-events: none;
        }
        #chat-tabs-container button {
            background-color: var(--parchment); border: 1px solid var(--ink-light);
            border-radius: 6px; padding: 5px 12px; /* Adjusted padding */
            color: var(--ink); font-size: 0.9rem; /* Smaller base font */ cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease;
            font-family: Georgia, serif; line-height: 1.2; /* Ensure text fits */
        }
        #chat-tabs-container button.active-tab { /* Style for the active tab */
             background-color: var(--gold);
             color: var(--ink);
             box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
             font-weight: bold;
         }
        #chat-tabs-container button:hover:not(.active-tab) {
            background-color: var(--parchment-dark); box-shadow: 0 0 5px rgba(0,0,0,0.1);
        }
        #chat-tabs-container button#general-tab { font-family: 'Cinzel Decorative', cursive; padding: 5px 15px; }
        #chat-tabs-container button#area-tab,
        #chat-tabs-container button#city-tab,
        #chat-tabs-container button#world-tab,
        #chat-tabs-container button#message-tab,
        #chat-tabs-container button#agent-tab { /* Added agent-tab */
            font-family: var(--tibia-like-font); text-transform: uppercase; font-size: 0.8rem; /* Even smaller */
        }
        /* --- End Chat Tabs --- */
        .chat-messages { flex: 1; padding: 25px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: var(--ink-light) var(--parchment-dark); display: flex; flex-direction: column; gap: 20px; background-color: var(--parchment); }
        .chat-messages::-webkit-scrollbar { width: 8px; } .chat-messages::-webkit-scrollbar-track { background: var(--parchment-dark); } .chat-messages::-webkit-scrollbar-thumb { background-color: var(--ink-light); border-radius: 4px; }
        .message { display: flex; gap: 15px; max-width: 85%; animation: appear 0.8s ease-out; }
        .message-user { align-self: flex-end; flex-direction: row-reverse; } .message-spirit { align-self: flex-start; }
        .message-system, .message-debug { align-self: flex-start; opacity: 0.8; font-size: 0.9em;}
        .message-system .message-content, .message-debug .message-content { background-color: var(--parchment-dark); border: 1px dashed var(--ink-light); }
        .avatar { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; flex-shrink: 0; border: 2px solid var(--parchment-dark); box-shadow: var(--shadow); display: flex; align-items: center; justify-content: center; font-family: 'Cinzel Decorative', cursive; font-size: 1.5rem; transition: var(--fade); color: white; cursor: pointer; /* Make all clickable */ }
        .user-avatar { background-color: var(--sapphire); } .spirit-avatar { background-color: var(--amethyst); }
        .system-avatar, .debug-avatar { background-color: var(--ink-light); font-size: 1.2rem; } /* System avatar is now clickable too */
        .spirit-avatar:hover, .user-avatar:hover, .system-avatar:hover, .debug-avatar:hover { transform: scale(1.1); box-shadow: var(--glow); } /* Hover effect added to system/debug */
        .message-content { padding: 18px 22px; border-radius: 8px; line-height: 1.6; position: relative; word-break: break-word; box-shadow: var(--shadow); max-width: 100%; font-size: 1.1rem; }
        .message-content p { margin-bottom: 1em; } .message-content p:last-child { margin-bottom: 0; }
        .message-content strong { font-weight: bold; color: var(--ink); } .message-content em { font-style: italic; }
        .message-content ul, .message-content ol { margin-left: 1.5em; margin-bottom: 1em; } .message-content li { margin-bottom: 0.5em; }
        .message-content code { font-family: monospace; background-color: rgba(0, 0, 0, 0.1); padding: 0.2em 0.4em; border-radius: 3px; }
        .message-content pre { position: relative; background-color: rgba(0, 0, 0, 0.1); padding: 1em; border-radius: 5px; overflow-x: auto; margin-bottom: 1em; font-family: monospace; font-size: 0.95em; }
        .copy-code-btn { position: absolute; top: 5px; right: 5px; background-color: var(--gold); color: var(--ink); border: none; border-radius: 3px; padding: 3px 8px; font-size: 0.8rem; cursor: pointer; opacity: 0; transition: opacity 0.3s ease; }
        .message-content pre:hover .copy-code-btn { opacity: 1; } .copy-code-btn:hover { background-color: var(--crimson); color: white; }
        .copy-code-btn.copied { background-color: var(--sapphire); color: white; }
        .message-content blockquote { border-left: 3px solid var(--gold); padding-left: 1em; margin-left: 0; margin-bottom: 1em; color: var(--ink-light); }
        .user-message { background-color: var(--sapphire); color: white; border-top-right-radius: 0; }
        .spirit-message { background-color: white; color: var(--ink); border: 1px solid var(--ink-light); border-top-left-radius: 0; }
        .system-message, .debug-message { background-color: var(--parchment-dark); color: var(--ink-light); border: 1px dashed var(--ink-light); border-top-left-radius: 0; font-style: italic; }
        .system-message .message-name, .debug-message .message-name { font-weight: bold; margin-right: 5px; display: inline-block; }
        .typing-indicator { display: inline-flex; align-items: center; gap: 8px; padding: 15px 20px; background-color: var(--parchment-dark); border-radius: 8px; box-shadow: var(--shadow); align-self: flex-start; color: var(--ink-light); font-style: italic; border: 1px dashed var(--ink-light); position: relative; overflow: hidden; font-size: 1rem; margin-left: 65px; }
        .typing-indicator::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(201, 162, 39, 0.2), transparent); animation: shimmer 2s infinite; }
        .rune { font-family: 'Cinzel Decorative', cursive; font-size: 1.2rem; animation: float 2s infinite ease-in-out; margin-left: 5px; }

        /* --- Input Area --- */
        .input-container { padding: 18px; background-color: var(--parchment-dark); border-top: none; display: flex; gap: 12px; align-items: flex-end; flex-shrink: 0; }
        #userInput { flex: 1; padding: 18px; background-color: var(--parchment); border: 2px solid var(--ink-light); border-radius: 5px; font-family: inherit; font-size: 1.1rem; resize: none; outline: none; color: var(--ink); min-height: 60px; max-height: 200px; line-height: 1.5; overflow-y: auto; }
        #userInput:focus { border-color: var(--gold); box-shadow: 0 0 0 3px rgba(201, 162, 39, 0.3); }
        #userInput::placeholder { color: var(--ink-light); font-style: italic; }
        #sendButton { background-color: var(--gold); color: var(--ink); border: none; border-radius: 5px; padding: 0 24px; height: 60px; font-family: 'Cinzel Decorative', cursive; font-weight: bold; cursor: pointer; transition: var(--fade); box-shadow: var(--shadow); display: flex; align-items: center; justify-content: center; gap: 10px; font-size: 1.1rem; flex-shrink: 0; align-self: flex-end; }
        #sendButton:hover:not(:disabled) { background-color: var(--crimson); color: white; }
        #sendButton:disabled { opacity: 0.7; cursor: not-allowed; background-color: var(--ink-light); color: var(--parchment); }

        /* --- Settings Modal (Paginated) --- */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; pointer-events: none; transition: var(--fade); }
        .modal-overlay.active { opacity: 1; pointer-events: all; }
        .modal-content {
            background-color: var(--parchment); color: var(--ink); border-radius: 8px;
            width: 90%; max-width: 800px; padding: 0;
            box-shadow: var(--shadow); transform: translateY(20px); transition: var(--fade);
            max-height: 85vh; display: flex; flex-direction: column;
            border: 1px solid var(--ink-light); overflow: hidden;
        }
        .modal-overlay.active .modal-content { transform: translateY(0); }
        .modal-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 0; border-bottom: 1px solid var(--ink-light);
            padding: 20px 28px 15px 28px; flex-shrink: 0;
        }
        .modal-title { font-family: 'Cinzel Decorative', cursive; font-size: 1.5rem; color: var(--ink); }
        .modal-close-btn { background: none; border: none; cursor: pointer; color: var(--ink-light); font-size: 1.8rem; line-height: 1; transition: var(--fade); }
        .modal-close-btn:hover { color: var(--crimson); }
        .modal-body {
            flex-grow: 1; overflow: hidden; display: flex; flex-direction: column;
            min-height: 300px; padding: 0 28px;
        }
        .settings-page { display: none; flex-grow: 1; overflow-y: auto; padding: 20px 5px 20px 0; scrollbar-width: thin; scrollbar-color: var(--modal-scrollbar-thumb) var(--modal-scrollbar-track); }
        .settings-page.active { display: block; }
        .settings-page::-webkit-scrollbar { width: 8px; } .settings-page::-webkit-scrollbar-track { background: var(--modal-scrollbar-track); border-radius: 4px; } .settings-page::-webkit-scrollbar-thumb { background-color: var(--modal-scrollbar-thumb); border-radius: 4px; border: 1px solid var(--modal-scrollbar-track); } .settings-page::-webkit-scrollbar-thumb:hover { background-color: var(--modal-scrollbar-thumb-hover); }
        .settings-section { margin-bottom: 25px; padding-bottom: 20px; border-bottom: 1px dashed var(--ink-light); } .settings-section:last-child { border-bottom: none; margin-bottom: 0; }
        .settings-section-title { font-size: 1.3rem; font-weight: bold; color: var(--ink); margin-bottom: 15px; border-bottom: 1px solid var(--gold); padding-bottom: 8px; font-family: 'Cinzel Decorative', cursive; }
        .settings-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
        .settings-item { background-color: var(--parchment-dark); padding: 15px; border-radius: 6px; border: 1px solid var(--ink-light); position: relative; }
        .settings-label { display: block; font-weight: bold; margin-bottom: 5px; font-size: 0.9rem; color: var(--ink); }
        .settings-input, .settings-textarea, .settings-select {
            width: 100%; padding: 10px 12px; border: 1px solid var(--ink-light); border-radius: 4px;
            font-family: inherit; font-size: 1rem; background-color: var(--parchment); color: var(--ink);
            margin-bottom: 10px; box-sizing: border-box; line-height: 1.5;
        }
        .settings-textarea { min-height: 80px; resize: vertical; }
        .settings-input:focus, .settings-textarea:focus, .settings-select:focus {
             border-color: var(--gold); outline: none; box-shadow: 0 0 0 3px rgba(201, 162, 39, 0.3);
        }
        .settings-env-item { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; position: relative; padding-right: 30px; }
        .settings-env-label { flex-shrink: 0; width: 80px; text-align: right; font-weight: normal; color: var(--ink); }
        .settings-env-input { flex-grow: 1; }
        .settings-delete-btn { position: absolute; top: 5px; right: 5px; width: 20px; height: 20px; line-height: 18px; text-align: center; background-color: var(--danger-color); color: white; border: none; border-radius: 50%; cursor: pointer; font-size: 12px; font-weight: bold; transition: background-color 0.2s ease; padding: 0; }
        .settings-delete-btn:hover { background-color: var(--danger-hover); }
        .settings-env-item .settings-delete-btn { top: 50%; right: 5px; transform: translateY(-50%); }
        .settings-city-controls { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .settings-city-controls label { font-weight: bold; color: var(--ink); flex-shrink: 0; margin-right: 5px; }
        .settings-city-selector { padding: 8px 10px; border-radius: 4px; border: 1px solid var(--ink-light); background-color: var(--parchment); color: var(--ink); font-size: 1rem; flex-grow: 1; min-width: 150px; font-family: inherit; }
        .settings-city-edit-btn { padding: 6px 10px; font-size: 1rem; height: 38px; line-height: 1; border-radius: 6px; background-color: var(--ink-light); color: var(--parchment); border: none; cursor: pointer; flex-shrink: 0; transition: var(--fade); font-family: 'Cinzel Decorative', cursive; display: inline-flex; align-items: center; justify-content: center;}
        .settings-city-edit-btn:hover { background-color: var(--ink); }
        .settings-city-delete-btn { background-color: var(--danger-color); color: white; } .settings-city-delete-btn:hover { background-color: var(--danger-hover); }
        .settings-city-add-btn { background-color: var(--gold); color: var(--ink); } .settings-city-add-btn:hover { background-color: #a1801f; }

        /* ---- API Key Multi-Key Styles ---- */
        .settings-api-config { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;}
        .api-key-management { display: flex; flex-direction: column; gap: 15px; }
        .api-key-list-container { max-height: 150px; overflow-y: auto; border: 1px solid var(--ink-light); border-radius: 4px; background-color: var(--parchment-dark); padding: 8px; scrollbar-width: thin; scrollbar-color: var(--modal-scrollbar-thumb) var(--modal-scrollbar-track); }
        .api-key-list-container::-webkit-scrollbar { width: 6px; } .api-key-list-container::-webkit-scrollbar-track { background: var(--modal-scrollbar-track); border-radius: 3px; } .api-key-list-container::-webkit-scrollbar-thumb { background-color: var(--modal-scrollbar-thumb); border-radius: 3px; } .api-key-list-container::-webkit-scrollbar-thumb:hover { background-color: var(--modal-scrollbar-thumb-hover); }
        .api-key-item { display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px dashed var(--ink-light); font-size: 0.9rem; } .api-key-item:last-child { border-bottom: none; }
        .api-key-item span { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 70%; font-family: monospace; }
        .api-key-item-controls { display: flex; gap: 5px; flex-shrink: 0; }
        .api-key-item-controls button { padding: 3px 8px; font-size: 0.8rem; border-radius: 3px; cursor: pointer; border: none; transition: var(--fade); font-family: 'Cinzel Decorative', cursive; }
        .api-key-item-delete-btn { background-color: var(--danger-color); color: white; } .api-key-item-delete-btn:hover { background-color: var(--danger-hover); }
        .api-key-add-controls { display: flex; gap: 10px; }
        #newApiKeyInput { flex-grow: 1; padding: 10px 12px; border: 1px solid var(--ink-light); border-radius: 4px; font-family: inherit; font-size: 1rem; background-color: var(--parchment); color: var(--ink); box-sizing: border-box; }
        #addApiKeyBtn { padding: 8px 15px; border-radius: 5px; font-weight: bold; cursor: pointer; transition: var(--fade); border: none; font-size: 1rem; background-color: var(--gold); color: var(--ink); font-family: 'Cinzel Decorative', cursive; }
        #addApiKeyBtn:hover:not(:disabled) { background-color: #a1801f; }
        #addApiKeyBtn:disabled { background-color: var(--ink-light); opacity: 0.7; cursor: not-allowed; }
        #newApiKeyInput:disabled { background-color: var(--parchment-dark); cursor: not-allowed; }
        .active-key-display { margin-top: 10px; font-size: 0.9rem; color: var(--ink-light); }
        .active-key-display strong { font-family: monospace; color: var(--amethyst); }
        .key-list-message { font-style: italic; color: var(--ink-light); text-align: center; padding: 10px 0; font-size: 0.9rem; }
        /* --- END API Key Multi-Key Styles ---- */

        .map-size-inputs { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; }
        .map-size-inputs input[type="number"] { width: 80px; padding: 8px 10px; font-size: 1rem; border: 1px solid var(--ink-light); background-color: var(--parchment); color: var(--ink); border-radius: 4px;}
        .map-size-inputs label { font-size: 1rem; color: var(--ink); margin-right: 5px; }
        .settings-checkbox-item { display: flex; align-items: center; gap: 8px; background-color: var(--parchment-dark); padding: 10px 15px; border-radius: 6px; border: 1px solid var(--ink-light); }
        .settings-checkbox-item label { font-size: 1rem; color: var(--ink); cursor: pointer; user-select: none; }
        .settings-checkbox-item input[type="checkbox"] { cursor: pointer; accent-color: var(--gold); }
        .settings-pagination {
            display: flex; justify-content: space-between; align-items: center;
            margin-top: 0; padding: 15px 28px;
            border-top: 1px solid var(--ink-light); flex-shrink: 0;
        }
        .pagination-btn { padding: 8px 16px; border-radius: 5px; font-family: 'Cinzel Decorative', cursive; font-weight: bold; cursor: pointer; transition: var(--fade); border: none; font-size: 1rem; background-color: var(--ink-light); color: var(--parchment); }
        .pagination-btn:hover:not(:disabled) { background-color: var(--ink); }
        .pagination-btn:disabled { background-color: var(--parchment-dark); color: var(--ink-light); cursor: not-allowed; }
        .page-indicator { font-size: 1rem; color: var(--ink-light); font-weight: bold; }
        .modal-footer {
            margin-top: 0; padding: 15px 28px 20px 28px;
            border-top: 1px solid var(--ink-light); display: flex; justify-content: flex-end;
            gap: 10px; flex-shrink: 0; background-color: var(--parchment-dark);
        }
        .modal-btn { padding: 12px 24px; border-radius: 5px; font-family: 'Cinzel Decorative', cursive; font-weight: bold; cursor: pointer; transition: var(--fade); border: none; font-size: 1.1rem; }
        .modal-btn-primary { background-color: var(--gold); color: var(--ink); } .modal-btn-primary:hover { background-color: var(--crimson); color: white; }
        .modal-btn-secondary { background-color: var(--ink-light); color: var(--parchment); } .modal-btn-secondary:hover { background-color: var(--ink); color: white; }


        /* --- Appearance Editor Modal --- */
        /* ... (Unchanged - omitted for brevity) ... */
         #appearance-editor-overlay .modal-content { max-width: 900px; }
        #appearance-editor-overlay .modal-body { overflow-y: auto; padding: 20px 28px 20px 28px; flex-grow: 1; scrollbar-width: thin; scrollbar-color: var(--modal-scrollbar-thumb) var(--modal-scrollbar-track); touch-action: pan-y; -webkit-overflow-scrolling: touch; min-height: 0; }
        #appearance-editor-overlay .modal-body::-webkit-scrollbar { width: 8px; } #appearance-editor-overlay .modal-body::-webkit-scrollbar-track { background: var(--modal-scrollbar-track); border-radius: 4px; } #appearance-editor-overlay .modal-body::-webkit-scrollbar-thumb { background-color: var(--modal-scrollbar-thumb); border-radius: 4px; border: 1px solid var(--modal-scrollbar-track); } #appearance-editor-overlay .modal-body::-webkit-scrollbar-thumb:hover { background-color: var(--modal-scrollbar-thumb-hover); }
        .appearance-editor-details { padding: 15px; background-color: var(--parchment-dark); border: 1px solid var(--ink-light); border-radius: 6px; margin-bottom: 15px; display: grid; grid-template-columns: auto 1fr auto; gap: 10px 15px; align-items: center; }
        .appearance-editor-details label { font-weight: bold; font-size: 1rem; color: var(--ink); text-align: right; }
        .appearance-editor-details input, .appearance-editor-details textarea { grid-column: 2; width: 100%; padding: 10px 12px; border: 1px solid var(--ink-light); border-radius: 4px; font-family: inherit; font-size: 1rem; background-color: var(--parchment); color: var(--ink); box-sizing: border-box; }
        .appearance-editor-details textarea { min-height: 60px; resize: vertical; line-height: 1.5; }
        .appearance-editor-details input:focus, .appearance-editor-details textarea:focus { border-color: var(--gold); outline: none; box-shadow: 0 0 0 3px rgba(201, 162, 39, 0.3); }
        .appearance-pfp-section { grid-column: 3; display: flex; flex-direction: column; align-items: center; gap: 8px; padding-left: 15px; }
        .appearance-pfp-preview { width: 60px; height: 60px; border-radius: 50%; object-fit: cover; border: 2px solid var(--ink-light); cursor: pointer; transition: border-color 0.3s ease; }
        .appearance-pfp-preview:hover { border-color: var(--gold); }
        .appearance-pfp-change-btn { font-size: 0.9rem; color: var(--ink-light); cursor: pointer; text-decoration: underline; background: none; border: none; padding: 0; }
        .appearance-pfp-change-btn:hover { color: var(--gold); }
        .appearance-iframe-container { border: 1px solid var(--ink-light); padding: 0; background-color: var(--parchment-dark); border-radius: 6px; overflow: hidden; flex-shrink: 0; }
        #characterCreatorFrame { width: 100%; height: 500px; border: none; display: block; background-color: var(--ink-light); }
        .pfp-upload { display: none; }


        /* --- Context Menu --- */
        .context-menu { display: none; position: absolute; background-color: var(--parchment-dark); border: 1px solid var(--ink-light); border-radius: 4px; padding: 5px 0; z-index: 1050; box-shadow: var(--shadow); min-width: 180px; font-size: 1rem; color: var(--ink); font-family: Georgia, serif; }
        .context-menu-item { padding: 8px 18px; cursor: pointer; white-space: nowrap; }
        .context-menu-item:hover { background-color: var(--ink-light); color: var(--parchment); }
        .context-menu-divider { border: none; border-top: 1px solid var(--ink-light); margin: 4px 0; }

        /* Animations */
        @keyframes appear { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }
        @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }

        /* Responsive */
        @media (max-width: 768px) {
            body { font-size: 1rem; } .chat-messages { padding: 18px; }
            .message-content { padding: 15px 18px; font-size: 1rem; } .input-container { padding: 15px; }
            #userInput { padding: 15px; min-height: 50px; font-size: 1rem; }
            #sendButton { height: 55px; padding: 0 18px; font-size: 1rem; }
            .avatar { width: 40px; height: 40px; font-size: 1.1rem; }
             .typing-indicator { margin-left: 55px; font-size: 0.9rem;} .rune { font-size: 1rem;}
             /* Modal adjustments */
             .modal-content { padding: 0; width: 95%; }
             .modal-header { padding: 15px 20px 10px 20px; }
             .modal-body { padding: 0 20px; }
             .settings-page { padding: 15px 5px 15px 0; }
             .settings-pagination { padding: 10px 20px; flex-direction: column; gap: 10px; } .page-indicator { order: -1; }
             .modal-footer { padding: 10px 20px 15px 20px; }
             /* Appearance Editor */
             #appearance-editor-overlay .modal-body { padding: 15px 20px; }
             .appearance-editor-details { grid-template-columns: auto 1fr; }
             .appearance-pfp-section { grid-column: 1 / -1; grid-row: 3; justify-self: center; padding-left: 0; margin-top: 10px; }
            /* Adjust tab buttons for smaller screens */
            #chat-tabs-container { padding: 5px 8px; gap: 5px; } /* Further reduced padding/gap */
            #chat-tabs-container button { padding: 4px 8px; font-size: 0.8rem; } /* Smaller padding/font */
            #chat-tabs-container button#general-tab { padding: 4px 10px; }
             #chat-tabs-container button#area-tab,
             #chat-tabs-container button#city-tab,
             #chat-tabs-container button#world-tab,
             #chat-tabs-container button#message-tab,
             #chat-tabs-container button#agent-tab { font-size: 0.7rem; } /* Even smaller font */
             /* API Config Responsive */
             .settings-api-config { grid-template-columns: 1fr; } /* Stack on mobile */
             .api-key-list-container { max-height: 120px; }
             .api-key-item span { max-width: 60%; }
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <div id="game-world">
            <div id="map-content">
                 <div class="character" id="player" data-name="Player">
                    <div class="part detail5"></div> <div class="part detail4"></div>
                    <div class="part detail3"></div> <div class="part legs"></div>
                    <div class="part arm-left"></div> <div class="part arm-right"></div>
                    <div class="part torso"></div> <div class="part detail1"></div>
                    <div class="part detail2"></div> <div class="part head"></div>
                    <span class="character-name-plate">Player</span>
                    <span class="speech"></span>
                </div>
                 <!-- NPCs -->
            </div>
        </div>
        <div id="chat-area">
             <!-- Chat Tabs Container -->
             <div id="chat-tabs-container">
                 <button id="general-tab">GENERAL</button>
                 <button id="area-tab">AREA</button>
                 <button id="city-tab">CITY</button>
                 <button id="world-tab">WORLD</button>
                 <button id="message-tab">MESSAGE</button>
                 <button id="agent-tab">AGENT</button> <!-- Added Agent Tab -->
             </div>
             <div class="chat-messages" id="chatMessages"></div>
             <div class="input-container">
                <textarea class="message-input" id="userInput" placeholder="Consult the spirit..." rows="1"></textarea>
                 <button class="send-button" id="sendButton" title="Send Message"><span>Send</span><span style="font-size: 1.2em;">â†’</span></button>
            </div>
        </div>
    </div>

    <!-- Settings Modal (Paginated) -->
    <div class="modal-overlay" id="settings-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Tome Configuration</h3>
                <button class="modal-close-btn" id="modal-close-btn">Ã—</button>
             </div>
            <div class="modal-body" id="settings-body-container">
                <!-- Pages populated by JS -->
            </div>
             <div class="settings-pagination" id="settings-pagination-controls">
                 <button class="pagination-btn" id="settings-prev-btn">&laquo; Previous</button>
                 <span class="page-indicator" id="settings-page-indicator">Page 1 / 4</span>
                 <button class="pagination-btn" id="settings-next-btn">Next &raquo;</button>
             </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" id="modal-cancel-btn">Cancel</button>
                <button class="modal-btn modal-btn-primary" id="modal-save-btn">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Appearance Editor Modal -->
     <div class="modal-overlay" id="appearance-editor-overlay">
         <div class="modal-content">
             <div class="modal-header">
                 <h3 class="modal-title" id="appearance-editor-title">Set Appearance & Details</h3>
                 <button class="modal-close-btn" id="appearance-editor-close-btn">Ã—</button>
             </div>
             <div class="modal-body">
                 <div class="appearance-editor-details">
                     <label for="appearance-editor-name">Name:</label>
                     <input type="text" id="appearance-editor-name" class="settings-input">
                     <label for="appearance-editor-persona">Persona:</label>
                     <textarea id="appearance-editor-persona" class="settings-textarea"></textarea>
                     <label>Sigil:</label>
                     <div class="appearance-pfp-section">
                         <img src="" alt="Sigil Preview" class="appearance-pfp-preview" id="appearance-pfp-preview" title="Click to change sigil">
                         <button class="appearance-pfp-change-btn" id="appearance-pfp-change-btn">Change Sigil</button>
                     </div>
                 </div>
                 <div class="appearance-iframe-container">
                     <iframe id="characterCreatorFrame" src="character_creator.html"></iframe>
                 </div>
             </div>
             <div class="modal-footer">
                 <button class="modal-btn modal-btn-secondary" id="appearance-editor-cancel-btn">Cancel</button>
                 <button class="modal-btn modal-btn-primary" id="appearance-editor-save-btn">Save Appearance & Details</button>
             </div>
         </div>
     </div>

    <!-- Context Menus -->
    <div id="npc-context-menu" class="context-menu" style="display: none;">
        <!-- 'Switch Mode' removed, handled by tabs now -->
        <div class="context-menu-item" data-action="talk">Talk (Agent Mode)</div> <!-- Specify mode -->
        <div class="context-menu-item" data-action="message">Message (Persona Mode)</div> <!-- Specify mode -->
        <div class="context-menu-item" data-action="follow">Follow</div>
        <div class="context-menu-item" data-action="appearance">Set Appearance, Details & Sigil</div>
        <hr class="context-menu-divider">
        <div class="context-menu-item" data-action="cancel">Cancel</div>
    </div>
    <div id="player-context-menu" class="context-menu" style="display: none;">
        <div class="context-menu-item" data-action="appearance">Set Appearance, Details & Sigil</div> <hr class="context-menu-divider">
        <div class="context-menu-item" data-action="add_area">Add Area Here</div> <div class="context-menu-item" data-action="add_agent">Add Agent Here</div> <hr class="context-menu-divider">
        <div class="context-menu-item" data-action="remove_closest_agent">Remove Closest Agent</div> <div class="context-menu-item" data-action="remove_closest_area">Remove Closest Area</div> <hr class="context-menu-divider">
        <div class="context-menu-item" data-action="cancel">Cancel</div>
    </div>
    <!-- PFP Context Menu -->
    <div id="pfp-context-menu" class="context-menu" style="display: none;">
        <div class="context-menu-item" data-action="toggle-tabs">Show/Hide Chat Tabs</div>
        <div class="context-menu-item" data-action="toggle-fullscreen">Toggle Fullscreen Chat</div>
        <hr class="context-menu-divider">
        <div class="context-menu-item" data-action="cancel">Cancel</div>
    </div>

    <input type="file" class="pfp-upload" id="pfp-upload" accept="image/*">

    <!-- Load External Scripts -->
    <script src="api_providers.js"></script>
    <script src="spatial_chat_manager.js"></script> <!-- Added Spatial Chat Manager -->

    <script>
        marked.setOptions({ breaks: true, gfm: true, smartypants: true });
        function darkenHexColor(h, p) { if (!h || typeof h !== 'string') return '#000'; h = h.replace(/^#/, ''); if (h.length === 3) h = h.split('').map(c => c + c).join(''); if (h.length !== 6) return '#000'; let r = parseInt(h.substring(0, 2), 16), g = parseInt(h.substring(2, 4), 16), b = parseInt(h.substring(4, 6), 16); r = Math.max(0, Math.floor(r * (1 - p))); g = Math.max(0, Math.floor(g * (1 - p))); b = Math.max(0, Math.floor(b * (1 - p))); return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`; }
        function maskApiKey(key) { if (!key || typeof key !== 'string') return "INVALID"; return key.length > 8 ? `${key.substring(0, 4)}...${key.substring(key.length - 4)}` : key; }

        function runSimulation() {
            // --- Element Refs ---
            const gameWorld = document.getElementById('game-world'); const mapContent = document.getElementById('map-content');
            const chatArea = document.getElementById('chat-area'); const chatMessages = document.getElementById('chatMessages');
            const userInput = document.getElementById('userInput'); const sendButton = document.getElementById('sendButton');
            const playerElement = document.getElementById('player');
            const settingsOverlay = document.getElementById('settings-overlay'); const settingsBodyContainer = document.getElementById('settings-body-container');
            const settingsPaginationControls = document.getElementById('settings-pagination-controls'); const settingsPrevBtn = document.getElementById('settings-prev-btn');
            const settingsNextBtn = document.getElementById('settings-next-btn'); const settingsPageIndicator = document.getElementById('settings-page-indicator');
            const modalCloseBtn = document.getElementById('modal-close-btn'); const modalCancelBtn = document.getElementById('modal-cancel-btn');
            const modalSaveBtn = document.getElementById('modal-save-btn');
            const npcContextMenu = document.getElementById('npc-context-menu');
            const playerContextMenu = document.getElementById('player-context-menu');
            const pfpContextMenu = document.getElementById('pfp-context-menu');
            const appearanceEditorOverlay = document.getElementById('appearance-editor-overlay');
            const appearanceEditorTitle = document.getElementById('appearance-editor-title'); const appearanceEditorCloseBtn = document.getElementById('appearance-editor-close-btn');
            const appearanceEditorCancelBtn = document.getElementById('appearance-editor-cancel-btn'); const appearanceEditorSaveBtn = document.getElementById('appearance-editor-save-btn');
            const characterCreatorFrame = document.getElementById('characterCreatorFrame'); const appearanceEditorNameInput = document.getElementById('appearance-editor-name');
            const appearanceEditorPersonaInput = document.getElementById('appearance-editor-persona'); const pfpUploadInput = document.getElementById('pfp-upload');
            const appearancePfpPreview = document.getElementById('appearance-pfp-preview'); const appearancePfpChangeBtn = document.getElementById('appearance-pfp-change-btn');
            const chatTabsContainer = document.getElementById('chat-tabs-container');
            // Tab Buttons
            const generalTabBtn = document.getElementById('general-tab');
            const areaTabBtn = document.getElementById('area-tab');
            const cityTabBtn = document.getElementById('city-tab');
            const worldTabBtn = document.getElementById('world-tab');
            const messageTabBtn = document.getElementById('message-tab');
            const agentTabBtn = document.getElementById('agent-tab'); // Added
            const allTabButtons = [generalTabBtn, areaTabBtn, cityTabBtn, worldTabBtn, messageTabBtn, agentTabBtn];

            // --- Game State & Config ---
            let MAP_WIDTH = 3000; let MAP_HEIGHT = 2000; let viewportWidth, viewportHeight;
            const npcData = []; // Holds full NPC data { id, element, name, personaPrompt, x, y, etc. }
            const environmentData = []; // Holds { id, name, x, y, width, height, element, nameElement }
            const playerData = { appearance: null, isPlayer: true, pfp: null, name: 'Player', personaPrompt: 'You are the Player.', x: 0, y: 0, element: playerElement, speechElement: null, nameplateElement: null, width: 24, height: 36 };
            const playerStepDistance = 16; const globalSpeechDuration = 4500;
            let currentAiNpcData = null; // NPC target for Message/Agent tabs
            let initialSpeakerData = null; // Closest NPC on load
            let currentCityKey = null;
            let isPlayerMoving = false; let playerMoveTimeout = null; let contextMenuTargetNpcId = null;
            let contextMenuTargetIsPlayer = false; let appearanceEditorTarget = null; let temporaryAppearanceData = null;
            let temporaryPfpData = null; let isWaitingForApiResponse = false; let hideSystemMessages = false;
            let npcFollowInterval = null; const FOLLOW_DISTANCE = 50; const NPC_FOLLOW_SPEED = 1.5;
            let currentSettingsPage = 1; const TOTAL_SETTINGS_PAGES = 4;
            let chatHeightBeforeFullscreen = null;
            let chatTabsVisible = true;

            // NEW: Chat Tab / Context State
            let currentChatTab = 'Agent'; // Default tab: General, Area, City, World, Message, Agent
            let isSpatialTabActive = false; // True if General, Area, City, World is active
            let conversationHistory = []; // ONLY for 'Message' (Persona) and 'Agent' direct interaction tabs
            // Spatial chat history is managed by SpatialChatManager

            // --- API Provider State (Multi-Key per Provider) ---
            let selectedProvider = null;
            let selectedModel = null;
            let apiKeyManagement = {
                providerKeys: {}, // { PROVIDER_ID: ["key1", "key2", ...] }
                activeKeyIndices: {} // { PROVIDER_ID: 0 } // Index of the *next* key to try
            };

            const defaultNpcAppearance = { outfit: 'citizen', gender: 'female', colors: { hair: '#e4b881', primary: '#a34444', secondary: '#fbe5d6', detail1: '#7a2a2a', legs: '#693434', feet: '#2a2a30' } };
            const defaultPlayerAppearance = { outfit: 'citizen', gender: 'male', colors: { hair: '#4a3021', primary: '#5d7a8a', secondary: '#d1c6b0', detail1: '#8b4513', legs: '#444450', feet: '#2a2a30' } };
            const DEFAULT_PLAYER_PFP = 'https://ui-avatars.com/api/?name=Player&background=1e3a8a&color=fff&size=64';
            const DEFAULT_NPC_PFP = 'https://ui-avatars.com/api/?name=Agent&background=6b21a8&color=fff&size=64';

            const MAX_HISTORY_TURNS = 6; let recentEvents = []; // Used for Agent mode context
            const USER_CITY_PREFIX = "userCity_";
            const LS_KEYS = {
                selectedCity: 'selectedCityKey',
                // interactionMode: 'interactionMode', // Replaced by currentChatTab
                currentChatTab: 'currentChatTab', // NEW
                providerApiKeysStorage: 'providerApiKeys_v2',
                chatAreaHeight: 'chatAreaHeight', hideSystemMessages: 'hideSystemMessages',
                playerAppearance: 'global-player-appearance', playerName: 'global-player-name',
                playerPersona: 'global-player-persona', playerPfp: 'global-player-pfp',
                playerPositionX: (cityKey) => `player-${cityKey}-x`, playerPositionY: (cityKey) => `player-${cityKey}-y`,
                npcName: (cityKey, npcId) => `npc-${cityKey}-${npcId}-name`, npcPersona: (cityKey, npcId) => `npc-${cityKey}-${npcId}-persona`,
                npcAppearance: (cityKey, npcId) => `npc-${cityKey}-${npcId}-appearance`, npcPfp: (cityKey, npcId) => `npc-${cityKey}-${npcId}-pfp`,
                npcPositionX: (cityKey, npcId) => `npc-${cityKey}-${npcId}-x`, npcPositionY: (cityKey, npcId) => `npc-${cityKey}-${npcId}-y`,
                envName: (cityKey, envId) => `env-${cityKey}-${envId}-name`,
                chatTabsVisible: 'chatTabsVisible',
                selectedProvider: 'selectedApiKeyProvider',
                selectedModel: 'selectedApiModel',
                conversationHistoryAgent: 'conversationHistoryAgent', // Separate history for Agent tab
                conversationHistoryMessage: 'conversationHistoryMessage', // Separate history for Message tab
            };

            // --- CORE FUNCTIONS ---
            function updateNameplate(c){if(c&&c.nameplateElement)c.nameplateElement.textContent=c.name;}

            /**
             * Displays a message in the chat UI. Handles different sender types and markdown.
             * This is the MAIN function for putting things in the chat box, called by various parts.
             */
            function addMessage(text, senderName, type, // 'user', 'assistant', 'system', 'debug', 'error'
                                speakerData = null, // Optional { name, pfp } for assistant PFP override
                                options = { skipHistory: false } // Option to skip adding to Message/Agent history
                                ) {
                 if (hideSystemMessages && ['debug', 'system', 'error'].includes(type)) return;

                 const messageDiv = document.createElement('div');
                 messageDiv.classList.add('message');
                 let senderTypeClass = '', avatarClass = '', pfpSrc = '', isMarkdown = false, displayName = senderName || 'Unknown';

                 // Determine styling and PFP based on type
                 if (type === 'user') {
                     senderTypeClass = 'message-user'; avatarClass = 'user-avatar'; pfpSrc = playerData.pfp || DEFAULT_PLAYER_PFP;
                     displayName = playerData.name || 'Player'; isMarkdown = false;
                 } else if (type === 'assistant') { // Bot/NPC response
                     senderTypeClass = 'message-spirit'; avatarClass = 'spirit-avatar';
                     // Use speakerData if provided (e.g., from spatial chat or direct interaction), otherwise default NPC
                     pfpSrc = speakerData?.pfp || DEFAULT_NPC_PFP;
                     displayName = speakerData?.name || senderName; // Use speakerData name if available
                     isMarkdown = true;
                 } else { // System, Debug, Error
                     senderTypeClass = type === 'error' ? 'message-debug' : `message-${type}`; avatarClass = type === 'error' ? 'debug-avatar' : `${type}-avatar`;
                     const systemBgColor = getComputedStyle(document.documentElement).getPropertyValue('--amethyst').trim() || '#6b21a8';
                     const defaultBgColor = getComputedStyle(document.documentElement).getPropertyValue('--ink-light').trim() || '#5a4e42';
                     const avatarBg = (type === 'system') ? systemBgColor : defaultBgColor;
                     pfpSrc = `https://ui-avatars.com/api/?name=${encodeURIComponent(displayName.substring(0,1))}&background=${avatarBg.substring(1)}&color=fff&size=64`;
                     displayName = senderName; isMarkdown = false; text = `[${type.toUpperCase()}] ${text}`;
                 }

                 messageDiv.classList.add(senderTypeClass);
                 const avatarImg = document.createElement('img');
                 avatarImg.className = `avatar ${avatarClass}`; avatarImg.src = pfpSrc; avatarImg.alt = `${displayName} avatar`; avatarImg.title = displayName;

                 // Avatar Click Logic
                 if (type === 'assistant' || type === 'system' || type === 'debug' || type === 'error') {
                     avatarImg.addEventListener('click', openSettingsModal);
                 } else if (type === 'user') {
                     avatarImg.addEventListener('click', showPfpContextMenu);
                 }

                 // Content Div
                 const contentDiv = document.createElement('div');
                 contentDiv.className = `message-content ${senderTypeClass.replace('message-', '')}-message`;

                 // Render Content (Markdown or Text)
                 if (isMarkdown) {
                     try {
                         contentDiv.innerHTML = marked.parse(text); // RENDER MARKDOWN
                         // Add copy buttons to code blocks (timeout ensures elements exist)
                         setTimeout(() => {
                             contentDiv.querySelectorAll('pre code').forEach(codeBlock => {
                                 const preElement = codeBlock.parentElement;
                                 if (preElement?.tagName === 'PRE' && !preElement.querySelector('.copy-code-btn')) {
                                     const btn = document.createElement('button');
                                     btn.className = 'copy-code-btn'; btn.textContent = 'Copy'; btn.title = 'Copy';
                                     btn.addEventListener('click', (e) => { /* ... copy logic ... */
                                          e.stopPropagation();
                                          navigator.clipboard.writeText(codeBlock.textContent)
                                              .then(() => { btn.textContent = 'Copied!'; btn.classList.add('copied'); setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 2000); })
                                              .catch(err => { console.error("Copy failed: ", err); btn.textContent = 'Error'; setTimeout(() => { btn.textContent = 'Copy'; }, 1500); });
                                      });
                                     preElement.style.position = 'relative';
                                     preElement.appendChild(btn);
                                 }
                             });
                         }, 0);
                     } catch (e) { console.error("Markdown parse error:", e); contentDiv.textContent = text; }
                 } else { // Plain text
                     if (['system', 'debug', 'error'].includes(type)) { const nS = document.createElement('span'); nS.className = 'message-name'; nS.textContent = `${displayName}: `; contentDiv.appendChild(nS); }
                     contentDiv.appendChild(document.createTextNode(text.replace(/\[(SYSTEM|DEBUG|ERROR)\]\s*/, ''))); // Display text without prefix
                 }

                 // Append elements based on sender
                 if (type === 'user') { messageDiv.appendChild(contentDiv); messageDiv.appendChild(avatarImg); }
                 else { messageDiv.appendChild(avatarImg); messageDiv.appendChild(contentDiv); }

                 chatMessages.appendChild(messageDiv);
                 // Debounced scroll to bottom
                 requestAnimationFrame(() => {
                     chatMessages.scrollTop = chatMessages.scrollHeight;
                 });

                 // Add to relevant conversation history (ONLY for Agent/Message tabs)
                  if (!options.skipHistory && (currentChatTab === 'Agent' || currentChatTab === 'Message') && (type === 'user' || type === 'assistant')) {
                     conversationHistory.push({ role: type, content: text });
                     if (conversationHistory.length > (MAX_HISTORY_TURNS * 2)) {
                         conversationHistory.shift(); // Keep history trimmed
                     }
                     saveCurrentConversationHistory(); // Save history for the current non-spatial tab
                 }

                 // Add system events for Agent mode context
                 if (currentChatTab === 'Agent' && type === 'system' && !text.includes("Settings saved") && !text.includes("Switched to")) {
                    recentEvents.push(`Event: ${text.replace('[SYSTEM] ', '')}`);
                    if(recentEvents.length > 5) recentEvents.shift();
                 }
            }


            // --- Chat Tab Visibility ---
            function setChatTabsVisibility(isVisible) {
                chatTabsVisible = isVisible;
                chatTabsContainer.classList.toggle('hidden', !isVisible);
                try { localStorage.setItem(LS_KEYS.chatTabsVisible, isVisible ? 'true' : 'false'); }
                catch (e) { console.error("Failed to save chat tab visibility state:", e); }
            }
            function toggleChatTabsVisibility() { setChatTabsVisibility(!chatTabsVisible); }

            // --- Context Menu Functions ---
            function handleGenericContextMenu(event, menuElement) { /* ... unchanged ... */
                event.preventDefault();
                closeAllContextMenus();
                const t = event.currentTarget;
                contextMenuTargetNpcId = null;
                contextMenuTargetIsPlayer = false;

                if (menuElement.id === 'player-context-menu') {
                    if (!currentCityKey || playerData.element.style.display === 'none') return;
                    contextMenuTargetIsPlayer = true;
                } else if (menuElement.id === 'npc-context-menu') {
                    if (!currentCityKey) return;
                    contextMenuTargetNpcId = parseInt(t.dataset.npcId, 10);
                    if (isNaN(contextMenuTargetNpcId)) { console.error("No NPC ID:", t); return; }
                    const n = npcData.find(n => n.id === contextMenuTargetNpcId);
                    if (!n) return;
                    // updateContextMenuModeText(); // No longer needed
                } else if (menuElement.id === 'pfp-context-menu') {
                    const toggleTabsItem = pfpContextMenu.querySelector('[data-action="toggle-tabs"]');
                    if (toggleTabsItem) { toggleTabsItem.textContent = chatTabsVisible ? "Hide Tabs" : "Show Tabs"; }
                    const toggleFullscreenItem = pfpContextMenu.querySelector('[data-action="toggle-fullscreen"]');
                    if (toggleFullscreenItem) {
                        const isCurrentlyFullscreen = chatArea.offsetHeight >= (window.innerHeight - 10);
                        toggleFullscreenItem.textContent = isCurrentlyFullscreen ? "Minimize Chat" : "Fullscreen Chat";
                    }
                } else { return; }

                const mW = menuElement.offsetWidth; const mH = menuElement.offsetHeight;
                let x = event.clientX; let y = event.clientY;
                if (x + mW > window.innerWidth) x -= mW;
                if (y + mH > window.innerHeight) y -= mH;
                menuElement.style.left = `${x}px`; menuElement.style.top = `${y}px`;
                menuElement.style.display = 'block';
                document.addEventListener('click', closeContextMenuOnClickOutside, { capture: true, once: true });
                document.addEventListener('contextmenu', closeContextMenuOnClickOutside, { capture: true, once: true });
            }
            function handleNpcContextMenu(event) { handleGenericContextMenu(event, npcContextMenu); }
            function handlePlayerContextMenu(event) { handleGenericContextMenu(event, playerContextMenu); }
            function showPfpContextMenu(event) { handleGenericContextMenu(event, pfpContextMenu); }
            function closeAllContextMenus() { /* ... unchanged ... */
                npcContextMenu.style.display = 'none';
                playerContextMenu.style.display = 'none';
                pfpContextMenu.style.display = 'none';
                contextMenuTargetNpcId = null;
                contextMenuTargetIsPlayer = false;
            }
            function closeContextMenuOnClickOutside(event) { /* ... unchanged ... */
                const activeMenu = [npcContextMenu, playerContextMenu, pfpContextMenu].find(menu => menu.style.display === 'block');
                if (activeMenu && !activeMenu.contains(event.target)){ closeAllContextMenus(); }
                else if (activeMenu) {
                    document.addEventListener('click', closeContextMenuOnClickOutside, { capture: true, once: true });
                    document.addEventListener('contextmenu', closeContextMenuOnClickOutside, { capture: true, once: true });
                }
             }

            // --- Other Core Functions (Helpers, Movement, Appearance, etc.) ---
            function getRandomHexColor(){ /* ... unchanged ... */ const l='0123456789ABCDEF';let c='#';for(let i=0;i<6;i++)c+=l[Math.floor(Math.random()*16)];const r=parseInt(c.substring(1,3),16),g=parseInt(c.substring(3,5),16),b=parseInt(c.substring(5,7),16);return(r<50&&g<50&&b<50)?getRandomHexColor():c; }
            function showSpeechBubble(c,m){ /* ... unchanged ... */ if(!c||!c.speechElement)return;if(c.speechTimeout)clearTimeout(c.speechTimeout);c.speechElement.textContent=m;c.speechElement.style.display='block';c.isTalking=true;c.speechTimeout=setTimeout(()=>{if(c.speechElement)c.speechElement.style.display='none';c.isTalking=false;c.speechTimeout=null;},globalSpeechDuration); }
            function updateCharacterPosition(c){ if(c&&c.element){c.element.style.left=`${c.x}px`;c.element.style.top=`${c.y}px`;} }
            function updateEnvironmentVisuals(e){ /* ... unchanged ... */ if(!e||!e.element)return;e.element.style.left=`${e.x}px`;e.element.style.top=`${e.y}px`;e.element.style.width=`${e.width}px`;e.element.style.height=`${e.height}px`;if(e.nameElement)e.nameElement.textContent=e.name; }
            function updateCameraPosition(){ if(playerData.x===undefined||playerData.y===undefined||!playerData.element||playerData.element.style.display==='none') return; viewportWidth=gameWorld.offsetWidth;viewportHeight=gameWorld.offsetHeight;let tx=playerData.x-viewportWidth/2+(playerData.width/2);let ty=playerData.y-viewportHeight/2+(playerData.height/2);const cx=Math.max(0,Math.min(MAP_WIDTH-viewportWidth,tx));const cy=Math.max(0,Math.min(MAP_HEIGHT-viewportHeight,ty));mapContent.style.transform=`translate3d(${-cx}px,${-cy}px,0)`; }
            function applyPlayerAppearance(styleData) { if (!playerData.element||!styleData||!styleData.colors) return; applyAppearanceToElement(playerData.element, styleData); }
            function applyNpcAppearance(npc) { if (!npc||!npc.element||!npc.appearance||!npc.appearance.colors) return; applyAppearanceToElement(npc.element, npc.appearance); }
            function applyAppearanceToElement(element, styleData) { /* ... Full implementation unchanged, omitted for brevity ... */ }
            function movePlayer(dx, dy) {
                 if (!playerData.element||!currentCityKey||playerData.element.style.display==='none') return;
                 const tX=playerData.x+dx*playerStepDistance; const tY=playerData.y+dy*playerStepDistance;
                 playerData.x=Math.max(0,Math.min(MAP_WIDTH-playerData.width,tX));
                 playerData.y=Math.max(0,Math.min(MAP_HEIGHT-playerData.height,tY));
                 updateCharacterPosition(playerData); updateCameraPosition();
                 if (!isPlayerMoving) { playerElement.classList.add('is-walking'); isPlayerMoving=true; }
                 clearTimeout(playerMoveTimeout);
                 playerMoveTimeout=setTimeout(() => {
                     playerElement.classList.remove('is-walking'); isPlayerMoving=false;
                     // Reset animation styles properly
                     const pR=playerElement.querySelectorAll('.part.arm-left,.part.arm-right,.part.legs');
                     pR.forEach(p=>{p.style.animation='none';p.offsetHeight;p.style.animation='';p.style.transform='';});
                     playerElement.style.animation='none';playerElement.offsetHeight;playerElement.style.animation='';playerElement.style.transform='';
                 }, 550);
                 updateInputPlaceholder();
                 // UPDATE SPATIAL CONTEXT
                 updateSpatialChatContext();
            }
            function findClosestNpc(log=true){/* ... unchanged ... */ let clNpc=null;let minDist=Infinity;if(playerData.x===undefined||playerData.y===undefined||!currentCityKey||playerData.element.style.display==='none') return null; npcData.forEach(n=>{ if(typeof n.x!=='number'||typeof n.y !=='number')return;const d=Math.hypot(playerData.x-n.x,playerData.y-n.y);if(d<minDist){minDist=d;clNpc=n;}});if(log&&clNpc)console.log("Closest NPC:",clNpc.name);return clNpc;}
            function generateSystemPrompt(npc, mode = 'agent') { // Mode: 'agent' or 'message' (persona)
                 const persona = npc.personaPrompt || `You are ${npc.name}.`;
                 if (mode === 'message') {
                     return persona; // Persona only for Message tab
                 } else { // Agent tab
                     const gameState = getGameStateString();
                     const events = recentEvents.length > 0 ? ` RecentEvents:[${recentEvents.join('; ')}]` : '';
                     const basePrompt = `${persona} ${events}`;
                     return `${basePrompt} ${gameState} ACTIONS: <Walk X,Y>, <Follow>. Your Current Pos=(${Math.round(npc.x)},${Math.round(npc.y)}). Respond to the user, optionally using an ACTION.`;
                 }
            }
            function processNpcActions(rawReply, npc){/* ... unchanged ... */ if(!npc)return rawReply;let cleanedReply=rawReply;const actionRegex=/<(\w+)(?:\s+([^>]*?))?\s*>/g;let match;const actions=[];while((match=actionRegex.exec(rawReply))!==null){actions.push({name:match[1]?.toLowerCase(),params:match[2]||"",fullTag:match[0]});cleanedReply=cleanedReply.replace(match[0],'');}actions.forEach(action=>{console.log(`Action:${action.name}(${action.params}) for ${npc.name}`);switch(action.name){case'walk':handleWalkAction(npc,action.params);break;case 'follow': handleFollowAction(npc); break; default:console.warn(`Unknown action:${action.name}`);}});return cleanedReply.trim();}
            function handleWalkAction(npc,params){/* ... unchanged ... */ if (!npc||!npc.element) return; npc.followingTargetId=null; const coords=params.split(',');if(coords.length===2){const targetX=parseInt(coords[0].trim(),10),targetY=parseInt(coords[1].trim(),10);if(!isNaN(targetX)&&!isNaN(targetY)){npc.x=Math.max(0,Math.min(MAP_WIDTH-npc.width,targetX));npc.y=Math.max(0,Math.min(MAP_HEIGHT-npc.height,targetY));updateCharacterPosition(npc);}else console.warn(`Invalid Walk Coords:${params}`);}else console.warn(`Invalid Walk Params:${params}`);}
            function findClosestCharacter(sourceNpc, includeSelf = false, onlyPlayer = false){/* ... unchanged ... */ let target=null,minDistSq=Infinity; let potentialTargets=[playerData]; if (!onlyPlayer) { potentialTargets=potentialTargets.concat(npcData); } potentialTargets=potentialTargets.filter(t => t && t.element?.style.display !== 'none' && (includeSelf || t !== sourceNpc) && (typeof sourceNpc.x === 'number' && typeof t.x === 'number' && sourceNpc.y !== undefined && t.y !== undefined) ); potentialTargets.forEach(t=>{ const distSq=Math.pow(sourceNpc.x-t.x,2)+Math.pow(sourceNpc.y-t.y,2); if(distSq<minDistSq){minDistSq=distSq;target=t;} }); console.log(`${sourceNpc.name} target (${onlyPlayer ? 'Player' : 'Any'}): ${target?target.name:"None"}`); return target;}
            function handleFollowAction(npc) {/* ... unchanged ... */ if (!npc || !npc.element) return; const target = findClosestCharacter(npc, false, false); if (target) { npc.followingTargetId = target === playerData ? 'player' : target.id; console.log(`${npc.name} follows ${target.name}`); addMessage(`${npc.name} starts following ${target.name}.`, 'SYSTEM', 'system'); } else { npc.followingTargetId = null; console.log(`${npc.name} cannot find anyone.`); addMessage(`${npc.name} finds no one to follow.`, 'SYSTEM', 'system'); } }
            function updateFollowingNpcs() {/* ... unchanged ... */ if (!currentCityKey) return; npcData.forEach(npc => { if (!npc.followingTargetId || !npc.element) return; let target = null; if (npc.followingTargetId === 'player') { target = playerData; } else if (typeof npc.followingTargetId === 'number') { target = npcData.find(n => n.id === npc.followingTargetId); } if (!target || target.element?.style.display === 'none' || typeof target.x !== 'number' || typeof target.y !== 'number' ) { npc.followingTargetId = null; return; } const dx = target.x - npc.x; const dy = target.y - npc.y; const distance = Math.hypot(dx, dy); if (distance > FOLLOW_DISTANCE) { const normDx = distance === 0 ? 0 : dx / distance; const normDy = distance === 0 ? 0 : dy / distance; const moveX = normDx * NPC_FOLLOW_SPEED; const moveY = normDy * NPC_FOLLOW_SPEED; let newX = npc.x + moveX; let newY = npc.y + moveY; newX = Math.max(0, Math.min(MAP_WIDTH - npc.width, newX)); newY = Math.max(0, Math.min(MAP_HEIGHT - npc.height, newY)); if (npc.x !== newX || npc.y !== newY) { npc.x = newX; npc.y = newY; updateCharacterPosition(npc); } } }); }
            function displayTypingIndicator() { /* ... unchanged ... */ removeTypingIndicator(); const t=document.createElement('div'); t.className='typing-indicator'; t.id='typing-indicator'; t.innerHTML=`<span>The spirit is responding</span><span class="rune">âœ§</span><span class="rune">âœ¦</span><span class="rune">âœ§</span>`; chatMessages.appendChild(t); requestAnimationFrame(()=>chatMessages.scrollTop=chatMessages.scrollHeight); }
            function removeTypingIndicator() { /* ... unchanged ... */ const t=document.getElementById('typing-indicator'); if(t) t.remove(); }

            // --- API Key Handling (Multi-Key per Provider) ---
            function loadApiKeyManagement() { /* ... unchanged ... */
                 console.log("Loading API key management state..."); const storedData = localStorage.getItem(LS_KEYS.providerApiKeysStorage); if (storedData) { try { const parsedData = JSON.parse(storedData); if (parsedData && typeof parsedData.providerKeys === 'object' && typeof parsedData.activeKeyIndices === 'object') { apiKeyManagement = parsedData; Object.keys(apiKeyManagement.providerKeys).forEach(prov => { if (!Array.isArray(apiKeyManagement.providerKeys[prov])) { apiKeyManagement.providerKeys[prov] = []; } if (typeof apiKeyManagement.activeKeyIndices[prov] !== 'number') { apiKeyManagement.activeKeyIndices[prov] = 0; } apiKeyManagement.activeKeyIndices[prov] = Math.max(0, Math.min(apiKeyManagement.activeKeyIndices[prov], (apiKeyManagement.providerKeys[prov]?.length || 1) -1)); if((apiKeyManagement.providerKeys[prov]?.length || 0) === 0) { apiKeyManagement.activeKeyIndices[prov] = 0; } }); console.log(`Loaded ${Object.keys(apiKeyManagement.providerKeys).length} providers' keys.`); } else { console.warn("Invalid structure in stored API key data. Resetting."); apiKeyManagement = { providerKeys: {}, activeKeyIndices: {} }; } } catch (e) { console.error("Error parsing stored API key data. Resetting.", e); apiKeyManagement = { providerKeys: {}, activeKeyIndices: {} }; localStorage.removeItem(LS_KEYS.providerApiKeysStorage); } } else { apiKeyManagement = { providerKeys: {}, activeKeyIndices: {} }; console.log("No stored API key data found."); }
            }
            function saveApiKeyManagement() { /* ... unchanged ... */
                try { localStorage.setItem(LS_KEYS.providerApiKeysStorage, JSON.stringify(apiKeyManagement)); } catch (e) { console.error("Failed to save API key management state:", e); addMessage("Error saving API key configuration.", "SYSTEM", "error"); }
            }
            function handleAddApiKey() { /* ... unchanged ... */
                const providerSelect = document.getElementById('apiProviderSelect'); const newApiKeyInput = document.getElementById('newApiKeyInput'); const currentSelectedProviderKey = providerSelect ? providerSelect.value : null; if (!newApiKeyInput || !currentSelectedProviderKey) { addMessage("Error: Cannot add key - UI elements missing or no provider selected.", "SYSTEM", "error"); return; } const providerConfig = PROVIDERS[currentSelectedProviderKey]; if (!providerConfig) { addMessage(`Error: Invalid provider selected (${currentSelectedProviderKey}).`, "SYSTEM", "error"); return; } if (providerConfig.format === 'proxy_compatible' || providerConfig.apiKeyLocation === 'none') { addMessage(`API Keys are not managed by the client for ${providerConfig.name}.`, "SYSTEM", "info"); newApiKeyInput.value = ''; return; } const newKey = newApiKeyInput.value.trim(); if (!newKey) { addMessage("Please enter an API key to add.", "SYSTEM", "info"); return; } if (!apiKeyManagement.providerKeys[currentSelectedProviderKey]) { apiKeyManagement.providerKeys[currentSelectedProviderKey] = []; apiKeyManagement.activeKeyIndices[currentSelectedProviderKey] = 0; } const keysForProvider = apiKeyManagement.providerKeys[currentSelectedProviderKey]; if (keysForProvider.includes(newKey)) { addMessage(`Key already exists for ${providerConfig.name}.`, "SYSTEM", "info"); } else { keysForProvider.push(newKey); addMessage(`Added key for ${providerConfig.name}.`, "SYSTEM", "system"); saveApiKeyManagement(); renderApiKeysForProvider(currentSelectedProviderKey); } newApiKeyInput.value = '';
            }
            function handleDeleteApiKey(providerKey, keyToDelete) { /* ... unchanged ... */
                if (!providerKey || !keyToDelete) return; const providerConfig = PROVIDERS[providerKey]; if (!providerConfig) return; if (providerConfig.format === 'proxy_compatible' || providerConfig.apiKeyLocation === 'none') return; const keys = apiKeyManagement.providerKeys[providerKey]; if (!keys || !keys.includes(keyToDelete)) return; const currentActiveIndex = apiKeyManagement.activeKeyIndices[providerKey] ?? 0; const keyIndexToDelete = keys.indexOf(keyToDelete); if (confirm(`Are you sure you want to remove the key "${maskApiKey(keyToDelete)}"?`)) { apiKeyManagement.providerKeys[providerKey] = keys.filter(k => k !== keyToDelete); const newKeys = apiKeyManagement.providerKeys[providerKey]; if (newKeys.length === 0) { delete apiKeyManagement.providerKeys[providerKey]; delete apiKeyManagement.activeKeyIndices[providerKey]; addMessage(`Removed last key for ${providerConfig.name}.`, "SYSTEM", "system"); } else { if (keyIndexToDelete < currentActiveIndex) { apiKeyManagement.activeKeyIndices[providerKey] = Math.max(0, currentActiveIndex - 1); } else if (keyIndexToDelete === currentActiveIndex) { apiKeyManagement.activeKeyIndices[providerKey] = currentActiveIndex % newKeys.length; } addMessage(`Removed key for ${providerConfig.name}.`, "SYSTEM", "system"); } saveApiKeyManagement(); renderApiKeysForProvider(providerKey); }
            }
            function renderApiKeysForProvider(providerKey) { /* ... unchanged ... */
                const apiKeyListDiv = document.getElementById('apiKeyListDiv'); const activeApiKeyDisplay = document.getElementById('activeApiKeyDisplay'); const newApiKeyInput = document.getElementById('newApiKeyInput'); const addApiKeyBtn = document.getElementById('addApiKeyBtn'); if (!apiKeyListDiv || !activeApiKeyDisplay || !newApiKeyInput || !addApiKeyBtn) return; apiKeyListDiv.innerHTML = ''; activeApiKeyDisplay.textContent = 'None'; if (!providerKey || !PROVIDERS[providerKey]) { apiKeyListDiv.innerHTML = '<p class="key-list-message">Select a provider.</p>'; newApiKeyInput.disabled = true; addApiKeyBtn.disabled = true; return; } const providerConfig = PROVIDERS[providerKey]; const keys = apiKeyManagement.providerKeys[providerKey] || []; const activeIndex = apiKeyManagement.activeKeyIndices[providerKey] ?? 0; if (providerConfig.format === 'proxy_compatible' || providerConfig.apiKeyLocation === 'none') { apiKeyListDiv.innerHTML = `<p class="key-list-message">API Key managed by proxy/server for ${providerConfig.name}.</p>`; activeApiKeyDisplay.innerHTML = `Key Location: <strong>${providerConfig.apiKeyLocation}</strong>`; newApiKeyInput.disabled = true; newApiKeyInput.placeholder = "Key handled by proxy"; addApiKeyBtn.disabled = true; return; } newApiKeyInput.disabled = false; newApiKeyInput.placeholder = `Add API Key for ${providerConfig.name}`; addApiKeyBtn.disabled = false; if (keys.length === 0) { apiKeyListDiv.innerHTML = '<p class="key-list-message">No keys added for this provider.</p>'; activeApiKeyDisplay.textContent = 'None'; } else { keys.forEach((key, index) => { const itemDiv = document.createElement('div'); itemDiv.className = 'api-key-item'; const keySpan = document.createElement('span'); keySpan.textContent = maskApiKey(key); keySpan.title = key; const controlsDiv = document.createElement('div'); controlsDiv.className = 'api-key-item-controls'; const deleteBtn = document.createElement('button'); deleteBtn.textContent = 'Del'; deleteBtn.title = `Delete key ${maskApiKey(key)}`; deleteBtn.className = 'api-key-item-delete-btn'; deleteBtn.onclick = () => handleDeleteApiKey(providerKey, key); controlsDiv.appendChild(deleteBtn); itemDiv.appendChild(keySpan); itemDiv.appendChild(controlsDiv); apiKeyListDiv.appendChild(itemDiv); if (index === activeIndex) { itemDiv.style.backgroundColor = 'var(--amethyst-light)'; activeApiKeyDisplay.innerHTML = `Next key to try: <strong>${maskApiKey(key)}</strong>`; } }); if (!activeApiKeyDisplay.innerHTML.includes('Next key') && keys.length > 0) { activeApiKeyDisplay.innerHTML = `Next key to try: <strong>${maskApiKey(keys[0])}</strong>`; } }
            }

            // --- API Call Logic (Direct Interaction - Agent/Message Tabs) ---
            async function getDirectApiResponse(userMessage, attempt = 1) {
                 // This function is ONLY used for Agent and Message tabs
                 if (!currentCityKey && currentChatTab !== 'Message') { // Message tab might work without city context
                     addMessage("No city loaded.", "SYSTEM", "system"); enableInput(); return;
                 }
                 if (typeof PROVIDERS === 'undefined' || Object.keys(PROVIDERS).length === 0) {
                     addMessage("API Provider configuration (api_providers.js) not loaded.", "SYSTEM", "error"); enableInput(); return;
                 }
                 if (!selectedProvider || !selectedModel) {
                     addMessage("No API Provider or Model selected (Settings Page 2).", "SYSTEM", "error"); enableInput(); return;
                 }
                 if (typeof window.getApiResponse !== 'function') {
                     addMessage("API Provider script function (getApiResponse) not found.", "SYSTEM", "error"); enableInput(); return;
                 }

                 const providerConfig = PROVIDERS[selectedProvider];
                 if (!providerConfig) {
                     addMessage(`Config error: Provider "${selectedProvider}" not found.`, "SYSTEM", "error"); enableInput(); return;
                 }

                 // Agent/Message Target Selection
                 if (!currentAiNpcData) {
                     const closeNpc = findClosestNpc(true);
                     if (closeNpc) { currentAiNpcData = closeNpc; }
                     else { // Allow message tab even if no NPC is close
                          if (currentChatTab === 'Agent') {
                             addMessage("No agent close enough for Agent interaction.", "SYSTEM", "system"); enableInput(); return;
                          } else { // Message Tab - Use a placeholder/default?
                               currentAiNpcData = { name: "Spirit", personaPrompt: "You are a helpful, disembodied spirit." }; // Placeholder
                               addMessage("Consulting the ambient spirit (Message Tab)...", "SYSTEM", "info");
                          }
                     }
                 }

                 if (attempt === 1) { displayTypingIndicator(); }

                 // --- Key Selection / Cycling Logic (Same as before) ---
                 let apiKeyToUse = null;
                 let keysForProvider = [];
                 let totalKeysForProvider = 0;
                 let currentKeyIndex = 0;
                 const needsClientKey = providerConfig.format !== 'proxy_compatible' && providerConfig.apiKeyLocation !== 'none';

                 if (needsClientKey) {
                     keysForProvider = apiKeyManagement.providerKeys[selectedProvider] || [];
                     totalKeysForProvider = keysForProvider.length;
                     if (totalKeysForProvider === 0) { removeTypingIndicator(); addMessage(`No API keys for ${providerConfig.name} (Settings Page 2).`, "SYSTEM", "error"); enableInput(); return; }
                     if (attempt > totalKeysForProvider) { removeTypingIndicator(); addMessage(`All ${totalKeysForProvider} keys for ${providerConfig.name} failed.`, "SYSTEM", "error"); enableInput(); return; }
                     const startIndex = apiKeyManagement.activeKeyIndices[selectedProvider] ?? 0;
                     currentKeyIndex = (startIndex + attempt - 1) % totalKeysForProvider;
                     apiKeyToUse = keysForProvider[currentKeyIndex];
                     if (!apiKeyToUse) { removeTypingIndicator(); addMessage(`Internal key retrieval error idx ${currentKeyIndex}.`, "SYSTEM", "error"); enableInput(); return; }
                     console.log(`Direct API Attempt ${attempt}/${totalKeysForProvider} for ${selectedProvider}. Idx: ${currentKeyIndex} (${maskApiKey(apiKeyToUse)})`);
                 } else {
                     apiKeyToUse = null; console.log(`Direct API for ${selectedProvider}. Key handled by proxy/server.`);
                 }
                 // --- End Key Selection ---

                 // --- Prepare Messages (Agent vs Message Tab) ---
                  const sysPrompt = generateSystemPrompt(currentAiNpcData, currentChatTab); // Pass tab for mode
                  const apiMsgs = [{ role: 'system', content: sysPrompt }, ...conversationHistory, { role: 'user', content: userMessage }];
                  if (attempt === 1) {
                     addMessage(`(${currentChatTab}) API Call -> ${currentAiNpcData.name} via ${providerConfig.name} (${selectedModel}) | Sys: ${sysPrompt.substring(0, 50)}... | User: ${userMessage.substring(0, 100)}...`, 'DEBUG', 'debug', null, { skipHistory: true });
                     if (currentChatTab === 'Agent') recentEvents = []; // Clear agent events on new user input
                  }
                 // --- End Prepare Messages ---

                 try {
                     const rawReply = await window.getApiResponse(selectedProvider, selectedModel, apiMsgs, apiKeyToUse, {});

                     // Success!
                     removeTypingIndicator();
                     addMessage(`(${currentChatTab}) API Raw <- ${currentAiNpcData.name}: ${rawReply.substring(0, 100)}...`, 'DEBUG', 'debug', null, { skipHistory: true });

                     if (needsClientKey) { // Update next key index on success
                         apiKeyManagement.activeKeyIndices[selectedProvider] = (currentKeyIndex + 1) % totalKeysForProvider;
                         saveApiKeyManagement();
                         // Optionally re-render key list if settings are open
                         if (settingsOverlay.classList.contains('active')) {
                             renderApiKeysForProvider(selectedProvider);
                         }
                     }

                     let displayReply = rawReply;
                     if (currentChatTab === 'Agent') { // Process actions ONLY in Agent tab
                         displayReply = processNpcActions(rawReply, currentAiNpcData);
                     }
                     if (displayReply && displayReply.trim()) {
                         addMessage(displayReply, currentAiNpcData.name, 'assistant', currentAiNpcData); // Adds to history if not skipped
                     } else if (currentChatTab === 'Agent') {
                         addMessage("...", currentAiNpcData.name, 'assistant', currentAiNpcData); // Indicate action without text
                     }
                     enableInput();

                 } catch (error) {
                      console.error(`Direct API Error attempt ${attempt} for ${selectedProvider} (Idx ${currentKeyIndex}):`, error);
                      const shouldCycle = needsClientKey && ( error.message.includes("401") || error.message.includes("403") || error.message.includes("429") || error.message.includes("Invalid API Key") || error.message.includes("authentication failed") || error.message.includes("permission denied") );

                      if (shouldCycle) {
                          addMessage(`API key issue (${error.message.substring(0,50)}...). Trying next...`, 'SYSTEM', 'debug', null, {skipHistory: true});
                          setTimeout(() => getDirectApiResponse(userMessage, attempt + 1), 500);
                      } else {
                          removeTypingIndicator();
                          let errorMessage = `Error contacting ${currentAiNpcData.name}: ${error.message}`;
                          if (error.message.includes("blocked")) { errorMessage = `Message blocked by ${providerConfig.name} filters. (${error.message})`; }
                          addMessage(errorMessage, 'SYSTEM', 'error'); // Adds to history if not skipped
                          enableInput();
                      }
                 }
            }

            function disableInput(){ userInput.disabled=true; sendButton.disabled=true; isWaitingForApiResponse = true; }
            function enableInput(){ if(currentCityKey || currentChatTab === 'Message'){ userInput.disabled=false; sendButton.disabled=false; userInput.focus(); isWaitingForApiResponse = false; }else{ disableInput(); } } // Allow input on Message tab even without city

            // --- Send Button Logic (Handles different tabs) ---
            function handlePlayerSend() {
                const msg = userInput.value.trim();
                if (!msg || isWaitingForApiResponse || sendButton.disabled) return;
                userInput.value = ''; userInput.style.height='auto';userInput.style.height=(userInput.scrollHeight)+'px';
                disableInput(); // Disable input immediately

                if (isSpatialTabActive) {
                    // Send to Spatial Chat Manager
                    if (typeof SpatialChatManager !== 'undefined') {
                        SpatialChatManager.sendMessage(msg);
                    } else {
                         addMessage("Spatial Chat Manager not available.", "SYSTEM", "error");
                    }
                     enableInput(); // Spatial manager handles its own response timing, re-enable UI here
                } else if (currentChatTab === 'Agent' || currentChatTab === 'Message') {
                    // Add user message to UI and history *before* API call
                     addMessage(msg, playerData.name, 'user');
                    // Send for direct interaction using selected provider/key cycling
                    getDirectApiResponse(msg, 1); // Start API call chain
                } else {
                     addMessage("Cannot send message in this tab.", "SYSTEM", "error");
                     enableInput(); // Re-enable if sending is not possible in the current tab
                }
            }

            // Removed toggleInteractionMode and updateContextMenuModeText

            function openSettingsModal() { populateSettingsModal(); settingsOverlay.classList.add('active'); }
            function closeSettingsModal() { settingsOverlay.classList.remove('active'); }
            function openAppearanceEditorModal(target = 'player') { /* ... unchanged ... */
                appearanceEditorTarget = target; temporaryAppearanceData = null; temporaryPfpData = null; let tA, tN, tP, tPf;
                appearanceEditorNameInput.value = ''; appearanceEditorPersonaInput.value = ''; appearancePfpPreview.src = '';
                if (target === 'player') { tA = playerData.appearance || JSON.parse(JSON.stringify(defaultPlayerAppearance)); tN = playerData.name || 'Player'; tP = playerData.personaPrompt || "You are the Player."; tPf = playerData.pfp || DEFAULT_PLAYER_PFP; }
                else { const n = npcData.find(n => n.id === target); if (!n) { console.error(`NPC ${target} not found for appearance editor`); return; } tA = n.appearance || JSON.parse(JSON.stringify(defaultNpcAppearance)); tN = n.name || `Agent ${target + 1}`; tP = n.personaPrompt || `You are ${tN}.`; tPf = n.pfp || DEFAULT_NPC_PFP; }
                appearanceEditorTitle.textContent = `Set Details for ${tN}`; appearanceEditorNameInput.value = tN; appearanceEditorPersonaInput.value = tP; appearancePfpPreview.src = tPf;
                if (characterCreatorFrame?.contentWindow) { setTimeout(() => { try { characterCreatorFrame.contentWindow.postMessage({ type: 'INIT_STYLE', payload: tA }, '*'); console.log(`Sent initial style to creator for ${tN}`); } catch (err) { console.error("Error sending message to character creator iframe:", err); } }, 200); } else { console.error("Character creator iframe or its content window is not accessible."); }
                appearanceEditorOverlay.classList.add('active');
            }
            function closeAppearanceEditorModal() { /* ... unchanged ... */
                appearanceEditorOverlay.classList.remove('active'); if (temporaryAppearanceData) { if (appearanceEditorTarget === 'player') { applyPlayerAppearance(playerData.appearance); } else { const n = npcData.find(n => n.id === appearanceEditorTarget); if (n?.appearance) applyNpcAppearance(n); } }
                appearanceEditorTarget = null; temporaryAppearanceData = null; temporaryPfpData = null; pfpUploadInput.value = '';
            }
            function saveAppearanceFromEditor() { /* ... unchanged ... */
                let styleSaved=false, detailsSaved=false; const newName=appearanceEditorNameInput.value.trim(); const newPersona=appearanceEditorPersonaInput.value.trim();
                if (appearanceEditorTarget === 'player') { if (newName && playerData.name !== newName) { playerData.name=newName; localStorage.setItem(LS_KEYS.playerName, playerData.name); updateNameplate(playerData); detailsSaved=true; } if (playerData.personaPrompt !== newPersona) { playerData.personaPrompt=newPersona; localStorage.setItem(LS_KEYS.playerPersona, playerData.personaPrompt); detailsSaved=true; } if (temporaryAppearanceData) { playerData.appearance = JSON.parse(JSON.stringify(temporaryAppearanceData)); localStorage.setItem(LS_KEYS.playerAppearance, JSON.stringify(playerData.appearance)); styleSaved=true; } if (temporaryPfpData) { playerData.pfp = temporaryPfpData; localStorage.setItem(LS_KEYS.playerPfp, playerData.pfp); detailsSaved=true; } if (styleSaved || detailsSaved) addMessage(`Details${styleSaved?'/style':''}${temporaryPfpData?'/sigil':''} saved for Player.`, "SYSTEM", "system", null, {skipHistory: true}); } // Skip history for settings messages
                else { const npc = npcData.find(n => n.id === appearanceEditorTarget); if (npc && currentCityKey) { const defaultNpcName = `Agent ${npc.id + 1}`; if (npc.name !== (newName || defaultNpcName)) { npc.name = newName || defaultNpcName; localStorage.setItem(LS_KEYS.npcName(currentCityKey, npc.id), npc.name); updateNameplate(npc); detailsSaved=true; } if (npc.personaPrompt !== newPersona) { npc.personaPrompt = newPersona; localStorage.setItem(LS_KEYS.npcPersona(currentCityKey, npc.id), npc.personaPrompt); detailsSaved=true; } if (temporaryAppearanceData) { npc.appearance = JSON.parse(JSON.stringify(temporaryAppearanceData)); localStorage.setItem(LS_KEYS.npcAppearance(currentCityKey, npc.id), JSON.stringify(npc.appearance)); styleSaved=true; } if (temporaryPfpData) { npc.pfp = temporaryPfpData; localStorage.setItem(LS_KEYS.npcPfp(currentCityKey, npc.id), npc.pfp); detailsSaved=true; } if (styleSaved || detailsSaved) addMessage(`Details${styleSaved?'/style':''}${temporaryPfpData?'/sigil':''} saved for ${npc.name}.`, "SYSTEM", "system", null, {skipHistory: true}); } else { console.error(`Failed to save appearance: NPC ${appearanceEditorTarget} not found or no city loaded.`); addMessage(`Error: Cannot find agent ${appearanceEditorTarget} to save details.`, "SYSTEM", "error", null, {skipHistory: true}); } }
                closeAppearanceEditorModal();
                 // Update spatial context if NPC details changed
                 if (detailsSaved || styleSaved) updateSpatialChatContext();
            }
            function handlePfpUpload(event) { /* ... unchanged ... */
                 const f = event.target.files[0]; if (!f) return; const r = new FileReader(); r.onload = (e) => { const u = e.target.result; temporaryPfpData = u; appearancePfpPreview.src = u; console.log("PFP Preview updated."); }; r.onerror = (e) => { console.error("FileReader err:", e); addMessage("Error reading sigil file.", "SYSTEM", "error"); temporaryPfpData = null; }; if (f.size > 2*1024*1024) { addMessage("Sigil file too large (max 2MB).", "SYSTEM", "error"); pfpUploadInput.value = ''; return; } r.readAsDataURL(f);
             }
            function showSettingsPage(pageNum) { /* ... unchanged ... */ currentSettingsPage = pageNum; const p = settingsBodyContainer.querySelectorAll('.settings-page'); p.forEach((pg, idx) => { pg.classList.toggle('active', (idx + 1) === pageNum); }); updatePaginationControls(); }
            function updatePaginationControls() { /* ... unchanged ... */ settingsPageIndicator.textContent=`Page ${currentSettingsPage} / ${TOTAL_SETTINGS_PAGES}`; settingsPrevBtn.disabled = currentSettingsPage === 1; settingsNextBtn.disabled = currentSettingsPage === TOTAL_SETTINGS_PAGES; }

            // --- Settings Modal Population (Page 2 API Config Updated) ---
            function populateSettingsModal(){
                 settingsBodyContainer.innerHTML = '';
                 for (let i=1; i<=TOTAL_SETTINGS_PAGES; i++) { const p=document.createElement('div'); p.className='settings-page'; p.id=`settings-page-${i}`; settingsBodyContainer.appendChild(p); }
                 const p1 = document.getElementById('settings-page-1'); const p2 = document.getElementById('settings-page-2');
                 const p3 = document.getElementById('settings-page-3'); const p4 = document.getElementById('settings-page-4');

                 // --- PAGE 1: City, Map, UI (Unchanged) ---
                 /* ... Page 1 population code unchanged ... */
                 const citySec = document.createElement('div'); citySec.className = 'settings-section'; citySec.innerHTML = `<h3 class="settings-section-title">City Management</h3>`; const cityControlsDiv = document.createElement('div'); cityControlsDiv.className = 'settings-city-controls'; const cityLabel = document.createElement('label'); cityLabel.htmlFor = 'settingsCitySelector'; cityLabel.textContent = 'City:'; const citySelect = document.createElement('select'); citySelect.id = 'settingsCitySelector'; citySelect.className = 'settings-city-selector settings-select'; const addBtn = document.createElement('button'); addBtn.id = 'settingsAddCityBtn'; addBtn.className = 'settings-city-edit-btn settings-city-add-btn'; addBtn.title = 'Add New City'; addBtn.textContent = '+'; const delBtn = document.createElement('button'); delBtn.id = 'settingsDeleteCityBtn'; delBtn.className = 'settings-city-edit-btn settings-city-delete-btn'; delBtn.title = 'Delete Current City'; delBtn.textContent = '-'; cityControlsDiv.appendChild(cityLabel); cityControlsDiv.appendChild(citySelect); cityControlsDiv.appendChild(addBtn); cityControlsDiv.appendChild(delBtn); citySec.appendChild(cityControlsDiv); p1.appendChild(citySec);
                 populateCitySelectorInModal(citySelect); citySelect.addEventListener('change', (event) => { const nk=event.target.value; if (nk && nk !== currentCityKey) { localStorage.setItem(LS_KEYS.selectedCity, nk); addMessage(`Switching to ${citySelect.options[citySelect.selectedIndex].text}. Reloading...`, "SYSTEM", "system", null, {skipHistory:true}); savePlayerPosition(); saveNpcPositions(); closeSettingsModal(); setTimeout(() => window.location.reload(), 300); } }); addBtn.addEventListener('click', addCity); delBtn.addEventListener('click', deleteCity); delBtn.disabled = !currentCityKey || !currentCityKey.startsWith(USER_CITY_PREFIX);
                 const mapSizeSec=document.createElement('div');mapSizeSec.className='settings-section';mapSizeSec.innerHTML=`<h3 class="settings-section-title">Map Dimensions</h3>`;const iDiv=document.createElement('div');iDiv.className='map-size-inputs';const wI=document.createElement('input');wI.type='number';wI.id='mapWidthInput';wI.value=MAP_WIDTH;wI.min=500;wI.step=100;const hI=document.createElement('input');hI.type='number';hI.id='mapHeightInput';hI.value=MAP_HEIGHT;hI.min=500;hI.step=100;const wL=document.createElement('label');wL.htmlFor='mapWidthInput';wL.textContent='Width:';const hL=document.createElement('label');hL.htmlFor='mapHeightInput';hL.textContent='Height:';iDiv.appendChild(wL);iDiv.appendChild(wI);iDiv.appendChild(hL);iDiv.appendChild(hI);mapSizeSec.appendChild(iDiv); p1.appendChild(mapSizeSec);
                 const uiSec = document.createElement('div'); uiSec.className = 'settings-section'; uiSec.innerHTML = `<h3 class="settings-section-title">UI Settings</h3>`; const hDiv = document.createElement('div'); hDiv.className = 'settings-checkbox-item'; const hCb = document.createElement('input'); hCb.type = 'checkbox'; hCb.id = 'hideSystemMessagesCheckbox'; hCb.checked = hideSystemMessages; const hL2 = document.createElement('label'); hL2.htmlFor = 'hideSystemMessagesCheckbox'; hL2.textContent = 'Hide System/Debug/Error Messages'; hDiv.appendChild(hCb); hDiv.appendChild(hL2); uiSec.appendChild(hDiv); p1.appendChild(uiSec);


                 // --- PAGE 2: API Configuration (Multi-Key UI) ---
                 const apiSec=document.createElement('div');apiSec.className='settings-section';apiSec.innerHTML=`<h3 class="settings-section-title">API Configuration</h3>`;
                 const apiConfigDiv = document.createElement('div'); apiConfigDiv.className = 'settings-api-config';
                 const providerDiv = document.createElement('div'); providerDiv.innerHTML = `<label class="settings-label" for="apiProviderSelect">API Provider:</label>`;
                 const providerSelect = document.createElement('select'); providerSelect.id = 'apiProviderSelect'; providerSelect.className = 'settings-select';
                 providerDiv.appendChild(providerSelect); apiConfigDiv.appendChild(providerDiv);
                 const modelDiv = document.createElement('div'); modelDiv.innerHTML = `<label class="settings-label" for="apiModelSelect">Model:</label>`;
                 const modelSelect = document.createElement('select'); modelSelect.id = 'apiModelSelect'; modelSelect.className = 'settings-select';
                 modelDiv.appendChild(modelSelect); apiConfigDiv.appendChild(modelDiv);
                 apiSec.appendChild(apiConfigDiv);

                 const apiKeyMgmtDiv = document.createElement('div'); apiKeyMgmtDiv.className = 'api-key-management';
                 apiKeyMgmtDiv.innerHTML = `<label class="settings-label">API Keys (for selected provider):</label>`;
                 const apiKeyListContainer = document.createElement('div'); apiKeyListContainer.className = 'api-key-list-container'; apiKeyListContainer.id = 'apiKeyListDiv';
                 apiKeyMgmtDiv.appendChild(apiKeyListContainer);
                 const apiKeyAddControls = document.createElement('div'); apiKeyAddControls.className = 'api-key-add-controls';
                 const newApiKeyInput = document.createElement('input'); newApiKeyInput.type = "password"; newApiKeyInput.id = 'newApiKeyInput'; newApiKeyInput.placeholder = 'Add API Key...';
                 const addApiKeyBtn = document.createElement('button'); addApiKeyBtn.textContent = 'Add Key'; addApiKeyBtn.id = 'addApiKeyBtn';
                 addApiKeyBtn.addEventListener('click', handleAddApiKey);
                 apiKeyAddControls.appendChild(newApiKeyInput); apiKeyAddControls.appendChild(addApiKeyBtn);
                 apiKeyMgmtDiv.appendChild(apiKeyAddControls);
                 const activeKeyDisplay = document.createElement('div'); activeKeyDisplay.className = 'active-key-display'; activeKeyDisplay.id = 'activeApiKeyDisplay';
                 activeKeyDisplay.textContent = 'Next key to try: None';
                 apiKeyMgmtDiv.appendChild(activeKeyDisplay);
                 apiSec.appendChild(apiKeyMgmtDiv);
                 p2.appendChild(apiSec);

                 // Populate Provider Dropdown
                 if (typeof PROVIDERS !== 'undefined') {
                    Object.keys(PROVIDERS).sort((a, b) => PROVIDERS[a].name.localeCompare(PROVIDERS[b].name)).forEach(key => {
                        const option = document.createElement('option'); option.value = key; option.textContent = PROVIDERS[key].name;
                        providerSelect.appendChild(option);
                    });
                    providerSelect.value = selectedProvider || Object.keys(PROVIDERS)[0];
                 } else { /* ... error handling ... */ }

                 const updateProviderSelectionUI = (providerKey) => {
                     modelSelect.innerHTML = ''; const providerConfig = PROVIDERS[providerKey];
                     if (providerConfig && providerConfig.availableModels && providerConfig.availableModels.length > 0) {
                         modelSelect.disabled = false;
                         providerConfig.availableModels.forEach(model => { const option = document.createElement('option'); option.value = model; option.textContent = model; modelSelect.appendChild(option); });
                         const targetModel = (selectedProvider === providerKey && selectedModel && providerConfig.availableModels.includes(selectedModel)) ? selectedModel : (providerConfig.defaultModel || providerConfig.availableModels[0]);
                         modelSelect.value = targetModel;
                         if (selectedModel !== targetModel && selectedProvider === providerKey) { selectedModel = targetModel; localStorage.setItem(LS_KEYS.selectedModel, selectedModel); }
                      } else { /* ... handle no models ... */ const option = document.createElement('option'); option.textContent = "N/A"; option.disabled = true; modelSelect.appendChild(option); modelSelect.disabled = true; if (selectedProvider === providerKey) selectedModel = null; }
                     renderApiKeysForProvider(providerKey);
                 };

                 providerSelect.addEventListener('change', () => {
                     const newProviderKey = providerSelect.value; if (newProviderKey !== selectedProvider) { selectedProvider = newProviderKey; localStorage.setItem(LS_KEYS.selectedProvider, selectedProvider); }
                     updateProviderSelectionUI(newProviderKey);
                 });
                 modelSelect.addEventListener('change', () => { if (modelSelect.value !== selectedModel) { selectedModel = modelSelect.value; localStorage.setItem(LS_KEYS.selectedModel, selectedModel); } });
                 updateProviderSelectionUI(providerSelect.value); // Initial population

                 // --- PAGE 3: Agents (Unchanged) ---
                 /* ... Page 3 population code unchanged ... */
                 const npcSec=document.createElement('div');npcSec.className='settings-section';npcSec.innerHTML=`<h3 class="settings-section-title">Agents</h3>`;const npcGrid=document.createElement('div');npcGrid.className='settings-grid';npcData.forEach(n=>{const item=document.createElement('div');item.className='settings-item';item.dataset.npcId=n.id;item.innerHTML=`<button class="settings-delete-btn" data-npc-id="${n.id}" title="Delete ${n.name}">X</button> <label class="settings-label" for="npc-name-${n.id}">Name (${n.id+1}):</label><input type="text" id="npc-name-${n.id}" class="settings-input" data-field="npcName" value="${n.name}"> <label class="settings-label" for="npc-persona-${n.id}">Persona:</label><textarea id="npc-persona-${n.id}" class="settings-textarea" data-field="npcPersona">${n.personaPrompt}</textarea><p><small>Set Appearance/Sigil via right-click.</small></p>`; npcGrid.appendChild(item);});npcSec.appendChild(npcGrid); p3.appendChild(npcSec);
                 npcGrid.querySelectorAll('.settings-delete-btn').forEach(btn => { btn.addEventListener('click', handleDeleteNpcFromSettings); });


                 // --- PAGE 4: Environments (Unchanged) ---
                 /* ... Page 4 population code unchanged ... */
                  const envSec=document.createElement('div');envSec.className='settings-section';envSec.innerHTML=`<h3 class="settings-section-title">Environments</h3>`;environmentData.forEach((e, idx)=>{const item=document.createElement('div');item.className='settings-env-item';item.dataset.envId=e.id; item.innerHTML=`<label class="settings-env-label" for="env-name-${e.id}">Area ${idx + 1}:</label><input type="text" id="env-name-${e.id}" class="settings-input settings-env-input" data-field="envName" value="${e.name}"> <button class="settings-delete-btn" data-env-id="${e.id}" title="Delete ${e.name}">X</button>`; envSec.appendChild(item);}); p4.appendChild(envSec);
                 envSec.querySelectorAll('.settings-delete-btn').forEach(btn => { btn.addEventListener('click', handleDeleteEnvFromSettings); });


                 // --- Disable fields if no city ---
                 if (!currentCityKey) { /* ... disable p1, p3, p4 ... */
                     p1.querySelectorAll('input, textarea, button:not(#settingsAddCityBtn), select').forEach(el => { if (el.id !== 'hideSystemMessagesCheckbox' && !el.closest('.settings-city-controls')) el.disabled = true; });
                     p3.querySelectorAll('input, textarea, button').forEach(el => el.disabled = true); p3.querySelectorAll('.settings-delete-btn').forEach(btn => btn.style.display = 'none');
                     p4.querySelectorAll('input, textarea, button').forEach(el => el.disabled = true); p4.querySelectorAll('.settings-delete-btn').forEach(btn => btn.style.display = 'none');
                     if(citySelect) citySelect.disabled = false;
                 }
                 showSettingsPage(1); // Show first page initially
            }

            // --- Save Settings (Non-API Key parts) ---
            function saveSettings() { /* ... Unchanged from previous correct version ... */
                 console.log("Saving settings..."); let changed = false, requiresReload = false, cityDefinition = null;
                 const hideSysMsgCb = document.getElementById('hideSystemMessagesCheckbox'); if (hideSysMsgCb) { const shouldHide = hideSysMsgCb.checked; if (hideSystemMessages !== shouldHide) { hideSystemMessages = shouldHide; localStorage.setItem(LS_KEYS.hideSystemMessages, hideSystemMessages ? 'true' : 'false'); changed = true; addMessage(`System messages will now be ${hideSystemMessages ? 'hidden' : 'shown'}.`, 'SYSTEM', 'system', null, {skipHistory: true}); } }
                 if (currentCityKey) { const cityDataString = localStorage.getItem(currentCityKey); if (cityDataString) { try { cityDefinition = JSON.parse(cityDataString); } catch (e) { console.error("Parse cityDef fail", e); addMessage("Error: Corrupt city data.", "SYSTEM", "error", null, {skipHistory: true}); cityDefinition = null; } } else { console.error("Save fail: city data missing:", currentCityKey); addMessage("Error: Cannot find city data.", "SYSTEM", "error", null, {skipHistory: true}); cityDefinition = null; } if(cityDefinition) { const widthInput = document.getElementById('mapWidthInput'); const heightInput = document.getElementById('mapHeightInput'); if (widthInput && heightInput && cityDefinition.map) { const newWidth = parseInt(widthInput.value, 10) || MAP_WIDTH; const newHeight = parseInt(heightInput.value, 10) || MAP_HEIGHT; if (cityDefinition.map.width !== newWidth || cityDefinition.map.height !== newHeight) { cityDefinition.map.width = newWidth; cityDefinition.map.height = newHeight; changed = true; requiresReload = true; addMessage(`Map size changed to ${newWidth}x${newHeight}. Reload needed.`, 'SYSTEM', 'system', null, {skipHistory: true}); } } document.querySelectorAll('#settings-page-3 .settings-item[data-npc-id]').forEach(item => { const id = parseInt(item.dataset.npcId, 10); const npc = npcData.find(n => n.id === id); if (!npc) return; const nameInput = item.querySelector('[data-field="npcName"]'); const personaInput = item.querySelector('[data-field="npcPersona"]'); const newName = nameInput ? (nameInput.value.trim() || `Agent ${id + 1}`) : npc.name; const newPersona = personaInput ? personaInput.value.trim() : npc.personaPrompt; if (npc.name !== newName) { npc.name = newName; localStorage.setItem(LS_KEYS.npcName(currentCityKey, id), newName); updateNameplate(npc); changed = true; } if (npc.personaPrompt !== newPersona) { npc.personaPrompt = newPersona; localStorage.setItem(LS_KEYS.npcPersona(currentCityKey, id), newPersona); changed = true; } }); document.querySelectorAll('#settings-page-4 .settings-env-item[data-env-id]').forEach(item => { const id = item.dataset.envId; const env = environmentData.find(e => e.id == id); if (!env) return; const nameInput = item.querySelector('[data-field="envName"]'); if (nameInput && env.name !== nameInput.value.trim()) { const envIndex = environmentData.findIndex(e => e.id == id); env.name = nameInput.value.trim() || `Area ${envIndex + 1}`; localStorage.setItem(LS_KEYS.envName(currentCityKey, id), env.name); if (env.nameElement) env.nameElement.textContent = env.name; changed = true; } }); if (changed || requiresReload) { localStorage.setItem(currentCityKey, JSON.stringify(cityDefinition)); console.log("Saved updated city definition."); } saveNpcPositions(); savePlayerPosition(); } } else if (!changed) { if(!changed) { addMessage("No changes detected.", "SYSTEM", "debug", null, {skipHistory: true}); closeSettingsModal(); return; } }
                 closeSettingsModal();
                 addMessage(changed ? "Settings saved." : "No changes made.", "SYSTEM", changed ? "system" : "debug", null, {skipHistory: true});
                 if (requiresReload) { addMessage("Map changes require reload. Reloading...", "SYSTEM", "system", null, {skipHistory: true}); setTimeout(() => window.location.reload(), 1000); }
                 // Update spatial context if NPC details changed
                 if (changed && !requiresReload) updateSpatialChatContext();
            }

            function saveNpcPositions(){ if (!currentCityKey) return; npcData.forEach(n=>{localStorage.setItem(LS_KEYS.npcPositionX(currentCityKey, n.id), String(n.x)); localStorage.setItem(LS_KEYS.npcPositionY(currentCityKey, n.id), String(n.y));}); }
            function savePlayerPosition(){ if (!currentCityKey) return; localStorage.setItem(LS_KEYS.playerPositionX(currentCityKey), String(playerData.x)); localStorage.setItem(LS_KEYS.playerPositionY(currentCityKey), String(playerData.y)); }
            function addCity(){ /* ... unchanged ... */ const n=prompt("Enter new city name:","My City");if(!n||!n.trim())return;const cN=n.trim();const nK=USER_CITY_PREFIX+cN.replace(/\s+/g,'_')+'_'+Date.now();if(localStorage.getItem(nK)){alert("A city with a similar name might already exist.");return;} const dC={meta:{cityName:cN},map:{width:2000,height:1500},player:{startX:1000,startY:750},environments:[{id:"start_"+Date.now(),name:"Start Zone",x:800,y:600,width:400,height:300}],npcSpawns:[{spawnId:"agent1_"+Date.now(),x:900,y:700,defaultName:"Agent 1",defaultPersona:"You are Agent 1."}]};localStorage.setItem(nK,JSON.stringify(dC));localStorage.setItem(LS_KEYS.selectedCity,nK);addMessage(`Created new city: ${cN}. Reloading...`,"SYSTEM","system", null, {skipHistory: true}); closeSettingsModal(); setTimeout(() => window.location.reload(), 300);}
            function deleteCity(){ /* ... unchanged ... */ if(!currentCityKey||!currentCityKey.startsWith(USER_CITY_PREFIX)){alert("Only user-created cities can be deleted.");return;}const s=document.getElementById('settingsCitySelector'); const cN=s?s.options[s.selectedIndex].text:currentCityKey; if(!confirm(`DELETE city "${cN}"? IRREVERSIBLE.`))return; const nm=currentCityKey.substring(USER_CITY_PREFIX.length).split('_')[0];localStorage.removeItem(currentCityKey);Object.keys(localStorage).forEach(k=>{if(k.includes(`-${currentCityKey}-`)||k.startsWith(`player-${currentCityKey}-`)||k.startsWith(`env-${currentCityKey}-`)||k.startsWith(`npc-${currentCityKey}-`))localStorage.removeItem(k);}); let nK=null;const rK=[]; Object.keys(localStorage).forEach(key=>{ if(key.startsWith(USER_CITY_PREFIX))rK.push(key); }); rK.sort(); nK=rK[0]||null; localStorage.setItem(LS_KEYS.selectedCity,nK||"");addMessage(`Deleted city: ${nm}. Reloading...`,"SYSTEM","system", null, {skipHistory: true}); closeSettingsModal(); setTimeout(() => window.location.reload(), 300);}
            function modifyCurrentCityDefinition(cb){ /* ... unchanged ... */ if(!currentCityKey) return false; const s=localStorage.getItem(currentCityKey);if(!s){addMessage("Error: Current city data not found.","SYSTEM","error", null, {skipHistory: true});return false;}try{let cD=JSON.parse(s);cb(cD);localStorage.setItem(currentCityKey,JSON.stringify(cD));return true;}catch(e){addMessage("Error modifying city definition: "+e.message,"SYSTEM","error", null, {skipHistory: true});console.error("Error modifying city definition:",e);return false;}}
            function addNpcAtPlayer(){ /* ... unchanged ... */ if (!currentCityKey||playerData.element.style.display==='none'){addMessage("Cannot add agent: No city or player position.", "SYSTEM", "error", null, {skipHistory: true}); return;} const iN=prompt("Enter name for the new agent:","New Agent"); if (!iN||!iN.trim()) return; const ok=modifyCurrentCityDefinition(def=>{const id=`uNPC_${Date.now()}`; def.npcSpawns=def.npcSpawns||[]; def.npcSpawns.push({ spawnId: id, x: Math.round(playerData.x), y: Math.round(playerData.y), defaultName: iN.trim(), defaultPersona:`You are ${iN.trim()}.` }); }); if(ok){ addMessage(`Added agent '${iN.trim()}'. Reload needed.`,"SYSTEM","system", null, {skipHistory: true}); savePlayerPosition(); saveNpcPositions(); closeSettingsModal(); if(confirm("Agent definition added. Reload map now?")) { setTimeout(() => window.location.reload(), 300); } else { addMessage("Remember to reload later.", "SYSTEM", "info", null, {skipHistory: true}); if(settingsOverlay.classList.contains('active')) populateSettingsModal(); } } }
            function handleDeleteNpcFromSettings(event, npcIdToDelete = null) { /* ... unchanged ... */ if (!currentCityKey) return; const id=npcIdToDelete !== null ? npcIdToDelete : parseInt(event?.target?.dataset?.npcId, 10); if (isNaN(id)) return; const n=npcData.find(n => n.id === id); const nN=n?n.name:`Agent ${id+1}`; if (!confirm(`Remove agent "${nN}" (ID:${id})? Irreversible.`)) return; let dM=false; const ok=modifyCurrentCityDefinition(def => { const iL=def.npcSpawns?.length||0; const sId=n?n.spawnId:null; if(sId){ def.npcSpawns=def.npcSpawns?.filter(s => s.spawnId !== sId)||[]; } dM=(def.npcSpawns?.length||0)<iL; }); if (ok&&dM) { localStorage.removeItem(LS_KEYS.npcName(currentCityKey,id)); localStorage.removeItem(LS_KEYS.npcPersona(currentCityKey,id)); localStorage.removeItem(LS_KEYS.npcAppearance(currentCityKey,id)); localStorage.removeItem(LS_KEYS.npcPfp(currentCityKey,id)); localStorage.removeItem(LS_KEYS.npcPositionX(currentCityKey,id)); localStorage.removeItem(LS_KEYS.npcPositionY(currentCityKey,id)); const iR=npcData.findIndex(n => n.id === id); if (iR > -1) { if(npcData[iR].element) { npcData[iR].element.remove(); } npcData.splice(iR, 1); addMessage(`Removed agent: ${nN}.`, "SYSTEM", "system", null, {skipHistory: true}); updateSpatialChatContext(); } else { addMessage(`Removed definition for: ${nN}.`, "SYSTEM", "system", null, {skipHistory: true}); } updateInputPlaceholder(); if(settingsOverlay.classList.contains('active')) populateSettingsModal(); } else { addMessage(`Failed to remove ${nN}.`, "SYSTEM", "warn", null, {skipHistory: true}); } }
            function addEnvAtPlayer(){ /* ... unchanged ... */ if (!currentCityKey||playerData.element.style.display==='none'){addMessage("Cannot add area: No city or player position.", "SYSTEM", "error", null, {skipHistory: true}); return;} const n=prompt("Enter name for the new area:","My Area");if(!n||!n.trim())return;const w=parseInt(prompt("Width:","300"),10)||300;const h=parseInt(prompt("Height:","200"),10)||200;const ok=modifyCurrentCityDefinition(def=>{const id=`uEnv_${Date.now()}`;def.environments=def.environments||[];def.environments.push({id:id,name:n.trim(),x:Math.round(playerData.x-w/2),y:Math.round(playerData.y-h/2),width:w,height:h});}); if(ok){ addMessage(`Added area '${n}'. Reload map.`,"SYSTEM","system", null, {skipHistory: true}); if(settingsOverlay.classList.contains('active')) populateSettingsModal(); if(confirm("Area definition added. Reload map now?")) { savePlayerPosition(); saveNpcPositions(); setTimeout(() => window.location.reload(), 300); } else { addMessage("Remember to reload later.", "SYSTEM", "info", null, {skipHistory: true}); } } else { addMessage("Failed to add area.", "SYSTEM", "error", null, {skipHistory: true}); } }
            function findClosestEnvironmentZone() { /* ... unchanged ... */ let cZ=null; let mDS=Infinity; if(playerData.x===undefined||playerData.y===undefined||!currentCityKey||playerData.element.style.display==='none') return null; environmentData.forEach(z => { const zCX=z.x+z.width/2; const zCY=z.y+z.height/2; const dS=Math.pow(playerData.x-zCX,2)+Math.pow(playerData.y-zCY,2); if(dS<mDS){mDS=dS;cZ=z;} }); console.log("Closest Zone:", cZ?cZ.name:"None"); return cZ; }
            function handleDeleteEnvFromSettings(event, envIdToDelete = null) { /* ... unchanged ... */ if (!currentCityKey) return; const id=envIdToDelete !== null ? envIdToDelete : event?.target?.dataset?.envId; if (!id) return; const e=environmentData.find(e => e.id === id); const eN=e?e.name:`Area ${id}`; if (!confirm(`Remove area "${eN}"? Irreversible.`)) return; let dM=false; const ok=modifyCurrentCityDefinition(def => { const iL=def.environments?.length||0; def.environments=def.environments?.filter(e => e.id !== id)||[]; dM=(def.environments?.length||0)<iL; }); if (ok&&dM) { localStorage.removeItem(LS_KEYS.envName(currentCityKey,id)); const iR=environmentData.findIndex(e => e.id === id); if (iR > -1) { if(environmentData[iR].element){ environmentData[iR].element.remove(); } environmentData.splice(iR, 1); } addMessage(`Removed area definition: ${eN}.`, "SYSTEM", "system", null, {skipHistory: true}); updateSpatialChatContext(); if(settingsOverlay.classList.contains('active')) populateSettingsModal(); } else { addMessage(`Failed to remove ${eN}.`, "SYSTEM", "warn", null, {skipHistory: true}); } }
            function findCurrentAreaName() { // Helper to get current area name based on player position
                 if(playerData.x===undefined||playerData.y===undefined||!currentCityKey) return null;
                 for (const area of environmentData) {
                     if (playerData.x >= area.x && playerData.x < (area.x + area.width) &&
                         playerData.y >= area.y && playerData.y < (area.y + area.height)) {
                         return area.name; // Return the name of the first area the player is inside
                     }
                 }
                 return null; // Not inside any defined area
            }
            function findNpcAreaName(npc) { // Helper to get area name based on NPC position
                 if(!npc || npc.x===undefined || npc.y===undefined || !currentCityKey) return null;
                 for (const area of environmentData) {
                     if (npc.x >= area.x && npc.x < (area.x + area.width) &&
                         npc.y >= area.y && npc.y < (area.y + area.height)) {
                         return area.name;
                     }
                 }
                 return null;
            }

            // --- Spatial Chat Integration ---
            /**
             * Callback function passed to SpatialChatManager for adding messages to the UI.
             * It checks if the relevant spatial tab is active before displaying.
             */
            function addSpatialMessageToUI(text, author, scopeKey, isBotOrigin = false) {
                if (typeof SpatialChatManager === 'undefined') return;

                const currentVisibleSpatialScopeKey = isSpatialTabActive ? SpatialChatManager.getMessageKeyForScope(currentChatTab) : null;

                if (scopeKey === currentVisibleSpatialScopeKey) {
                    // Determine PFP and message type for the main addMessage function
                    let speakerDataForUI = null;
                    let messageTypeForUI = 'system'; // Default for system messages from spatial chat

                    if (author !== 'SYSTEM' && author !== 'USER') { // It's an NPC
                         messageTypeForUI = 'assistant';
                         const npcOrigin = npcData.find(n => n.name === author);
                         speakerDataForUI = {
                             name: author,
                             pfp: npcOrigin?.pfp || DEFAULT_NPC_PFP
                         };
                    } else if (author === 'USER') { // Should ideally not happen via this callback, but handle anyway
                        messageTypeForUI = 'user';
                         speakerDataForUI = { name: playerData.name, pfp: playerData.pfp };
                    }

                    // Call the main UI display function
                     // Ensure system messages from spatial manager don't go into Agent/Message history
                    addMessage(text, author, messageTypeForUI, speakerDataForUI, { skipHistory: true });
                }
                 // Save spatial chat state (messages) after receiving a message
                 SpatialChatManager.forceSaveState();
            }

            /**
             * Updates the SpatialChatManager with the current game state.
             */
            function updateSpatialChatContext() {
                if (typeof SpatialChatManager === 'undefined' || !currentCityKey) return;

                const simplePlayerData = {
                    x: playerData.x,
                    y: playerData.y,
                    currentCity: currentCityKey,
                    currentArea: findCurrentAreaName() // Use helper
                };
                const simpleNpcData = npcData.map(n => ({
                    name: n.name,
                    x: n.x,
                    y: n.y,
                    personality: n.personaPrompt,
                    city: currentCityKey, // Assuming all loaded NPCs belong to current city
                    area: findNpcAreaName(n) // Use helper
                }));

                SpatialChatManager.updateSpatialContext(simplePlayerData, simpleNpcData);
            }
            // --- End Spatial Chat Integration ---

             // --- Conversation History Management ---
             function loadCurrentConversationHistory() {
                 let historyKey = null;
                 if (currentChatTab === 'Agent') historyKey = LS_KEYS.conversationHistoryAgent;
                 else if (currentChatTab === 'Message') historyKey = LS_KEYS.conversationHistoryMessage;

                 if (historyKey) {
                     try {
                         const saved = localStorage.getItem(historyKey);
                         if (saved) {
                             const parsed = JSON.parse(saved);
                             if (Array.isArray(parsed)) {
                                 conversationHistory = parsed;
                                 // Ensure history starts with system prompt if needed (or handle missing)
                                 if (conversationHistory.length === 0 || conversationHistory[0].role !== 'system') {
                                     console.warn(`History for ${currentChatTab} invalid/missing system prompt. Resetting.`);
                                      const sysPromptContent = currentAiNpcData ? generateSystemPrompt(currentAiNpcData, currentChatTab) : "You are a helpful assistant.";
                                      conversationHistory = [{ role: 'system', content: sysPromptContent }];
                                 }
                                 // Trim history if it's too long
                                 while (conversationHistory.length > (MAX_HISTORY_TURNS * 2 + 1)) { // +1 for system prompt
                                     conversationHistory.splice(1, 1); // Remove oldest non-system message
                                 }

                                 console.log(`Loaded ${conversationHistory.length} messages for ${currentChatTab}`);
                                 return;
                             }
                         }
                     } catch (e) {
                         console.error(`Error loading conversation history for ${currentChatTab}:`, e);
                     }
                 }
                 // Default/Reset if loading fails or not applicable
                 const sysPromptContent = currentAiNpcData ? generateSystemPrompt(currentAiNpcData, currentChatTab) : "You are a helpful assistant.";
                 conversationHistory = [{ role: 'system', content: sysPromptContent }];
                 console.log(`Initialized/Reset history for ${currentChatTab}`);
             }

             function saveCurrentConversationHistory() {
                 let historyKey = null;
                 if (currentChatTab === 'Agent') historyKey = LS_KEYS.conversationHistoryAgent;
                 else if (currentChatTab === 'Message') historyKey = LS_KEYS.conversationHistoryMessage;

                 if (historyKey) {
                     try {
                         // Ensure history isn't excessively long before saving
                         const historyToSave = conversationHistory.slice(-(MAX_HISTORY_TURNS * 2 + 1)); // Keep trimmed version
                         localStorage.setItem(historyKey, JSON.stringify(historyToSave));
                     } catch (e) {
                         console.error(`Error saving conversation history for ${currentChatTab}:`, e);
                     }
                 }
             }

             // --- Chat History Rendering ---
             function renderCurrentChatHistory() {
                 chatMessages.innerHTML = ''; // Clear existing messages

                 if (isSpatialTabActive && typeof SpatialChatManager !== 'undefined') {
                     const spatialMessages = SpatialChatManager.getMessagesForCurrentScope();
                     if (spatialMessages) {
                         spatialMessages.forEach(msgString => {
                             // Parse the "<Author> Text" format from SpatialChatManager
                             const match = msgString.match(/^<([^>]+)>\s*(.*)/s);
                             if (match) {
                                 const author = match[1];
                                 const text = match[2];
                                 const isBot = author !== 'USER' && author !== 'SYSTEM';
                                 const npcOrigin = isBot ? npcData.find(n => n.name === author) : null;
                                 const speakerDataForUI = isBot ? { name: author, pfp: npcOrigin?.pfp || DEFAULT_NPC_PFP } : null;
                                 const messageType = author === 'USER' ? 'user' : (isBot ? 'assistant' : 'system');

                                 // Add message but skip adding to Agent/Message history
                                 addMessage(text, author, messageType, speakerDataForUI, { skipHistory: true });
                             } else {
                                  // Fallback for unparseable messages (e.g., plain system messages)
                                  addMessage(msgString, 'SYSTEM', 'system', null, { skipHistory: true });
                             }
                         });
                     } else {
                         addMessage("No messages in this spatial scope yet, or location invalid.", "SYSTEM", 'system', null, {skipHistory: true});
                     }
                 } else if (currentChatTab === 'Agent' || currentChatTab === 'Message') {
                     loadCurrentConversationHistory(); // Load the specific history for this tab
                     // Render messages, skipping the system prompt
                     conversationHistory.slice(1).forEach(msg => {
                         const speakerDataForUI = msg.role === 'assistant' ? (currentAiNpcData || { name: "Spirit", pfp: DEFAULT_NPC_PFP }) : null;
                         addMessage(msg.content, msg.role === 'user' ? playerData.name : (speakerDataForUI?.name || 'Spirit'), msg.role, speakerDataForUI, { skipHistory: true }); // Always skip history during re-render
                     });
                      if (conversationHistory.length <= 1) {
                           addMessage(`Started ${currentChatTab} chat. Send a message!`, "SYSTEM", 'system', null, {skipHistory: true});
                      }
                 }
                 // Scroll to bottom after rendering
                  requestAnimationFrame(() => {
                     chatMessages.scrollTop = chatMessages.scrollHeight;
                 });
             }

             // --- Tab Switching Logic ---
             function handleTabSwitch(newTabId) {
                 const newTab = newTabId.replace('-tab', ''); // 'General', 'Area', 'Message', etc.
                 if (newTab === currentChatTab) return; // No change

                 console.log("Switching tab to:", newTab);

                 // Update state
                 const oldTab = currentChatTab;
                 currentChatTab = newTab;
                 isSpatialTabActive = ['General', 'Area', 'City', 'World'].includes(currentChatTab);
                 localStorage.setItem(LS_KEYS.currentChatTab, currentChatTab);

                 // Update Spatial Manager state
                 if (typeof SpatialChatManager !== 'undefined') {
                     SpatialChatManager.setActive(isSpatialTabActive);
                     if (isSpatialTabActive) {
                         SpatialChatManager.switchScope(currentChatTab); // Tell manager the scope
                     }
                 }

                 // Update UI
                 allTabButtons.forEach(btn => {
                     btn.classList.toggle('active-tab', btn.id === newTabId);
                 });

                 // Update placeholder text based on tab
                 updateInputPlaceholder();

                 // Clear and Render History for the new tab
                 renderCurrentChatHistory();
            }

            function updateInputPlaceholder() { // Overridden to include tab context
                 let placeholder = "Consult the spirit..."; // Default

                 if (!currentCityKey && currentChatTab !== 'Message') {
                     placeholder = "Open Settings (Click Sigil)...";
                 } else if (isSpatialTabActive) {
                     placeholder = `Send to #${currentChatTab}...`;
                 } else if (currentChatTab === 'Agent' || currentChatTab === 'Message') {
                     const targetNpc = currentAiNpcData || findClosestNpc(false);
                     if (targetNpc) {
                         placeholder = `(${currentChatTab}) Consult ${targetNpc.name}...`;
                     } else {
                         placeholder = `(${currentChatTab}) Walk near an agent or send message...`;
                     }
                 }
                 userInput.placeholder = placeholder;
            }


            // --- Simulation Initialization ---
            function initializeSimulation(cityKey) {
                 console.log(`Initializing simulation for city: ${cityKey}`);
                 if(npcFollowInterval) clearInterval(npcFollowInterval);

                 // --- Load Core Systems ---
                 if (typeof PROVIDERS === 'undefined' || typeof SpatialChatManager === 'undefined' || typeof window.getApiResponse === 'undefined') {
                      const missing = [
                          (typeof PROVIDERS === 'undefined' ? 'api_providers.js' : ''),
                          (typeof SpatialChatManager === 'undefined' ? 'spatial_chat_manager.js' : ''),
                          (typeof window.getApiResponse === 'undefined' ? 'getApiResponse function' : '')
                      ].filter(Boolean).join(', ');
                     document.body.innerHTML = `<div style="padding: 20px; font-family: Georgia, serif; color: #8b0000; background: #f5e7d0; border: 2px solid #3a3129;">FATAL ERROR: Required script(s) failed to load: ${missing}. Check file existence and browser console.</div>`;
                     console.error(`FATAL: Missing critical components: ${missing}`); return;
                 }

                 // --- Load API Keys & Provider/Model Selection ---
                 loadApiKeyManagement();
                 selectedProvider = localStorage.getItem(LS_KEYS.selectedProvider);
                 if (!selectedProvider || !PROVIDERS[selectedProvider]) {
                     selectedProvider = Object.keys(PROVIDERS)[0]; localStorage.setItem(LS_KEYS.selectedProvider, selectedProvider);
                 }
                 const providerConfig = PROVIDERS[selectedProvider];
                 const savedModel = localStorage.getItem(LS_KEYS.selectedModel);
                 if (providerConfig && providerConfig.availableModels?.includes(savedModel)) { selectedModel = savedModel; }
                 else if (providerConfig?.availableModels?.length > 0) { selectedModel = providerConfig.defaultModel || providerConfig.availableModels[0]; localStorage.setItem(LS_KEYS.selectedModel, selectedModel); }
                 else { selectedModel = null; localStorage.removeItem(LS_KEYS.selectedModel); }
                 console.log(`API Initialized: Provider=${selectedProvider}, Model=${selectedModel}`);

                 // --- Initialize Spatial Chat Manager ---
                 SpatialChatManager.init({}, addSpatialMessageToUI, window.getApiResponse);

                 // --- Reset UI and Load City ---
                 chatMessages.innerHTML=''; mapContent.innerHTML=''; mapContent.appendChild(playerElement);
                 playerElement.style.display='block'; currentCityKey=cityKey;
                 const cityDataString=localStorage.getItem(cityKey); let cityDefinition=null;
                 try { cityDefinition=JSON.parse(cityDataString); } catch(e){ /* ... error handling ... */ console.error(`Failed to parse city data for "${cityKey}":`,e); addMessage(`FATAL ERROR: Corrupt city data for "${cityKey}".`, "SYSTEM","error"); disableInput(); currentCityKey=null; return; }
                 if(!cityDefinition){ /* ... error handling ... */ addMessage(`FATAL ERROR: Could not load city data for key "${cityKey}".`, "SYSTEM","error"); disableInput(); currentCityKey=null; return; }

                 console.log(`Using city: ${cityDefinition.meta?.cityName||cityKey}`);
                 MAP_WIDTH=cityDefinition.map?.width??2000; MAP_HEIGHT=cityDefinition.map?.height??1500;
                 mapContent.style.width=`${MAP_WIDTH}px`; mapContent.style.height=`${MAP_HEIGHT}px`;

                 // --- Load Settings & Tabs ---
                 // interactionMode removed, use currentChatTab
                 hideSystemMessages=localStorage.getItem(LS_KEYS.hideSystemMessages)==='true';
                 const savedTab = localStorage.getItem(LS_KEYS.currentChatTab);
                 currentChatTab = ['General', 'Area', 'City', 'World', 'Message', 'Agent'].includes(savedTab) ? savedTab : 'Agent'; // Default to Agent
                 isSpatialTabActive = ['General', 'Area', 'City', 'World'].includes(currentChatTab);
                 SpatialChatManager.setActive(isSpatialTabActive); // Activate manager if needed
                 if (isSpatialTabActive) { SpatialChatManager.switchScope(currentChatTab); } // Set initial spatial scope

                 const savedTabsVisibility = localStorage.getItem(LS_KEYS.chatTabsVisible);
                 setChatTabsVisibility(savedTabsVisibility === null || savedTabsVisibility === 'true');

                 const savedChatHeight=localStorage.getItem(LS_KEYS.chatAreaHeight);
                 if(savedChatHeight){ chatArea.style.flexBasis=`${Math.max(parseInt(savedChatHeight,10),parseInt(getComputedStyle(document.documentElement).getPropertyValue('--chat-min-height'))||150)}px`; } else { chatArea.style.flexBasis = '300px'; }
                 doChatResize();

                 // --- Load Player ---
                 playerData.element=playerElement; playerData.speechElement=playerElement.querySelector('.speech'); playerData.nameplateElement=playerElement.querySelector('.character-name-plate');
                 playerData.name=localStorage.getItem(LS_KEYS.playerName)||'Player'; playerData.personaPrompt=localStorage.getItem(LS_KEYS.playerPersona)||"You are the Player.";
                 playerData.pfp=localStorage.getItem(LS_KEYS.playerPfp)||DEFAULT_PLAYER_PFP;
                 const savedPlayerX=localStorage.getItem(LS_KEYS.playerPositionX(cityKey)); const savedPlayerY=localStorage.getItem(LS_KEYS.playerPositionY(cityKey));
                 playerData.x=savedPlayerX!==null?parseFloat(savedPlayerX):(cityDefinition.player?.startX??MAP_WIDTH/2);
                 playerData.y=savedPlayerY!==null?parseFloat(savedPlayerY):(cityDefinition.player?.startY??MAP_HEIGHT/2);
                 // Assign width/height AFTER element is potentially visible
                 playerData.width=playerElement.offsetWidth||24; playerData.height=playerElement.offsetHeight||36;
                 playerData.isTalking=false; playerData.speechTimeout=null;
                 const savedPlayerAppearance=localStorage.getItem(LS_KEYS.playerAppearance);
                 try{ playerData.appearance= savedPlayerAppearance ? JSON.parse(savedPlayerAppearance) : JSON.parse(JSON.stringify(defaultPlayerAppearance)); } catch(e){ /* ... error handling ... */ playerData.appearance = JSON.parse(JSON.stringify(defaultPlayerAppearance)); }
                 applyPlayerAppearance(playerData.appearance); updateNameplate(playerData); updateCharacterPosition(playerData);
                 playerElement.removeEventListener('contextmenu', handlePlayerContextMenu); playerElement.addEventListener('contextmenu', handlePlayerContextMenu);

                 // --- Load Environments ---
                 environmentData.length=0; (cityDefinition.environments||[]).forEach((envDef,idx)=>{ /* ... unchanged env loading ... */ const id=envDef.id||`env_${idx}_${Date.now()}`; const zoneElement=document.createElement('div'); zoneElement.className='environment-zone'; zoneElement.id=`env-${id}`; const nameElement=document.createElement('span'); nameElement.className='environment-name-plate'; const savedName=localStorage.getItem(LS_KEYS.envName(cityKey,id)); const currentName=savedName||envDef.name||`Area ${idx+1}`; nameElement.textContent=currentName; zoneElement.appendChild(nameElement); mapContent.appendChild(zoneElement); const envRuntimeData={ id:id, name: currentName, x:envDef.x, y:envDef.y, width:envDef.width, height:envDef.height, element:zoneElement, nameElement:nameElement }; environmentData.push(envRuntimeData); updateEnvironmentVisuals(envRuntimeData); if (savedName === null || savedName !== envRuntimeData.name) { localStorage.setItem(LS_KEYS.envName(cityKey,id),envRuntimeData.name); } }); console.log(`Created ${environmentData.length} environment zones.`);

                 // --- Load NPCs ---
                 npcData.length=0; (cityDefinition.npcSpawns||[]).forEach((spawnDef,idx)=>{ /* ... mostly unchanged npc loading ... */ const id=idx; const npcElement=document.createElement('div'); npcElement.className='character npc'; npcElement.id=`npc-${id}`; npcElement.dataset.npcId=id; npcElement.innerHTML=`<div class="part detail5"></div> <div class="part detail4"></div> <div class="part detail3"></div> <div class="part legs"></div> <div class="part arm-left"></div> <div class="part arm-right"></div> <div class="part torso"></div> <div class="part detail1"></div> <div class="part detail2"></div> <div class="part head"></div> <span class="character-name-plate"></span> <span class="speech"></span>`; mapContent.appendChild(npcElement); const namePlate=npcElement.querySelector('.character-name-plate'); const speechBubble=npcElement.querySelector('.speech'); const npcWidth=npcElement.offsetWidth||24; const npcHeight=npcElement.offsetHeight||36; const savedName=localStorage.getItem(LS_KEYS.npcName(cityKey,id)); const savedPersona=localStorage.getItem(LS_KEYS.npcPersona(cityKey,id)); const savedX=localStorage.getItem(LS_KEYS.npcPositionX(cityKey,id)); const savedY=localStorage.getItem(LS_KEYS.npcPositionY(cityKey,id)); const savedPfp=localStorage.getItem(LS_KEYS.npcPfp(cityKey,id)); const defaultName=spawnDef.defaultName||`Agent ${id+1}`; const npc={ id:id, element:npcElement, name:savedName||defaultName, speechElement:speechBubble, nameplateElement:namePlate, personaPrompt:savedPersona||spawnDef.defaultPersona||`You are ${savedName||defaultName}.`, width:npcWidth, height:npcHeight, x:savedX!==null?parseFloat(savedX):spawnDef.x, y:savedY!==null?parseFloat(savedY):spawnDef.y, isTalking:false, speechTimeout:null, appearance:null, pfp: savedPfp||DEFAULT_NPC_PFP, spawnId: spawnDef.spawnId, followingTargetId: null }; if (savedName===null&&npc.name!==defaultName) localStorage.setItem(LS_KEYS.npcName(cityKey,id),npc.name); if (savedPersona===null&&npc.personaPrompt!==(spawnDef.defaultPersona||`You are ${defaultName}.`)) localStorage.setItem(LS_KEYS.npcPersona(cityKey,id),npc.personaPrompt); const savedAppearance=localStorage.getItem(LS_KEYS.npcAppearance(cityKey,id)); try { npc.appearance = savedAppearance ? JSON.parse(savedAppearance) : JSON.parse(JSON.stringify(defaultNpcAppearance)); } catch(e){ npc.appearance=JSON.parse(JSON.stringify(defaultNpcAppearance)); } npcData.push(npc); updateNameplate(npc); applyNpcAppearance(npc); updateCharacterPosition(npc); npcElement.removeEventListener('contextmenu', handleNpcContextMenu); npcElement.addEventListener('contextmenu', handleNpcContextMenu); }); console.log(`Created ${npcData.length} NPCs.`);

                 // --- Final Setup ---
                 viewportWidth=gameWorld.offsetWidth; viewportHeight=gameWorld.offsetHeight; updateCameraPosition();
                 initialSpeakerData=findClosestNpc(true); // Find closest for potential Agent/Message target
                 currentAiNpcData = initialSpeakerData; // Set initial target

                 // Update Spatial Manager with initial context
                 updateSpatialChatContext();

                 // Update UI (Tabs, Placeholder, Render History)
                 allTabButtons.forEach(btn => btn.classList.toggle('active-tab', btn.id === `${currentChatTab.toLowerCase()}-tab`));
                 updateInputPlaceholder();
                 renderCurrentChatHistory(); // Render history for the initially active tab

                 // Start NPC following interval
                 npcFollowInterval=setInterval(updateFollowingNpcs,200);

                 // Welcome messages
                 const welcomeMsg = `Welcome to ${cityDefinition.meta?.cityName||'the Simulation'}.`;
                 const systemSpeakerName = "Tome";
                 addMessage(welcomeMsg, systemSpeakerName, 'system', null, { skipHistory: true }); // Skip history for welcome
                 addMessage(`Current Tab: ${currentChatTab}. Click your avatar for options.`, systemSpeakerName, "system", null, { skipHistory: true });

                 enableInput();
                 console.log(`Initialization complete for: ${cityDefinition.meta?.cityName}. Active Tab: ${currentChatTab}.`);
            }

            // --- No City State ---
            function enterNoCityState() {
                console.log("Entering No City state.");
                if(npcFollowInterval) clearInterval(npcFollowInterval);
                currentCityKey=null; chatMessages.innerHTML=''; mapContent.innerHTML=''; mapContent.appendChild(playerElement);
                playerElement.style.display='none'; playerData.x=undefined; playerData.y=undefined;
                npcData.length=0; environmentData.length=0;
                mapContent.style.width='100%'; mapContent.style.height='100%'; mapContent.style.transform='translate3d(0,0,0)';
                gameWorld.style.display='none';
                conversationHistory=[]; // Reset direct history
                if(typeof SpatialChatManager !== 'undefined') SpatialChatManager.setActive(false); // Deactivate spatial chat
                isSpatialTabActive = false;
                currentChatTab = 'Message'; // Default to Message if no city
                localStorage.setItem(LS_KEYS.currentChatTab, currentChatTab);
                allTabButtons.forEach(btn => btn.classList.toggle('active-tab', btn.id === 'message-tab'));

                addMessage("Welcome! No cities created yet. Open Settings (click sigil) to add a city.", "SYSTEM", "system");
                disableInput();
                userInput.placeholder="Open Settings...";
                chatTabsContainer.classList.add('hidden'); // Hide tabs

                // Load API settings even without city
                 if (typeof PROVIDERS !== 'undefined') {
                     loadApiKeyManagement();
                     selectedProvider = localStorage.getItem(LS_KEYS.selectedProvider);
                     if (!selectedProvider || !PROVIDERS[selectedProvider]) { selectedProvider = Object.keys(PROVIDERS)[0]; localStorage.setItem(LS_KEYS.selectedProvider, selectedProvider); }
                     const providerConfig = PROVIDERS[selectedProvider];
                     const savedModel = localStorage.getItem(LS_KEYS.selectedModel);
                     if (providerConfig?.availableModels?.includes(savedModel)) { selectedModel = savedModel; }
                     else if (providerConfig?.availableModels?.length > 0) { selectedModel = providerConfig.defaultModel || providerConfig.availableModels[0]; localStorage.setItem(LS_KEYS.selectedModel, selectedModel); }
                     else { selectedModel = null; }
                 } else { console.error("PROVIDERS object not defined."); }
                openSettingsModal(); // Guide user to create city
            }

            // --- UI Helpers ---
            function doChatResize() { /* ... unchanged ... */
                const chatHeight = chatArea.offsetHeight; const windowHeight = window.innerHeight; const isEffectivelyFullscreen = chatHeight >= (windowHeight - 10); gameWorld.style.display = isEffectivelyFullscreen ? 'none' : 'block'; if(!isEffectivelyFullscreen){ updateCameraPosition(); }
            }
            function saveChatHeight() { /* ... unchanged ... */
                const chatHeight = chatArea.offsetHeight; const windowHeight = window.innerHeight; if (chatHeight < (windowHeight - 10)) { localStorage.setItem(LS_KEYS.chatAreaHeight, chatHeight.toString()); console.log("Saved chat height:", chatHeight); } else { console.log("Chat is fullscreen, not saving height."); }
            }
            function toggleFullscreenChat() { /* ... unchanged ... */
                 const currentHeight = chatArea.offsetHeight; const windowHeight = window.innerHeight; const minChatHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--chat-min-height')) || 150; const isFullscreen = currentHeight >= (windowHeight - 10); if (isFullscreen) { const savedHeight = chatHeightBeforeFullscreen || localStorage.getItem(LS_KEYS.chatAreaHeight); let restoreHeightPx = parseInt(savedHeight, 10); if (isNaN(restoreHeightPx) || restoreHeightPx < minChatHeight || restoreHeightPx >= (windowHeight - 10)) { restoreHeightPx = 300; } chatArea.style.flexBasis = `${restoreHeightPx}px`; console.log("Exiting fullscreen, restored height:", restoreHeightPx); localStorage.setItem(LS_KEYS.chatAreaHeight, `${restoreHeightPx}`); chatHeightBeforeFullscreen = null; setTimeout(() => { chatMessages.scrollTop = chatMessages.scrollHeight; }, 350); } else { chatHeightBeforeFullscreen = `${currentHeight}px`; chatArea.style.flexBasis = '100vh'; console.log("Entering fullscreen, stored height:", chatHeightBeforeFullscreen); setTimeout(() => { chatMessages.scrollTop = chatMessages.scrollHeight; }, 50); } setTimeout(doChatResize, 50);
             }
             function populateCitySelectorInModal(selectElement){ /* ... unchanged ... */ if (!selectElement) return false; selectElement.innerHTML = ''; let uCE=false; const cK=[]; Object.keys(localStorage).forEach(key => { if (key.startsWith(USER_CITY_PREFIX)) { cK.push(key); uCE=true; } }); cK.sort(); if (!uCE) { const o=document.createElement('option'); o.value=""; o.textContent="No cities created"; o.disabled=true; selectElement.appendChild(o); } else { const dO=document.createElement('option'); dO.value=""; dO.textContent="-- Select a City --"; dO.disabled=!currentCityKey; selectElement.appendChild(dO); cK.forEach(key => { const o=document.createElement('option'); o.value=key; let dN=key.substring(USER_CITY_PREFIX.length).split('_')[0]; try{ const cd=JSON.parse(localStorage.getItem(key)); dN=cd?.meta?.cityName||dN; }catch(e){} o.textContent=`* ${dN}`; selectElement.appendChild(o); }); if(currentCityKey){ selectElement.value=currentCityKey; } else { selectElement.value=""; } } return uCE; }


            // --- Event Listeners ---
            document.addEventListener('keydown',(e)=>{if(settingsOverlay.classList.contains('active')||appearanceEditorOverlay.classList.contains('active')||document.activeElement===userInput||!currentCityKey||isWaitingForApiResponse)return;let m=false;switch(e.key.toLowerCase()){case'arrowup':case'w':movePlayer(0,-1);m=true;break;case'arrowdown':case's':movePlayer(0,1);m=true;break;case'arrowleft':case'a':movePlayer(-1,0);m=true;break;case'arrowright':case'd':movePlayer(1,0);m=true;break;}if(m)e.preventDefault();});
            userInput.addEventListener('keypress',(e)=>{if(e.key==='Enter'&&!sendButton.disabled&&!e.shiftKey){e.preventDefault();handlePlayerSend();}});
            userInput.addEventListener('input',()=>{userInput.style.height='auto';userInput.style.height=(userInput.scrollHeight)+'px';});
            sendButton.addEventListener('click',()=>{if(!sendButton.disabled&&!isWaitingForApiResponse)handlePlayerSend();});
            modalCloseBtn.addEventListener('click',closeSettingsModal); modalCancelBtn.addEventListener('click',closeSettingsModal); modalSaveBtn.addEventListener('click',saveSettings);
            settingsOverlay.addEventListener('click',(e)=>{if(e.target===settingsOverlay)closeSettingsModal();});
            settingsPrevBtn.addEventListener('click',()=>{if(currentSettingsPage>1)showSettingsPage(currentSettingsPage-1);}); settingsNextBtn.addEventListener('click',()=>{if(currentSettingsPage<TOTAL_SETTINGS_PAGES)showSettingsPage(currentSettingsPage+1);});
            appearanceEditorCloseBtn.addEventListener('click', closeAppearanceEditorModal); appearanceEditorCancelBtn.addEventListener('click', closeAppearanceEditorModal); appearanceEditorSaveBtn.addEventListener('click', saveAppearanceFromEditor);
            appearanceEditorOverlay.addEventListener('click',(e)=>{if(e.target===appearanceEditorOverlay)closeAppearanceEditorModal();});
            appearancePfpPreview.addEventListener('click',()=>pfpUploadInput.click()); appearancePfpChangeBtn.addEventListener('click',()=>pfpUploadInput.click());
            pfpUploadInput.addEventListener('change', handlePfpUpload);
            window.addEventListener('resize',()=>{if(currentCityKey){viewportWidth=gameWorld.offsetWidth;viewportHeight=gameWorld.offsetHeight;doChatResize();updateInputPlaceholder();}});
            // NPC Context Menu Actions
            npcContextMenu.addEventListener('click',(e)=>{ if(e.target.classList.contains('context-menu-item')){ const a=e.target.dataset.action; const targetNpc = npcData.find(n=>n.id===contextMenuTargetNpcId); if(!targetNpc){ closeAllContextMenus(); return; } console.log(`Action: ${a} on ${targetNpc.name}`); currentAiNpcData = targetNpc; // Set target for direct interaction
                 switch(a){
                     case 'talk': // Switch to Agent tab and send hello
                         handleTabSwitch('agent-tab');
                         addMessage("Hello.",playerData.name,'user'); disableInput(); getDirectApiResponse("Hello.",1);
                         break;
                     case 'message': // Switch to Message tab and send hello
                          handleTabSwitch('message-tab');
                          addMessage("Hello.",playerData.name,'user'); disableInput(); getDirectApiResponse("Hello.",1);
                         break;
                     case 'follow': handleFollowAction(targetNpc); break;
                     case 'appearance': openAppearanceEditorModal(targetNpc.id); break;
                     case 'cancel': break;
                 } closeAllContextMenus(); }});
            // Player Context Menu Actions
            playerContextMenu.addEventListener('click',(e)=>{ if(e.target.classList.contains('context-menu-item')){const a=e.target.dataset.action; console.log(`Action: ${a} on Player`); switch(a){case 'appearance': openAppearanceEditorModal('player'); break; case 'add_area': addEnvAtPlayer(); break; case 'add_agent': addNpcAtPlayer(); break; case 'remove_closest_agent': const cN=findClosestNpc(false); if(cN){handleDeleteNpcFromSettings(null,cN.id);} else {addMessage("No agent nearby to remove.","SYSTEM","system");} break; case 'remove_closest_area': const cZ=findClosestEnvironmentZone(); if(cZ){handleDeleteEnvFromSettings(null,cZ.id);} else {addMessage("No area nearby to remove.","SYSTEM","system");} break; case 'cancel': break;} closeAllContextMenus(); }});
            // PFP Context Menu Actions
            pfpContextMenu.addEventListener('click', (e) => { if (e.target.classList.contains('context-menu-item')) { const action = e.target.dataset.action; console.log(`PFP Menu Action: ${action}`); switch(action) { case 'toggle-tabs': toggleChatTabsVisibility(); break; case 'toggle-fullscreen': toggleFullscreenChat(); break; case 'cancel': break; } closeAllContextMenus(); } });
            // Tab Button Listeners
            allTabButtons.forEach(button => {
                if (button) { // Check if button exists
                    button.addEventListener('click', () => handleTabSwitch(button.id));
                }
            });

            window.addEventListener('beforeunload',(e)=>{ if(currentCityKey){saveNpcPositions();savePlayerPosition(); saveChatHeight();} if(npcFollowInterval) clearInterval(npcFollowInterval); if(typeof SpatialChatManager !== 'undefined') SpatialChatManager.forceSaveState(); saveCurrentConversationHistory(); }); // Save both histories
            window.addEventListener('message', receiveCreatorData);
            function receiveCreatorData(event) { /* ... unchanged ... */ if(event.data?.type==='CHARACTER_STYLE_UPDATE'){const rS=event.data.payload;if(typeof rS==='object'&&rS!==null&&rS.colors){temporaryAppearanceData=JSON.parse(JSON.stringify(rS));if(appearanceEditorTarget==='player'){applyAppearanceToElement(playerData.element,rS);}else if(appearanceEditorTarget!==null){const tN=npcData.find(n=>n.id===appearanceEditorTarget);if(tN){applyAppearanceToElement(tN.element,rS);}else{console.error(`Target NPC ${appearanceEditorTarget} not found for style update!`);}}else{console.warn("Received style update from creator, but no target is set.");}}else{console.warn("Received invalid style data from creator:", rS);}}}

            // --- Initial Execution ---
            let cityKeyToLoad=localStorage.getItem(LS_KEYS.selectedCity); if(!cityKeyToLoad||!cityKeyToLoad.startsWith(USER_CITY_PREFIX)||!localStorage.getItem(cityKeyToLoad)){ const userCityKeys=[]; Object.keys(localStorage).forEach(key => { if (key.startsWith(USER_CITY_PREFIX)) userCityKeys.push(key); }); userCityKeys.sort(); cityKeyToLoad=userCityKeys[0]||null; if(cityKeyToLoad){ localStorage.setItem(LS_KEYS.selectedCity, cityKeyToLoad); } }
            if (cityKeyToLoad) { initializeSimulation(cityKeyToLoad); } else { enterNoCityState(); }

        } // End runSimulation

        document.addEventListener('DOMContentLoaded', runSimulation);
    </script>

</body>
</html>
