<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Agent Sim - Arcane Tome UI</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=Georgia&family=Uncial+Antiqua&display=swap" rel="stylesheet">

    <style>
        /* --- Base Styles & Variables --- */
        :root {
            --parchment: #f5e7d0; --parchment-dark: #e3d5b8; --ink: #3a3129;
            --ink-light: #5a4e42; --gold: #c9a227; --crimson: #8b0000;
            --sapphire: #1e3a8a; --amethyst: #6b21a8; --shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            --glow: 0 0 10px rgba(201, 162, 39, 0.7); --fade: all 0.3s ease; /* Faster fade */
            --skin-tone: #fbe5d6; --default-outline: #222; --swatch-size: 20px;
            --danger-color: var(--crimson); --danger-hover: #6b0000;
            --modal-scrollbar-track: var(--parchment-dark); --modal-scrollbar-thumb: var(--ink-light);
            --modal-scrollbar-thumb-hover: var(--ink); --chat-min-height: 150px;
            --tibia-like-font: 'Uncial Antiqua', cursive;
            --tab-close-size: 16px;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; width: 100%; overflow: hidden; background-color: var(--parchment); font-family: Georgia, 'Times New Roman', Times, serif; font-size: 1.1rem; line-height: 1.6; color: var(--ink); }
        #ui-container { display: flex; flex-direction: column; width: 100vw; height: 100vh; background-color: transparent; box-sizing: border-box; position: relative; }
        #ui-container::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: url('https://www.transparenttextures.com/patterns/old-map.png'); opacity: 0.15; pointer-events: none; z-index: -1; }

        /* --- Game World & Map --- */
        #game-world { flex-grow: 1; background-color: #333; position: relative; overflow: hidden; image-rendering: pixelated; image-rendering: crisp-edges; min-height: 0; }
        #map-content { position: absolute; top: 0; left: 0; width: 3000px; height: 2000px; background-color: #4a7c2d; background-image: linear-gradient(45deg, rgba(0,0,0,0.04) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.04) 75%, rgba(0,0,0,0.04)), linear-gradient(45deg, rgba(0,0,0,0.04) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.04) 75%, rgba(0,0,0,0.04)); background-size: 12px 12px; background-position: 0 0, 6px 6px; transform: translate3d(0, 0, 0); transition: transform 0.3s linear; }

        /* --- Character Styling --- */
        /* ... (Character styles remain unchanged) ... */
        .character { width: 24px; height: 36px; position: absolute; cursor: pointer; z-index: 5; background-color: transparent; border: none; margin-top: 0; transition: top 0.2s linear, left 0.2s linear, opacity 0.5s ease; transform-origin: center bottom; }
        #player { z-index: 6; }
        .character .part { position: absolute; box-sizing: border-box; transition: background-color 0.1s ease, border-color 0.1s ease; display: none; background-color: transparent; image-rendering: pixelated; image-rendering: crisp-edges; }
        .character .part.head, .character .part.torso, .character .part.legs, .character .part.arm-left, .character .part.arm-right, .character .part.detail1 { border: 1px solid var(--default-outline); }
        .character .part.head { z-index: 10; background-color: var(--skin-tone); } .character .part.torso { z-index: 5; } .character .part.legs { z-index: 4; }
        .character .part.arm-left { z-index: 6; transform-origin: 2px 1px; } .character .part.arm-right { z-index: 6; transform-origin: 1px 1px; }
        .character .part.detail1 { z-index: 7; } .character .part.detail2 { z-index: 11; } .character .part.detail3 { z-index: 3; }
        .character .part.detail4 { z-index: 12; border: none; } .character .part.detail5 { z-index: 12; border: none; }
        .character.gender-male .part.head { top: 1px; left: 7px; width: 10px; height: 9px; border-radius: 2px 2px 0 0; }
        .character.gender-male .part.detail2 { display: block; top: 0px; left: 5px; width: 14px; height: 6px; border-radius: 3px 3px 1px 1px; border: 1px solid var(--default-outline); }
        .character.gender-male .part.detail3 { display: block; top: 5px; left: 6px; width: 12px; height: 6px; border-radius: 0 0 2px 2px; border: 1px solid var(--default-outline); }
        .character.gender-male.outfit-citizen .part.head, .character.gender-male.outfit-citizen .part.torso, .character.gender-male.outfit-citizen .part.legs, .character.gender-male.outfit-citizen .part.detail2, .character.gender-male.outfit-citizen .part.detail3, .character.gender-male.outfit-citizen .part.arm-left, .character.gender-male.outfit-citizen .part.arm-right { display: block; }
        .character.gender-male.outfit-citizen .part.torso { top: 9px; left: 5px; width: 14px; height: 12px; border-top-width: 2px; border-bottom: none;}
        .character.gender-male.outfit-citizen .part.legs { top: 21px; left: 6px; width: 12px; height: 9px; border-bottom-width: 3px; border-top: none; }
        .character.gender-male.outfit-citizen .part.arm-left { top: 10px; left: 2px; width: 3px; height: 10px; border-radius: 1px; }
        .character.gender-male.outfit-citizen .part.arm-right { top: 10px; left: 19px; width: 3px; height: 10px; border-radius: 1px; }
        .character.gender-male.outfit-mage .part.head, .character.gender-male.outfit-mage .part.torso, .character.gender-male.outfit-mage .part.legs, .character.gender-male.outfit-mage .part.detail1, .character.gender-male.outfit-mage .part.detail4, .character.gender-male.outfit-mage .part.arm-left, .character.gender-male.outfit-mage .part.arm-right { display: block; }
        .character.gender-male.outfit-mage .part.detail2, .character.gender-male.outfit-mage .part.detail3 { display: none; }
        .character.gender-male.outfit-mage .part.detail4 { top: -4px; left: 4px; width: 16px; height: 10px; border-radius: 50% 50% 0 0 / 40% 40% 0 0; border: 1px solid var(--default-outline); border-bottom: none; clip-path: polygon(50% 0%, 100% 100%, 0% 100%); }
        .character.gender-male.outfit-mage .part.torso { top: 9px; left: 4px; width: 16px; height: 18px; }
        .character.gender-male.outfit-mage .part.legs { top: 27px; left: 6px; width: 12px; height: 6px; border-bottom-width: 3px; border-top: none; }
        .character.gender-male.outfit-mage .part.detail1 { top: 18px; left: 4px; width: 16px; height: 3px; }
        .character.gender-male.outfit-mage .part.arm-left { top: 11px; left: 1px; width: 4px; height: 10px; }
        .character.gender-male.outfit-mage .part.arm-right { top: 11px; left: 19px; width: 4px; height: 10px; }
        .character.gender-male.outfit-warrior .part.head, .character.gender-male.outfit-warrior .part.torso, .character.gender-male.outfit-warrior .part.legs, .character.gender-male.outfit-warrior .part.detail1, .character.gender-male.outfit-warrior .part.detail2, .character.gender-male.outfit-warrior .part.detail3, .character.gender-male.outfit-warrior .part.detail4, .character.gender-male.outfit-warrior .part.detail5, .character.gender-male.outfit-warrior .part.arm-left, .character.gender-male.outfit-warrior .part.arm-right { display: block; }
        .character.gender-male.outfit-warrior .part.detail4 { top: 0px; left: 1px; width: 7px; height: 10px; border-radius: 3px 0 0 0; border-width: 1px; border-style: outset; }
        .character.gender-male.outfit-warrior .part.detail5 { top: 0px; left: 16px; width: 7px; height: 10px; border-radius: 0 3px 0 0; border-width: 1px; border-style: outset; }
        .character.gender-male.outfit-warrior .part.head { border-radius: 1px; }
        .character.gender-male.outfit-warrior .part.torso { top: 9px; left: 4px; width: 16px; height: 13px; border-width: 2px; border-style: outset; }
        .character.gender-male.outfit-warrior .part.legs { top: 22px; left: 5px; width: 14px; height: 8px; border-bottom-width: 4px; border-style: outset; border-top: none;}
        .character.gender-male.outfit-warrior .part.detail1 { top: 18px; left: 4px; width: 16px; height: 4px; }
        .character.gender-male.outfit-warrior .part.arm-left { top: 11px; left: 1px; width: 4px; height: 10px; }
        .character.gender-male.outfit-warrior .part.arm-right { top: 11px; left: 19px; width: 4px; height: 10px; }
        .character.gender-male.outfit-scifi .part.head, .character.gender-male.outfit-scifi .part.torso, .character.gender-male.outfit-scifi .part.legs, .character.gender-male.outfit-scifi .part.detail1, .character.gender-male.outfit-scifi .part.detail2, .character.gender-male.outfit-scifi .part.detail3, .character.gender-male.outfit-scifi .part.arm-left, .character.gender-male.outfit-scifi .part.arm-right { display: block; }
        .character.gender-male.outfit-scifi .part.head { top: 1px; left: 7px; width: 10px; height: 9px; border-radius: 2px; }
        .character.gender-male.outfit-scifi .part.torso { top: 9px; left: 5px; width: 14px; height: 13px; border-style: solid; border-width: 1px 2px;}
        .character.gender-male.outfit-scifi .part.legs { top: 22px; left: 6px; width: 12px; height: 9px; border-bottom-width: 3px; border-style: solid; border-width: 1px 2px;}
        .character.gender-male.outfit-scifi .part.detail1 { top: 11px; left: 8px; width: 8px; height: 5px; border-radius: 1px; z-index: 7; }
        .character.gender-male.outfit-scifi .part.arm-left { top: 10px; left: 2px; width: 4px; height: 11px; border-radius: 1px;}
        .character.gender-male.outfit-scifi .part.arm-right { top: 10px; left: 18px; width: 4px; height: 11px; border-radius: 1px;}
        .character.gender-male.outfit-ranger .part.head, .character.gender-male.outfit-ranger .part.torso, .character.gender-male.outfit-ranger .part.legs, .character.gender-male.outfit-ranger .part.detail1, .character.gender-male.outfit-ranger .part.detail2, .character.gender-male.outfit-ranger .part.detail3, .character.gender-male.outfit-ranger .part.arm-left, .character.gender-male.outfit-ranger .part.arm-right { display: block; }
        .character.gender-male.outfit-ranger .part.torso { top: 9px; left: 5px; width: 14px; height: 13px; }
        .character.gender-male.outfit-ranger .part.legs { top: 22px; left: 6px; width: 12px; height: 9px; border-bottom-width: 3px; }
        .character.gender-male.outfit-ranger .part.detail1 { top: 18px; left: 5px; width: 14px; height: 4px; }
        .character.gender-male.outfit-ranger .part.arm-left { top: 10px; left: 2px; width: 4px; height: 11px; }
        .character.gender-male.outfit-ranger .part.arm-right { top: 10px; left: 18px; width: 4px; height: 11px; }
        .character.gender-male.outfit-kimono .part.head, .character.gender-male.outfit-kimono .part.torso, .character.gender-male.outfit-kimono .part.legs, .character.gender-male.outfit-kimono .part.detail1, .character.gender-male.outfit-kimono .part.detail2, .character.gender-male.outfit-kimono .part.detail3, .character.gender-male.outfit-kimono .part.arm-left, .character.gender-male.outfit-kimono .part.arm-right { display: block; }
        .character.gender-male.outfit-kimono .part.torso { top: 9px; left: 4px; width: 16px; height: 18px; border-radius: 1px; border-right-width: 2px; border-left-width: 2px;}
        .character.gender-male.outfit-kimono .part.legs { top: 27px; left: 6px; width: 12px; height: 6px; border-bottom-width: 3px; border-top: none; }
        .character.gender-male.outfit-kimono .part.detail1 { top: 16px; left: 4px; width: 16px; height: 5px; z-index: 7; }
        .character.gender-male.outfit-kimono .part.arm-left { top: 10px; left: 0px; width: 6px; height: 15px; border-radius: 0 0 2px 2px; }
        .character.gender-male.outfit-kimono .part.arm-right { top: 10px; left: 18px; width: 6px; height: 15px; border-radius: 0 0 2px 2px; }
        .character.gender-female .part.head { width: 12px; height: 11px; left: 6px; top: 1px; border-radius: 40% 40% 35% 35%; }
        .character.gender-female .part.detail3 { display: block; top: 4px; left: 4px; width: 16px; height: 20px; border-radius: 0 0 10px 10px; border: none; }
        .character.gender-female .part.detail2 { display: block; top: 1px; left: 5px; width: 14px; height: 8px; border-radius: 5px 5px 2px 2px; border: none; border-bottom: 1px solid #111;}
        .character.gender-female.outfit-citizen .part.head, .character.gender-female.outfit-citizen .part.torso, .character.gender-female.outfit-citizen .part.legs, .character.gender-female.outfit-citizen .part.detail1, .character.gender-female.outfit-citizen .part.detail2, .character.gender-female.outfit-citizen .part.detail3, .character.gender-female.outfit-citizen .part.arm-left, .character.gender-female.outfit-citizen .part.arm-right { display: block; }
        .character.gender-female.outfit-citizen .part.torso { top: 10px; left: 7px; width: 10px; height: 11px; border-radius: 2px; }
        .character.gender-female.outfit-citizen .part.detail1 { top: 18px; left: 6px; width: 12px; height: 3px; border-radius: 1px; }
        .character.gender-female.outfit-citizen .part.legs { top: 21px; left: 5px; width: 14px; height: 10px; border-bottom-width: 3px; border-top: none; border-radius: 0 0 5px 5px; }
        .character.gender-female.outfit-citizen .part.arm-left { top: 11px; left: 4px; width: 3px; height: 6px; border-radius: 1px; }
        .character.gender-female.outfit-citizen .part.arm-right { top: 11px; left: 17px; width: 3px; height: 6px; border-radius: 1px; }
        .character.gender-female.outfit-mage .part.head, .character.gender-female.outfit-mage .part.torso, .character.gender-female.outfit-mage .part.legs, .character.gender-female.outfit-mage .part.detail1, .character.gender-female.outfit-mage .part.detail2, .character.gender-female.outfit-mage .part.detail3, .character.gender-female.outfit-mage .part.arm-left, .character.gender-female.outfit-mage .part.arm-right { display: block; }
        .character.gender-female.outfit-mage .part.head { top: 2px; }
        .character.gender-female.outfit-mage .part.detail2 { top: 1px; left: 4px; width: 16px; height: 9px; border-radius: 6px 6px 3px 3px; }
        .character.gender-female.outfit-mage .part.detail3 { top: 5px; left: 4px; width: 16px; height: 22px; border-radius: 0 0 10px 10px;}
        .character.gender-female.outfit-mage .part.torso { top: 11px; left: 5px; width: 14px; height: 18px; border-radius: 2px; }
        .character.gender-female.outfit-mage .part.detail1 { top: 14px; left: 9px; width: 6px; height: 4px; border-radius: 50%; z-index: 7; }
        .character.gender-female.outfit-mage .part.legs { top: 29px; left: 6px; width: 12px; height: 5px; border-bottom-width: 2px; border-top: none; border-radius: 0 0 3px 3px;}
        .character.gender-female.outfit-mage .part.arm-left { top: 12px; left: 1px; width: 5px; height: 15px; border-radius: 0 0 3px 3px; }
        .character.gender-female.outfit-mage .part.arm-right { top: 12px; left: 18px; width: 5px; height: 15px; border-radius: 0 0 3px 3px; }
        .character.gender-female.outfit-warrior .part.head, .character.gender-female.outfit-warrior .part.torso, .character.gender-female.outfit-warrior .part.legs, .character.gender-female.outfit-warrior .part.detail1, .character.gender-female.outfit-warrior .part.detail2, .character.gender-female.outfit-warrior .part.detail3, .character.gender-female.outfit-warrior .part.arm-left, .character.gender-female.outfit-warrior .part.arm-right { display: block; }
        .character.gender-female.outfit-warrior .part.torso { top: 10px; left: 6px; width: 12px; height: 11px; border-radius: 3px 3px 1px 1px; border-style: solid; border-width: 1px; }
        .character.gender-female.outfit-warrior .part.detail1 { top: 20px; left: 4px; width: 16px; height: 7px; border-radius: 0 0 4px 4px; border-style: outset; }
        .character.gender-female.outfit-warrior .part.legs { top: 27px; left: 7px; width: 10px; height: 6px; border-bottom-width: 3px; border-top: none; }
        .character.gender-female.outfit-warrior .part.arm-left { top: 11px; left: 3px; width: 3px; height: 9px; border-radius: 1px; border-style: outset; border-width: 1px; }
        .character.gender-female.outfit-warrior .part.arm-right { top: 11px; left: 18px; width: 3px; height: 9px; border-radius: 1px; border-style: outset; border-width: 1px; }
        .character.gender-female.outfit-warrior .part.detail2 { top: 1px; height: 7px; left: 4px; width: 16px;}
        .character.gender-female.outfit-warrior .part.detail3 { height: 22px;}
        .character.gender-female.outfit-scifi .part.head, .character.gender-female.outfit-scifi .part.torso, .character.gender-female.outfit-scifi .part.legs, .character.gender-female.outfit-scifi .part.detail1, .character.gender-female.outfit-scifi .part.detail2, .character.gender-female.outfit-scifi .part.detail3, .character.gender-female.outfit-scifi .part.arm-left, .character.gender-female.outfit-scifi .part.arm-right { display: block; }
        .character.gender-female.outfit-scifi .part.torso { top: 10px; left: 6px; width: 12px; height: 12px; border-style: solid; border-width: 1px; border-radius: 2px; }
        .character.gender-female.outfit-scifi .part.legs { top: 22px; left: 7px; width: 10px; height: 9px; border-bottom-width: 3px; border-style: solid; border-width: 1px; }
        .character.gender-female.outfit-scifi .part.detail1 { top: 11px; left: 9px; width: 6px; height: 4px; border-radius: 1px; z-index: 7;}
        .character.gender-female.outfit-scifi .part.arm-left { top: 11px; left: 3px; width: 3px; height: 11px; border-radius: 1px; }
        .character.gender-female.outfit-scifi .part.arm-right { top: 11px; left: 18px; width: 3px; height: 11px; border-radius: 1px; }
        .character.gender-female.outfit-ranger .part.head, .character.gender-female.outfit-ranger .part.torso, .character.gender-female.outfit-ranger .part.legs, .character.gender-female.outfit-ranger .part.detail1, .character.gender-female.outfit-ranger .part.detail2, .character.gender-female.outfit-ranger .part.detail3, .character.gender-female.outfit-ranger .part.arm-left, .character.gender-female.outfit-ranger .part.arm-right { display: block; }
        .character.gender-female.outfit-ranger .part.torso { top: 10px; left: 6px; width: 12px; height: 13px; border-radius: 1px; }
        .character.gender-female.outfit-ranger .part.legs { top: 23px; left: 7px; width: 10px; height: 8px; border-bottom-width: 3px;}
        .character.gender-female.outfit-ranger .part.detail1 { top: 19px; left: 6px; width: 12px; height: 4px; z-index: 7;}
        .character.gender-female.outfit-ranger .part.arm-left { top: 11px; left: 3px; width: 3px; height: 11px; }
        .character.gender-female.outfit-ranger .part.arm-right { top: 11px; left: 18px; width: 3px; height: 11px; }
        .character.gender-female.outfit-kimono .part.head, .character.gender-female.outfit-kimono .part.torso, .character.gender-female.outfit-kimono .part.legs, .character.gender-female.outfit-kimono .part.detail1, .character.gender-female.outfit-kimono .part.detail2, .character.gender-female.outfit-kimono .part.detail3, .character.gender-female.outfit-kimono .part.arm-left, .character.gender-female.outfit-kimono .part.arm-right { display: block; }
        .character.gender-female.outfit-kimono .part.torso { top: 10px; left: 4px; width: 16px; height: 17px; border-radius: 1px; border-right-width: 2px; border-left-width: 2px; border-style: solid;}
        .character.gender-female.outfit-kimono .part.legs { top: 27px; left: 7px; width: 10px; height: 7px; border-bottom-width: 2px; border-top: none;}
        .character.gender-female.outfit-kimono .part.detail1 { top: 17px; left: 4px; width: 16px; height: 7px; border-radius: 1px;}
        .character.gender-female.outfit-kimono .part.arm-left { top: 11px; left: 0px; width: 6px; height: 18px; border-radius: 0 0 6px 2px; }
        .character.gender-female.outfit-kimono .part.arm-right { top: 11px; left: 18px; width: 6px; height: 18px; border-radius: 0 0 2px 6px; }
        @keyframes playerBobbing { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-2px); } }
        @keyframes playerWalkArmLeft { 0%, 100% { transform: rotate(-10deg) translateX(0px); } 50% { transform: rotate(8deg) translateX(0px); } }
        @keyframes playerWalkArmRight { 0%, 100% { transform: rotate(8deg) translateX(0px); } 50% { transform: rotate(-10deg) translateX(0px); } }
        @keyframes playerWalkLegs { 0%, 100% { transform: translateX(0px); } 50% { transform: translateX(-0.5px); } }
        #player.is-walking { animation: playerBobbing 0.5s infinite ease-in-out; }
        #player.is-walking .part.arm-left { animation: playerWalkArmLeft 0.5s infinite ease-in-out; }
        #player.is-walking .part.arm-right { animation: playerWalkArmRight 0.5s infinite ease-in-out; }
        #player.is-walking .part.legs { animation: playerWalkLegs 0.5s infinite ease-in-out; }
        .character .character-name-plate { position: absolute; bottom: calc(100% + 10px); left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7); color: #fff; padding: 1px 5px; border-radius: 3px; font-size: 10px; font-weight: bold; white-space: nowrap; text-shadow: 1px 1px 1px #000; z-index: 11; border: 1px solid rgba(255, 255, 255, 0.2); pointer-events: none; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
        .character .speech { display: none; /* Positioned by JS if needed */ }

        /* --- Environment Zones --- */
        .environment-zone { position: absolute; border: 2px dashed rgba(58, 49, 41, 0.5); background-color: rgba(58, 49, 41, 0.08); border-radius: 8px; display: flex; justify-content: center; align-items: flex-start; padding-top: 8px; pointer-events: none; box-sizing: border-box; z-index: 1; color: var(--ink-light); font-size: 14px; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.2); }
        .environment-name-plate { background-color: rgba(58, 49, 41, 0.6); color: var(--parchment); padding: 3px 8px; border-radius: 4px; white-space: nowrap; border: 1px solid rgba(245, 231, 208, 0.3); }

        /* --- Chat Area & Messages --- */
        #chat-area { flex-basis: 300px; min-height: var(--chat-min-height); display: flex; flex-direction: column; background: var(--parchment-dark); flex-shrink: 0; position: relative; border-top: 2px solid var(--ink-light); transition: flex-basis 0.3s ease-out; }

        /* --- Chat Tabs Area (MODIFIED) --- */
        #chat-tabs-area {
            display: flex;
            align-items: center; /* Align items vertically */
            padding: 5px 10px 5px 15px; /* Adjust padding */
            gap: 8px;
            background-color: var(--parchment-dark);
            border-bottom: 1px solid var(--ink-light);
            flex-shrink: 0;
            transition: max-height 0.3s ease, padding 0.3s ease, opacity 0.3s ease, border 0.3s ease;
            max-height: 100px; /* Allow more height for wrapping */
            overflow: hidden;
            opacity: 1;
            flex-wrap: wrap; /* Allow tabs to wrap */
        }
        #chat-tabs-area.hidden { max-height: 0; padding-top: 0; padding-bottom: 0; opacity: 0; border-bottom: none; pointer-events: none; }

        /* Static and Dynamic Tab Buttons */
        #chat-tabs-area button {
            background-color: var(--parchment); border: 1px solid var(--ink-light); border-radius: 6px; padding: 5px 12px;
            color: var(--ink); font-size: 0.95rem; cursor: pointer; transition: var(--fade);
            font-family: Georgia, serif; flex-shrink: 0; position: relative; /* Needed for close button */
            line-height: 1.3; /* Ensure text fits */
            white-space: nowrap; /* Prevent button text wrapping */
            max-width: 150px; /* Limit width */
            overflow: hidden; /* Hide overflow */
            text-overflow: ellipsis; /* Add ellipsis */
        }
        #chat-tabs-area button:hover { background-color: var(--parchment-dark); box-shadow: 0 0 5px rgba(0,0,0,0.1); }
        #chat-tabs-area button.active-tab { background-color: var(--gold); color: var(--ink); border-color: var(--gold); box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); }

        /* Dynamic NPC Tab Specifics */
        .npc-tab-button {
            padding-right: calc(var(--tab-close-size) + 10px); /* Make space for close button */
        }
        .npc-tab-close {
            position: absolute; top: 50%; right: 5px; transform: translateY(-50%);
            width: var(--tab-close-size); height: var(--tab-close-size); line-height: var(--tab-close-size);
            border-radius: 50%; background-color: rgba(0,0,0,0.1); color: var(--ink-light);
            border: none; font-size: 10px; font-weight: bold; text-align: center;
            cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease;
            padding: 0;
        }
        .npc-tab-button:hover .npc-tab-close { background-color: rgba(0,0,0,0.2); }
        .npc-tab-close:hover { background-color: var(--danger-color); color: white; }
        /* Active NPC tab doesn't need different close button style unless desired */
        .active-tab .npc-tab-close { color: var(--ink); }
        .active-tab .npc-tab-close:hover { background-color: var(--danger-hover); color: white; }


        /* Apply Tibia font to specific static tabs */
        #chat-tabs-area button#area-tab,
        #chat-tabs-area button#city-tab,
        #chat-tabs-area button#world-tab,
        /* #chat-tabs-area button#main-chat-tab, /* Optional: Style main chat tab differently if needed */
        #chat-tabs-area button#agent-tab {
            font-family: var(--tibia-like-font);
            text-transform: uppercase;
            font-size: 0.85rem;
        }

        /* Clear All Button */
        #clear-all-chat-btn {
            margin-left: auto; /* Push to the right */
            padding: 4px 8px;
            font-size: 0.8rem;
            background-color: var(--ink-light);
            color: var(--parchment);
            border: 1px solid var(--ink);
            border-radius: 4px;
            cursor: pointer;
            transition: var(--fade);
            font-family: 'Cinzel Decorative', cursive;
            flex-shrink: 0; /* Prevent shrinking */
        }
        #clear-all-chat-btn:hover { background-color: var(--danger-color); color: white; border-color: var(--danger-hover); }
        /* --- End Chat Tabs Area --- */

        .chat-messages { flex: 1; padding: 25px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: var(--ink-light) var(--parchment-dark); display: flex; flex-direction: column; gap: 10px; background-color: var(--parchment); }
        .chat-messages::-webkit-scrollbar { width: 8px; } .chat-messages::-webkit-scrollbar-track { background: var(--parchment-dark); } .chat-messages::-webkit-scrollbar-thumb { background-color: var(--ink-light); border-radius: 4px; }
        .message { display: flex; gap: 15px; max-width: 85%; animation: appear 0.5s ease-out; margin-bottom: 10px; /* Faster appear */ }
        .message-user { align-self: flex-end; flex-direction: row-reverse; } .message-spirit { align-self: flex-start; }
        .message-system, .message-debug, .message-error { align-self: flex-start; opacity: 0.8; font-size: 0.9em;} /* Added error */
        .message-system .message-content, .message-debug .message-content, .message-error .message-content { background-color: var(--parchment-dark); border: 1px dashed var(--ink-light); }
        .message-error .message-content { border-color: var(--danger-color); color: var(--danger-color); } /* Style error messages */
        /* Style for spatial chat messages (plain text) */
        .spatial-message { font-family: monospace; font-size: 1rem; color: var(--ink); white-space: pre-wrap; line-height: 1.4; padding: 2px 0; border-bottom: 1px dotted var(--ink-light); }
        .spatial-message:last-child { border-bottom: none; }
        .avatar { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; flex-shrink: 0; border: 2px solid var(--parchment-dark); box-shadow: var(--shadow); display: flex; align-items: center; justify-content: center; font-family: 'Cinzel Decorative', cursive; font-size: 1.5rem; transition: var(--fade); color: white; cursor: pointer; }
        .user-avatar { background-color: var(--sapphire); } .spirit-avatar { background-color: var(--amethyst); }
        .system-avatar, .debug-avatar, .error-avatar { background-color: var(--ink-light); font-size: 1.2rem; } /* Added error avatar */
        .error-avatar { background-color: var(--danger-color); } /* Error avatar color */
        .spirit-avatar:hover, .user-avatar:hover, .system-avatar:hover, .debug-avatar:hover, .error-avatar:hover { transform: scale(1.1); box-shadow: var(--glow); }
        .message-content { padding: 18px 22px; border-radius: 8px; line-height: 1.6; position: relative; word-break: break-word; box-shadow: var(--shadow); max-width: 100%; font-size: 1.1rem; }
        .message-content p { margin-bottom: 1em; } .message-content p:last-child { margin-bottom: 0; }
        .message-content strong { font-weight: bold; color: var(--ink); } .message-content em { font-style: italic; }
        .message-content ul, .message-content ol { margin-left: 1.5em; margin-bottom: 1em; } .message-content li { margin-bottom: 0.5em; }
        .message-content code { font-family: monospace; background-color: rgba(0, 0, 0, 0.1); padding: 0.2em 0.4em; border-radius: 3px; }
        .message-content pre { position: relative; background-color: rgba(0, 0, 0, 0.1); padding: 1em; border-radius: 5px; overflow-x: auto; margin-bottom: 1em; font-family: monospace; font-size: 0.95em; }
        .copy-code-btn { position: absolute; top: 5px; right: 5px; background-color: var(--gold); color: var(--ink); border: none; border-radius: 3px; padding: 3px 8px; font-size: 0.8rem; cursor: pointer; opacity: 0; transition: opacity 0.3s ease; }
        .message-content pre:hover .copy-code-btn { opacity: 1; } .copy-code-btn:hover { background-color: var(--crimson); color: white; }
        .copy-code-btn.copied { background-color: var(--sapphire); color: white; }
        .message-content blockquote { border-left: 3px solid var(--gold); padding-left: 1em; margin-left: 0; margin-bottom: 1em; color: var(--ink-light); }
        .user-message { background-color: var(--sapphire); color: white; border-top-right-radius: 0; }
        .spirit-message { background-color: white; color: var(--ink); border: 1px solid var(--ink-light); border-top-left-radius: 0; }
        .system-message, .debug-message, .error-message { background-color: var(--parchment-dark); color: var(--ink-light); border: 1px dashed var(--ink-light); border-top-left-radius: 0; font-style: italic; } /* Added error */
        .error-message { color: var(--danger-color); border-color: var(--danger-color); }
        .system-message .message-name, .debug-message .message-name, .error-message .message-name { font-weight: bold; margin-right: 5px; display: inline-block; } /* Added error */
        .typing-indicator { display: inline-flex; align-items: center; gap: 8px; padding: 15px 20px; background-color: var(--parchment-dark); border-radius: 8px; box-shadow: var(--shadow); align-self: flex-start; color: var(--ink-light); font-style: italic; border: 1px dashed var(--ink-light); position: relative; overflow: hidden; font-size: 1rem; margin-left: 65px; }
        .typing-indicator::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(201, 162, 39, 0.2), transparent); animation: shimmer 2s infinite; }
        .rune { font-family: 'Cinzel Decorative', cursive; font-size: 1.2rem; animation: float 2s infinite ease-in-out; margin-left: 5px; }

        /* --- Input Area --- */
        .input-container { padding: 18px; background-color: var(--parchment-dark); border-top: none; display: flex; gap: 12px; align-items: flex-end; flex-shrink: 0; }
        #userInput { flex: 1; padding: 18px; background-color: var(--parchment); border: 2px solid var(--ink-light); border-radius: 5px; font-family: inherit; font-size: 1.1rem; resize: none; outline: none; color: var(--ink); min-height: 60px; max-height: 200px; line-height: 1.5; overflow-y: auto; }
        #userInput:focus { border-color: var(--gold); box-shadow: 0 0 0 3px rgba(201, 162, 39, 0.3); }
        #userInput::placeholder { color: var(--ink-light); font-style: italic; }
        #sendButton { background-color: var(--gold); color: var(--ink); border: none; border-radius: 5px; padding: 0 24px; height: 60px; font-family: 'Cinzel Decorative', cursive; font-weight: bold; cursor: pointer; transition: var(--fade); box-shadow: var(--shadow); display: flex; align-items: center; justify-content: center; gap: 10px; font-size: 1.1rem; flex-shrink: 0; align-self: flex-end; }
        #sendButton:hover:not(:disabled) { background-color: var(--crimson); color: white; }
        #sendButton:disabled { opacity: 0.7; cursor: not-allowed; background-color: var(--ink-light); color: var(--parchment); }

        /* --- Settings Modal (Paginated) --- */
        /* ... (Modal styles remain largely unchanged) ... */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; pointer-events: none; transition: var(--fade); }
        .modal-overlay.active { opacity: 1; pointer-events: all; }
        .modal-content {
            background-color: var(--parchment); color: var(--ink); border-radius: 8px;
            width: 90%; max-width: 800px; padding: 0;
            box-shadow: var(--shadow); transform: translateY(20px); transition: var(--fade);
            max-height: 85vh; display: flex; flex-direction: column;
            border: 1px solid var(--ink-light); overflow: hidden;
        }
        .modal-overlay.active .modal-content { transform: translateY(0); }
        .modal-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 0; border-bottom: 1px solid var(--ink-light);
            padding: 20px 28px 15px 28px; flex-shrink: 0;
        }
        .modal-title { font-family: 'Cinzel Decorative', cursive; font-size: 1.5rem; color: var(--ink); }
        .modal-close-btn { background: none; border: none; cursor: pointer; color: var(--ink-light); font-size: 1.8rem; line-height: 1; transition: var(--fade); }
        .modal-close-btn:hover { color: var(--crimson); }
        .modal-body {
            flex-grow: 1; overflow: hidden; display: flex; flex-direction: column;
            min-height: 300px; padding: 0 28px;
        }
        .settings-page { display: none; flex-grow: 1; overflow-y: auto; padding: 20px 5px 20px 0; scrollbar-width: thin; scrollbar-color: var(--modal-scrollbar-thumb) var(--modal-scrollbar-track); }
        .settings-page.active { display: block; }
        .settings-page::-webkit-scrollbar { width: 8px; } .settings-page::-webkit-scrollbar-track { background: var(--modal-scrollbar-track); border-radius: 4px; } .settings-page::-webkit-scrollbar-thumb { background-color: var(--modal-scrollbar-thumb); border-radius: 4px; border: 1px solid var(--modal-scrollbar-track); } .settings-page::-webkit-scrollbar-thumb:hover { background-color: var(--modal-scrollbar-thumb-hover); }
        .settings-section { margin-bottom: 25px; padding-bottom: 20px; border-bottom: 1px dashed var(--ink-light); } .settings-section:last-child { border-bottom: none; margin-bottom: 0; }
        .settings-section-title { font-size: 1.3rem; font-weight: bold; color: var(--ink); margin-bottom: 15px; border-bottom: 1px solid var(--gold); padding-bottom: 8px; font-family: 'Cinzel Decorative', cursive; }
        .settings-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
        .settings-item { background-color: var(--parchment-dark); padding: 15px; border-radius: 6px; border: 1px solid var(--ink-light); position: relative; }
        .settings-label { display: block; font-weight: bold; margin-bottom: 5px; font-size: 0.9rem; color: var(--ink); }
        .settings-input, .settings-textarea, .settings-select {
            width: 100%; padding: 10px 12px; border: 1px solid var(--ink-light); border-radius: 4px;
            font-family: inherit; font-size: 1rem; background-color: var(--parchment); color: var(--ink);
            margin-bottom: 10px; box-sizing: border-box; line-height: 1.5;
        }
        .settings-textarea { min-height: 80px; resize: vertical; }
        .settings-input:focus, .settings-textarea:focus, .settings-select:focus {
             border-color: var(--gold); outline: none; box-shadow: 0 0 0 3px rgba(201, 162, 39, 0.3);
        }
        .settings-env-item { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; position: relative; padding-right: 30px; }
        .settings-env-label { flex-shrink: 0; width: 80px; text-align: right; font-weight: normal; color: var(--ink); }
        .settings-env-input { flex-grow: 1; }
        .settings-delete-btn { position: absolute; top: 5px; right: 5px; width: 20px; height: 20px; line-height: 18px; text-align: center; background-color: var(--danger-color); color: white; border: none; border-radius: 50%; cursor: pointer; font-size: 12px; font-weight: bold; transition: background-color 0.2s ease; padding: 0; }
        .settings-delete-btn:hover { background-color: var(--danger-hover); }
        .settings-env-item .settings-delete-btn { top: 50%; right: 5px; transform: translateY(-50%); }
        .settings-city-controls { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .settings-city-controls label { font-weight: bold; color: var(--ink); flex-shrink: 0; margin-right: 5px; }
        .settings-city-selector { padding: 8px 10px; border-radius: 4px; border: 1px solid var(--ink-light); background-color: var(--parchment); color: var(--ink); font-size: 1rem; flex-grow: 1; min-width: 150px; font-family: inherit; }
        .settings-city-edit-btn { padding: 6px 10px; font-size: 1rem; height: 38px; line-height: 1; border-radius: 6px; background-color: var(--ink-light); color: var(--parchment); border: none; cursor: pointer; flex-shrink: 0; transition: var(--fade); font-family: 'Cinzel Decorative', cursive; display: inline-flex; align-items: center; justify-content: center;}
        .settings-city-edit-btn:hover { background-color: var(--ink); }
        .settings-city-delete-btn { background-color: var(--danger-color); color: white; } .settings-city-delete-btn:hover { background-color: var(--danger-hover); }
        .settings-city-add-btn { background-color: var(--gold); color: var(--ink); } .settings-city-add-btn:hover { background-color: #a1801f; }
        /* API Key Multi-Key Styles */
        .settings-api-config { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;}
        .api-key-management { display: flex; flex-direction: column; gap: 15px; }
        .api-key-list-container { max-height: 150px; overflow-y: auto; border: 1px solid var(--ink-light); border-radius: 4px; background-color: var(--parchment-dark); padding: 8px; scrollbar-width: thin; scrollbar-color: var(--modal-scrollbar-thumb) var(--modal-scrollbar-track); }
        .api-key-list-container::-webkit-scrollbar { width: 6px; } .api-key-list-container::-webkit-scrollbar-track { background: var(--modal-scrollbar-track); border-radius: 3px; } .api-key-list-container::-webkit-scrollbar-thumb { background-color: var(--modal-scrollbar-thumb); border-radius: 3px; } .api-key-list-container::-webkit-scrollbar-thumb:hover { background-color: var(--modal-scrollbar-thumb-hover); }
        .api-key-item { display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px dashed var(--ink-light); font-size: 0.9rem; } .api-key-item:last-child { border-bottom: none; }
        .api-key-item span { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 70%; font-family: monospace; }
        .api-key-item-controls { display: flex; gap: 5px; flex-shrink: 0; }
        .api-key-item-controls button { padding: 3px 8px; font-size: 0.8rem; border-radius: 3px; cursor: pointer; border: none; transition: var(--fade); font-family: 'Cinzel Decorative', cursive; }
        .api-key-item-delete-btn { background-color: var(--danger-color); color: white; } .api-key-item-delete-btn:hover { background-color: var(--danger-hover); }
        .api-key-add-controls { display: flex; gap: 10px; }
        #newApiKeyInput { flex-grow: 1; padding: 10px 12px; border: 1px solid var(--ink-light); border-radius: 4px; font-family: inherit; font-size: 1rem; background-color: var(--parchment); color: var(--ink); box-sizing: border-box; }
        #addApiKeyBtn { padding: 8px 15px; border-radius: 5px; font-weight: bold; cursor: pointer; transition: var(--fade); border: none; font-size: 1rem; background-color: var(--gold); color: var(--ink); font-family: 'Cinzel Decorative', cursive; }
        #addApiKeyBtn:hover:not(:disabled) { background-color: #a1801f; }
        #addApiKeyBtn:disabled { background-color: var(--ink-light); opacity: 0.7; cursor: not-allowed; }
        #newApiKeyInput:disabled { background-color: var(--parchment-dark); cursor: not-allowed; }
        .active-key-display { margin-top: 10px; font-size: 0.9rem; color: var(--ink-light); }
        .active-key-display strong { font-family: monospace; color: var(--amethyst); }
        .key-list-message { font-style: italic; color: var(--ink-light); text-align: center; padding: 10px 0; font-size: 0.9rem; }
        /* End API Key Multi-Key Styles */
        .map-size-inputs { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; }
        .map-size-inputs input[type="number"] { width: 80px; padding: 8px 10px; font-size: 1rem; border: 1px solid var(--ink-light); background-color: var(--parchment); color: var(--ink); border-radius: 4px;}
        .map-size-inputs label { font-size: 1rem; color: var(--ink); margin-right: 5px; }
        .settings-checkbox-item { display: flex; align-items: center; gap: 8px; background-color: var(--parchment-dark); padding: 10px 15px; border-radius: 6px; border: 1px solid var(--ink-light); }
        .settings-checkbox-item label { font-size: 1rem; color: var(--ink); cursor: pointer; user-select: none; }
        .settings-checkbox-item input[type="checkbox"] { cursor: pointer; accent-color: var(--gold); }
        .settings-pagination {
            display: flex; justify-content: space-between; align-items: center;
            margin-top: 0; padding: 15px 28px;
            border-top: 1px solid var(--ink-light); flex-shrink: 0;
        }
        .pagination-btn { padding: 8px 16px; border-radius: 5px; font-family: 'Cinzel Decorative', cursive; font-weight: bold; cursor: pointer; transition: var(--fade); border: none; font-size: 1rem; background-color: var(--ink-light); color: var(--parchment); }
        .pagination-btn:hover:not(:disabled) { background-color: var(--ink); }
        .pagination-btn:disabled { background-color: var(--parchment-dark); color: var(--ink-light); cursor: not-allowed; }
        .page-indicator { font-size: 1rem; color: var(--ink-light); font-weight: bold; }
        .modal-footer {
            margin-top: 0; padding: 15px 28px 20px 28px;
            border-top: 1px solid var(--ink-light); display: flex; justify-content: flex-end;
            gap: 10px; flex-shrink: 0; background-color: var(--parchment-dark);
        }
        .modal-btn { padding: 12px 24px; border-radius: 5px; font-family: 'Cinzel Decorative', cursive; font-weight: bold; cursor: pointer; transition: var(--fade); border: none; font-size: 1.1rem; }
        .modal-btn-primary { background-color: var(--gold); color: var(--ink); } .modal-btn-primary:hover { background-color: var(--crimson); color: white; }
        .modal-btn-secondary { background-color: var(--ink-light); color: var(--parchment); } .modal-btn-secondary:hover { background-color: var(--ink); color: white; }

        /* --- Appearance Editor Modal --- */
        /* ... (Appearance Editor styles remain unchanged) ... */
         #appearance-editor-overlay .modal-content { max-width: 900px; }
        #appearance-editor-overlay .modal-body { overflow-y: auto; padding: 20px 28px 20px 28px; flex-grow: 1; scrollbar-width: thin; scrollbar-color: var(--modal-scrollbar-thumb) var(--modal-scrollbar-track); touch-action: pan-y; -webkit-overflow-scrolling: touch; min-height: 0; }
        #appearance-editor-overlay .modal-body::-webkit-scrollbar { width: 8px; } #appearance-editor-overlay .modal-body::-webkit-scrollbar-track { background: var(--modal-scrollbar-track); border-radius: 4px; } #appearance-editor-overlay .modal-body::-webkit-scrollbar-thumb { background-color: var(--modal-scrollbar-thumb); border-radius: 4px; border: 1px solid var(--modal-scrollbar-track); } #appearance-editor-overlay .modal-body::-webkit-scrollbar-thumb:hover { background-color: var(--modal-scrollbar-thumb-hover); }
        .appearance-editor-details { padding: 15px; background-color: var(--parchment-dark); border: 1px solid var(--ink-light); border-radius: 6px; margin-bottom: 15px; display: grid; grid-template-columns: auto 1fr auto; gap: 10px 15px; align-items: center; }
        .appearance-editor-details label { font-weight: bold; font-size: 1rem; color: var(--ink); text-align: right; }
        .appearance-editor-details input, .appearance-editor-details textarea { grid-column: 2; width: 100%; padding: 10px 12px; border: 1px solid var(--ink-light); border-radius: 4px; font-family: inherit; font-size: 1rem; background-color: var(--parchment); color: var(--ink); box-sizing: border-box; }
        .appearance-editor-details textarea { min-height: 60px; resize: vertical; line-height: 1.5; }
        .appearance-editor-details input:focus, .appearance-editor-details textarea:focus { border-color: var(--gold); outline: none; box-shadow: 0 0 0 3px rgba(201, 162, 39, 0.3); }
        .appearance-pfp-section { grid-column: 3; display: flex; flex-direction: column; align-items: center; gap: 8px; padding-left: 15px; }
        .appearance-pfp-preview { width: 60px; height: 60px; border-radius: 50%; object-fit: cover; border: 2px solid var(--ink-light); cursor: pointer; transition: border-color 0.3s ease; }
        .appearance-pfp-preview:hover { border-color: var(--gold); }
        .appearance-pfp-change-btn { font-size: 0.9rem; color: var(--ink-light); cursor: pointer; text-decoration: underline; background: none; border: none; padding: 0; }
        .appearance-pfp-change-btn:hover { color: var(--gold); }
        .appearance-iframe-container { border: 1px solid var(--ink-light); padding: 0; background-color: var(--parchment-dark); border-radius: 6px; overflow: hidden; flex-shrink: 0; }
        #characterCreatorFrame { width: 100%; height: 500px; border: none; display: block; background-color: var(--ink-light); }
        .pfp-upload { display: none; }

        /* --- Context Menu --- */
        .context-menu { display: none; position: absolute; background-color: var(--parchment-dark); border: 1px solid var(--ink-light); border-radius: 4px; padding: 5px 0; z-index: 1050; box-shadow: var(--shadow); min-width: 180px; font-size: 1rem; color: var(--ink); font-family: Georgia, serif; }
        .context-menu-item { padding: 8px 18px; cursor: pointer; white-space: nowrap; }
        .context-menu-item:hover { background-color: var(--ink-light); color: var(--parchment); }
        .context-menu-divider { border: none; border-top: 1px solid var(--ink-light); margin: 4px 0; }

        /* Animations */
        @keyframes appear { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } } /* Faster appear */
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }
        @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }

        /* Responsive */
        @media (max-width: 768px) {
            body { font-size: 1rem; } .chat-messages { padding: 18px; }
            .message-content { padding: 15px 18px; font-size: 1rem; } .input-container { padding: 15px; }
            #userInput { padding: 15px; min-height: 50px; font-size: 1rem; }
            #sendButton { height: 55px; padding: 0 18px; font-size: 1rem; }
            .avatar { width: 40px; height: 40px; font-size: 1.1rem; }
            .typing-indicator { margin-left: 55px; font-size: 0.9rem;} .rune { font-size: 1rem;}
            /* Modal adjustments */
            .modal-content { padding: 0; width: 95%; }
            .modal-header { padding: 15px 20px 10px 20px; }
            .modal-body { padding: 0 20px; }
            .settings-page { padding: 15px 5px 15px 0; }
            .settings-pagination { padding: 10px 20px; flex-direction: column; gap: 10px; } .page-indicator { order: -1; }
            .modal-footer { padding: 10px 20px 15px 20px; }
            /* Appearance Editor */
            #appearance-editor-overlay .modal-body { padding: 15px 20px; }
            .appearance-editor-details { grid-template-columns: auto 1fr; }
            .appearance-pfp-section { grid-column: 1 / -1; grid-row: 3; justify-self: center; padding-left: 0; margin-top: 10px; }
            /* Adjust tab area for smaller screens */
            #chat-tabs-area { padding: 5px 10px; gap: 5px; }
            #chat-tabs-area button { padding: 5px 10px; font-size: 0.9rem; max-width: 120px; }
             #chat-tabs-area button#area-tab,
             #chat-tabs-area button#city-tab,
             #chat-tabs-area button#world-tab,
             #chat-tabs-area button#agent-tab { font-size: 0.8rem; }
             /* NPC Tabs on small screens */
             .npc-tab-button { padding-right: calc(var(--tab-close-size) + 6px); }
             .npc-tab-close { right: 3px; width: calc(var(--tab-close-size) - 2px); height: calc(var(--tab-close-size) - 2px); line-height: calc(var(--tab-close-size) - 2px); font-size: 8px;}
             #clear-all-chat-btn { padding: 3px 6px; font-size: 0.7rem; }
             /* API Config Responsive */
             .settings-api-config { grid-template-columns: 1fr; }
             .api-key-list-container { max-height: 120px; }
             .api-key-item span { max-width: 60%; }
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <div id="game-world">
            <div id="map-content">
                 <div class="character" id="player" data-name="Player">
                    <div class="part detail5"></div> <div class="part detail4"></div>
                    <div class="part detail3"></div> <div class="part legs"></div>
                    <div class="part arm-left"></div> <div class="part arm-right"></div>
                    <div class="part torso"></div> <div class="part detail1"></div>
                    <div class="part detail2"></div> <div class="part head"></div>
                    <span class="character-name-plate">Player</span>
                    <span class="speech"></span>
                </div>
                 <!-- NPCs added by JS -->
            </div>
        </div>
        <div id="chat-area">
             <!-- Chat Tabs Area (MODIFIED STRUCTURE) -->
             <div id="chat-tabs-area">
                 <!-- Static Tabs -->
                 <button id="main-chat-tab" data-mode="main-chat">CHAT</button> <!-- RENAMED, new data-mode -->
                 <button id="agent-tab" data-mode="agent">AGENT</button>
                 <button id="area-tab" data-mode="spatial" data-scope="Area">AREA</button>
                 <button id="city-tab" data-mode="spatial" data-scope="City">CITY</button>
                 <button id="world-tab" data-mode="spatial" data-scope="World">WORLD</button>
                 <!-- Container for Dynamic NPC Tabs -->
                 <div id="dynamic-npc-tabs" style="display: contents;"></div> <!-- Use contents to integrate with flexbox -->
                 <!-- Clear All Button -->
                 <button id="clear-all-chat-btn" title="Clear All Chat History & Context">X ALL</button>
             </div>
             <div class="chat-messages" id="chatMessages"></div>
             <div class="input-container">
                <textarea class="message-input" id="userInput" placeholder="Consult the spirit..." rows="1"></textarea>
                 <button class="send-button" id="sendButton" title="Send Message"><span>Send</span><span style="font-size: 1.2em;">→</span></button>
            </div>
        </div>
    </div>

    <!-- Settings Modal (Paginated - Unchanged Structure) -->
    <div class="modal-overlay" id="settings-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Tome Configuration</h3>
                <button class="modal-close-btn" id="modal-close-btn">×</button>
             </div>
            <div class="modal-body" id="settings-body-container">
                <!-- Pages populated by JS -->
            </div>
             <div class="settings-pagination" id="settings-pagination-controls">
                 <button class="pagination-btn" id="settings-prev-btn">« Previous</button>
                 <span class="page-indicator" id="settings-page-indicator">Page 1 / 4</span>
                 <button class="pagination-btn" id="settings-next-btn">Next »</button>
             </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" id="modal-cancel-btn">Cancel</button>
                <button class="modal-btn modal-btn-primary" id="modal-save-btn">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Appearance Editor Modal (Unchanged Structure) -->
     <div class="modal-overlay" id="appearance-editor-overlay">
         <div class="modal-content">
             <div class="modal-header">
                 <h3 class="modal-title" id="appearance-editor-title">Set Appearance & Details</h3>
                 <button class="modal-close-btn" id="appearance-editor-close-btn">×</button>
             </div>
             <div class="modal-body">
                 <div class="appearance-editor-details">
                     <label for="appearance-editor-name">Name:</label>
                     <input type="text" id="appearance-editor-name" class="settings-input">
                     <label for="appearance-editor-persona">Persona:</label>
                     <textarea id="appearance-editor-persona" class="settings-textarea"></textarea>
                     <label>Sigil:</label>
                     <div class="appearance-pfp-section">
                         <img src="" alt="Sigil Preview" class="appearance-pfp-preview" id="appearance-pfp-preview" title="Click to change sigil">
                         <button class="appearance-pfp-change-btn" id="appearance-pfp-change-btn">Change Sigil</button>
                     </div>
                 </div>
                 <div class="appearance-iframe-container">
                     <iframe id="characterCreatorFrame" src="character_creator.html"></iframe>
                 </div>
             </div>
             <div class="modal-footer">
                 <button class="modal-btn modal-btn-secondary" id="appearance-editor-cancel-btn">Cancel</button>
                 <button class="modal-btn modal-btn-primary" id="appearance-editor-save-btn">Save Appearance & Details</button>
             </div>
         </div>
     </div>

    <!-- Context Menus (MODIFIED NPC MENU ITEM) -->
    <div id="npc-context-menu" class="context-menu" style="display: none;">
        <div class="context-menu-item" data-action="talk">Talk (Open Tab)</div> <!-- RENAMED Action -->
        <div class="context-menu-item" data-action="command">Command (Agent Mode)</div>
        <div class="context-menu-item" data-action="toggleFollow">Toggle Follow/Unfollow</div>
        <div class="context-menu-item" data-action="appearance">Set Appearance, Details & Sigil</div>
        <hr class="context-menu-divider">
        <div class="context-menu-item" data-action="cancel">Cancel</div>
    </div>
    <div id="player-context-menu" class="context-menu" style="display: none;">
        <!-- Unchanged -->
        <div class="context-menu-item" data-action="appearance">Set Appearance, Details & Sigil</div> <hr class="context-menu-divider">
        <div class="context-menu-item" data-action="add_area">Add Area Here</div> <div class="context-menu-item" data-action="add_agent">Add Agent Here</div> <hr class="context-menu-divider">
        <div class="context-menu-item" data-action="remove_closest_agent">Remove Closest Agent</div> <div class="context-menu-item" data-action="remove_closest_area">Remove Closest Area</div> <hr class="context-menu-divider">
        <div class="context-menu-item" data-action="cancel">Cancel</div>
    </div>
    <div id="pfp-context-menu" class="context-menu" style="display: none;">
        <!-- Unchanged -->
        <div class="context-menu-item" data-action="toggle-tabs">Show/Hide Chat Tabs</div>
        <div class="context-menu-item" data-action="toggle-fullscreen">Toggle Fullscreen Chat</div>
        <hr class="context-menu-divider">
        <div class="context-menu-item" data-action="cancel">Cancel</div>
    </div>

    <input type="file" class="pfp-upload" id="pfp-upload" accept="image/*">

    <!-- Load API Providers Script (Make sure this file exists) -->
    <script src="api_providers.js"></script>

    <!-- Embed Modified Spatial Chat Logic (ADDED clearAllMessages) -->
    <script>
        // spatial_chat.js (Modified Version - Added clearAllMessages)
        const SpatialChat = (function() {

            // --- Private State ---
            let _internalState = {
                player: { x: 0, y: 0, currentCity: null, currentArea: null, name: 'Player' },
                npcs: [], // { id, name, x, y, personality, currentCity, currentArea }
                cities: {}, // { cityName: { areaName1: {}, areaName2: {} } }
                messages: {}, // { 'scope-key': ['<Author> msg1', ...] }
                currentDisplayScope: null, // e.g., 'Area', 'City', 'World'
                isInitialized: false,
                isActive: true,
            };

            let _config = {
                proxyProviderId: 'BIGMODEL_PROXY',
                proxyModelId: 'glm-4-flash',
                botIntervalMs: 2500,
                maxMessagesPerScope: 50,
                maxContextTurns: 4,
                scopeSpeakChance: 0.6,
                npcSpeakChanceMultiplier: 0.3,
                debugLogging: false,
            };

            let _botIntervalId = null;
            let _apiProviderFunction = null;
            let _isBotTickRunning = false;

            // --- Private Utility Functions ---
            function _log(message, level = 'log') {
                if (_config.debugLogging || level === 'error' || level === 'warn') {
                    console[level](`[SpatialChat] ${message}`);
                }
            }

            function _getScopeKey(scope, city = null, area = null) {
                city = city || _internalState.player.currentCity;
                area = area || _internalState.player.currentArea;
                switch (scope) {
                    case 'Area':
                        if (!city || !area) return null;
                        return `area-${city}-${area}`;
                    case 'City':
                        if (!city) return null;
                        return `city-${city}`;
                    case 'World':
                        return 'world';
                    default:
                        if (scope !== null) _log(`Invalid scope requested for key generation: ${scope}`, 'warn');
                        return null;
                }
            }

            function _getNpcsInScope(scope) {
                const { player, npcs } = _internalState;
                if (!player.currentCity) return [];
                const city = player.currentCity;
                const area = player.currentArea;
                let relevantNpcs = [];
                switch (scope) {
                    case 'Area':
                         if (!area) return [];
                         relevantNpcs = npcs.filter(npc => npc.currentCity === city && npc.currentArea === area );
                         break;
                    case 'City':
                         relevantNpcs = npcs.filter(npc => npc.currentCity === city);
                         break;
                    case 'World':
                         relevantNpcs = [...npcs];
                         break;
                    default: relevantNpcs = [];
                }
                return relevantNpcs;
            }

             function _addMessage(scopeKey, author, text) {
                 if (!scopeKey || !text || !author) return false;
                 if (!_internalState.messages[scopeKey]) _internalState.messages[scopeKey] = [];
                 const cleanText = String(text).trim().substring(0, 500);
                 if (!cleanText) return false;
                 const message = `<${author}> ${cleanText}`;
                 _internalState.messages[scopeKey].push(message);
                 if (_internalState.messages[scopeKey].length > _config.maxMessagesPerScope) {
                     _internalState.messages[scopeKey].shift();
                 }
                 _log(`Added to [${scopeKey}]: ${message.substring(0, 60)}...`);
                 return true;
             }

            async function _callAIProxy(prompt, personality) {
                if (!_apiProviderFunction || !_config.proxyProviderId || !_config.proxyModelId) return null;
                const messages = [
                    { role: "system", content: personality || "You are an AI in a simulated world. Respond concisely." },
                    { role: "user", content: prompt }
                ];
                try {
                    const response = await window.getApiResponse( _config.proxyProviderId, _config.proxyModelId, messages, null, { temperature: 0.8 } );
                    return (response && typeof response === 'string') ? response.trim() : null;
                } catch (error) {
                    _log(`Error calling AI proxy: ${error.message}`, 'error'); console.error(error); return null;
                }
            }

            async function _botTick() {
                if (_isBotTickRunning || !_internalState.isActive || !_internalState.isInitialized || !_internalState.player.currentCity || !_internalState.currentDisplayScope) return;
                const validSpatialScopes = ['Area', 'City', 'World'];
                if (!validSpatialScopes.includes(_internalState.currentDisplayScope)) return;
                _isBotTickRunning = true;
                try {
                    const activeScope = _internalState.currentDisplayScope;
                    const activeScopeKey = _getScopeKey(activeScope);
                    if (!activeScopeKey) { _isBotTickRunning = false; return; }
                    const potentialSpeakers = _getNpcsInScope(activeScope);
                    if (potentialSpeakers.length === 0) { _isBotTickRunning = false; return; }
                    const collectiveSpeakChance = Math.min(1, _config.scopeSpeakChance * potentialSpeakers.length * _config.npcSpeakChanceMultiplier);
                    if (Math.random() > collectiveSpeakChance) { _isBotTickRunning = false; return; }
                    const speaker = potentialSpeakers[Math.floor(Math.random() * potentialSpeakers.length)];
                    if (!speaker || !speaker.name || !speaker.personality) { _isBotTickRunning = false; return; }
                    const history = _internalState.messages[activeScopeKey] || [];
                    const context = history.slice(-_config.maxContextTurns).join('\n') || `The #${activeScope} chat is quiet.`;
                    const locationDesc = `${speaker.currentArea || 'Somewhere'}, ${speaker.currentCity || 'Unknown City'}`;
                    const prompt = `You are ${speaker.name} in ${locationDesc}. Personality: "${speaker.personality}".\nYou are speaking in the #${activeScope} scope. Keep messages very short (1-2 brief sentences) & in character.\nReact naturally to the last few messages or make a brief observation about your surroundings or personality if it's quiet. Avoid generic greetings like "Hello".\n\nRecent Context in #${activeScope}:\n---\n${context}\n---\n\nYour short message:`;
                    const response = await _callAIProxy(prompt, speaker.personality);
                    if (response) _addMessage(activeScopeKey, speaker.name, response);
                } catch (error) {
                    _log(`Error during bot tick: ${error}`, 'error'); console.error(error);
                } finally {
                    _isBotTickRunning = false;
                }
            }

            // --- Public API ---
            const publicApi = {
                init: function(config = {}, initialState = {}) {
                    _log("Initializing Spatial Chat...");
                    _config = { ..._config, ...config };
                    if (typeof window.getApiResponse === 'function') { _apiProviderFunction = window.getApiResponse; }
                    else { _log("CRITICAL: window.getApiResponse function not found.", 'error'); _internalState.isInitialized = false; return; }
                    const initialPlayer = { ..._internalState.player, ...(initialState.player || {}) };
                    this.updateState(initialPlayer, initialState.npcs, initialState.cities, null);
                    _internalState.messages = {};
                    _internalState.isInitialized = true;
                    _internalState.isActive = false;
                    _log(`Spatial Chat Initialized. Interval: ${_config.botIntervalMs}ms.`);
                },
                updateState: function(playerState = null, npcList = null, cityData = null, displayScope = undefined) {
                    if (!_internalState.isInitialized) return;
                    let stateChanged = false, playerPosChanged = false;
                    if (playerState) {
                         if (playerState.name !== undefined && _internalState.player.name !== playerState.name) { _internalState.player.name = playerState.name; stateChanged = true; }
                         if (typeof playerState.x === 'number' && typeof playerState.y === 'number' && (_internalState.player.x !== playerState.x || _internalState.player.y !== playerState.y)) { _internalState.player.x = playerState.x; _internalState.player.y = playerState.y; stateChanged = true; playerPosChanged = true; }
                         if (playerState.currentCity !== undefined && _internalState.player.currentCity !== playerState.currentCity) { _internalState.player.currentCity = playerState.currentCity; stateChanged = true; }
                         if (playerState.currentArea !== undefined && _internalState.player.currentArea !== playerState.currentArea) { _internalState.player.currentArea = playerState.currentArea; stateChanged = true; }
                    }
                    if (npcList && Array.isArray(npcList)) {
                          const npcStateString = (npcs) => JSON.stringify(npcs.map(n => `${n.id}|${n.x?.toFixed(1)}|${n.y?.toFixed(1)}|${n.currentArea}|${n.personality?.substring(0,20)}`).sort());
                          if (npcStateString(npcList) !== npcStateString(_internalState.npcs)) {
                             _internalState.npcs = npcList.map(npc => ({ id: npc.id, name: npc.name, x: npc.x, y: npc.y, personality: npc.personality, currentCity: npc.currentCity, currentArea: npc.currentArea }));
                             stateChanged = true; _log("Spatial NPC list updated.");
                          }
                    }
                    if (cityData && typeof cityData === 'object') {
                        if (JSON.stringify(cityData) !== JSON.stringify(_internalState.cities)) { _internalState.cities = JSON.parse(JSON.stringify(cityData)); stateChanged = true; }
                    }
                    if (displayScope !== undefined && _internalState.currentDisplayScope !== displayScope) {
                         _internalState.currentDisplayScope = displayScope; _log(`Spatial Display scope updated to: ${displayScope}`); stateChanged = true;
                    }
                },
                getMessagesForScope: function(scope, cityKey = null, areaKey = null) {
                    const scopeKey = _getScopeKey(scope, cityKey, areaKey);
                    if (!scopeKey) return [`<SYSTEM> Cannot determine chat scope for '${scope}'.`];
                    if (!_internalState.messages[scopeKey]) _internalState.messages[scopeKey] = [];
                    return [...(_internalState.messages[scopeKey] || [])];
                },
                addPlayerMessageToScope: function(scope, playerName, text) {
                    const scopeKey = _getScopeKey(scope);
                    if (scopeKey) return _addMessage(scopeKey, playerName || _internalState.player.name, text);
                    _log(`Could not add player message: Invalid scope '${scope}'.`, 'warn'); return false;
                },
                start: function() {
                    if (!_internalState.isInitialized || _internalState.isActive) return;
                    _log("Starting autonomous spatial chat bot..."); _internalState.isActive = true;
                    clearInterval(_botIntervalId); _botIntervalId = setInterval(_botTick, _config.botIntervalMs);
                },
                stop: function() {
                    if (!_internalState.isActive) return;
                    _log("Stopping autonomous spatial chat bot."); _internalState.isActive = false;
                    clearInterval(_botIntervalId); _botIntervalId = null; _isBotTickRunning = false;
                },
                addSystemMessage: function(scope, cityKey, areaKey, text) {
                     const scopeKey = _getScopeKey(scope, cityKey, areaKey);
                     return scopeKey ? _addMessage(scopeKey, 'SYSTEM', text) : false;
                },
                // --- NEW METHOD ---
                clearAllMessages: function() {
                     _log("Clearing all spatial chat messages.");
                     _internalState.messages = {}; // Reset the messages object
                }
            };
            return publicApi;
        })();
    </script>

    <!-- Load Main Simulation Logic (MODIFIED) -->
    <script>
        marked.setOptions({ breaks: true, gfm: true, smartypants: true });
        function darkenHexColor(h, p) { /* ... (unchanged helper) ... */ if (!h || typeof h !== 'string') return '#000'; h = h.replace(/^#/, ''); if (h.length === 3) h = h.split('').map(c => c + c).join(''); if (h.length !== 6) return '#000'; let r = parseInt(h.substring(0, 2), 16), g = parseInt(h.substring(2, 4), 16), b = parseInt(h.substring(4, 6), 16); r = Math.max(0, Math.floor(r * (1 - p))); g = Math.max(0, Math.floor(g * (1 - p))); b = Math.max(0, Math.floor(b * (1 - p))); return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`; }
        function maskApiKey(key) { /* ... (unchanged helper) ... */ if (!key || typeof key !== 'string') return "INVALID"; return key.length > 8 ? `${key.substring(0, 4)}...${key.substring(key.length - 4)}` : key; }

        function runSimulation() {
            // --- Element Refs (MODIFIED) ---
            const gameWorld = document.getElementById('game-world'); const mapContent = document.getElementById('map-content');
            const chatArea = document.getElementById('chat-area'); const chatMessages = document.getElementById('chatMessages');
            const userInput = document.getElementById('userInput'); const sendButton = document.getElementById('sendButton');
            const playerElement = document.getElementById('player');
            const settingsOverlay = document.getElementById('settings-overlay'); const settingsBodyContainer = document.getElementById('settings-body-container');
            const settingsPaginationControls = document.getElementById('settings-pagination-controls'); const settingsPrevBtn = document.getElementById('settings-prev-btn');
            const settingsNextBtn = document.getElementById('settings-next-btn'); const settingsPageIndicator = document.getElementById('settings-page-indicator');
            const modalCloseBtn = document.getElementById('modal-close-btn'); const modalCancelBtn = document.getElementById('modal-cancel-btn');
            const modalSaveBtn = document.getElementById('modal-save-btn');
            const npcContextMenu = document.getElementById('npc-context-menu');
            const playerContextMenu = document.getElementById('player-context-menu');
            const pfpContextMenu = document.getElementById('pfp-context-menu');
            const appearanceEditorOverlay = document.getElementById('appearance-editor-overlay');
            const appearanceEditorTitle = document.getElementById('appearance-editor-title'); const appearanceEditorCloseBtn = document.getElementById('appearance-editor-close-btn');
            const appearanceEditorCancelBtn = document.getElementById('appearance-editor-cancel-btn'); const appearanceEditorSaveBtn = document.getElementById('appearance-editor-save-btn');
            const characterCreatorFrame = document.getElementById('characterCreatorFrame'); const appearanceEditorNameInput = document.getElementById('appearance-editor-name');
            const appearanceEditorPersonaInput = document.getElementById('appearance-editor-persona'); const pfpUploadInput = document.getElementById('pfp-upload');
            const appearancePfpPreview = document.getElementById('appearance-pfp-preview'); const appearancePfpChangeBtn = document.getElementById('appearance-pfp-change-btn');
            const chatTabsArea = document.getElementById('chat-tabs-area'); // Main container for tabs
            const dynamicNpcTabsContainer = document.getElementById('dynamic-npc-tabs'); // Container for NPC tabs
            const clearAllChatBtn = document.getElementById('clear-all-chat-btn'); // Clear all button

            // --- Game State & Config (MODIFIED) ---
            let MAP_WIDTH = 3000; let MAP_HEIGHT = 2000; let viewportWidth, viewportHeight;
            const npcData = []; const environmentData = []; const playerData = { appearance: null, isPlayer: true, pfp: null, name: 'Player' };
            const playerStepDistance = 16; const globalSpeechDuration = 4500;
            let currentChatDisplayMode = 'agent'; // Default mode (e.g., 'main-chat', 'agent', 'spatial', 'npc-chat')
            let currentSpatialScope = 'Area'; // Default spatial scope
            let currentAiNpcData = null; // Stores the NPC data object for the *active* Agent or NPC-Chat tab
            let activeTabId = null; // ID of the currently active tab element (e.g., 'main-chat-tab', 'npc-tab-5')
            let initialSpeakerData = null; // NPC closest at load time (used as fallback)
            let currentCityKey = null;
            let isPlayerMoving = false; let playerMoveTimeout = null; let contextMenuTargetNpcId = null;
            let contextMenuTargetIsPlayer = false; let appearanceEditorTarget = null; let temporaryAppearanceData = null;
            let temporaryPfpData = null; let isWaitingForApiResponse = false; let hideSystemMessages = false;
            let npcFollowInterval = null;
            const FOLLOW_DISTANCE = 50;
            const NPC_FOLLOW_SPEED = 4.0; // Slightly increased follow speed again
            let currentSettingsPage = 1; const TOTAL_SETTINGS_PAGES = 4;
            let chatHeightBeforeFullscreen = null;
            let chatTabsVisible = true;
            let spatialChatUpdateIntervalId = null;
            let spatialChatRenderIntervalId = null;

            // --- API Provider State (Unchanged) ---
            let selectedProvider = null; let selectedModel = null;
            let apiKeyManagement = { providerKeys: {}, activeKeyIndices: {} };

            // --- Appearance & Default Data (Unchanged) ---
            const defaultNpcAppearance = { outfit: 'citizen', gender: 'female', colors: { hair: '#e4b881', primary: '#a34444', secondary: '#fbe5d6', detail1: '#7a2a2a', legs: '#693434', feet: '#2a2a30' } };
            const defaultPlayerAppearance = { outfit: 'citizen', gender: 'male', colors: { hair: '#4a3021', primary: '#5d7a8a', secondary: '#d1c6b0', detail1: '#8b4513', legs: '#444450', feet: '#2a2a30' } };
            const DEFAULT_PLAYER_PFP = 'https://ui-avatars.com/api/?name=Player&background=1e3a8a&color=fff&size=64';
            const DEFAULT_NPC_PFP = 'https://ui-avatars.com/api/?name=Agent&background=6b21a8&color=fff&size=64';

            // --- Chat History Management (MODIFIED) ---
            let npcChatHistories = {}; // Stores { 'main': [...], 'npc-1': [...], 'npc-5': [...] }
            const MAX_HISTORY_TURNS_PER_TAB = 8; // Max turns (user + assistant) per individual NPC tab
            let recentEvents = []; // For agent mode context

            // --- Agent Mode Rules (Unchanged) ---
            const BASE_ACTION_RULES = `ACTIONS: <Walk X,Y>, <Follow>, <Unfollow>. Respond with ONLY the chosen action tag, nothing else. Pos=(X,Y).`;

            // --- Local Storage Keys (MODIFIED) ---
            const USER_CITY_PREFIX = "userCity_";
            const LS_KEYS = {
                selectedCity: 'selectedCityKey',
                providerApiKeysStorage: 'providerApiKeys_v2',
                chatAreaHeight: 'chatAreaHeight', hideSystemMessages: 'hideSystemMessages',
                playerAppearance: 'global-player-appearance', playerName: 'global-player-name',
                playerPersona: 'global-player-persona', playerPfp: 'global-player-pfp',
                playerPositionX: (cityKey) => `player-${cityKey}-x`, playerPositionY: (cityKey) => `player-${cityKey}-y`,
                npcName: (cityKey, npcId) => `npc-${cityKey}-${npcId}-name`, npcPersona: (cityKey, npcId) => `npc-${cityKey}-${npcId}-persona`,
                npcAppearance: (cityKey, npcId) => `npc-${cityKey}-${npcId}-appearance`, npcPfp: (cityKey, npcId) => `npc-${cityKey}-${npcId}-pfp`,
                npcPositionX: (cityKey, npcId) => `npc-${cityKey}-${npcId}-x`, npcPositionY: (cityKey, npcId) => `npc-${cityKey}-${npcId}-y`,
                envName: (cityKey, envId) => `env-${cityKey}-${envId}-name`,
                chatTabsVisible: 'chatTabsVisible',
                selectedProvider: 'selectedApiKeyProvider',
                selectedModel: 'selectedApiModel',
                currentChatDisplayMode: 'currentChatDisplayMode_v3', // Incremented version
                npcChatHistories: 'npcSpecificChatHistories_v1' // NEW key for NPC histories
                // Removed: conversationHistory (replaced by npcChatHistories)
            };

             // --- CORE FUNCTIONS (Many Modified or New) ---

             function updateNameplate(c){ /* ... (unchanged) ... */ if(c&&c.nameplateElement)c.nameplateElement.textContent=c.name;}

             // NEW: Load/Save NPC-specific histories
            function saveNpcChatHistories() {
                try {
                    // Prune histories before saving if needed (optional)
                    // for (const key in npcChatHistories) {
                    //    if (npcChatHistories[key].length > (MAX_HISTORY_TURNS_PER_TAB * 2 + 20)) { // Allow buffer
                    //        npcChatHistories[key] = npcChatHistories[key].slice(-(MAX_HISTORY_TURNS_PER_TAB * 2 + 10));
                    //    }
                    // }
                    localStorage.setItem(LS_KEYS.npcChatHistories, JSON.stringify(npcChatHistories));
                } catch (e) {
                    console.error("Error saving NPC chat histories:", e);
                     // Avoid flooding UI with errors during save
                    // addMessage("Error saving chat histories.", "SYSTEM", "error", null, activeTabId);
                }
            }
            function loadNpcChatHistories() {
                const saved = localStorage.getItem(LS_KEYS.npcChatHistories);
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        // Basic validation: Check if it's an object
                        if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
                            npcChatHistories = parsed;
                            console.log(`Loaded histories for ${Object.keys(npcChatHistories).length} tabs.`);
                            // Ensure 'main' history exists if not loaded
                            if (!npcChatHistories['main']) {
                                npcChatHistories['main'] = [];
                            }
                        } else {
                             console.warn("Invalid structure in saved NPC chat history. Resetting.");
                             npcChatHistories = { 'main': [] }; // Initialize with main
                             localStorage.removeItem(LS_KEYS.npcChatHistories);
                        }
                    } catch (e) {
                        console.error("Error parsing saved NPC chat histories:", e);
                        npcChatHistories = { 'main': [] }; // Initialize with main
                        localStorage.removeItem(LS_KEYS.npcChatHistories);
                    }
                } else {
                    npcChatHistories = { 'main': [] }; // Initialize with main if nothing saved
                    console.log("No saved NPC chat histories found. Initializing.");
                }
            }

            // --- Rendering Logic (MODIFIED) ---

            // Renders history for a SPECIFIC tab ID into the chatMessages container
            function renderHistoryForTab(tabId) {
                chatMessages.innerHTML = ''; // Clear existing messages
                const historyKey = (tabId && tabId.startsWith('npc-tab-')) ? tabId.replace('npc-tab-', 'npc-') : 'main';
                const history = npcChatHistories[historyKey] || [];

                if (history.length === 0) {
                     // Show placeholder if history is empty
                     const p = document.createElement('p');
                     p.textContent = "No messages yet...";
                     p.style.fontStyle = 'italic'; p.style.color = 'var(--ink-light)'; p.style.textAlign = 'center';
                     chatMessages.appendChild(p);
                     return;
                }

                // Filter history based on mode? For now, render all for the specific tab.
                history.forEach(msg => {
                    if (!msg || !msg.role || msg.content === undefined) return; // Basic validation

                    let speakerData = null;
                    let senderName = msg.senderName || 'Unknown'; // Use stored senderName

                    // Determine speaker data for avatar/styling based on role and senderName
                    if (msg.role === 'user') {
                        speakerData = playerData;
                        senderName = playerData.name; // Ensure player name is up-to-date
                    } else if (msg.role === 'assistant') {
                        // Find NPC data by stored name (or use fallback)
                        speakerData = npcData.find(n => n.name === senderName) || { pfp: DEFAULT_NPC_PFP, name: senderName };
                    }
                    // else: system/debug/error roles handled directly by _renderSingleMessage

                    _renderSingleMessage(msg.content, senderName, msg.role, speakerData);
                });
                chatMessages.scrollTop = chatMessages.scrollHeight; // Scroll to bottom after rendering
            }

            // Renders the spatial chat messages (unchanged logic, just called differently)
            function renderSpatialChatMessages(messages) {
                 const wasScrolledToBottom = chatMessages.scrollHeight - chatMessages.clientHeight <= chatMessages.scrollTop + 1;
                 chatMessages.innerHTML = ''; // Clear existing messages
                 if (!messages || messages.length === 0) {
                     const p = document.createElement('p');
                     p.textContent = currentSpatialScope ? `The #${currentSpatialScope} scope is quiet...` : "Select a spatial scope...";
                     p.style.fontStyle = 'italic'; p.style.color = 'var(--ink-light)'; p.style.textAlign = 'center';
                     chatMessages.appendChild(p);
                 } else {
                     messages.forEach(msgString => {
                         const msgEl = document.createElement('div'); msgEl.className = 'spatial-message';
                         msgEl.textContent = msgString; chatMessages.appendChild(msgEl);
                     });
                 }
                 if (wasScrolledToBottom) {
                     chatMessages.scrollTop = chatMessages.scrollHeight;
                 }
            }

            // Modified: Renamed from addMessage, only handles rendering ONE message to UI
            // History management is now separate.
            function _renderSingleMessage(text, senderName, type, speakerData = null) {
                 if (hideSystemMessages && ['debug', 'system', 'error'].includes(type)) return;

                 const isSpatialMode = currentChatDisplayMode === 'spatial';
                 // Prevent rendering non-spatial messages when in spatial mode
                 if (isSpatialMode) return;

                 const wasScrolledToBottom = chatMessages.scrollHeight - chatMessages.clientHeight <= chatMessages.scrollTop + 1;

                 const messageDiv = document.createElement('div'); messageDiv.classList.add('message');
                 let senderTypeClass = '', avatarClass = '', pfpSrc = '', isMarkdown = false, displayName = senderName || 'Unknown';

                 // Determine classes, PFP, display name based on type
                 if (type === 'user') {
                     senderTypeClass = 'message-user'; avatarClass = 'user-avatar';
                     pfpSrc = playerData.pfp || DEFAULT_PLAYER_PFP;
                     displayName = playerData.name || 'Player';
                     isMarkdown = false;
                 } else if (type === 'assistant') {
                     senderTypeClass = 'message-spirit'; avatarClass = 'spirit-avatar';
                     const actualSpeaker = speakerData || npcData.find(n => n.name === senderName) || { pfp: DEFAULT_NPC_PFP, name: senderName };
                     pfpSrc = actualSpeaker.pfp || DEFAULT_NPC_PFP;
                     displayName = actualSpeaker.name || senderName;
                     isMarkdown = true;
                 } else { // system, debug, error
                     senderTypeClass = `message-${type}`; // Simple mapping
                     avatarClass = `${type}-avatar`; // Simple mapping
                     const systemBgColor = getComputedStyle(document.documentElement).getPropertyValue('--amethyst').trim() || '#6b21a8';
                     const dangerBgColor = getComputedStyle(document.documentElement).getPropertyValue('--danger-color').trim() || '#8b0000';
                     const defaultBgColor = getComputedStyle(document.documentElement).getPropertyValue('--ink-light').trim() || '#5a4e42';
                     let avatarBg = defaultBgColor;
                     if (type === 'system') avatarBg = systemBgColor;
                     else if (type === 'error') avatarBg = dangerBgColor;
                     const avatarLetter = (senderName || type.substring(0,1)).substring(0,1).toUpperCase();
                     pfpSrc = `https://ui-avatars.com/api/?name=${encodeURIComponent(avatarLetter)}&background=${avatarBg.substring(1)}&color=fff&size=64`;
                     displayName = senderName || type.charAt(0).toUpperCase() + type.slice(1); // Default to capitalized type if no name
                     isMarkdown = false;
                 }

                 messageDiv.classList.add(senderTypeClass);
                 const avatarImg = document.createElement('img');
                 avatarImg.className = `avatar ${avatarClass}`; avatarImg.src = pfpSrc; avatarImg.alt = `${displayName} avatar`; avatarImg.title = displayName;

                 // Add click listeners for avatars (unchanged)
                 if (type === 'assistant' || type === 'system' || type === 'debug' || type === 'error') { avatarImg.addEventListener('click', openSettingsModal); }
                 else if (type === 'user') { avatarImg.addEventListener('click', showPfpContextMenu); }

                 const contentDiv = document.createElement('div');
                 contentDiv.className = `message-content ${senderTypeClass.replace('message-', '')}-message`;

                 // Apply markdown or plain text (unchanged logic)
                 if (isMarkdown) {
                     try {
                         contentDiv.innerHTML = marked.parse(text);
                         setTimeout(() => { /* ... copy button logic ... */ const pre = contentDiv.querySelectorAll('pre'); pre.forEach(p => { const cC = p.querySelector('code')?.textContent || p.textContent; if (!cC || cC.trim() === '') return; const b = document.createElement('button'); b.className = 'copy-code-btn'; b.textContent = 'Copy'; b.title = 'Copy'; b.addEventListener('click', (e) => { e.stopPropagation(); const c = p.querySelector('code') || p; navigator.clipboard.writeText(c.textContent).then(() => { b.textContent = 'Copied!'; b.classList.add('copied'); setTimeout(() => { b.textContent = 'Copy'; b.classList.remove('copied'); }, 2000); }).catch(err => console.error("Copy failed: ", err)); }); p.style.position = 'relative'; p.appendChild(b); }); }, 0);
                     } catch (e) { console.error("Markdown err:", e); contentDiv.textContent = text; }
                 } else {
                     if (['system', 'debug', 'error'].includes(type)) {
                         const nameSpan = document.createElement('span'); nameSpan.className = 'message-name'; nameSpan.textContent = `${displayName}: `;
                         contentDiv.appendChild(nameSpan); contentDiv.appendChild(document.createTextNode(text));
                     } else { contentDiv.textContent = text; }
                 }

                 // Append elements based on sender type (unchanged)
                 if (type === 'user') { messageDiv.appendChild(contentDiv); messageDiv.appendChild(avatarImg); }
                 else { messageDiv.appendChild(avatarImg); messageDiv.appendChild(contentDiv); }

                 chatMessages.appendChild(messageDiv);
                 if(wasScrolledToBottom) {
                     chatMessages.scrollTop = chatMessages.scrollHeight;
                 }
            }

            // NEW: Function to add message to the correct history AND render if tab active
            function addMessageToHistoryAndUI(text, senderName, type, speakerData, targetTabId) {
                const historyKey = (targetTabId && targetTabId.startsWith('npc-tab-')) ? targetTabId.replace('npc-tab-', 'npc-') : 'main';

                // Ensure history array exists
                if (!npcChatHistories[historyKey]) {
                    npcChatHistories[historyKey] = [];
                }

                // Add to history
                const history = npcChatHistories[historyKey];
                history.push({ role: type, content: text, senderName: senderName });

                // Trim history if it exceeds the limit for this specific tab
                const maxLen = MAX_HISTORY_TURNS_PER_TAB * 2 + 10; // Allow buffer
                if (history.length > maxLen) {
                    npcChatHistories[historyKey] = history.slice(-maxLen);
                }

                // Save all histories (can be optimized later if needed)
                saveNpcChatHistories();

                // Render the message *only* if the target tab is currently active
                if (targetTabId === activeTabId) {
                    _renderSingleMessage(text, senderName, type, speakerData);
                }
            }


            // --- Tab Management ---
            function setChatTabsVisibility(isVisible) { /* ... (unchanged) ... */ chatTabsVisible = isVisible; chatTabsArea.classList.toggle('hidden', !isVisible); try { localStorage.setItem(LS_KEYS.chatTabsVisible, isVisible ? 'true' : 'false'); } catch (e) { console.error("Failed to save chat tab visibility state:", e); } }
            function toggleChatTabsVisibility() { setChatTabsVisibility(!chatTabsVisible); }

            // --- Context Menu Functions (Modified 'talk' handler) ---
             function handleGenericContextMenu(event, menuElement) { /* ... (unchanged setup) ... */
                 event.preventDefault(); closeAllContextMenus();
                 const t = event.currentTarget;
                 contextMenuTargetNpcId = null; contextMenuTargetIsPlayer = false;

                 if (menuElement.id === 'player-context-menu') {
                     if (!currentCityKey || playerData.element.style.display === 'none') return;
                     contextMenuTargetIsPlayer = true;
                 } else if (menuElement.id === 'npc-context-menu') {
                     if (!currentCityKey) return;
                     contextMenuTargetNpcId = parseInt(t.dataset.npcId, 10);
                     if (isNaN(contextMenuTargetNpcId)) { console.error("No NPC ID:", t); return; }
                     const n = npcData.find(npc => npc.id === contextMenuTargetNpcId);
                     if (!n) return;
                     const toggleFollowItem = npcContextMenu.querySelector('[data-action="toggleFollow"]');
                     if (toggleFollowItem) { toggleFollowItem.textContent = n.followingTargetId !== null ? 'Unfollow' : 'Follow'; toggleFollowItem.style.opacity = '1'; }
                 } else if (menuElement.id === 'pfp-context-menu') {
                      const toggleTabsItem = pfpContextMenu.querySelector('[data-action="toggle-tabs"]'); if (toggleTabsItem) { toggleTabsItem.textContent = chatTabsVisible ? "Hide Tabs" : "Show Tabs"; }
                      const toggleFullscreenItem = pfpContextMenu.querySelector('[data-action="toggle-fullscreen"]'); if (toggleFullscreenItem) { const isCurrentlyFullscreen = chatArea.offsetHeight >= (window.innerHeight - 10); toggleFullscreenItem.textContent = isCurrentlyFullscreen ? "Minimize Chat" : "Fullscreen Chat"; }
                 } else { return; }

                 const mW = menuElement.offsetWidth; const mH = menuElement.offsetHeight;
                 let x = event.clientX; let y = event.clientY;
                 if (x + mW > window.innerWidth) x -= mW; if (y + mH > window.innerHeight) y -= mH;
                 menuElement.style.left = `${x}px`; menuElement.style.top = `${y}px`;
                 menuElement.style.display = 'block';
                 document.addEventListener('click', closeContextMenuOnClickOutside, { capture: true, once: true });
                 document.addEventListener('contextmenu', closeContextMenuOnClickOutside, { capture: true, once: true });
             }
            function handleNpcContextMenu(event) { handleGenericContextMenu(event, npcContextMenu); }
            function handlePlayerContextMenu(event) { handleGenericContextMenu(event, playerContextMenu); }
            function showPfpContextMenu(event) { handleGenericContextMenu(event, pfpContextMenu); }
            function closeAllContextMenus() { npcContextMenu.style.display = 'none'; playerContextMenu.style.display = 'none'; pfpContextMenu.style.display = 'none'; contextMenuTargetNpcId = null; contextMenuTargetIsPlayer = false; }
            function closeContextMenuOnClickOutside(event) { /* ... (unchanged) ... */ const activeMenu = [npcContextMenu, playerContextMenu, pfpContextMenu].find(menu => menu.style.display === 'block'); if (activeMenu && !activeMenu.contains(event.target)){ closeAllContextMenus(); } else if (activeMenu) { document.addEventListener('click', closeContextMenuOnClickOutside, { capture: true, once: true }); document.addEventListener('contextmenu', closeContextMenuOnClickOutside, { capture: true, once: true }); } }

            function findCurrentAreaName(x, y, envList) { /* ... (unchanged) ... */ if (x === undefined || y === undefined || !envList) return null; for (const env of envList) { if (x >= env.x && x < env.x + env.width && y >= env.y && y < env.y + env.height) { return env.name; } } return null; }

            // --- Other Core Functions (some modified, some unchanged) ---
            function getRandomHexColor(){ /* ... (unchanged) ... */ const l='0123456789ABCDEF';let c='#';for(let i=0;i<6;i++)c+=l[Math.floor(Math.random()*16)];const r=parseInt(c.substring(1,3),16),g=parseInt(c.substring(3,5),16),b=parseInt(c.substring(5,7),16);return(r<50&&g<50&&b<50)?getRandomHexColor():c; }
            function showSpeechBubble(c,m){ /* ... (unchanged) ... */ if(!c||!c.speechElement)return;if(c.speechTimeout)clearTimeout(c.speechTimeout);c.speechElement.textContent=m;c.speechElement.style.display='block';c.isTalking=true;c.speechTimeout=setTimeout(()=>{if(c.speechElement)c.speechElement.style.display='none';c.isTalking=false;c.speechTimeout=null;},globalSpeechDuration); }
            function updateCharacterPosition(c){ /* ... (unchanged) ... */ if(c&&c.element){c.element.style.left=`${c.x}px`;c.element.style.top=`${c.y}px`;} }
            function updateEnvironmentVisuals(e){ /* ... (unchanged) ... */ if(!e||!e.element)return;e.element.style.left=`${e.x}px`;e.element.style.top=`${e.y}px`;e.element.style.width=`${e.width}px`;e.element.style.height=`${e.height}px`;if(e.nameElement)e.nameElement.textContent=e.name; }
            function updateCameraPosition(){ /* ... (unchanged) ... */ if(playerData.x===undefined||playerData.y===undefined||!playerData.element||playerData.element.style.display==='none') return; viewportWidth=gameWorld.offsetWidth;viewportHeight=gameWorld.offsetHeight;let tx=playerData.x-viewportWidth/2+(playerData.width/2);let ty=playerData.y-viewportHeight/2+(playerData.height/2);const cx=Math.max(0,Math.min(MAP_WIDTH-viewportWidth,tx));const cy=Math.max(0,Math.min(MAP_HEIGHT-viewportHeight,ty));mapContent.style.transform=`translate3d(${-cx}px,${-cy}px,0)`; }
            function applyPlayerAppearance(styleData) { /* ... (unchanged) ... */ if (!playerData.element||!styleData||!styleData.colors) return; applyAppearanceToElement(playerData.element, styleData); }
            function applyNpcAppearance(npc) { /* ... (unchanged) ... */ if (!npc||!npc.element||!npc.appearance||!npc.appearance.colors) return; applyAppearanceToElement(npc.element, npc.appearance); }
            function applyAppearanceToElement(element, styleData) { /* ... (full implementation unchanged) ... */ if (!element || !styleData || !styleData.colors) return; const { outfit, gender, colors } = styleData; let baseClasses = "character"; if (element.id === 'player') baseClasses += ""; else baseClasses += " npc"; if (element.classList.contains('is-walking')) baseClasses += ' is-walking'; element.className = `${baseClasses} gender-${gender} outfit-${outfit}`; const parts = { head: element.querySelector('.part.head'), torso: element.querySelector('.part.torso'), legs: element.querySelector('.part.legs'), armLeft: element.querySelector('.part.arm-left'), armRight: element.querySelector('.part.arm-right'), detail1: element.querySelector('.part.detail1'), detail2: element.querySelector('.part.detail2'), detail3: element.querySelector('.part.detail3'), detail4: element.querySelector('.part.detail4'), detail5: element.querySelector('.part.detail5') }; if (!parts.head) { console.error("Cannot find .part.head in:", element); return; } const FIXED_SKIN_TONE = getComputedStyle(document.documentElement).getPropertyValue('--skin-tone').trim() || '#fbe5d6'; const DEFAULT_OUTLINE = getComputedStyle(document.documentElement).getPropertyValue('--default-outline').trim() || '#222'; Object.entries(parts).forEach(([key, p]) => { if(p) { p.style.backgroundColor=''; p.style.borderColor=DEFAULT_OUTLINE; p.style.borderTopColor=''; p.style.borderBottomColor=''; p.style.borderLeftColor=''; p.style.borderRightColor=''; p.style.outlineColor=''; p.style.clipPath = ''; p.style.borderStyle = 'solid'; p.style.borderWidth = '1px'; if (key === 'detail3' || key === 'detail4' || key === 'detail5') p.style.borderColor = 'transparent'; if (key === 'detail2' && gender === 'female') { p.style.borderColor = 'transparent'; p.style.borderBottomColor = darkenHexColor(colors.hair, 0.2); } else if (key === 'detail2') p.style.borderBottomColor = ''; if((key === 'detail2' || key === 'detail3') && gender === 'male' && outfit === 'mage') p.style.borderColor = DEFAULT_OUTLINE; } }); if(parts.head) { parts.head.style.backgroundColor = FIXED_SKIN_TONE; parts.head.style.borderColor = darkenHexColor(FIXED_SKIN_TONE, 0.2); } if(parts.legs) parts.legs.style.borderBottomColor = colors.feet; if (gender === 'male') { if (outfit !== 'mage') { if(parts.detail2){parts.detail2.style.backgroundColor=colors.hair;parts.detail2.style.borderColor=darkenHexColor(colors.hair,0.3);} if(parts.detail3){parts.detail3.style.backgroundColor=colors.hair;parts.detail3.style.borderColor=darkenHexColor(colors.hair,0.3);} } else { if(parts.detail2){parts.detail2.style.backgroundColor='';parts.detail2.style.borderColor=DEFAULT_OUTLINE;} if(parts.detail3){parts.detail3.style.backgroundColor='';parts.detail3.style.borderColor=DEFAULT_OUTLINE;} } switch(outfit){ case 'citizen': if(parts.torso){parts.torso.style.backgroundColor=colors.primary;parts.torso.style.borderTopColor=colors.secondary;parts.torso.style.borderTopWidth='2px';parts.torso.style.borderBottomStyle='none';} if(parts.legs){parts.legs.style.backgroundColor=colors.legs;parts.legs.style.borderBottomWidth='3px';parts.legs.style.borderTopStyle='none';} if(parts.armLeft)parts.armLeft.style.backgroundColor=FIXED_SKIN_TONE; if(parts.armRight)parts.armRight.style.backgroundColor=FIXED_SKIN_TONE; break; case 'mage': if(parts.torso)parts.torso.style.backgroundColor=colors.primary; if(parts.armLeft)parts.armLeft.style.backgroundColor=colors.primary; if(parts.armRight)parts.armRight.style.backgroundColor=colors.primary; if(parts.detail1){parts.detail1.style.backgroundColor=colors.detail1;parts.detail1.style.borderColor=darkenHexColor(colors.detail1,0.3);} if(parts.detail4){parts.detail4.style.backgroundColor=colors.hair;parts.detail4.style.borderColor=darkenHexColor(colors.hair,0.3);parts.detail4.style.borderBottomStyle='none';} if(parts.legs){parts.legs.style.backgroundColor=darkenHexColor(colors.primary,0.1);parts.legs.style.borderBottomWidth='3px';parts.legs.style.borderTopStyle='none';} break; case 'warrior': /* ... */ break; case 'scifi': /* ... */ break; case 'ranger': /* ... */ break; case 'kimono': /* ... */ break; } } else { if(parts.detail2){parts.detail2.style.backgroundColor=colors.hair;parts.detail2.style.border='none';parts.detail2.style.borderBottom=`1px solid ${darkenHexColor(colors.hair, 0.2)}`;} if(parts.detail3){parts.detail3.style.backgroundColor=colors.hair;parts.detail3.style.border='none';} switch(outfit){ case 'citizen': /* ... */ break; case 'mage': /* ... */ break; case 'warrior': /* ... */ break; case 'scifi': /* ... */ break; case 'ranger': /* ... */ break; case 'kimono': /* ... */ break; } } /* End of massive style block */ }
            function movePlayer(dx, dy) { /* ... (unchanged, but calls updateSpatialChatModuleState) ... */
                 if (!playerData.element||!currentCityKey||playerData.element.style.display==='none') return;
                 const tX=playerData.x+dx*playerStepDistance; const tY=playerData.y+dy*playerStepDistance;
                 playerData.x=Math.max(0,Math.min(MAP_WIDTH-playerData.width,tX)); playerData.y=Math.max(0,Math.min(MAP_HEIGHT-playerData.height,tY));
                 updateCharacterPosition(playerData); updateCameraPosition(); updateSpatialChatModuleState();
                 if (!isPlayerMoving) { playerElement.classList.add('is-walking'); isPlayerMoving=true; }
                 clearTimeout(playerMoveTimeout); playerMoveTimeout=setTimeout(() => {
                    playerElement.classList.remove('is-walking'); isPlayerMoving=false;
                    const pR=playerElement.querySelectorAll('.part.arm-left,.part.arm-right,.part.legs'); pR.forEach(p=>{p.style.animation='none';p.offsetHeight;p.style.animation='';p.style.transform='';});
                    playerElement.style.animation='none';playerElement.offsetHeight;playerElement.style.animation='';playerElement.style.transform='';
                    updateInputPlaceholder();
                 }, 550);
            }
            function updateInputPlaceholder(){ // MODIFIED
                 if (!currentCityKey) { userInput.placeholder = "Open Settings (Click Spirit Sigil)..."; return; }
                 if (isWaitingForApiResponse && ['main-chat', 'npc-chat', 'agent'].includes(currentChatDisplayMode)) {
                     userInput.placeholder = "Waiting for response..."; return;
                 }

                 switch(currentChatDisplayMode) {
                     case 'spatial':
                         userInput.placeholder = currentSpatialScope ? `Shout into #${currentSpatialScope}...` : 'Select a spatial scope...';
                         break;
                     case 'main-chat':
                         // Indicate that this tab finds the closest NPC
                         const closest = findClosestNpc(false);
                         userInput.placeholder = closest ? `Chat with ${closest.name} (closest)...` : `Chat (find NPC)...`;
                         break;
                     case 'npc-chat':
                         const targetNpc = currentAiNpcData; // Should be set by setActiveTab
                         userInput.placeholder = targetNpc ? `Chat with ${targetNpc.name}...` : `Chat with Unknown...`;
                         break;
                     case 'agent':
                         const agentTarget = currentAiNpcData || findClosestNpc(false);
                         userInput.placeholder = agentTarget ? `Command ${agentTarget.name}...` : `Command (find Agent)...`;
                         break;
                     default:
                          userInput.placeholder = 'Select a chat mode...';
                 }
            }
            function findClosestNpc(log=true){ /* ... (unchanged) ... */ let clNpc=null;let minDist=Infinity;if(playerData.x===undefined||playerData.y===undefined||!currentCityKey||playerData.element.style.display==='none') return null; npcData.forEach(n=>{ if(typeof n.x!=='number'||typeof n.y !=='number')return;const d=Math.hypot(playerData.x-n.x,playerData.y-n.y);if(d<minDist){minDist=d;clNpc=n;}});if(log&&clNpc)console.log("Closest NPC:",clNpc.name);return clNpc;}
            function getGameStateString(){ /* ... (unchanged) ... */ let s=`[P(${playerData.name}):Pos(${Math.round(playerData.x)},${Math.round(playerData.y)})]`;npcData.forEach(n=>{s+=` [${n.name}(${n.id}):Pos(${Math.round(n.x)},${Math.round(n.y)})${n.followingTargetId !== null ? ` F(${n.followingTargetId === 'player' ? 'P' : n.followingTargetId})` : ''}]`;});environmentData.forEach(e=>{s+=` [Env(${e.name}):Pos(${Math.round(e.x)},${Math.round(e.y)})W(${e.width})H(${e.height})]`;}); return s;}

            // Modified: Generates prompt based on currentAiNpcData and mode
            function generateSystemPrompt(npc, mode) {
                if (!npc) return "You are a helpful assistant."; // Fallback
                const persona = npc.personaPrompt || `You are ${npc.name}.`;
                if (mode === 'agent') {
                    return `${persona} ${BASE_ACTION_RULES}`;
                } else { // 'npc-chat' or 'main-chat' (if it ever calls API directly)
                    return persona;
                }
            }

            // Modified: Calls addMessageToHistoryAndUI for feedback
            function processNpcActions(r, n, sourceTabId) {
                if (!n) return r;
                let commandText = r; const actionRegex = /<(\w+)(?:\s+([^>]*?))?\s*>/g;
                let match; const actions = [];
                while ((match = actionRegex.exec(r)) !== null) { actions.push({ name: match[1]?.toLowerCase(), params: match[2] || "", tag: match[0] }); commandText = commandText.replace(match[0], '').trim(); }

                const systemSpeaker = "Agent Command"; // Speaker name for system feedback
                if (actions.length > 0) {
                    const action = actions[0];
                    console.log(`Processing Action: ${action.name}(${action.params}) for ${n.name}`);
                    switch (action.name) {
                        case 'walk':
                            handleWalkAction(n, action.params);
                            const coords = action.params.split(',');
                            if (coords.length === 2) { addMessageToHistoryAndUI(`${n.name} walks towards ${coords[0].trim()}, ${coords[1].trim()}.`, systemSpeaker, 'system', null, sourceTabId); }
                            else { addMessageToHistoryAndUI(`${n.name} attempts to walk (invalid coords: ${action.params}).`, systemSpeaker, 'error', null, sourceTabId); }
                            break;
                        case 'follow': handleFollowAction(n, sourceTabId); break; // Pass tabId
                        case 'unfollow': handleUnfollowAction(n, sourceTabId); break; // Pass tabId
                        default:
                            console.warn(`Unknown action tag: ${action.name}`);
                            addMessageToHistoryAndUI(`${n.name} considered an unknown action: ${action.tag}.`, systemSpeaker, 'warn', null, sourceTabId);
                    }
                    return null; // Expect only action tag
                } else {
                     if (r && r.trim()) {
                         console.warn(`Agent ${n.name} responded with text instead of an action: "${r}"`);
                         addMessageToHistoryAndUI(`(${n.name} did not provide a valid action: "${r.substring(0,50)}...")`, systemSpeaker, 'error', null, sourceTabId);
                     }
                    return null; // No valid action found
                }
            }

            function handleWalkAction(n,p){ /* ... (unchanged) ... */ if (!n||!n.element) return; n.followingTargetId=null; const c=p.split(',');if(c.length===2){const x=parseInt(c[0].trim(),10),y=parseInt(c[1].trim(),10);if(!isNaN(x)&&!isNaN(y)){n.x=Math.max(0,Math.min(MAP_WIDTH-n.width,x));n.y=Math.max(0,Math.min(MAP_HEIGHT-n.height,y));updateCharacterPosition(n);}else console.warn(`Inv Walk Coords:${p}`);}else console.warn(`Inv Walk Params:${p}`);}
            function findClosestCharacter(s, includeSelf = false, onlyPlayer = false){ /* ... (unchanged) ... */ let t=null,minD=Infinity; let pots=[playerData]; if (!onlyPlayer) { pots=pots.concat(npcData); } pots=pots.filter(tg => tg && tg.element?.style.display !== 'none' && (includeSelf || tg !== s) && (typeof s.x === 'number' && typeof tg.x === 'number' && s.y !== undefined && tg.y !== undefined) ); pots.forEach(tg=>{ const d=Math.hypot(s.x-tg.x,s.y-tg.y); if(d<minD){minD=d;t=tg;} }); console.log(`${s.name} target (${onlyPlayer ? 'Player' : 'Any'}): ${t?t.name:"None"}`); return t;}

            // Modified: Add feedback message to the correct tab
            function handleFollowAction(n, feedbackTabId) {
                if (!n || !n.element) return;
                const target = playerData;
                const systemSpeaker = "Follow Command";
                 if (target && target.element?.style.display !== 'none') {
                    n.followingTargetId = 'player';
                    console.log(`${n.name} starts following ${target.name}`);
                    addMessageToHistoryAndUI(`${n.name} starts following ${target.name}.`, systemSpeaker, 'system', null, feedbackTabId);
                 } else {
                     n.followingTargetId = null;
                     console.log(`${n.name} cannot find the player to follow.`);
                     addMessageToHistoryAndUI(`${n.name} cannot find the player to follow.`, systemSpeaker, 'warn', null, feedbackTabId);
                 }
            }
            // Modified: Add feedback message to the correct tab
            function handleUnfollowAction(n, feedbackTabId) {
                if (!n || !n.element) return;
                const systemSpeaker = "Follow Command";
                if (n.followingTargetId !== null) {
                    const targetName = n.followingTargetId === 'player' ? playerData.name : `Agent ${n.followingTargetId}`;
                    console.log(`${n.name} stops following ${targetName}.`);
                    addMessageToHistoryAndUI(`${n.name} stops following.`, systemSpeaker, 'system', null, feedbackTabId);
                    n.followingTargetId = null;
                } else {
                     addMessageToHistoryAndUI(`${n.name} was not following anyone.`, systemSpeaker, 'info', null, feedbackTabId);
                }
            }


            function updateFollowingNpcs() { /* ... (unchanged, but calls updateSpatialChatModuleState) ... */
                 if (!currentCityKey) return;
                 let positionChanged = false;
                 npcData.forEach(npc => {
                     if (!npc.followingTargetId || !npc.element) return;
                     let target = null;
                     if (npc.followingTargetId === 'player') target = playerData;
                     else if (typeof npc.followingTargetId === 'number') target = npcData.find(n => n.id === npc.followingTargetId);

                     if (!target || target.element?.style.display === 'none' || typeof target.x !== 'number' || typeof target.y !== 'number' ) {
                         if (npc.followingTargetId !== null) {
                             console.log(`${npc.name} lost target, stopping follow.`);
                             // Don't add UI message here, let actions handle explicit unfollow feedback
                             npc.followingTargetId = null;
                         } return;
                     }
                     const dx = target.x - npc.x; const dy = target.y - npc.y; const distance = Math.hypot(dx, dy);
                     if (distance > FOLLOW_DISTANCE) {
                         const normDx = distance === 0 ? 0 : dx / distance; const normDy = distance === 0 ? 0 : dy / distance;
                         const moveX = normDx * NPC_FOLLOW_SPEED; const moveY = normDy * NPC_FOLLOW_SPEED;
                         let newX = npc.x + moveX; let newY = npc.y + moveY;
                         newX = Math.max(0, Math.min(MAP_WIDTH - npc.width, newX)); newY = Math.max(0, Math.min(MAP_HEIGHT - npc.height, newY));
                         if (npc.x !== newX || npc.y !== newY) { npc.x = newX; npc.y = newY; updateCharacterPosition(npc); positionChanged = true; }
                     }
                 });
                 if (positionChanged) updateSpatialChatModuleState();
            }

            function displayTypingIndicator() { /* ... (unchanged, but should only show in non-spatial modes) ... */ if (currentChatDisplayMode === 'spatial') return; removeTypingIndicator(); const t=document.createElement('div'); t.className='typing-indicator'; t.id='typing-indicator'; t.innerHTML=`<span>The spirit is responding</span><span class="rune">✧</span><span class="rune">✦</span><span class="rune">✧</span>`; chatMessages.appendChild(t); chatMessages.scrollTop=chatMessages.scrollHeight; }
            function removeTypingIndicator() { const t=document.getElementById('typing-indicator'); if(t) t.remove(); }

            // --- API Key Handling (Unchanged) ---
            function loadApiKeyManagement() { /* ... */ }
            function saveApiKeyManagement() { /* ... */ }
            function handleAddApiKey() { /* ... */ }
            function handleDeleteApiKey(providerKey, keyToDelete) { /* ... */ }
            function renderApiKeysForProvider(providerKey) { /* ... */ }














                        // --- API Call Logic (MODIFIED - Handles different tab contexts) ---
            async function getApiResponseFromProvider(userMessage, targetNpcData, sourceTabId, attempt = 1) {
                const currentMode = currentChatDisplayMode; // Capture mode at call time

                // Basic checks (API config, provider function)
                if (typeof PROVIDERS === 'undefined' || Object.keys(PROVIDERS).length === 0) { addMessageToHistoryAndUI("API Provider configuration not loaded.", "SYSTEM", "error", null, sourceTabId); enableInput(); return; }
                if (!selectedProvider || !selectedModel) { addMessageToHistoryAndUI("No API Provider/Model selected (Settings Page 2).", "SYSTEM", "error", null, sourceTabId); enableInput(); return; }
                if (typeof window.getApiResponse !== 'function') { addMessageToHistoryAndUI("API Provider script function not found.", "SYSTEM", "error", null, sourceTabId); enableInput(); return; }
                const providerConfig = PROVIDERS[selectedProvider];
                if (!providerConfig) { addMessageToHistoryAndUI(`Config error: Provider "${selectedProvider}" not found.`, "SYSTEM", "error", null, sourceTabId); enableInput(); return; }

                // Ensure we have a target NPC for relevant modes
                if (!targetNpcData && (currentMode === 'npc-chat' || currentMode === 'agent')) {
                    console.error("API Call Error: Target NPC data is missing for NPC/Agent mode.");
                    addMessageToHistoryAndUI("Internal error: Cannot determine chat target.", "SYSTEM", "error", null, sourceTabId);
                    enableInput(); return;
                }
                 // Use a default "Spirit" if in main chat and no specific NPC is targeted yet (shouldn't happen often now)
                 const npc = targetNpcData || { name: "Spirit", personaPrompt: "You are a helpful, disembodied spirit.", pfp: DEFAULT_NPC_PFP };


                // Display typing indicator only on first attempt
                if (attempt === 1) { displayTypingIndicator(); }

                // API Key selection logic (unchanged from previous version)
                let apiKeyToUse = null; let keysForProvider = []; let totalKeysForProvider = 0; let currentKeyIndex = 0;
                const needsClientKey = providerConfig.format !== 'proxy_compatible' && providerConfig.apiKeyLocation !== 'none';
                if (needsClientKey) {
                    keysForProvider = apiKeyManagement.providerKeys[selectedProvider] || []; totalKeysForProvider = keysForProvider.length;
                    if (totalKeysForProvider === 0) { removeTypingIndicator(); addMessageToHistoryAndUI(`No API keys for ${providerConfig.name} (Settings Page 2).`, "SYSTEM", "error", null, sourceTabId); enableInput(); return; }
                    if (attempt > totalKeysForProvider) { removeTypingIndicator(); addMessageToHistoryAndUI(`All ${totalKeysForProvider} keys for ${providerConfig.name} failed.`, "SYSTEM", "error", null, sourceTabId); enableInput(); return; }
                    const startIndex = apiKeyManagement.activeKeyIndices[selectedProvider] ?? 0;
                    currentKeyIndex = (startIndex + attempt - 1) % totalKeysForProvider; apiKeyToUse = keysForProvider[currentKeyIndex];
                    if (!apiKeyToUse) { removeTypingIndicator(); addMessageToHistoryAndUI(`Internal key retrieval error for ${providerConfig.name}.`, "SYSTEM", "error", null, sourceTabId); enableInput(); return; }
                    console.log(`API Call Attempt ${attempt}/${totalKeysForProvider} for ${selectedProvider}. Key index: ${currentKeyIndex} (${maskApiKey(apiKeyToUse)})`);
                } else { apiKeyToUse = null; console.log(`API Call for ${selectedProvider} (${providerConfig.name}). Key handled by proxy/server.`); }

                // --- Generate Prompt & History based on Mode and Tab ---
                const sysPrompt = generateSystemPrompt(npc, currentMode);
                let userContent = "";
                const historyKey = getHistoryKeyForTab(sourceTabId); // Get history key (e.g., 'main', 'npc-5')
                const specificHistory = (npcChatHistories[historyKey] || []).filter(m => m.role === 'user' || m.role === 'assistant'); // Get only user/assistant messages for context

                if (currentMode === 'agent') {
                    const gameState = currentCityKey ? getGameStateString() : "[No City Loaded]";
                    const events = recentEvents.length > 0 ? ` RecentEvents:[${recentEvents.join('; ')}]` : '';
                    const context = `(You are ${npc.name}. Player ${playerData.name} is near you).`;
                    userContent = `${gameState}${events} ${context} Player command: ${userMessage}`.trim();
                    if (attempt === 1) { recentEvents = []; } // Clear events only on first attempt for agent mode
                } else { // 'main-chat' or 'npc-chat'
                    userContent = `${playerData.name || 'User'} says: ${userMessage}`.trim();
                }

                // Construct message history: System Prompt + Specific Tab History + Current User Message
                const messagesForApi = [{ role: 'system', content: sysPrompt }];
                messagesForApi.push(...specificHistory); // Add history relevant to this specific chat/agent tab
                messagesForApi.push({ role: 'user', content: userContent });

                // Limit history length sent to API
                const limitedApiMsgs = messagesForApi.length > (MAX_HISTORY_TURNS_PER_TAB * 2 + 2) ?
                     [messagesForApi[0], ...messagesForApi.slice(-(MAX_HISTORY_TURNS_PER_TAB * 2 + 1))] : messagesForApi;

                 // Debug log before sending
                 if (attempt === 1) {
                     addMessageToHistoryAndUI(`(${currentMode.toUpperCase()} -> ${npc.name}) API Call: ${userMessage.substring(0,100)}...`, 'DEBUG', 'debug', null, sourceTabId);
                     console.log("Sending messages to API:", limitedApiMsgs);
                 }

                try {
                    const rawReply = await window.getApiResponse(selectedProvider, selectedModel, limitedApiMsgs, apiKeyToUse, {});
                    removeTypingIndicator();
                    addMessageToHistoryAndUI(`(${currentMode.toUpperCase()} <- ${npc.name}) Raw Reply: ${rawReply.substring(0, 100)}...`, 'DEBUG', 'debug', null, sourceTabId);
                    console.log("Raw API Reply:", rawReply);


                    // API Key index update (unchanged)
                    if (needsClientKey) {
                        apiKeyManagement.activeKeyIndices[selectedProvider] = (currentKeyIndex + 1) % totalKeysForProvider;
                        saveApiKeyManagement();
                        if (settingsOverlay.classList.contains('active')) { renderApiKeysForProvider(selectedProvider); }
                    }

                    // --- Process Response based on Mode ---
                    if (currentMode === 'agent') {
                        processNpcActions(rawReply, npc, sourceTabId); // Provide feedback to the agent tab
                    } else { // 'main-chat' or 'npc-chat'
                        if (rawReply && rawReply.trim()) {
                            addMessageToHistoryAndUI(rawReply, npc.name, 'assistant', npc, sourceTabId);
                        } else {
                            addMessageToHistoryAndUI("...", npc.name, 'assistant', npc, sourceTabId); // Indicate empty reply
                        }
                    }
                    // --- End Response Handling ---

                    enableInput();

                } catch (error) {
                     console.error(`Error during API call attempt ${attempt} for ${selectedProvider} (Index ${currentKeyIndex}):`, error);
                     const shouldCycle = needsClientKey && ( error.message.includes("401") || error.message.includes("403") || error.message.includes("429") || error.message.toLowerCase().includes("invalid api key") || error.message.toLowerCase().includes("authentication failed") || error.message.toLowerCase().includes("permission denied") );
                     if (shouldCycle) {
                         addMessageToHistoryAndUI(`API key issue for ${providerConfig.name}. Trying next...`, 'SYSTEM', 'debug', null, sourceTabId);
                         setTimeout(() => getApiResponseFromProvider(userMessage, npc, sourceTabId, attempt + 1), 500); // Try next key
                     } else {
                         removeTypingIndicator();
                         let errorMessage = `Error contacting ${providerConfig.name}: ${error.message}`;
                         if (error.message.includes("blocked")) errorMessage = `Message blocked by ${providerConfig.name} content filters. (${error.message})`;
                         addMessageToHistoryAndUI(errorMessage, 'SYSTEM', 'error', null, sourceTabId);
                         enableInput();
                     }
                }
            }


            // --- Input Enable/Disable (Unchanged) ---
            function disableInput(){ userInput.disabled=true; sendButton.disabled=true; isWaitingForApiResponse = true; updateInputPlaceholder(); }
            function enableInput(){ userInput.disabled = false; sendButton.disabled = false; isWaitingForApiResponse = false; updateInputPlaceholder(); }

            // --- Player Send Logic (MODIFIED) ---
            function handlePlayerSend() {
                const msg = userInput.value.trim();
                if (!msg || sendButton.disabled) return;

                userInput.value = ''; userInput.style.height='auto';userInput.style.height=(userInput.scrollHeight)+'px';

                // Add user message to the history of the currently active tab
                addMessageToHistoryAndUI(msg, playerData.name, 'user', playerData, activeTabId);

                // Handle based on the *active* tab's mode
                switch(currentChatDisplayMode) {
                    case 'spatial':
                        if (typeof SpatialChat !== 'undefined' && SpatialChat.addPlayerMessageToScope) {
                            const added = SpatialChat.addPlayerMessageToScope(currentSpatialScope, playerData.name, msg);
                            if (added) displaySpatialChat(currentSpatialScope); // Re-render spatial view
                            else addMessageToHistoryAndUI("Could not send message to spatial scope.", "SYSTEM", "error", null, activeTabId);
                        } else { addMessageToHistoryAndUI("Spatial Chat module not available.", "SYSTEM", "error", null, activeTabId); }
                        userInput.focus(); // Re-focus input after sending spatial message
                        break;

                    case 'main-chat':
                        // Find closest NPC to talk to in the main chat
                        const closestNpc = findClosestNpc(true); // Log finding
                        if (closestNpc) {
                             // Goal 2: Automatically open/switch to NPC tab
                             const npcTabId = `npc-tab-${closestNpc.id}`;
                             openNpcChatTab(closestNpc, msg); // Pass the message along
                             // API call will be triggered by setActiveTab if it's a new tab,
                             // or we need to explicitly call if the tab already exists and is switched to.
                             // openNpcChatTab handles switching and rendering.
                             // We already added the user message to the *new* tab's history via openNpcChatTab.
                             // No need to call getApiResponseFromProvider directly here.
                        } else {
                             addMessageToHistoryAndUI("No one is close enough to talk to.", "SYSTEM", "info", null, activeTabId);
                             // Optionally, send to a generic 'Spirit' if desired, but current goal is NPC tabs
                             // disableInput();
                             // getApiResponseFromProvider(msg, { name: "Spirit", personaPrompt: "You are a helpful spirit..." }, activeTabId, 1);
                        }
                        break;

                    case 'npc-chat':
                         // Send API call for the specific NPC associated with this tab
                         if (currentAiNpcData) {
                             disableInput();
                             getApiResponseFromProvider(msg, currentAiNpcData, activeTabId, 1);
                         } else {
                             addMessageToHistoryAndUI("Error: No NPC associated with this chat tab.", "SYSTEM", "error", null, activeTabId);
                         }
                         break;

                    case 'agent':
                        // Send API call for the agent associated with this tab (or closest if none set)
                        const agentTarget = currentAiNpcData || findClosestNpc(false);
                        if (agentTarget) {
                             if(!currentAiNpcData) currentAiNpcData = agentTarget; // Set if found fallback
                             disableInput();
                             getApiResponseFromProvider(msg, agentTarget, activeTabId, 1);
                        } else {
                             addMessageToHistoryAndUI("No agent nearby to command.", "SYSTEM", "info", null, activeTabId);
                        }
                        break;

                    default:
                         console.error("Unhandled chat mode in handlePlayerSend:", currentChatDisplayMode);
                         addMessageToHistoryAndUI("Cannot send message in this mode.", "SYSTEM", "error", null, activeTabId);
                }
            }

            // --- Settings & Appearance Modals (Largely Unchanged Logic) ---
            function openSettingsModal() { populateSettingsModal(); settingsOverlay.classList.add('active'); }
            function closeSettingsModal() { settingsOverlay.classList.remove('active'); }
            function openAppearanceEditorModal(target = 'player') { /* ... (unchanged) ... */
                appearanceEditorTarget = target; temporaryAppearanceData = null; temporaryPfpData = null; let tA, tN, tP, tPf;
                appearanceEditorNameInput.value = ''; appearanceEditorPersonaInput.value = ''; appearancePfpPreview.src = '';
                if (target === 'player') { tA = playerData.appearance || JSON.parse(JSON.stringify(defaultPlayerAppearance)); tN = playerData.name || 'Player'; tP = playerData.personaPrompt || "You are the Player."; tPf = playerData.pfp || DEFAULT_PLAYER_PFP; }
                else { const n = npcData.find(n => n.id === target); if (!n) { console.error(`NPC ${target} not found for appearance editor`); return; } tA = n.appearance || JSON.parse(JSON.stringify(defaultNpcAppearance)); tN = n.name || `Agent ${target + 1}`; tP = n.personaPrompt || `You are ${tN}.`; tPf = n.pfp || DEFAULT_NPC_PFP; }
                appearanceEditorTitle.textContent = `Set Details for ${tN}`; appearanceEditorNameInput.value = tN; appearanceEditorPersonaInput.value = tP; appearancePfpPreview.src = tPf;
                if (characterCreatorFrame?.contentWindow) { setTimeout(() => { try { characterCreatorFrame.contentWindow.postMessage({ type: 'INIT_STYLE', payload: tA }, '*'); } catch (err) { console.error("Error sending message to creator iframe:", err); } }, 200); } else { console.error("Character creator iframe not accessible."); }
                appearanceEditorOverlay.classList.add('active');
             }
            function closeAppearanceEditorModal() { /* ... (unchanged, including reverting preview style) ... */
                appearanceEditorOverlay.classList.remove('active'); if (temporaryAppearanceData) { if (appearanceEditorTarget === 'player') { applyPlayerAppearance(playerData.appearance); } else { const n = npcData.find(n => n.id === appearanceEditorTarget); if (n?.appearance) applyNpcAppearance(n); } }
                appearanceEditorTarget = null; temporaryAppearanceData = null; temporaryPfpData = null; pfpUploadInput.value = '';
             }
            function saveAppearanceFromEditor() { /* ... (unchanged, saves to LS) ... */
                 let styleSaved=false, detailsSaved=false; const newName=appearanceEditorNameInput.value.trim(); const newPersona=appearanceEditorPersonaInput.value.trim();
                 const targetTabId = appearanceEditorTarget === 'player' ? null : `npc-tab-${appearanceEditorTarget}`; // Get potential tab ID

                 if (appearanceEditorTarget === 'player') {
                     if (newName && playerData.name !== newName) { playerData.name=newName; localStorage.setItem(LS_KEYS.playerName, playerData.name); updateNameplate(playerData); detailsSaved=true; updateSpatialChatModuleState(); }
                     if (playerData.personaPrompt !== newPersona) { playerData.personaPrompt=newPersona; localStorage.setItem(LS_KEYS.playerPersona, playerData.personaPrompt); detailsSaved=true; }
                     if (temporaryAppearanceData) { playerData.appearance = JSON.parse(JSON.stringify(temporaryAppearanceData)); localStorage.setItem(LS_KEYS.playerAppearance, JSON.stringify(playerData.appearance)); styleSaved=true; }
                     if (temporaryPfpData) { playerData.pfp = temporaryPfpData; localStorage.setItem(LS_KEYS.playerPfp, playerData.pfp); detailsSaved=true; }
                     if (styleSaved || detailsSaved) addMessageToHistoryAndUI(`Details${styleSaved?'/style':''}${temporaryPfpData?'/sigil':''} saved for Player.`, "SYSTEM", "system", null, activeTabId); // Add message to active tab
                 } else {
                     const npc = npcData.find(n => n.id === appearanceEditorTarget);
                     if (npc && currentCityKey) {
                         const oldName = npc.name;
                         const defaultNpcName = `Agent ${npc.id + 1}`;
                         if (npc.name !== (newName || defaultNpcName)) { npc.name = newName || defaultNpcName; localStorage.setItem(LS_KEYS.npcName(currentCityKey, npc.id), npc.name); updateNameplate(npc); detailsSaved=true; updateSpatialChatModuleState(); updateNpcTabName(npc.id, npc.name); } // Update tab name if open
                         if (npc.personaPrompt !== newPersona) { npc.personaPrompt = newPersona; localStorage.setItem(LS_KEYS.npcPersona(currentCityKey, npc.id), newPersona); detailsSaved=true; updateSpatialChatModuleState(); }
                         if (temporaryAppearanceData) { npc.appearance = JSON.parse(JSON.stringify(temporaryAppearanceData)); localStorage.setItem(LS_KEYS.npcAppearance(currentCityKey, npc.id), JSON.stringify(npc.appearance)); styleSaved=true; }
                         if (temporaryPfpData) { npc.pfp = temporaryPfpData; localStorage.setItem(LS_KEYS.npcPfp(currentCityKey, npc.id), npc.pfp); detailsSaved=true; }
                         if (styleSaved || detailsSaved) addMessageToHistoryAndUI(`Details${styleSaved?'/style':''}${temporaryPfpData?'/sigil':''} saved for ${npc.name}.`, "SYSTEM", "system", null, activeTabId); // Add message to active tab
                     } else { console.error(`Failed save appearance: NPC ${appearanceEditorTarget} not found/no city.`); addMessageToHistoryAndUI(`Error: Cannot find agent ${appearanceEditorTarget} to save details.`, "SYSTEM", "error", null, activeTabId); }
                 }
                 closeAppearanceEditorModal();
             }
            function handlePfpUpload(event) { /* ... (unchanged) ... */
                 const f = event.target.files[0]; if (!f) return; const r = new FileReader(); r.onload = (e) => { const u = e.target.result; temporaryPfpData = u; appearancePfpPreview.src = u; console.log("PFP Preview updated."); }; r.onerror = (e) => { console.error("FileReader err:", e); addMessageToHistoryAndUI("Error reading sigil file.", "SYSTEM", "error", null, activeTabId); temporaryPfpData = null; }; if (f.size > 2*1024*1024) { addMessageToHistoryAndUI("Sigil file too large (max 2MB).", "SYSTEM", "error", null, activeTabId); pfpUploadInput.value = ''; return; } r.readAsDataURL(f);
             }
            function showSettingsPage(pageNum) { /* ... (unchanged) ... */ currentSettingsPage = pageNum; const p = settingsBodyContainer.querySelectorAll('.settings-page'); p.forEach((pg, idx) => { pg.classList.toggle('active', (idx + 1) === pageNum); }); updatePaginationControls(); }
            function updatePaginationControls() { /* ... (unchanged) ... */ settingsPageIndicator.textContent=`Page ${currentSettingsPage} / ${TOTAL_SETTINGS_PAGES}`; settingsPrevBtn.disabled = currentSettingsPage === 1; settingsNextBtn.disabled = currentSettingsPage === TOTAL_SETTINGS_PAGES; }
            function populateSettingsModal(){ /* ... (unchanged - uses addMessage which now needs tabId, default to active) ... */
                settingsBodyContainer.innerHTML = ''; /* ... create pages ... */
                const p1 = document.getElementById('settings-page-1'); /* ... City/Map/UI sections ... */
                 const citySec = document.createElement('div'); /* ... */ p1.appendChild(citySec); populateCitySelectorInModal(citySelect); /* ... events ... */
                 const mapSizeSec=document.createElement('div'); /* ... */ p1.appendChild(mapSizeSec);
                 const uiSec = document.createElement('div'); /* ... */ p1.appendChild(uiSec);
                 // --- API Settings ---
                 const p2 = document.getElementById('settings-page-2'); const apiSec=document.createElement('div'); /* ... */ p2.appendChild(apiSec); // API Config + Key Management sections
                 /* ... populate provider/model selects and key list ... */
                  if (typeof PROVIDERS !== 'undefined') { /* ... */ } else { /* ... error handling ... */ }
                  const updateProviderSelectionUI = (providerKey) => { /* ... updates model select and calls renderApiKeys ... */ };
                  providerSelect.addEventListener('change', () => { /* ... updates selection and calls updateProviderSelectionUI ... */ });
                  modelSelect.addEventListener('change', () => { /* ... updates selection ... */ });
                  updateProviderSelectionUI(providerSelect.value); // Initial population
                 // --- NPC Settings ---
                 const p3 = document.getElementById('settings-page-3'); const npcSec=document.createElement('div'); /* ... */ p3.appendChild(npcSec);
                  /* ... create grid and populate items for npcData ... */
                  npcGrid.querySelectorAll('.settings-delete-btn').forEach(btn => { btn.addEventListener('click', handleDeleteNpcFromSettings); });
                 // --- Environment Settings ---
                 const p4 = document.getElementById('settings-page-4'); const envSec=document.createElement('div'); /* ... */ p4.appendChild(envSec);
                  /* ... populate items for environmentData ... */
                  envSec.querySelectorAll('.settings-delete-btn').forEach(btn => { btn.addEventListener('click', handleDeleteEnvFromSettings); });
                 // Disable inputs if no city
                 if (!currentCityKey) { /* ... disable relevant inputs ... */ }
                 showSettingsPage(1);
             }
             function saveSettings() { /* ... (unchanged logic, uses addMessage -> defaults to activeTabId) ... */
                 console.log("Saving settings..."); let changed = false, requiresReload = false, cityDefinition = null;
                 const hideSysMsgCb = document.getElementById('hideSystemMessagesCheckbox'); /* ... check hideSystemMessages ... */
                 if (currentCityKey) {
                     const cityDataString = localStorage.getItem(currentCityKey); /* ... parse cityDefinition ... */
                     if(cityDefinition) {
                         const widthInput = document.getElementById('mapWidthInput'); /* ... check map size ... */
                         document.querySelectorAll('#settings-page-3 .settings-item[data-npc-id]').forEach(item => { /* ... update npc name/persona in LS and runtime data ... */ if(npc.name !== newName) updateNpcTabName(id, newName); });
                         document.querySelectorAll('#settings-page-4 .settings-env-item[data-env-id]').forEach(item => { /* ... update env name in LS and runtime data ... */ });
                         if (changed || requiresReload) { localStorage.setItem(currentCityKey, JSON.stringify(cityDefinition)); }
                         saveNpcPositions(); savePlayerPosition();
                     }
                 } else if (!changed) { addMessageToHistoryAndUI("No changes detected.", "SYSTEM", "debug", null, activeTabId); closeSettingsModal(); return; }
                 closeSettingsModal(); addMessageToHistoryAndUI(changed ? "Settings saved." : "No changes made.", "SYSTEM", changed ? "system" : "debug", null, activeTabId);
                 if (requiresReload) { addMessageToHistoryAndUI("Map changes require reload. Reloading...", "SYSTEM", "system", null, activeTabId); setTimeout(() => window.location.reload(), 1000); }
             }

            // --- City/NPC/Env Management (Mostly Unchanged - use addMessageToHistoryAndUI) ---
            function saveNpcPositions(){ /* ... (unchanged) ... */ }
            function savePlayerPosition(){ /* ... (unchanged) ... */ }
            function addCity(){ /* ... (unchanged logic - uses addMessage) ... */ const n=prompt("Enter new city name:","My City");if(!n||!n.trim())return; const cN=n.trim(); const nK=USER_CITY_PREFIX+cN.replace(/\s+/g,'_')+'_'+Date.now(); /* ... create definition ... */ localStorage.setItem(nK,JSON.stringify(dC)); localStorage.setItem(LS_KEYS.selectedCity,nK); addMessageToHistoryAndUI(`Created new city: ${cN}. Reloading...`,"SYSTEM","system", null, activeTabId); closeSettingsModal(); setTimeout(() => window.location.reload(), 300); }
            function deleteCity(){ /* ... (unchanged logic - uses addMessage) ... */ if(!currentCityKey||!currentCityKey.startsWith(USER_CITY_PREFIX)){alert("Only user-created cities (*) can be deleted.");return;} const s=document.getElementById('settingsCitySelector'); const cN=s?s.options[s.selectedIndex].text:currentCityKey; if(!confirm(`DELETE city "${cN}"? IRREVERSIBLE!`))return; /* ... remove data ... */ localStorage.setItem(LS_KEYS.selectedCity,nK||""); addMessageToHistoryAndUI(`Deleted city: ${cN.replace('* ','')}. Reloading...`,"SYSTEM","system", null, activeTabId); closeSettingsModal(); setTimeout(() => window.location.reload(), 300); }
            function modifyCurrentCityDefinition(cb){ /* ... (unchanged logic - uses addMessage) ... */ if(!currentCityKey) return false; const s=localStorage.getItem(currentCityKey); if(!s){addMessageToHistoryAndUI("Error: Current city data not found.", "SYSTEM", "error", null, activeTabId); return false;} try{let cD=JSON.parse(s);cb(cD);localStorage.setItem(currentCityKey,JSON.stringify(cD));return true;}catch(e){addMessageToHistoryAndUI("Error modifying city definition: "+e.message, "SYSTEM", "error", null, activeTabId); console.error(e); return false;} }
            function addNpcAtPlayer(){ /* ... (unchanged logic - uses addMessage) ... */ if (!currentCityKey||playerData.element.style.display==='none'){addMessageToHistoryAndUI("Cannot add agent: No city/player.", "SYSTEM", "error", null, activeTabId); return;} const iN=prompt("Enter name:","New Agent"); if (!iN||!iN.trim()) return; const ok=modifyCurrentCityDefinition(def=>{ /* ... add to npcSpawns ... */ }); if(ok){ addMessageToHistoryAndUI(`Added definition for '${iN.trim()}'. Reload needed.`,"SYSTEM","system", null, activeTabId); if(confirm("Agent added. Reload map?")) { /* ... save pos & reload ... */ } else { /* ... remind to reload ... */ } } }
            function handleDeleteNpcFromSettings(event, npcIdToDelete = null) { /* ... (unchanged logic - uses addMessage) ... */ if (!currentCityKey) { addMessageToHistoryAndUI("Cannot remove: No city.", "SYSTEM", "error", null, activeTabId); return; } const id=npcIdToDelete !== null ? npcIdToDelete : parseInt(event?.target?.dataset?.npcId, 10); if (isNaN(id)) return; const n=npcData.find(n => n.id === id); const nN=n?n.name:`Agent ${id+1}`; if (!confirm(`Remove agent "${nN}" definition?`)) return; let dM=false; const ok=modifyCurrentCityDefinition(def => { /* ... remove from npcSpawns ... */ }); if (ok&&dM) { /* ... remove LS items ... */ const iR=npcData.findIndex(n => n.id === id); if (iR > -1) { /* ... remove element ... */ npcData.splice(iR, 1); addMessageToHistoryAndUI(`Removed agent from session: ${nN}.`, "SYSTEM", "system", null, activeTabId); } else { addMessageToHistoryAndUI(`Removed definition for: ${nN}.`, "SYSTEM", "system", null, activeTabId); } closeNpcChatTab(id); updateInputPlaceholder(); updateSpatialChatModuleState(); if(settingsOverlay.classList.contains('active')) populateSettingsModal(); } else { /* ... error messages ... */ } }
            function addEnvAtPlayer(){ /* ... (unchanged logic - uses addMessage) ... */ }
            function findClosestEnvironmentZone() { /* ... (unchanged) ... */ }
            function handleDeleteEnvFromSettings(event, envIdToDelete = null) { /* ... (unchanged logic - uses addMessage) ... */ }

             // --- Spatial Chat Update Function (Unchanged) ---
             function updateSpatialChatModuleState() {
                 if (typeof SpatialChat === 'undefined' || !SpatialChat.updateState) return;
                 if (!currentCityKey) { SpatialChat.updateState({ currentCity: null, currentArea: null }, [], {}, null); return; }
                 const currentPlayerArea = findCurrentAreaName(playerData.x, playerData.y, environmentData);
                 const currentPlayerState = { x: playerData.x, y: playerData.y, currentCity: currentCityKey, currentArea: currentPlayerArea, name: playerData.name };
                 const currentNpcs = npcData.map(npc => ({ id: npc.id, name: npc.name, x: npc.x, y: npc.y, personality: npc.personaPrompt, currentCity: currentCityKey, currentArea: findCurrentAreaName(npc.x, npc.y, environmentData) }));
                 const currentCities = {}; if (currentCityKey) currentCities[currentCityKey] = {};
                 const currentDisplay = currentChatDisplayMode === 'spatial' ? currentSpatialScope : null;
                 SpatialChat.updateState(currentPlayerState, currentNpcs, currentCities, currentDisplay);
            }

             // --- Helper to get History Key from Tab ID ---
             function getHistoryKeyForTab(tabId) {
                 if (!tabId) return 'main'; // Default if no tab ID provided
                 if (tabId === 'main-chat-tab' || tabId === 'agent-tab') return 'main'; // Agent mode shares main history for now
                 if (tabId.startsWith('npc-tab-')) return tabId.replace('npc-tab-', 'npc-');
                 // Spatial tabs don't have direct history in npcChatHistories
                 if (tabId === 'area-tab' || tabId === 'city-tab' || tabId === 'world-tab') return null;
                 return 'main'; // Fallback
             }

            // --- Tab Switching Logic (REWRITTEN) ---
            function setActiveTab(tabButton) {
                if (!tabButton) {
                    console.warn("setActiveTab called with null button. Falling back to main chat.");
                    tabButton = document.getElementById('main-chat-tab');
                    if (!tabButton) return; // Serious issue if main tab doesn't exist
                }

                const newTabId = tabButton.id;
                const newMode = tabButton.dataset.mode;
                const newScope = tabButton.dataset.scope; // Only for spatial
                const newNpcId = tabButton.dataset.npcId ? parseInt(tabButton.dataset.npcId, 10) : null;

                console.log(`Switching Tab: ID=${newTabId}, Mode=${newMode}, Scope=${newScope || 'N/A'}, NPC=${newNpcId ?? 'N/A'}`);

                // Deactivate previous tab
                const currentActive = chatTabsArea.querySelector('.active-tab');
                if (currentActive) currentActive.classList.remove('active-tab');

                // Activate new tab
                tabButton.classList.add('active-tab');
                activeTabId = newTabId;
                currentChatDisplayMode = newMode;
                localStorage.setItem(LS_KEYS.currentChatDisplayMode, currentChatDisplayMode); // Save the general mode

                // Stop/Start Spatial Chat Bot
                if (newMode === 'spatial') {
                    if (typeof SpatialChat !== 'undefined' && SpatialChat.start) SpatialChat.start();
                    clearInterval(spatialChatRenderIntervalId); // Clear existing render interval
                    spatialChatRenderIntervalId = setInterval(() => { if (currentChatDisplayMode === 'spatial') displaySpatialChat(currentSpatialScope); }, 3000);
                } else {
                    if (typeof SpatialChat !== 'undefined' && SpatialChat.stop) SpatialChat.stop();
                    clearInterval(spatialChatRenderIntervalId);
                    spatialChatRenderIntervalId = null;
                }

                // Update State (NPC target, Scope) and Render Content
                chatMessages.innerHTML = ''; // Clear display area
                currentAiNpcData = null; // Reset NPC context by default

                switch (newMode) {
                    case 'spatial':
                        currentSpatialScope = newScope || 'Area'; // Default if missing
                        updateSpatialChatModuleState(); // Update spatial module's view
                        displaySpatialChat(currentSpatialScope); // Render spatial messages
                        enableInput();
                        break;
                    case 'main-chat':
                    case 'agent':
                        // These modes use the 'main' history. Agent might target closest NPC.
                        currentAiNpcData = (newMode === 'agent') ? findClosestNpc(false) : null; // Agent targets closest, main doesn't pre-target
                        renderHistoryForTab('main-chat-tab'); // Render 'main' history
                        enableInput();
                        userInput.focus();
                        break;
                    case 'npc-chat':
                        if (newNpcId !== null) {
                            currentAiNpcData = npcData.find(n => n.id === newNpcId);
                            if (!currentAiNpcData) {
                                console.error(`Could not find NPC data for ID ${newNpcId}`);
                                // Optionally close the tab automatically or show an error
                                closeNpcChatTab(newNpcId); // Close the broken tab
                                setActiveTab(document.getElementById('main-chat-tab')); // Switch back to main
                                return;
                            }
                             renderHistoryForTab(newTabId); // Render this NPC's history
                             enableInput();
                             userInput.focus();
                        } else {
                             console.error("NPC Chat tab activated without NPC ID!");
                             setActiveTab(document.getElementById('main-chat-tab')); // Fallback
                             return;
                        }
                        break;
                    default:
                        console.error("Unknown tab mode:", newMode);
                        renderHistoryForTab('main-chat-tab'); // Fallback to main history
                        enableInput();
                }

                updateInputPlaceholder(); // Update placeholder based on new mode/target
            }

            // --- NEW Tab Management Functions ---

            // Creates or focuses an NPC tab
            function openNpcChatTab(npc, initialMessage = null) {
                if (!npc || npc.id === undefined) return;
                const tabId = `npc-tab-${npc.id}`;
                let tabButton = document.getElementById(tabId);

                if (!tabButton) {
                    // Create Tab Button
                    tabButton = document.createElement('button');
                    tabButton.id = tabId;
                    tabButton.className = 'npc-tab-button'; // Base class
                    tabButton.dataset.mode = 'npc-chat';
                    tabButton.dataset.npcId = npc.id;
                    tabButton.title = `Chat with ${npc.name}`;

                    const tabText = document.createElement('span');
                    tabText.textContent = npc.name;
                    tabText.style.overflow = 'hidden';
                    tabText.style.textOverflow = 'ellipsis';
                    tabText.style.whiteSpace = 'nowrap';
                    tabText.style.maxWidth = '100px'; // Adjust as needed
                    tabText.style.display = 'inline-block'; // Needed for ellipsis

                    const closeButton = document.createElement('button');
                    closeButton.className = 'npc-tab-close';
                    closeButton.innerHTML = '×'; // '×' symbol
                    closeButton.title = `Close chat with ${npc.name}`;
                    closeButton.dataset.npcId = npc.id;
                    closeButton.onclick = (e) => {
                        e.stopPropagation(); // Prevent tab activation when clicking close
                        closeNpcChatTab(npc.id);
                    };

                    tabButton.appendChild(tabText);
                    tabButton.appendChild(closeButton);

                    // Add click listener to switch to this tab
                    tabButton.addEventListener('click', () => setActiveTab(tabButton));

                    dynamicNpcTabsContainer.appendChild(tabButton);

                     // Ensure history array exists for the new tab
                     const historyKey = getHistoryKeyForTab(tabId);
                     if (!npcChatHistories[historyKey]) {
                         npcChatHistories[historyKey] = [];
                         console.log(`Initialized history for ${historyKey}`);
                     }
                }

                // Switch to the tab
                setActiveTab(tabButton);

                // If an initial message was provided (e.g., from main chat redirect), add it and trigger API call
                if (initialMessage) {
                    // Add user message to *this new* tab's history
                    addMessageToHistoryAndUI(initialMessage, playerData.name, 'user', playerData, tabId);
                    // Trigger API call for this NPC tab
                    if(currentAiNpcData) { // Should be set by setActiveTab
                         disableInput();
                         getApiResponseFromProvider(initialMessage, currentAiNpcData, tabId, 1);
                    }
                }
            }

             // Updates the name displayed on an NPC tab if it's open
             function updateNpcTabName(npcId, newName) {
                 const tabId = `npc-tab-${npcId}`;
                 const tabButton = document.getElementById(tabId);
                 if (tabButton) {
                     const textSpan = tabButton.querySelector('span');
                     if (textSpan) textSpan.textContent = newName;
                     tabButton.title = `Chat with ${newName}`;
                     const closeButton = tabButton.querySelector('.npc-tab-close');
                     if(closeButton) closeButton.title = `Close chat with ${newName}`;
                 }
             }


            // Closes an NPC tab and removes its history
            function closeNpcChatTab(npcId) {
                const tabId = `npc-tab-${npcId}`;
                const tabButton = document.getElementById(tabId);
                if (!tabButton) return;

                const historyKey = getHistoryKeyForTab(tabId);

                // Remove the tab button
                tabButton.remove();

                // Remove the history for this NPC
                if (npcChatHistories[historyKey]) {
                    delete npcChatHistories[historyKey];
                    saveNpcChatHistories(); // Save the change
                    console.log(`Closed tab and removed history for ${historyKey}`);
                }

                // If the closed tab was the active one, switch to main chat
                if (activeTabId === tabId) {
                    setActiveTab(document.getElementById('main-chat-tab'));
                }
            }

             // --- NEW Clear All Chat Functionality ---
             function handleClearAllChat() {
                 if (!confirm("Clear ALL chat histories (NPC tabs, Main Chat, Agent Context) and Spatial Chat messages? This cannot be undone.")) {
                     return;
                 }
                 console.log("Clearing all chat data...");

                 // 1. Clear NPC-specific and Main histories
                 npcChatHistories = { 'main': [] }; // Reset to just an empty main history
                 saveNpcChatHistories(); // Save the cleared state

                 // 2. Clear Spatial Chat messages
                 if (typeof SpatialChat !== 'undefined' && SpatialChat.clearAllMessages) {
                     SpatialChat.clearAllMessages();
                 }

                 // 3. Clear Agent Mode recent events
                 recentEvents = [];

                 // 4. Close all dynamic NPC tabs
                 const dynamicTabs = dynamicNpcTabsContainer.querySelectorAll('.npc-tab-button');
                 dynamicTabs.forEach(tab => tab.remove());

                 // 5. Reset current view to main chat and clear display
                 setActiveTab(document.getElementById('main-chat-tab')); // Switch to main chat
                 // setActiveTab already clears chatMessages, but we can do it again just to be sure
                 chatMessages.innerHTML = '';
                 renderHistoryForTab('main-chat-tab'); // Render the now empty main history

                 addMessageToHistoryAndUI("All chat histories and contexts cleared.", "SYSTEM", "system", null, 'main-chat-tab');
                 console.log("All chat data cleared.");
            }


            // --- Display Spatial Chat Function (Unchanged) ---
            function displaySpatialChat(scope) {
                 if (typeof SpatialChat === 'undefined' || !SpatialChat.getMessagesForScope) { chatMessages.innerHTML = '<p style="color:red;">Error: SpatialChat module not loaded.</p>'; return; }
                 const playerArea = findCurrentAreaName(playerData.x, playerData.y, environmentData);
                 const messages = SpatialChat.getMessagesForScope(scope, currentCityKey, playerArea);
                 renderSpatialChatMessages(messages); // Uses the separate rendering function
            }

            // --- Initialization (MODIFIED) ---
            function initializeSimulation(cityKey) {
                console.log(`Initializing simulation for city: ${cityKey}`);
                if(npcFollowInterval) clearInterval(npcFollowInterval);
                if(spatialChatUpdateIntervalId) clearInterval(spatialChatUpdateIntervalId);
                if(spatialChatRenderIntervalId) clearInterval(spatialChatRenderIntervalId);

                // --- Basic Setup & API/History Loading ---
                 if (typeof PROVIDERS === 'undefined' || typeof SpatialChat === 'undefined') { /* ... fatal error handling ... */ return; }
                 loadApiKeyManagement();
                 loadNpcChatHistories(); // Load NPC histories instead of single history

                 // --- API Provider/Model Selection (Unchanged) ---
                 selectedProvider = localStorage.getItem(LS_KEYS.selectedProvider); /* ... select provider ... */
                 const providerConfig = selectedProvider ? PROVIDERS[selectedProvider] : null;
                 const savedModel = localStorage.getItem(LS_KEYS.selectedModel); /* ... select model ... */
                 console.log(`API Initialized: Provider=${selectedProvider || 'None'}, Model=${selectedModel || 'None'}`);

                // --- Reset UI & Load City Definition ---
                chatMessages.innerHTML=''; mapContent.innerHTML=''; mapContent.appendChild(playerElement); dynamicNpcTabsContainer.innerHTML = ''; // Clear dynamic tabs
                playerElement.style.display='block'; gameWorld.style.display='block';
                currentCityKey=cityKey;
                const cityDataString=localStorage.getItem(cityKey); let cityDefinition=null;
                if(cityDataString){try{cityDefinition=JSON.parse(cityDataString);}catch(e){/* ... error handling ... */}}
                if(!cityDefinition){ addMessageToHistoryAndUI(`FATAL: Could not load city data for "${cityKey}".`, "SYSTEM","error", null, 'main-chat-tab'); disableInput(); currentCityKey=null; return; }
                console.log(`Using city: ${cityDefinition.meta?.cityName||cityKey}`);
                MAP_WIDTH=cityDefinition.map?.width??2000; MAP_HEIGHT=cityDefinition.map?.height??1500;
                mapContent.style.width=`${MAP_WIDTH}px`; mapContent.style.height=`${MAP_HEIGHT}px`;

                // --- UI State Restoration ---
                currentSpatialScope = 'Area'; // Default spatial scope
                hideSystemMessages=localStorage.getItem(LS_KEYS.hideSystemMessages)==='true';
                recentEvents=[]; // Reset agent events
                const savedTabsVisibility = localStorage.getItem(LS_KEYS.chatTabsVisible);
                setChatTabsVisibility(savedTabsVisibility === null || savedTabsVisibility === 'true');
                const savedChatHeight=localStorage.getItem(LS_KEYS.chatAreaHeight); /* ... restore height ... */ doChatResize();

                 // --- Player Setup (Unchanged) ---
                playerData.element=playerElement; /* ... set player properties, position, appearance ... */
                applyPlayerAppearance(playerData.appearance); updateNameplate(playerData); updateCharacterPosition(playerData);
                playerElement.removeEventListener('contextmenu', handlePlayerContextMenu); playerElement.addEventListener('contextmenu', handlePlayerContextMenu);

                 // --- Environment & NPC Setup (Unchanged logic) ---
                environmentData.length=0; (cityDefinition.environments||[]).forEach((envDef,idx)=>{ /* ... create env zones ... */ });
                npcData.length=0; (cityDefinition.npcSpawns||[]).forEach((spawnDef,idx)=>{ /* ... create NPCs, load saved data ... */ });
                console.log(`Created ${environmentData.length} zones, ${npcData.length} NPCs.`);

                viewportWidth=gameWorld.offsetWidth; viewportHeight=gameWorld.offsetHeight; updateCameraPosition();
                initialSpeakerData=findClosestNpc(true); // Still useful as a fallback
                currentAiNpcData = null; // Let setActiveTab handle targeting

                 // --- Initialize SpatialChat Module (Unchanged) ---
                 if (typeof SpatialChat !== 'undefined' && SpatialChat.init) { /* ... init SpatialChat ... */ }
                 else { console.error("SpatialChat module not loaded!"); addMessageToHistoryAndUI("Error: Spatial Chat unavailable.", "SYSTEM", "error", null, 'main-chat-tab'); }

                 // --- Set Initial Tab (Default to Main Chat) ---
                 const initialTabButton = document.getElementById('main-chat-tab') || chatTabsArea.querySelector('button'); // Fallback to first button
                 setActiveTab(initialTabButton); // Start on the main chat tab

                // --- Welcome Messages ---
                const welcomeMsg = `Welcome to ${cityDefinition.meta?.cityName||'the Simulation'}.`;
                const providerNameForMsg = (providerConfig && providerConfig.name) ? providerConfig.name : (selectedProvider || 'None');
                addMessageToHistoryAndUI(welcomeMsg, "Tome", 'system', null, 'main-chat-tab'); // Add to main chat history
                addMessageToHistoryAndUI(`API: ${providerNameForMsg} (${selectedModel || 'N/A'}).`, "Tome", 'system', null, 'main-chat-tab');


                // Start intervals
                npcFollowInterval=setInterval(updateFollowingNpcs, 200);
                spatialChatUpdateIntervalId = setInterval(updateSpatialChatModuleState, 1000); // Keep updating spatial state

                console.log(`Initialization complete for: ${cityDefinition.meta?.cityName}. Initial Tab: ${activeTabId}.`);
            }

            function enterNoCityState() { // MODIFIED
                console.log("Entering No City state.");
                if(npcFollowInterval) clearInterval(npcFollowInterval); if(spatialChatUpdateIntervalId) clearInterval(spatialChatUpdateIntervalId); if(spatialChatRenderIntervalId) clearInterval(spatialChatRenderIntervalId);
                if (typeof SpatialChat !== 'undefined' && SpatialChat.stop) SpatialChat.stop();

                currentCityKey=null; chatMessages.innerHTML=''; mapContent.innerHTML=''; mapContent.appendChild(playerElement); dynamicNpcTabsContainer.innerHTML = '';
                playerElement.style.display='none'; playerData.x=undefined; playerData.y=undefined;
                npcData.length=0; environmentData.length=0;
                mapContent.style.width='100%'; mapContent.style.height='100%'; mapContent.style.transform='translate3d(0,0,0)';
                gameWorld.style.display='none';

                loadApiKeyManagement(); // Still load API keys
                loadNpcChatHistories(); // Load/initialize history object

                selectedProvider = localStorage.getItem(LS_KEYS.selectedProvider); /* ... select provider/model ... */
                hideSystemMessages=localStorage.getItem(LS_KEYS.hideSystemMessages)==='true';
                const savedTabsVisibility = localStorage.getItem(LS_KEYS.chatTabsVisible);
                setChatTabsVisibility(savedTabsVisibility === null || savedTabsVisibility === 'true');

                // Initialize SpatialChat even without a city for consistency
                if (typeof SpatialChat !== 'undefined' && SpatialChat.init) { SpatialChat.init({}, { player: { name: playerData.name || 'Player', currentCity: null }, npcs: [], cities: {} }); SpatialChat.stop(); }

                // Set initial tab to main chat
                setActiveTab(document.getElementById('main-chat-tab'));

                addMessageToHistoryAndUI("Welcome! No city loaded. Open Settings (click sigil) to add/select.", "SYSTEM", "system", null, 'main-chat-tab');

                // Disable tabs that require a city
                ['agent-tab', 'area-tab', 'city-tab', 'world-tab'].forEach(id => { const btn = document.getElementById(id); if (btn) btn.disabled = true; });
                clearAllChatBtn.disabled = true; // Disable clear button too

                openSettingsModal(); // Guide user to create/select a city
            }

            function doChatResize() { /* ... (unchanged) ... */ }
            function saveChatHeight() { /* ... (unchanged) ... */ }
            function toggleFullscreenChat() { /* ... (unchanged) ... */ }


            // --- Event Listeners (MODIFIED) ---
            document.addEventListener('keydown',(e)=>{ /* ... (unchanged player movement) ... */ });
            userInput.addEventListener('keypress',(e)=>{if(e.key==='Enter'&&!sendButton.disabled&&!e.shiftKey){e.preventDefault();handlePlayerSend();}});
            userInput.addEventListener('input',()=>{userInput.style.height='auto';userInput.style.height=(userInput.scrollHeight)+'px';});
            sendButton.addEventListener('click',()=>{if(!sendButton.disabled)handlePlayerSend();});
            modalCloseBtn.addEventListener('click',closeSettingsModal); modalCancelBtn.addEventListener('click',closeSettingsModal); modalSaveBtn.addEventListener('click',saveSettings);
            settingsOverlay.addEventListener('click',(e)=>{if(e.target===settingsOverlay)closeSettingsModal();});
            settingsPrevBtn.addEventListener('click',()=>{if(currentSettingsPage>1)showSettingsPage(currentSettingsPage-1);}); settingsNextBtn.addEventListener('click',()=>{if(currentSettingsPage<TOTAL_SETTINGS_PAGES)showSettingsPage(currentSettingsPage+1);});
            appearanceEditorCloseBtn.addEventListener('click', closeAppearanceEditorModal); appearanceEditorCancelBtn.addEventListener('click', closeAppearanceEditorModal); appearanceEditorSaveBtn.addEventListener('click', saveAppearanceFromEditor);
            appearanceEditorOverlay.addEventListener('click',(e)=>{if(e.target===appearanceEditorOverlay)closeAppearanceEditorModal();});
            appearancePfpPreview.addEventListener('click',()=>pfpUploadInput.click()); appearancePfpChangeBtn.addEventListener('click',()=>pfpUploadInput.click());
            pfpUploadInput.addEventListener('change', handlePfpUpload);
            window.addEventListener('resize',()=>{if(currentCityKey){viewportWidth=gameWorld.offsetWidth;viewportHeight=gameWorld.offsetHeight;doChatResize();updateInputPlaceholder();}});
            clearAllChatBtn.addEventListener('click', handleClearAllChat); // Listener for Clear All

            // Context Menu Listener (NPC) - MODIFIED 'talk' action
            npcContextMenu.addEventListener('click', (e) => {
                 if (e.target.classList.contains('context-menu-item')) {
                     const action = e.target.dataset.action;
                     const targetNpc = npcData.find(n => n.id === contextMenuTargetNpcId);
                     if (!targetNpc) { console.error(`NPC ${contextMenuTargetNpcId} not found.`); closeAllContextMenus(); return; }

                     console.log(`Action: ${action} on ${targetNpc.name} (ID: ${targetNpc.id})`);
                     switch (action) {
                         case 'talk': // Open/Switch to NPC tab
                             openNpcChatTab(targetNpc);
                             break;
                         case 'command': // Switch to AGENT mode, targeting this NPC
                             currentAiNpcData = targetNpc; // Set the target for agent mode
                             setActiveTab(document.getElementById('agent-tab'));
                             addMessageToHistoryAndUI(`Agent mode activated for ${targetNpc.name}.`, 'SYSTEM', 'system', null, 'main-chat-tab'); // Add msg to main history
                             break;
                         case 'toggleFollow':
                              // Pass the *currently active* tab ID for feedback message placement
                             if (targetNpc.followingTargetId !== null) handleUnfollowAction(targetNpc, activeTabId);
                             else handleFollowAction(targetNpc, activeTabId);
                             break;
                         case 'appearance': openAppearanceEditorModal(targetNpc.id); break;
                         case 'cancel': break;
                     }
                     closeAllContextMenus();
                 }
             });

            playerContextMenu.addEventListener('click',(e)=>{ /* ... (unchanged) ... */ });
            pfpContextMenu.addEventListener('click', (e) => { /* ... (unchanged) ... */ });

            // Add listeners ONLY to static tabs initially
            ['main-chat-tab', 'agent-tab', 'area-tab', 'city-tab', 'world-tab'].forEach(id => {
                 const tab = document.getElementById(id);
                 if (tab) tab.addEventListener('click', () => setActiveTab(tab));
             });
             // Dynamic tab listeners are added in openNpcChatTab

            window.addEventListener('beforeunload',(e)=>{ if(currentCityKey){saveNpcPositions();savePlayerPosition(); saveChatHeight();} if(npcFollowInterval) clearInterval(npcFollowInterval); if(spatialChatUpdateIntervalId) clearInterval(spatialChatUpdateIntervalId); if(spatialChatRenderIntervalId) clearInterval(spatialChatRenderIntervalId); if (typeof SpatialChat !== 'undefined' && SpatialChat.stop) SpatialChat.stop(); /* localStorage.setItem(LS_KEYS.currentChatDisplayMode, currentChatDisplayMode); */ /* No need to save mode, determined by active tab */ saveNpcChatHistories(); }); // Save NPC histories
            window.addEventListener('message', receiveCreatorData);
            function receiveCreatorData(event) { /* ... (unchanged) ... */ }


            // --- Initial Execution ---
            let cityKeyToLoad=localStorage.getItem(LS_KEYS.selectedCity); /* ... find valid city key ... */
            if (cityKeyToLoad) { initializeSimulation(cityKeyToLoad); }
            else { enterNoCityState(); }

        } // End runSimulation

        document.addEventListener('DOMContentLoaded', runSimulation);
    </script>

</body>
</html>
