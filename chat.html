<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcane Tome</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- ### ADD IDB LIBRARY ### -->
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
    <!-- Optional: Add DOMPurify for security -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.8/purify.min.js"></script> -->

    <!-- Link to the external CSS file -->
    <link rel="stylesheet" href="chat-style.css">

</head>
<body>
    <div class="tome">
        <div class="pages" id="pages"></div>
        <div class="writing-area">
            <textarea class="message-input" id="message-input" placeholder="Write your message here..." rows="1"></textarea>
            <button class="send-button" id="send-button"><span>Send</span><span>✒</span></button>
        </div>
    </div>

    <!-- Settings Modal (Unchanged) -->
    <div class="modal-overlay" id="settings-modal"> <div class="modal-content"> <div class="modal-header"> <h3 class="modal-title">Tome Settings</h3> <button class="close-btn" id="close-modal">×</button> </div> <div class="modal-body"> <!-- Guidance --> <div class="settings-section"> <h4 class="settings-section-title"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" /></svg> Spirit Guidance </h4> <div class="guidance-controls"> <select class="guidance-select" id="guidance-select"><option value="">Select saved guidance...</option></select> <button class="small-button button-primary" id="save-guidance-btn">Save</button> <button class="small-button button-danger" id="remove-guidance-btn">Remove</button> </div> <textarea class="system-prompt-input" id="system-prompt-input" placeholder="How should the spirit behave?"></textarea> </div> <!-- Tools --> <div class="settings-section"> <h4 class="settings-section-title"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg> Conversation Tools </h4> <div style="display: flex; gap: 10px;"> <button class="small-button button-danger" id="new-chat-btn">Start New Chat</button> <button class="small-button button-primary" id="undo-btn">Undo Last Message</button> </div> </div> <!-- Avatars --> <div class="settings-section"> <h4 class="settings-section-title"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.121 17.804A13.937 13.937 0 0112 16c2.5 0 4.847.655 6.879 1.804M15 10a3 3 0 11-6 0 3 3 0 016 0zm6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg> Avatar Settings </h4> <div class="avatar-preview-container"> <div class="avatar-preview"><span class="avatar-preview-label">Your Sigil</span><img src="" class="avatar-img" id="user-avatar-preview"></div> <div class="avatar-preview"><span class="avatar-preview-label">Spirit's Sigil</span><img src="" class="avatar-img" id="spirit-avatar-preview"></div> </div> </div> </div> <div class="modal-footer"> <button class="modal-btn modal-btn-secondary" id="cancel-btn">Cancel</button> <button class="modal-btn modal-btn-primary" id="save-btn">Save</button> </div> </div> </div>
    <!-- Hidden File Input (Unchanged) -->
    <input type="file" class="pfp-upload" id="pfp-upload" accept="image/*">

    <!-- Secret Menu (Unchanged - Note: inline styles remain here) -->
    <div id="api-key-menu" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #e3d5b8; border: 1px solid #3a3129; padding: 15px; font-size: 0.9rem; z-index: 200; box-shadow: 0 5px 15px rgba(0,0,0,0.4); border-radius: 4px; min-width: 350px; max-width: 90%; max-height: 80vh; overflow-y: auto; color: var(--ink);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;"> <span style="font-weight: bold; font-family: 'Cinzel Decorative', cursive;">Secrets & Providers</span> <button id="close-api-menu" style="background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0 5px; color: var(--ink-light);">×</button> </div>
        <div style="margin-bottom: 15px; border-bottom: 1px dashed var(--ink-light); padding-bottom: 15px;"> <label for="provider-select">API Provider:</label> <select id="provider-select"></select> <label for="model-select">Model:</label> <select id="model-select"></select> </div>
        <div style="margin-bottom: 15px;"> <span style="font-weight: bold; display: block; margin-bottom: 5px; font-family: 'Cinzel Decorative', cursive; font-size: 1rem;" id="api-key-section-title">API Keys for [Provider]</span> <div id="api-key-list"> <p style="font-style: italic; color: #5a4e42; text-align: center; padding: 5px 0;">Select a provider.</p> </div> <div class="api-key-controls"> <input type="text" id="new-api-key-input" placeholder="Add API Key for selected provider"> <button id="add-api-key-btn">Add</button> </div> <p class="active-key-line">Active Key: <strong id="current-active-key-display">None</strong></p> </div>
        <div id="saved-chats-section"> <span style="font-weight: bold; display: block; margin-bottom: 5px; font-family: 'Cinzel Decorative', cursive; font-size: 1rem;">Saved Chats</span> <div id="saved-chats-list-items"> <p style="font-style: italic; color: #5a4e42; text-align: center; padding: 10px 0;" id="chats-loading-msg">Checking storage...</p> </div> </div>
        <!-- Danger Zone Section REMOVED -->
    </div>

    <!-- Reference to the external script file -->
    <script src="api_providers.js"></script>

    <!-- Your main script with IndexedDB -->
    <script>
        // Ensure PROVIDERS is available
        if (typeof PROVIDERS === 'undefined') { alert("Critical Error: api_providers.js failed to load."); }
        // Ensure idb library is available
        if (typeof idb === 'undefined') { alert("Critical Error: idb library failed to load."); }

        // Configure marked.js
        marked.setOptions({ breaks: true, gfm: true, smartypants: true });

        // State Management
        const state = { conversationHistory: [], userPfp: '', botPfp: '', currentAvatarBeingEdited: null, isWaitingForResponse: false, savedPrompts: {}, currentChatId: null, selectedProvider: null, selectedModel: null };
        const apiKeyManagement = { providerKeys: {}, activeKeys: {} };

        // --- REMOVED Android Interface Check ---

        // DOM Elements (Unchanged)
        const pages = document.getElementById('pages'); const messageInput = document.getElementById('message-input'); const sendButton = document.getElementById('send-button'); const settingsModal = document.getElementById('settings-modal'); const systemPromptInput = document.getElementById('system-prompt-input'); const userAvatarPreview = document.getElementById('user-avatar-preview'); const spiritAvatarPreview = document.getElementById('spirit-avatar-preview'); const closeModalBtn = document.getElementById('close-modal'); const cancelBtn = document.getElementById('cancel-btn'); const saveBtn = document.getElementById('save-btn'); const pfpUpload = document.getElementById('pfp-upload'); const guidanceSelect = document.getElementById('guidance-select'); const saveGuidanceBtn = document.getElementById('save-guidance-btn'); const removeGuidanceBtn = document.getElementById('remove-guidance-btn'); const newChatBtn = document.getElementById('new-chat-btn'); const undoBtn = document.getElementById('undo-btn'); const apiKeyMenu = document.getElementById('api-key-menu'); const closeApiMenuBtn = document.getElementById('close-api-menu'); const providerSelect = document.getElementById('provider-select'); const modelSelect = document.getElementById('model-select'); const apiKeySectionTitle = document.getElementById('api-key-section-title'); const apiKeyListDiv = document.getElementById('api-key-list'); const newApiKeyInput = document.getElementById('new-api-key-input'); const addApiKeyBtn = document.getElementById('add-api-key-btn'); const currentActiveKeyDisplay = document.getElementById('current-active-key-display'); const savedChatsListItems = document.getElementById('saved-chats-list-items'); const chatsLoadingMsg = document.getElementById('chats-loading-msg');

        // === IndexedDB Setup and Helpers === (Unchanged)
        const DB_NAME = 'ArcaneTomeDB';
        const DB_VERSION = 1;
        const CHAT_STORE_NAME = 'chats';

        async function openArcaneTomeDB() {
            return idb.openDB(DB_NAME, DB_VERSION, {
                upgrade(db, oldVersion, newVersion, transaction) {
                    console.log(`Upgrading DB from version ${oldVersion} to ${newVersion}`);
                    if (oldVersion < 1) {
                        // Create the 'chats' object store
                        const store = db.createObjectStore(CHAT_STORE_NAME, { keyPath: 'id' });
                        // Create an index on 'timestamp' for sorting
                        store.createIndex('timestamp', 'timestamp');
                        console.log('Created chats object store and timestamp index.');
                    }
                    // Add future upgrade logic here based on oldVersion
                },
            });
        }

        async function saveChatDB(chatData) {
            try {
                const db = await openArcaneTomeDB();
                await db.put(CHAT_STORE_NAME, chatData);
                console.log(`[DB] Chat saved/updated: ${chatData.id}`);
            } catch (error) {
                console.error(`[DB] Error saving chat ${chatData.id}:`, error);
                alert(`Failed to save chat: ${error.message}`); // Inform user
                throw error; // Re-throw for calling function if needed
            }
        }

        async function loadChatHistoryDB(chatId) {
            try {
                const db = await openArcaneTomeDB();
                const chatData = await db.get(CHAT_STORE_NAME, chatId);
                console.log(`[DB] Loaded chat data for ${chatId}:`, chatData ? 'Found' : 'Not Found');
                return chatData ? chatData.history : null; // Return only the history array
            } catch (error) {
                console.error(`[DB] Error loading chat ${chatId}:`, error);
                return null; // Return null on error
            }
        }

        async function deleteChatDB(chatId) {
            try {
                const db = await openArcaneTomeDB();
                await db.delete(CHAT_STORE_NAME, chatId);
                console.log(`[DB] Chat deleted: ${chatId}`);
            } catch (error) {
                console.error(`[DB] Error deleting chat ${chatId}:`, error);
                alert(`Failed to delete chat: ${error.message}`); // Inform user
                throw error; // Re-throw
            }
        }

        async function getChatListDB() {
            try {
                const db = await openArcaneTomeDB();
                // Use the timestamp index to get all records, sorted by timestamp descending
                // getAll() is simpler if getting all, then sorting in JS
                const allChats = await db.getAllFromIndex(CHAT_STORE_NAME, 'timestamp');
                // Sort descending (newest first)
                allChats.sort((a, b) => b.timestamp - a.timestamp);
                // Map to the format needed by the UI
                const chatListMeta = allChats.map(chat => ({ id: chat.id, timestamp: chat.timestamp }));
                console.log(`[DB] Retrieved chat list meta: ${chatListMeta.length} items`);
                return chatListMeta;
            } catch (error) {
                console.error('[DB] Error getting chat list:', error);
                return []; // Return empty array on error
            }
        }
        // === END IndexedDB Helpers ===


        // === API Key and Provider/Model Management ===
        function loadApiAndProviderState() { /* ... Unchanged logic ... */ console.log("[DEBUG] loadApiAndProviderState: Starting."); const storedProviderKeys = localStorage.getItem('providerApiKeys'); if (storedProviderKeys) { try { apiKeyManagement.providerKeys = JSON.parse(storedProviderKeys); if (typeof apiKeyManagement.providerKeys !== 'object' || apiKeyManagement.providerKeys === null) { apiKeyManagement.providerKeys = {}; } Object.keys(apiKeyManagement.providerKeys).forEach(prov => { if (!Array.isArray(apiKeyManagement.providerKeys[prov])) { apiKeyManagement.providerKeys[prov] = []; } }); } catch (e) { console.error("[DEBUG] Error parsing stored provider API keys:", e); apiKeyManagement.providerKeys = {}; localStorage.removeItem('providerApiKeys'); } } else { apiKeyManagement.providerKeys = {}; } const storedActiveKeys = localStorage.getItem('activeApiKeys'); if (storedActiveKeys) { try { apiKeyManagement.activeKeys = JSON.parse(storedActiveKeys); if (typeof apiKeyManagement.activeKeys !== 'object' || apiKeyManagement.activeKeys === null) { apiKeyManagement.activeKeys = {}; } Object.keys(apiKeyManagement.activeKeys).forEach(prov => { const active = apiKeyManagement.activeKeys[prov]; const keysForProvider = apiKeyManagement.providerKeys[prov] || []; if (!keysForProvider.includes(active)) { delete apiKeyManagement.activeKeys[prov]; } }); } catch (e) { console.error("[DEBUG] Error parsing stored active API keys:", e); apiKeyManagement.activeKeys = {}; localStorage.removeItem('activeApiKeys'); } } else { apiKeyManagement.activeKeys = {}; } const savedProvider = localStorage.getItem('selectedProvider'); const savedModel = localStorage.getItem('selectedModel'); if (savedProvider && PROVIDERS[savedProvider]) { state.selectedProvider = savedProvider; } else { state.selectedProvider = Object.keys(PROVIDERS)[0]; } const providerConf = PROVIDERS[state.selectedProvider]; if (savedModel && providerConf && providerConf.availableModels.includes(savedModel)) { state.selectedModel = savedModel; } else { state.selectedModel = providerConf?.defaultModel || null; } Object.keys(apiKeyManagement.providerKeys).forEach(prov => { if (!apiKeyManagement.activeKeys[prov] && apiKeyManagement.providerKeys[prov]?.length > 0) { apiKeyManagement.activeKeys[prov] = apiKeyManagement.providerKeys[prov][0]; } }); saveApiAndProviderState(); console.log(`[DEBUG] Initial provider: ${state.selectedProvider}, model: ${state.selectedModel}`); console.log("[DEBUG] loadApiAndProviderState: Finished."); }
        function saveApiAndProviderState() { localStorage.setItem('providerApiKeys', JSON.stringify(apiKeyManagement.providerKeys)); localStorage.setItem('activeApiKeys', JSON.stringify(apiKeyManagement.activeKeys)); localStorage.setItem('selectedProvider', state.selectedProvider || ''); localStorage.setItem('selectedModel', state.selectedModel || ''); }
        function populateProviderDropdown() { /* ... Unchanged ... */ providerSelect.innerHTML = ''; Object.keys(PROVIDERS).forEach(providerKey => { const option = document.createElement('option'); option.value = providerKey; option.textContent = PROVIDERS[providerKey].name; providerSelect.appendChild(option); }); providerSelect.value = state.selectedProvider; }
        function updateModelDropdown() { /* ... Unchanged ... */ modelSelect.innerHTML = ''; if (!state.selectedProvider || !PROVIDERS[state.selectedProvider]) { modelSelect.disabled = true; return; } const providerConf = PROVIDERS[state.selectedProvider]; if (!providerConf.availableModels || providerConf.availableModels.length === 0) { const option = document.createElement('option'); option.value = ""; option.textContent = "No models available"; modelSelect.appendChild(option); modelSelect.disabled = true; state.selectedModel = null; return; } modelSelect.disabled = false; providerConf.availableModels.forEach(modelName => { const option = document.createElement('option'); option.value = modelName; option.textContent = modelName; modelSelect.appendChild(option); }); if (state.selectedModel && providerConf.availableModels.includes(state.selectedModel)) { modelSelect.value = state.selectedModel; } else { state.selectedModel = providerConf.defaultModel; modelSelect.value = state.selectedModel; saveApiAndProviderState(); } }

        // --- MODIFIED: Render API Keys, handle proxy provider ---
        function renderApiKeysForSelectedProvider() {
            apiKeyListDiv.innerHTML = ''; // Clear previous list

            if (!state.selectedProvider) {
                apiKeyListDiv.innerHTML = '<p style="font-style: italic; color: #5a4e42; text-align: center; padding: 5px 0;">Select a provider.</p>';
                apiKeySectionTitle.textContent = "API Keys";
                // Ensure controls are enabled by default if no provider selected
                newApiKeyInput.disabled = true; // Disable if no provider
                newApiKeyInput.placeholder = 'Select provider first';
                addApiKeyBtn.disabled = true; // Disable if no provider
                updateActiveKeyDisplay();
                return;
            }

            const providerConf = PROVIDERS[state.selectedProvider];
            apiKeySectionTitle.textContent = `API Keys for ${providerConf?.name || state.selectedProvider}`;

            // --- NEW: Check for proxy format ---
            if (providerConf?.format === 'proxy_compatible') {
                apiKeyListDiv.innerHTML = '<p style="font-style: italic; color: #5a4e42; text-align: center; padding: 5px 0;">API Key managed by proxy function. No user key needed.</p>';
                newApiKeyInput.disabled = true;
                newApiKeyInput.placeholder = 'Key handled by proxy';
                addApiKeyBtn.disabled = true;
                updateActiveKeyDisplay(); // Will show 'Managed by Proxy'
                return; // Skip rendering the key list and controls
            }
            // --- END NEW ---

            // Existing logic for providers requiring user keys
            newApiKeyInput.disabled = false;
            newApiKeyInput.placeholder = 'Add API Key for selected provider';
            addApiKeyBtn.disabled = false;

            const keys = apiKeyManagement.providerKeys[state.selectedProvider] || [];
            const activeKey = apiKeyManagement.activeKeys[state.selectedProvider] || null;

            if (keys.length === 0) {
                apiKeyListDiv.innerHTML = '<p style="font-style: italic; color: #5a4e42; text-align: center; padding: 5px 0;">No keys added for this provider.</p>';
            } else {
                keys.forEach((key) => {
                    const isKeyActive = (key === activeKey);
                    const kdiv = document.createElement('div');
                    kdiv.className = 'saved-chat-item';
                    if(isKeyActive) kdiv.style.backgroundColor = 'rgba(107, 33, 168, 0.1)';

                    const kspan = document.createElement('span');
                    kspan.textContent = key;
                    kspan.title = key; // Show full key on hover
                    if (isKeyActive) {
                        kspan.style.fontWeight = 'bold';
                        kspan.style.color = 'var(--amethyst)';
                    }

                    const cdiv = document.createElement('div');
                    cdiv.style.display = 'flex'; cdiv.style.gap = '5px'; cdiv.style.flexShrink = '0';

                    const ubtn = document.createElement('button');
                    ubtn.textContent = 'Use';
                    ubtn.className = 'load-chat-btn';
                    ubtn.style.backgroundColor = isKeyActive ? 'var(--parchment-dark)' : 'var(--gold)';
                    ubtn.style.color = isKeyActive ? 'var(--ink-light)' : 'var(--ink)';
                    ubtn.disabled = isKeyActive;
                    ubtn.onclick = () => setActiveApiKey(state.selectedProvider, key);

                    const dbtn = document.createElement('button');
                    dbtn.textContent = 'Del';
                    dbtn.className = 'delete-chat-btn';
                    // --- CORRECTED: Call deleteApiKey, not deleteChat ---
                    dbtn.onclick = () => deleteApiKey(state.selectedProvider, key);
                    // --- END CORRECTION ---

                    cdiv.appendChild(ubtn);
                    cdiv.appendChild(dbtn);
                    kdiv.appendChild(kspan);
                    kdiv.appendChild(cdiv);
                    apiKeyListDiv.appendChild(kdiv);
                });
            }
            updateActiveKeyDisplay();
        }
        // --- END MODIFIED ---


        function setActiveApiKey(provider, key) {
             // Add safety check for proxy provider
             if (PROVIDERS[provider]?.format === 'proxy_compatible') {
                 console.warn("Attempted to set active key for a proxy provider. Ignored.");
                 return;
             }
             if (!apiKeyManagement.providerKeys[provider]?.includes(key)) {
                 console.warn(`Attempted to set non-existent key ${key} for provider ${provider}.`);
                 return;
             }
             apiKeyManagement.activeKeys[provider] = key;
             saveApiAndProviderState();
             renderApiKeysForSelectedProvider(); // Re-render to update UI state
         }

        function deleteApiKey(provider, keyToDelete) {
            // Add safety check for proxy provider
            if (PROVIDERS[provider]?.format === 'proxy_compatible') {
                 console.warn("Attempted to delete key for a proxy provider. Ignored.");
                 return;
            }
            if (!apiKeyManagement.providerKeys[provider]) return;

            apiKeyManagement.providerKeys[provider] = apiKeyManagement.providerKeys[provider].filter(k => k !== keyToDelete);

            // If the deleted key was active, select the first remaining key or null
            if (apiKeyManagement.activeKeys[provider] === keyToDelete) {
                const remainingKeys = apiKeyManagement.providerKeys[provider];
                apiKeyManagement.activeKeys[provider] = remainingKeys.length > 0 ? remainingKeys[0] : null;
            }

            // Clean up if no keys left for the provider
            if (apiKeyManagement.providerKeys[provider].length === 0) {
                delete apiKeyManagement.providerKeys[provider];
                // Also remove the active key entry if the provider has no keys left
                delete apiKeyManagement.activeKeys[provider];
            }

            saveApiAndProviderState();
            renderApiKeysForSelectedProvider(); // Re-render the list
        }

        function addApiKey() {
            if (!state.selectedProvider) {
                alert("Please select an API provider first.");
                return;
            }
             // --- NEW: Prevent adding keys for proxy provider ---
             if (PROVIDERS[state.selectedProvider]?.format === 'proxy_compatible') {
                 alert("API Key is managed by the proxy function for this provider and cannot be added here.");
                 newApiKeyInput.value = ''; // Clear input
                 return;
             }
             // --- END NEW ---

            const newKey = newApiKeyInput.value.trim();
            if (!newKey) return;

            if (!apiKeyManagement.providerKeys[state.selectedProvider]) {
                apiKeyManagement.providerKeys[state.selectedProvider] = [];
            }
            const currentKeys = apiKeyManagement.providerKeys[state.selectedProvider];

            if (!currentKeys.includes(newKey)) {
                currentKeys.push(newKey);
                // Automatically set the first added key as active if none is active
                if (!apiKeyManagement.activeKeys[state.selectedProvider]) {
                    apiKeyManagement.activeKeys[state.selectedProvider] = newKey;
                }
                saveApiAndProviderState();
                renderApiKeysForSelectedProvider(); // Refresh the list and active display
                newApiKeyInput.value = ''; // Clear input after adding
            } else {
                alert(`Key already exists for ${PROVIDERS[state.selectedProvider].name}.`);
                newApiKeyInput.value = ''; // Clear input even if duplicate
            }
        }

        // --- MODIFIED: Update active key display for proxy ---
        function updateActiveKeyDisplay() {
             const providerConf = state.selectedProvider ? PROVIDERS[state.selectedProvider] : null;

             // --- NEW: Handle proxy provider ---
             if (providerConf?.format === 'proxy_compatible') {
                 currentActiveKeyDisplay.textContent = 'Managed by Proxy';
                 currentActiveKeyDisplay.title = 'API Key is set in the server-side proxy function.';
                 return;
             }
             // --- END NEW ---

             // Existing logic for other providers
             const activeKey = state.selectedProvider ? apiKeyManagement.activeKeys[state.selectedProvider] : null;
             currentActiveKeyDisplay.textContent = activeKey || 'None';
             currentActiveKeyDisplay.title = activeKey || ''; // Show full key on hover if set
         }
         // --- END MODIFIED ---

        function handleProviderChange() { /* ... Unchanged ... */ const newProvider = providerSelect.value; state.selectedProvider = newProvider; state.selectedModel = PROVIDERS[newProvider]?.defaultModel || null; saveApiAndProviderState(); updateModelDropdown(); renderApiKeysForSelectedProvider(); }
        function handleModelChange() { /* ... Unchanged ... */ const newModel = modelSelect.value; state.selectedModel = newModel; saveApiAndProviderState(); }


        // === Saved Chats Management (Using IndexedDB) === (Unchanged)
        async function populateChatList() { /* ... */ savedChatsListItems.innerHTML = ''; chatsLoadingMsg.textContent = 'Loading chats from DB...'; chatsLoadingMsg.style.display = 'block'; try { const chatList = await getChatListDB(); console.log("[DB] Retrieved chat list:", chatList); if (chatList.length === 0) { chatsLoadingMsg.textContent = 'No saved chats found.'; } else { chatsLoadingMsg.style.display = 'none'; chatList.forEach(chatMeta => { const itemDiv = document.createElement('div'); itemDiv.className = 'saved-chat-item'; const tsSpan = document.createElement('span'); const date = new Date(chatMeta.timestamp); tsSpan.textContent = date.toLocaleString(undefined, { dateStyle: 'short', timeStyle: 'short' }); tsSpan.title = `ID: ${chatMeta.id}\nSaved: ${date.toISOString()}`; const ctrlDiv = document.createElement('div'); const loadBtn = document.createElement('button'); loadBtn.textContent = 'Load'; loadBtn.className = 'load-chat-btn'; loadBtn.onclick = (e) => { e.stopPropagation(); loadChat(chatMeta.id); }; const delBtn = document.createElement('button'); delBtn.textContent = 'Del'; delBtn.className = 'delete-chat-btn'; delBtn.onclick = (e) => { e.stopPropagation(); deleteChat(chatMeta.id); }; ctrlDiv.appendChild(loadBtn); ctrlDiv.appendChild(delBtn); itemDiv.appendChild(tsSpan); itemDiv.appendChild(ctrlDiv); savedChatsListItems.appendChild(itemDiv); }); } } catch (error) { console.error("Error populating chat list from DB:", error); savedChatsListItems.innerHTML = ''; chatsLoadingMsg.style.display = 'block'; chatsLoadingMsg.textContent = 'Error loading chats.'; } }
        async function loadChat(chatId) { /* ... */ console.log(`JS: Attempting to load ${chatId} from DB`); try { const loadedHistory = await loadChatHistoryDB(chatId); if (loadedHistory) { if (Array.isArray(loadedHistory) && loadedHistory.length > 0 && loadedHistory[0]?.role === 'system') { state.conversationHistory = loadedHistory; state.currentChatId = chatId; renderChatHistory(); systemPromptInput.value = state.conversationHistory[0].content; console.log(`JS: Successfully loaded chat history for ${chatId} from DB.`); closeApiMenu(); } else { console.error("[DEBUG] Loaded data from DB is not a valid chat history array:", loadedHistory); throw new Error("Invalid format in loaded chat data"); } } else { console.warn(`JS: Chat ${chatId} not found in DB or error loading.`); alert(`Could not load chat "${chatId}". Data not found.`); await populateChatList(); } } catch (error) { console.error(`JS: Error loading or processing ${chatId} from DB:`, error); alert(`Error loading chat: ${error.message}`); await populateChatList(); } }
        async function deleteChat(chatId) { /* ... */ if (!confirm(`Delete chat saved around ${document.querySelector(`.saved-chat-item span[title*='ID: ${chatId}']`)?.textContent || chatId}?`)) return; console.log(`JS: Deleting ${chatId} from DB`); try { await deleteChatDB(chatId); console.log(`JS: Delete ${chatId} command sent to DB.`); await populateChatList(); if (state.currentChatId === chatId) { console.log("Active chat deleted."); await startNewChat(false); } } catch (error) { console.error(`JS: Error deleting ${chatId} from DB:`, error); } }


        // Open/Close Secret Menu (Unchanged)
        async function openApiMenu() { /* ... */ loadApiAndProviderState(); populateProviderDropdown(); updateModelDropdown(); renderApiKeysForSelectedProvider(); await populateChatList(); apiKeyMenu.style.display = 'block';}
        function closeApiMenu() { apiKeyMenu.style.display = 'none'; }

        // === App Initialization and Core Logic ===
        // initializeChat (Unchanged)
        function initializeChat() { /* ... */ console.log("[DEBUG] initializeChat: Starting new chat session."); state.currentChatId = `chat_${Date.now()}`; state.conversationHistory = [ { role: 'system', content: localStorage.getItem('systemPrompt') || 'You are a mystical spirit...' } ]; systemPromptInput.value = state.conversationHistory[0].content; console.log("[DEBUG] initializeChat: New chat session initialized with ID:", state.currentChatId); console.log(`[DEBUG] Using Provider: ${state.selectedProvider}, Model: ${state.selectedModel}`); }

        // init (Unchanged)
        function init() { /* ... */ console.log("[DEBUG] init: Starting Initialization..."); try { state.savedPrompts = JSON.parse(localStorage.getItem('savedPrompts')) || {}; state.userPfp = localStorage.getItem('userPfp') || 'https://ui-avatars.com/api/?name=User&background=1e3a8a&color=fff&bold=true'; state.botPfp = localStorage.getItem('botPfp') || 'https://ui-avatars.com/api/?name=Spirit&background=6b21a8&color=fff&bold=true'; userAvatarPreview.src = state.userPfp; spiritAvatarPreview.src = state.botPfp; updateGuidanceSelect(); loadApiAndProviderState(); initializeChat(); if (!sendButton /* etc. */) { throw new Error("Core DOM elements not found!"); } console.log("[DEBUG] init: Attaching event listeners..."); closeApiMenuBtn.addEventListener('click', closeApiMenu); providerSelect.addEventListener('change', handleProviderChange); modelSelect.addEventListener('change', handleModelChange); addApiKeyBtn.addEventListener('click', addApiKey); newApiKeyInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); addApiKey(); } }); document.addEventListener('click', (event) => { if (apiKeyMenu.style.display === 'block' && !apiKeyMenu.contains(event.target) && !event.target.closest('.user-avatar') && !event.target.closest('#user-avatar-preview')) { closeApiMenu(); } }, true); sendButton.addEventListener('click', sendMessage); messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } }); messageInput.addEventListener('input', () => { messageInput.style.height = 'auto'; messageInput.style.height = (messageInput.scrollHeight) + 'px'; }); closeModalBtn.addEventListener('click', closeSettings); cancelBtn.addEventListener('click', closeSettings); saveBtn.addEventListener('click', saveSettings); pfpUpload.addEventListener('change', handlePfpUpload); guidanceSelect.addEventListener('change', loadGuidance); saveGuidanceBtn.addEventListener('click', saveCurrentGuidance); removeGuidanceBtn.addEventListener('click', removeSelectedGuidance); newChatBtn.addEventListener('click', () => startNewChat(true)); undoBtn.addEventListener('click', undoLastMessage); userAvatarPreview.addEventListener('click', () => { state.currentAvatarBeingEdited = 'user'; pfpUpload.click(); }); spiritAvatarPreview.addEventListener('click', () => { state.currentAvatarBeingEdited = 'spirit'; pfpUpload.click(); }); pages.addEventListener('click', (event) => { if (event.target.matches('.user-avatar') && event.target.closest('.message-user')) { openApiMenu(); } else if (event.target.matches('.spirit-avatar') && event.target.closest('.message-spirit')) { openSettings(); } }); renderChatHistory(); console.log("[DEBUG] init: Initialization flow complete."); } catch (error) { console.error("[DEBUG] CRITICAL ERROR DURING INIT:", error); alert("A critical error occurred during initialization: " + error.message + ". Check the debug console."); } }

        // renderChatHistory (Unchanged)
        function renderChatHistory() { /* ... */ pages.innerHTML = ''; state.conversationHistory.slice(1).forEach(msg => { if (!msg || !msg.role || typeof msg.content === 'undefined') { console.warn("Skipping invalid message:", msg); return; } const sender = msg.role === 'user' ? 'user' : 'spirit'; const pfp = sender === 'user' ? state.userPfp : state.botPfp; const isMarkdown = msg.role === 'assistant'; displayMessage(msg.content, sender, pfp, isMarkdown); }); requestAnimationFrame(() => { pages.scrollTop = pages.scrollHeight; }); }

        // startNewChat (Uses IndexedDB save) (Unchanged)
        async function startNewChat(confirmFirst = true) { /* ... */ if (confirmFirst && !confirm('Start a new chat?\n(Current chat will be saved if possible)')) return; if (state.currentChatId && state.conversationHistory.length > 1) { console.log(`JS: Saving current ${state.currentChatId} to DB`); const chatData = { id: state.currentChatId, timestamp: Date.now(), history: state.conversationHistory }; try { await saveChatDB(chatData); console.log(`JS: Save ${state.currentChatId} to DB successful.`); } catch (error) { console.error(`JS: Error saving ${state.currentChatId} to DB:`, error); } } const currentSystemPrompt = state.conversationHistory[0]?.content || localStorage.getItem('systemPrompt') || 'You are a mystical spirit...'; const newChatId = `chat_${Date.now()}`; console.log("Starting new chat:", newChatId); state.currentChatId = newChatId; state.conversationHistory = [ { role: 'system', content: currentSystemPrompt } ]; systemPromptInput.value = currentSystemPrompt; renderChatHistory(); closeSettings(); closeApiMenu(); messageInput.focus(); }


        // --- MODIFIED: sendMessage to handle API key requirement check ---
        async function sendMessage() {
             console.log("[DEBUG] sendMessage: Called.");
             if (state.isWaitingForResponse) { console.log("[DEBUG] sendMessage: Aborted, waiting."); return; }
             const userInput = messageInput.value.trim();
             if (!userInput) { console.log("[DEBUG] sendMessage: Aborted, empty input."); return; }

             const userMessage = { role: 'user', content: userInput };
             state.conversationHistory.push(userMessage);
             displayMessage(userInput, 'user', state.userPfp, false);
             messageInput.value = ''; messageInput.style.height = 'auto';
             requestAnimationFrame(() => { messageInput.style.height = (messageInput.scrollHeight) + 'px'; });

             state.isWaitingForResponse = true;
             sendButton.disabled = true;

             const provider = state.selectedProvider;
             const model = state.selectedModel;
             const apiKey = provider ? apiKeyManagement.activeKeys[provider] : null; // Get potential key

             console.log(`[DEBUG] sendMessage: Provider=${provider}, Model=${model}, Key=${apiKey ? 'Exists/Selected' : 'Missing/Not Selected'}`);

             if (!provider || !model) {
                 console.error("[DEBUG] sendMessage: Provider or Model not selected.");
                 displayMessage("Cannot contact the spirit: Please select a valid API Provider and Model in the User Sigil menu.", 'spirit', state.botPfp, false);
                 state.isWaitingForResponse = false; sendButton.disabled = false;
                 return;
             }

             // --- NEW: Check if API key is required AND missing ---
             const providerConf = PROVIDERS[provider];
             const requiresUserKey = providerConf?.format !== 'proxy_compatible' && providerConf?.apiKeyLocation !== 'none';

             if (requiresUserKey && !apiKey) {
                 console.error(`[DEBUG] sendMessage: No active API key set for provider ${provider}, which requires one.`);
                 displayMessage(`Cannot contact the spirit: No API Key is active for ${providerConf?.name || provider}. Please set one via the User Sigil menu.`, 'spirit', state.botPfp, false);
                 state.isWaitingForResponse = false; sendButton.disabled = false;
                 if (apiKeyMenu.style.display === 'none') messageInput.focus(); // Focus input if menu isn't open
                 return;
             }
             // --- END NEW ---

             displayTypingIndicator();

             try {
                 // Ensure getApiResponse is globally available (or imported if using modules)
                 if (typeof getApiResponse !== 'function') throw new Error("API provider functions (getApiResponse) not loaded.");
                 console.log(`[DEBUG] sendMessage: Calling getApiResponse for ${provider}...`);

                 // Call getApiResponse - it now knows whether to use the apiKey or not based on format
                 const botResponse = await getApiResponse(
                     provider,
                     model,
                     state.conversationHistory,
                     apiKey // Pass the key; getApiResponse decides if it's needed
                 );

                 console.log("[DEBUG] sendMessage: getApiResponse successful.");
                 removeTypingIndicator();
                 const assistantMessage = { role: 'assistant', content: botResponse };
                 state.conversationHistory.push(assistantMessage);
                 displayMessage(botResponse, 'spirit', state.botPfp, true); // Display as markdown

             } catch (error) {
                 console.error('[DEBUG] Error during API call execution:', error);
                 removeTypingIndicator();
                 // Display the error message thrown by getApiResponse or fetch
                 displayMessage(`The connection falters...\n(${error.message || 'Unknown error'})`, 'spirit', state.botPfp, false);
             } finally {
                 console.log("[DEBUG] sendMessage: Entering finally block.");
                 // Ensure typing indicator is removed even if errors occurred before its removal point
                 removeTypingIndicator();
                 state.isWaitingForResponse = false;
                 sendButton.disabled = false;
                 // Focus input only if modals aren't open
                 if (!settingsModal.classList.contains('active') && apiKeyMenu.style.display === 'none') {
                     messageInput.focus();
                 }
             }
         }
        // --- END MODIFIED ---


        // Display a message (Unchanged)
        function displayMessage(content, sender, pfp, isMarkdown = false) { /* ... */ const msgDiv = document.createElement('div'); msgDiv.className = `message message-${sender}`; const avImg = document.createElement('img'); avImg.className = `avatar ${sender}-avatar`; avImg.src = pfp; avImg.alt = `${sender} avatar`; const cntDiv = document.createElement('div'); cntDiv.className = `message-content ${sender}-message`; if (isMarkdown) { if (typeof DOMPurify !== 'undefined') { cntDiv.innerHTML = DOMPurify.sanitize(marked.parse(content)); } else { cntDiv.innerHTML = marked.parse(content); if (cntDiv.innerHTML.includes('<script')) { console.warn("Potential XSS vector detected without DOMPurify."); cntDiv.innerHTML = cntDiv.innerHTML.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, ''); } } setTimeout(() => { cntDiv.querySelectorAll('pre').forEach(pre => { if (pre.querySelector('.copy-code-btn')) return; const btn = document.createElement('button'); btn.className = 'copy-code-btn'; btn.textContent = 'Copy'; btn.title = 'Copy code'; btn.addEventListener('click', (e) => { e.stopPropagation(); const code = pre.querySelector('code') || pre; navigator.clipboard.writeText(code.textContent).then(() => { btn.textContent = 'Copied!'; btn.classList.add('copied'); setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 1500); }).catch(err => { console.error('Failed to copy code:', err); btn.textContent = 'Error'; setTimeout(() => { btn.textContent = 'Copy'; }, 1500); }); }); pre.style.position = 'relative'; pre.appendChild(btn); }); }, 0); } else { cntDiv.textContent = content; } if (sender === 'user') { msgDiv.appendChild(cntDiv); msgDiv.appendChild(avImg); } else { msgDiv.appendChild(avImg); msgDiv.appendChild(cntDiv); } pages.appendChild(msgDiv); requestAnimationFrame(() => { pages.scrollTo({ top: pages.scrollHeight, behavior: 'smooth' }); }); }
        // Show/Remove typing indicator (Unchanged)
        function displayTypingIndicator() { /* ... */ if(document.getElementById('typing-indicator'))return;const typDiv=document.createElement('div');typDiv.className='message message-spirit';typDiv.id='typing-indicator';typDiv.style.opacity='0.8';const avImg=document.createElement('img');avImg.className='avatar spirit-avatar';avImg.src=state.botPfp;avImg.alt='spirit avatar';avImg.style.cursor='default';const cntDiv=document.createElement('div');cntDiv.className='typing-indicator';cntDiv.innerHTML=`<span>The spirit is responding</span><span class="rune" style="animation-delay: 0s;">ᛟ</span><span class="rune" style="animation-delay: 0.2s;">ᛞ</span><span class="rune" style="animation-delay: 0.4s;">ᛝ</span>`;typDiv.appendChild(avImg);typDiv.appendChild(cntDiv);pages.appendChild(typDiv);requestAnimationFrame(()=>{pages.scrollTo({ top: pages.scrollHeight, behavior: 'smooth' });});}
        function removeTypingIndicator() { /* ... */ const ti=document.getElementById('typing-indicator');if(ti)ti.remove();}

        // --- Settings Modal / Guidance / PFP Logic (saveSettings uses IndexedDB) --- (Unchanged)
        function openSettings() { /* ... */ systemPromptInput.value = state.conversationHistory[0]?.content || ''; userAvatarPreview.src = state.userPfp; spiritAvatarPreview.src = state.botPfp; updateGuidanceSelect(); const currentPromptName = Object.keys(state.savedPrompts).find(name => state.savedPrompts[name] === systemPromptInput.value); guidanceSelect.value = currentPromptName || ""; settingsModal.classList.add('active'); document.body.style.overflow = 'hidden'; }
        function closeSettings() { /* ... */ settingsModal.classList.remove('active'); document.body.style.overflow = ''; }
        async function saveSettings() { /* ... */ console.log("[DEBUG] saveSettings called."); const newSysPrompt = systemPromptInput.value.trim(); const defaultPrompt = 'You are a mystical spirit...'; const finalPrompt = newSysPrompt || defaultPrompt; let promptChanged = false; if (!state.conversationHistory || state.conversationHistory.length === 0) { state.conversationHistory = [{ role: 'system', content: finalPrompt }]; promptChanged = true; } else if (state.conversationHistory[0]?.content !== finalPrompt) { state.conversationHistory[0] = { role: 'system', content: finalPrompt }; promptChanged = true; } if (promptChanged) { console.log("[DEBUG] System prompt changed."); localStorage.setItem('systemPrompt', finalPrompt); } localStorage.setItem('userPfp', state.userPfp); localStorage.setItem('botPfp', state.botPfp); document.querySelectorAll('.user-avatar').forEach(img => { if(img.closest('.message') || img.id === 'user-avatar-preview') img.src = state.userPfp; }); document.querySelectorAll('.spirit-avatar').forEach(img => { if(img.closest('.message') || img.closest('#typing-indicator') || img.id === 'spirit-avatar-preview') img.src = state.botPfp; }); if (promptChanged && state.currentChatId) { const chatData = { id: state.currentChatId, timestamp: Date.now(), history: state.conversationHistory }; try { await saveChatDB(chatData); console.log(`[DEBUG] Saved chat ${state.currentChatId} to DB after settings save.`); } catch (e) { console.error("[DEBUG] Save error after settings save:", e); } } closeSettings(); }
        function updateGuidanceSelect() { /* ... */ guidanceSelect.innerHTML = '<option value="">Select saved guidance...</option>'; Object.entries(state.savedPrompts).forEach(([name, prompt]) => { const opt = document.createElement('option'); opt.value = name; opt.textContent = name; guidanceSelect.appendChild(opt); }); }
        function loadGuidance() { /* ... */ const selName = guidanceSelect.value; if (selName && state.savedPrompts[selName]) { systemPromptInput.value = state.savedPrompts[selName]; } }
        function saveCurrentGuidance() { /* ... */ const currentPrompt = systemPromptInput.value.trim(); if (!currentPrompt) { alert("Guidance cannot be empty."); return; } const pName = prompt('Enter a name for this guidance:', Object.keys(state.savedPrompts).find(name => state.savedPrompts[name] === currentPrompt) || ''); if (pName) { state.savedPrompts[pName] = currentPrompt; localStorage.setItem('savedPrompts', JSON.stringify(state.savedPrompts)); updateGuidanceSelect(); guidanceSelect.value = pName; } }
        function removeSelectedGuidance() { /* ... */ const selName = guidanceSelect.value; if (selName && state.savedPrompts[selName]) { if (confirm(`Delete guidance "${selName}"?`)) { const promptVal = state.savedPrompts[selName]; delete state.savedPrompts[selName]; localStorage.setItem('savedPrompts', JSON.stringify(state.savedPrompts)); updateGuidanceSelect(); if (systemPromptInput.value === promptVal) { systemPromptInput.value = ''; } guidanceSelect.value = ''; } } }
        function handlePfpUpload(event) { /* ... */ const file = event.target.files[0]; if (!file || !file.type.startsWith('image/')) return; const reader = new FileReader(); reader.onload = (e) => { const url = e.target.result; if (state.currentAvatarBeingEdited === 'user') { state.userPfp = url; userAvatarPreview.src = url; } else if (state.currentAvatarBeingEdited === 'spirit') { state.botPfp = url; spiritAvatarPreview.src = url; } }; reader.onerror = (e) => console.error("PFP Read Err:", e); reader.readAsDataURL(file); pfpUpload.value = null; }
        async function undoLastMessage() { /* ... */ if (state.conversationHistory.length <= 1) return; let removed = 0; const last = state.conversationHistory.pop(); removed = 1; if (last?.role === 'assistant' && state.conversationHistory[state.conversationHistory.length - 1]?.role === 'user') { state.conversationHistory.pop(); removed = 2; } if (removed > 0) { console.log(`[DEBUG] Undo removed ${removed} message(s).`); renderChatHistory(); if(state.isWaitingForResponse){ console.log("[DEBUG] Undo while waiting - cancelling response."); state.isWaitingForResponse = false; sendButton.disabled = false; removeTypingIndicator(); } if (state.currentChatId) { const chatData = { id: state.currentChatId, timestamp: Date.now(), history: state.conversationHistory }; try { await saveChatDB(chatData); console.log(`[DEBUG] Saved chat ${state.currentChatId} to DB after undo.`); } catch(e) { console.error("Save error after undo:", e); } } } else { console.log("[DEBUG] Undo called but no messages to remove."); } }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', init);

    </script>

</body>
</html>
