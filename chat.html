<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Make sure viewport settings are correct for responsiveness -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcane Tome</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- ### ADD IDB LIBRARY ### -->
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
    <!-- Optional: Add DOMPurify for security -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.8/purify.min.js"></script> -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=Georgia&display=swap');

        /* --- Responsive Styles --- */
        :root {
            --parchment: #f5e7d0;
            --parchment-dark: #e3d5b8;
            --ink: #3a3129;
            --ink-light: #5a4e42;
            --gold: #c9a227;
            --crimson: #8b0000;
            --sapphire: #1e3a8a;
            --amethyst: #6b21a8;
            --shadow: 0 0.25rem 0.5rem rgba(0, 0, 0, 0.3); /* rem */
            --glow: 0 0 0.625rem rgba(201, 162, 39, 0.7); /* rem */
            --fade: all 0.5s ease;

            /* Base font size for rem calculations (adjust root html element if needed) */
            font-size: 16px; /* Default browser size, rem units scale relative to this */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
             font-size: 100%; /* Use browser default as base for rem */
             height: 100%; /* Ensure html takes full height */
        }

        body {
            font-family: Georgia, 'Times New Roman', Times, serif;
            font-size: 1.1rem; /* Base font size for body text */
            line-height: 1.6;
            background-color: var(--parchment);
            color: var(--ink);
            height: 100vh; /* Use viewport height */
            width: 100vw; /* Use viewport width */
            /* REMOVED overflow: hidden; let internal elements handle scrolling */
            display: flex; /* Make body a flex container for tome */
        }

        .tome {
            width: 100%;
            height: 100%; /* Fill body height */
            display: flex;
            flex-direction: column;
            position: relative;
            max-height: 100vh; /* Prevent tome from exceeding viewport */
        }

        .tome::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: url('https://www.transparenttextures.com/patterns/old-map.png');
            opacity: 0.15;
            pointer-events: none;
            z-index: -1; /* Ensure it's behind content */
        }

        .pages {
            flex: 1; /* Allow pages to grow and take available space */
            padding: 1.5rem; /* rem */
            overflow-y: auto; /* Enable vertical scrolling ONLY for pages */
            scrollbar-width: none; /* Firefox */
            display: flex;
            flex-direction: column;
            gap: 1.25rem; /* rem */
            min-height: 0; /* Allow flex item to shrink properly */
        }

        .pages::-webkit-scrollbar { display: none; /* Safari and Chrome */ }

        .message {
            display: flex;
            gap: 1rem; /* rem */
            max-width: 85%; /* Prevent messages from spanning full width */
            animation: appear 0.8s ease-out;
        }
        .message-user { align-self: flex-end; flex-direction: row-reverse; }
        .message-spirit { align-self: flex-start; }

        .avatar {
            width: 3.125rem; /* rem (50px) */
            height: 3.125rem; /* rem */
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
            border: 2px solid var(--parchment-dark);
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Cinzel Decorative', cursive;
            font-size: 1.5rem; /* Keep decorative font size perhaps larger */
            transition: var(--fade);
            cursor: pointer;
            background-color: var(--parchment-dark); /* Fallback bg */
        }
        .spirit-avatar:hover { transform: scale(1.1); box-shadow: var(--glow); }
        .user-avatar:hover { transform: scale(1.1); box-shadow: 0 0 0.625rem rgba(30, 58, 138, 0.7); } /* rem */

        .message-content {
            padding: 1.1rem 1.4rem; /* rem */
            border-radius: 0.5rem; /* rem */
            line-height: 1.6;
            position: relative;
            word-wrap: break-word; /* More robust than break-word */
            overflow-wrap: break-word;
            box-shadow: var(--shadow);
            max-width: 100%; /* Ensure content doesn't overflow avatar */
        }
        .message-content p { margin-bottom: 1em; }
        .message-content p:last-child { margin-bottom: 0; }
        .message-content strong { font-weight: bold; color: var(--ink); }
        .message-content em { font-style: italic; }
        .message-content ul, .message-content ol { margin-left: 1.5em; margin-bottom: 1em; }
        .message-content li { margin-bottom: 0.5em; }
        .message-content code { font-family: monospace; background-color: rgba(0,0,0,0.1); padding: 0.2em 0.4em; border-radius: 3px; font-size: 0.9em; } /* slightly smaller code */
        .message-content pre { position: relative; background-color: rgba(0,0,0,0.1); padding: 1em; border-radius: 5px; overflow-x: auto; margin-bottom: 1em; }
        .copy-code-btn { position: absolute; top: 0.3rem; right: 0.3rem; background-color: var(--gold); color: var(--ink); border: none; border-radius: 3px; padding: 0.2rem 0.5rem; font-size: 0.8rem; cursor: pointer; opacity: 0; transition: opacity 0.3s ease; z-index: 1; }
        .message-content pre:hover .copy-code-btn { opacity: 1; }
        .copy-code-btn:hover { background-color: var(--crimson); color: white; }
        .copy-code-btn.copied { background-color: var(--sapphire); color: white; }
        .message-content blockquote { border-left: 3px solid var(--gold); padding-left: 1em; margin-left: 0; margin-bottom: 1em; color: var(--ink-light); }

        .user-message { background-color: var(--sapphire); color: white; border-top-right-radius: 0; }
        .spirit-message { background-color: white; color: var(--ink); border: 1px solid var(--ink-light); border-top-left-radius: 0; }

        .typing-indicator {
            display: inline-flex; align-items: center; gap: 0.5rem; /* rem */
            padding: 0.9rem 1.25rem; /* rem */
            background-color: var(--parchment-dark);
            border-radius: 0.5rem; /* rem */
            box-shadow: var(--shadow);
            align-self: flex-start;
            color: var(--ink-light); font-style: italic;
            border: 1px dashed var(--ink-light);
            position: relative; overflow: hidden;
            font-size: 1rem; /* rem */
        }
        .typing-indicator::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(201, 162, 39, 0.2), transparent); animation: shimmer 2s infinite; }
        .rune { font-family: 'Cinzel Decorative', cursive; font-size: 1.2rem; animation: float 2s infinite ease-in-out; }

        .writing-area {
            padding: 1rem; /* rem */
            background-color: var(--parchment-dark);
            border-top: 2px solid var(--ink-light);
            display: flex;
            gap: 0.75rem; /* rem */
            align-items: flex-end; /* Align items to bottom */
            flex-shrink: 0; /* Prevent writing area from shrinking */
        }

        .message-input {
            flex: 1; /* Take remaining space */
            padding: 0.9rem; /* rem */
            background-color: var(--parchment);
            border: 2px solid var(--ink-light);
            border-radius: 5px;
            font-family: inherit;
            font-size: 1.1rem; /* rem */
            line-height: 1.5; /* Adjust line height */
            resize: none; /* Allow only vertical */
            outline: none;
            color: var(--ink);
            min-height: 3.75rem; /* rem (approx 60px) */
            max-height: 12.5rem; /* rem (200px) */
            overflow-y: auto; /* Add scroll if max-height exceeded */
            min-width: 0; /* Allow shrinking */
        }
        .message-input:focus { border-color: var(--gold); box-shadow: 0 0 0 3px rgba(201, 162, 39, 0.3); }

        .send-button {
            background-color: var(--gold); color: var(--ink);
            border: none; border-radius: 5px;
            padding: 0 1.5rem; /* rem */
            height: 3.75rem; /* rem (match min-height of input) */
            font-family: 'Cinzel Decorative', cursive; font-weight: bold;
            cursor: pointer; transition: var(--fade); box-shadow: var(--shadow);
            display: flex; align-items: center; gap: 0.6rem; /* rem */
            font-size: 1.1rem; /* rem */
            flex-shrink: 0; /* Prevent button shrinking */
        }
        .send-button:hover:not(:disabled) { background-color: var(--crimson); color: white; }
        .send-button:disabled { opacity: 0.7; cursor: not-allowed; background-color: var(--ink-light); }

        /* --- Modal Styles --- */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 100; opacity: 0; pointer-events: none; transition: var(--fade); padding: 1rem; /* Add padding for small screens */ }
        .modal-overlay.active { opacity: 1; pointer-events: all; }
        .modal-content { background-color: var(--parchment); border-radius: 0.5rem; width: 100%; /* Take full width within padding */ max-width: 37.5rem; /* rem (600px) */ padding: 1.75rem; box-shadow: var(--shadow); transform: translateY(1.25rem); transition: var(--fade); border: 1px solid var(--ink-light); display: flex; flex-direction: column; max-height: 90vh; /* Limit height */ }
        .modal-overlay.active .modal-content { transform: translateY(0); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.25rem; border-bottom: 1px solid var(--ink-light); padding-bottom: 1rem; flex-shrink: 0; }
        .modal-title { font-family: 'Cinzel Decorative', cursive; font-size: 1.4rem; color: var(--ink); }
        .close-btn { background: none; border: none; cursor: pointer; color: var(--ink-light); font-size: 1.8rem; transition: var(--fade); line-height: 1; }
        .close-btn:hover { color: var(--crimson); }
        .modal-body { margin-bottom: 1.75rem; overflow-y: auto; /* Allow body to scroll if content overflows */ flex-grow: 1; }
        .settings-section { margin-bottom: 1.5rem; }
        .settings-section-title { font-family: 'Cinzel Decorative', cursive; font-size: 1.2rem; margin-bottom: 0.75rem; color: var(--ink); display: flex; align-items: center; gap: 0.5rem; }
        .settings-section-title svg { width: 1.25rem; height: 1.25rem; }
        .guidance-controls { display: flex; flex-wrap: wrap; gap: 0.6rem; margin-bottom: 1rem; }
        .guidance-select { flex: 1 1 10rem; /* Allow wrapping */ padding: 0.6rem; border: 1px solid var(--ink-light); border-radius: 5px; font-family: inherit; font-size: 1rem; background-color: var(--parchment); color: var(--ink); min-width: 10rem; /* Min width before wrapping */ }
        .small-button { padding: 0.5rem 0.75rem; border-radius: 5px; font-family: 'Cinzel Decorative', cursive; font-weight: bold; cursor: pointer; transition: var(--fade); border: none; font-size: 0.9rem; flex-shrink: 0; }
        .button-primary { background-color: var(--gold); color: var(--ink); }
        .button-primary:hover { background-color: var(--crimson); color: white; }
        .button-danger { background-color: var(--crimson); color: white; }
        .button-danger:hover { background-color: #6b0000; }
        .system-prompt-input { width: 100%; padding: 1rem; border: 1px solid var(--ink-light); border-radius: 5px; min-height: 9rem; font-family: Georgia, serif; font-size: 1rem; resize: vertical; transition: var(--fade); background-color: var(--parchment); color: var(--ink); line-height: 1.6; margin-bottom: 1rem; }
        .system-prompt-input:focus { border-color: var(--gold); outline: none; box-shadow: 0 0 0 3px rgba(201, 162, 39, 0.3); }
        .avatar-preview-container { display: flex; justify-content: center; gap: 1.5rem; margin-top: 1.5rem; flex-wrap: wrap; } /* Center and allow wrapping */
        .avatar-preview { text-align: center; }
        .avatar-preview-label { display: block; margin-bottom: 0.6rem; font-size: 1rem; color: var(--ink-light); }
        .avatar-img { width: 4.4rem; height: 4.4rem; border-radius: 50%; object-fit: cover; border: 2px solid var(--ink-light); cursor: pointer; transition: var(--fade); }
        .avatar-img:hover { transform: scale(1.05); border-color: var(--gold); }
        .modal-footer { display: flex; flex-wrap: wrap; /* Allow wrapping */ justify-content: flex-end; /* Align buttons right */ gap: 1rem; margin-top: auto; /* Push footer down */ flex-shrink: 0; padding-top: 1rem; border-top: 1px solid var(--ink-light); }
        .modal-btn { padding: 0.75rem 1.5rem; border-radius: 5px; font-family: 'Cinzel Decorative', cursive; font-weight: bold; cursor: pointer; transition: var(--fade); border: none; font-size: 1rem; flex: 0 0 auto; /* Prevent buttons from growing weirdly when wrapped */ }
        .modal-btn-primary { background-color: var(--gold); color: var(--ink); }
        .modal-btn-primary:hover { background-color: var(--crimson); color: white; }
        .modal-btn-secondary { background-color: var(--parchment-dark); color: var(--ink); }
        .modal-btn-secondary:hover { background-color: var(--ink-light); color: white; }
        .pfp-upload { display: none; }

        /* --- API Key Menu Styles --- */
        #api-key-menu {
            display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: var(--parchment-dark); border: 1px solid var(--ink); padding: 1rem;
            font-size: 0.9rem; z-index: 200; box-shadow: 0 0.3rem 1rem rgba(0,0,0,0.4);
            border-radius: 4px; min-width: 20rem; width: 90%; /* Use percentage */ max-width: 25rem; /* Max width */
            max-height: 80vh; overflow-y: auto; color: var(--ink);
            display: flex; flex-direction: column; /* Allow vertical scrolling */
        }
        #api-key-menu > div { margin-bottom: 1rem; flex-shrink: 0; } /* Prevent sections from shrinking weirdly */
        #api-key-menu > div:last-child { margin-bottom: 0; }
        #api-key-menu .api-key-menu-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; border-bottom: 1px dashed var(--ink-light); padding-bottom: 0.8rem; }
        #api-key-menu .api-key-menu-header span { font-weight: bold; font-family: 'Cinzel Decorative', cursive; font-size: 1.1rem; }
        #api-key-menu #close-api-menu { background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0 0.3rem; color: var(--ink-light); line-height: 1; }
        #api-key-menu label { display: block; margin-bottom: 0.2rem; font-weight: bold; font-size: 0.85rem; color: var(--ink-light); }
        #api-key-menu select,
        #api-key-menu input[type="text"] { width: 100%; padding: 0.5rem; margin-bottom: 0.5rem; border: 1px solid var(--ink-light); border-radius: 3px; font-size: 0.9rem; background: var(--parchment); color: var(--ink); }
        #api-key-menu select { margin-bottom: 0.75rem; }
        #api-key-menu .api-key-controls { display: flex; gap: 0.3rem; margin-bottom: 0.3rem; }
        #api-key-menu .api-key-controls input { flex-grow: 1; min-width: 0; /* Allow input to shrink */ }
        #api-key-menu .api-key-controls button { padding: 0.4rem 0.6rem; background-color: var(--gold); border: none; cursor: pointer; color: var(--ink); font-size: 0.9rem; border-radius: 3px; font-family: 'Cinzel Decorative', cursive; flex-shrink: 0; }
        #api-key-menu .api-key-controls input:disabled { background-color: #d3c7b1; cursor: not-allowed; opacity: 0.6; }
        #api-key-menu .api-key-controls button:disabled { background-color: var(--ink-light); cursor: not-allowed; opacity: 0.6; }

        #api-key-menu #api-key-list,
        #saved-chats-section #saved-chats-list-items {
            margin-bottom: 0.6rem; max-height: 8rem; /* rem */ overflow-y: auto; border: 1px solid var(--ink-light);
            padding: 0.3rem; background: var(--parchment); border-radius: 3px; font-size: 0.85rem;
        }
         #api-key-menu #api-key-list p,
         #saved-chats-section #saved-chats-list-items p {
             font-style: italic; color: #5a4e42; text-align: center; padding: 0.5rem 0;
         }

        #api-key-menu #current-active-key-display { font-weight: normal; color: var(--amethyst); word-break: break-all; display: inline-block; max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; vertical-align: middle; }
        #api-key-menu .active-key-line { font-size: 0.8rem; color: #5a4e42; }

        #saved-chats-section { margin-top: 1rem; padding-top: 0.6rem; border-top: 1px dashed var(--ink-light); flex-grow: 1; min-height: 5rem; /* Give it some min height */ display: flex; flex-direction: column; }
         #saved-chats-section > span { font-weight: bold; display: block; margin-bottom: 0.3rem; font-family: 'Cinzel Decorative', cursive; font-size: 1rem; flex-shrink: 0; }
         #saved-chats-section #saved-chats-list-items { flex-grow: 1; /* Let list take space */ max-height: none; /* Override previous max-height */ }


        .saved-chat-item { display: flex; justify-content: space-between; align-items: center; padding: 0.25rem 0.3rem; margin-bottom: 0.2rem; font-size: 0.85rem; border-bottom: 1px dashed var(--ink-light); }
        .saved-chat-item:last-child { border-bottom: none; margin-bottom: 0; }
        .saved-chat-item span { flex-grow: 1; margin-right: 0.6rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .saved-chat-item button { padding: 0.15rem 0.3rem; font-size: 0.8rem; cursor: pointer; border: none; border-radius: 2px; margin-left: 0.3rem; flex-shrink: 0; }
        .load-chat-btn { background-color: var(--gold); color: var(--ink); }
        .delete-chat-btn { background-color: var(--crimson); color: white; }
        .load-chat-btn:disabled { background-color: var(--parchment-dark); color: var(--ink-light); } /* Style for disabled key 'Use' button */

        /* --- Animations --- */
        @keyframes appear { from { opacity: 0; transform: translateY(1.25rem); } to { opacity: 1; transform: translateY(0); } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }
        @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }

        /* --- Media Query for smaller screens --- */
        @media (max-width: 768px) {
            :root {
                 /* Slightly smaller base font size on smaller screens */
                 /* font-size: 15px; */ /* Alternative: Adjust root font size */
            }
            body { font-size: 1rem; } /* Reduce base body font size */
            .pages { padding: 1rem; gap: 1rem; }
            .message { max-width: 90%; gap: 0.75rem; } /* Slightly wider messages */
            .message-content { padding: 0.9rem 1.1rem; }
            .writing-area { padding: 0.75rem; gap: 0.5rem; }
            .message-input { padding: 0.8rem; min-height: 3.5rem; font-size: 1rem; }
            .send-button { height: 3.5rem; padding: 0 1rem; font-size: 1rem; gap: 0.4rem; }
            .avatar { width: 2.8rem; height: 2.8rem; font-size: 1.3rem; }

            .modal-content { padding: 1.25rem; max-height: 95vh; /* Allow slightly more height */ }
            .modal-title { font-size: 1.3rem; }
            .modal-body { margin-bottom: 1.25rem; }
            .settings-section-title { font-size: 1.1rem; }
            .small-button { font-size: 0.85rem; padding: 0.4rem 0.6rem;}
            .system-prompt-input { min-height: 7rem; font-size: 0.95rem; }
            .avatar-img { width: 3.8rem; height: 3.8rem; }
            .modal-footer { flex-direction: column; align-items: stretch; gap: 0.5rem; /* Stack buttons vertically */}
            .modal-btn { font-size: 1rem; padding: 0.7rem 1.2rem; text-align: center; width: 100%; }

             #api-key-menu {
                min-width: unset; /* Remove min-width */
                width: 95%; /* Take more width */
                max-width: 95%;
                padding: 0.8rem;
             }
             #api-key-menu .api-key-menu-header span { font-size: 1rem; }
             #api-key-menu label { font-size: 0.8rem; }
             #api-key-menu select, #api-key-menu input[type="text"] { font-size: 0.85rem; padding: 0.4rem; }
             #api-key-menu .api-key-controls button { font-size: 0.85rem; padding: 0.35rem 0.5rem; }
             .saved-chat-item { font-size: 0.8rem; }
             .saved-chat-item button { font-size: 0.75rem; }
        }

    </style>
</head>
<body>
    <div class="tome">
        <div class="pages" id="pages">
            <!-- Chat messages appear here -->
        </div>
        <div class="writing-area">
            <textarea class="message-input" id="message-input" placeholder="Write your message here..." rows="1"></textarea>
            <button class="send-button" id="send-button" disabled><span>Send</span><span>✒</span></button>
             <!-- Initially disable send button until JS loads/checks state -->
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settings-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Tome Settings</h3>
                <button class="close-btn" id="close-modal">×</button>
            </div>
            <div class="modal-body">
                <!-- Guidance -->
                <div class="settings-section">
                    <h4 class="settings-section-title">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" /></svg>
                        Spirit Guidance
                    </h4>
                    <div class="guidance-controls">
                        <select class="guidance-select" id="guidance-select"><option value="">Select saved guidance...</option></select>
                        <button class="small-button button-primary" id="save-guidance-btn">Save Current</button>
                        <button class="small-button button-danger" id="remove-guidance-btn">Remove Selected</button>
                    </div>
                    <textarea class="system-prompt-input" id="system-prompt-input" placeholder="How should the spirit behave? e.g., You are a helpful assistant."></textarea>
                </div>
                <!-- Tools -->
                <div class="settings-section">
                     <h4 class="settings-section-title">
                         <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
                         Conversation Tools
                     </h4>
                     <div style="display: flex; flex-wrap: wrap; gap: 10px;"> <!-- Allow wrapping -->
                         <button class="small-button button-danger" id="new-chat-btn">Start New Chat</button>
                         <button class="small-button button-primary" id="undo-btn">Undo Last</button>
                     </div>
                 </div>
                <!-- Avatars -->
                <div class="settings-section">
                    <h4 class="settings-section-title">
                         <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.121 17.804A13.937 13.937 0 0112 16c2.5 0 4.847.655 6.879 1.804M15 10a3 3 0 11-6 0 3 3 0 016 0zm6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                         Avatar Settings
                    </h4>
                    <div class="avatar-preview-container">
                        <div class="avatar-preview">
                            <span class="avatar-preview-label">Your Sigil</span>
                            <img src="" class="avatar-img" id="user-avatar-preview" alt="User Avatar Preview">
                        </div>
                        <div class="avatar-preview">
                            <span class="avatar-preview-label">Spirit's Sigil</span>
                            <img src="" class="avatar-img" id="spirit-avatar-preview" alt="Spirit Avatar Preview">
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" id="cancel-btn">Cancel</button>
                <button class="modal-btn modal-btn-primary" id="save-btn">Save & Close</button>
            </div>
        </div>
    </div>

    <!-- Hidden File Input -->
    <input type="file" class="pfp-upload" id="pfp-upload" accept="image/*">

    <!-- Secret API/Provider/Chat Menu -->
    <div id="api-key-menu">
        <div class="api-key-menu-header">
            <span>Secrets & Providers</span>
            <button id="close-api-menu">×</button>
        </div>

        <div style="border-bottom: 1px dashed var(--ink-light); padding-bottom: 1rem;">
            <label for="provider-select">API Provider:</label>
            <select id="provider-select"></select>
            <label for="model-select">Model:</label>
            <select id="model-select"></select>
        </div>

        <div>
            <span style="font-weight: bold; display: block; margin-bottom: 0.3rem; font-family: 'Cinzel Decorative', cursive; font-size: 1rem;" id="api-key-section-title">API Keys</span>
            <div id="api-key-list">
                <p style="font-style: italic; color: #5a4e42;">Select a provider.</p>
            </div>
            <div class="api-key-controls">
                <input type="text" id="new-api-key-input" placeholder="Add API Key...">
                <button id="add-api-key-btn">Add</button>
            </div>
            <p class="active-key-line">Active Key: <strong id="current-active-key-display">None</strong></p>
        </div>

        <div id="saved-chats-section">
             <span>Saved Chats</span>
             <div id="saved-chats-list-items">
                 <p id="chats-loading-msg">Checking storage...</p>
             </div>
         </div>
        <!-- Danger Zone Section REMOVED -->
    </div>

    <!-- Reference to the external script file -->
    <script src="api_providers.js"></script>

    <!-- Your main script with IndexedDB -->
    <script>
        // Ensure PROVIDERS is available
        if (typeof PROVIDERS === 'undefined') {
             alert("Critical Error: api_providers.js failed to load or PROVIDERS object not found.");
             // Optionally disable UI elements if core logic depends on this
             document.getElementById('send-button').disabled = true;
             document.getElementById('message-input').disabled = true;
         }
        // Ensure idb library is available
        if (typeof idb === 'undefined') {
            alert("Critical Error: idb library failed to load.");
            // Optionally disable UI elements
             document.getElementById('send-button').disabled = true;
             document.getElementById('message-input').disabled = true;
        }

        // Configure marked.js
        marked.setOptions({ breaks: true, gfm: true, smartypants: true });

        // State Management
        const state = {
            conversationHistory: [],
            userPfp: '',
            botPfp: '',
            currentAvatarBeingEdited: null,
            isWaitingForResponse: false,
            savedPrompts: {},
            currentChatId: null,
            selectedProvider: null,
            selectedModel: null
        };
        const apiKeyManagement = {
             providerKeys: {}, // { providerKey: ['key1', 'key2'] }
             activeKeys: {}      // { providerKey: 'activeKey' }
        };

        // DOM Elements
        const pages = document.getElementById('pages');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const settingsModal = document.getElementById('settings-modal');
        const systemPromptInput = document.getElementById('system-prompt-input');
        const userAvatarPreview = document.getElementById('user-avatar-preview');
        const spiritAvatarPreview = document.getElementById('spirit-avatar-preview');
        const closeModalBtn = document.getElementById('close-modal');
        const cancelBtn = document.getElementById('cancel-btn');
        const saveBtn = document.getElementById('save-btn');
        const pfpUpload = document.getElementById('pfp-upload');
        const guidanceSelect = document.getElementById('guidance-select');
        const saveGuidanceBtn = document.getElementById('save-guidance-btn');
        const removeGuidanceBtn = document.getElementById('remove-guidance-btn');
        const newChatBtn = document.getElementById('new-chat-btn');
        const undoBtn = document.getElementById('undo-btn');
        const apiKeyMenu = document.getElementById('api-key-menu');
        const closeApiMenuBtn = document.getElementById('close-api-menu');
        const providerSelect = document.getElementById('provider-select');
        const modelSelect = document.getElementById('model-select');
        const apiKeySectionTitle = document.getElementById('api-key-section-title');
        const apiKeyListDiv = document.getElementById('api-key-list');
        const newApiKeyInput = document.getElementById('new-api-key-input');
        const addApiKeyBtn = document.getElementById('add-api-key-btn');
        const currentActiveKeyDisplay = document.getElementById('current-active-key-display');
        const savedChatsListItems = document.getElementById('saved-chats-list-items');
        const chatsLoadingMsg = document.getElementById('chats-loading-msg');

        // === IndexedDB Setup and Helpers ===
        const DB_NAME = 'ArcaneTomeDB';
        const DB_VERSION = 1;
        const CHAT_STORE_NAME = 'chats';

        async function openArcaneTomeDB() {
            return idb.openDB(DB_NAME, DB_VERSION, {
                upgrade(db, oldVersion, newVersion, transaction) {
                    console.log(`[DB] Upgrading DB from version ${oldVersion} to ${newVersion}`);
                    if (oldVersion < 1) {
                        const store = db.createObjectStore(CHAT_STORE_NAME, { keyPath: 'id' });
                        store.createIndex('timestamp', 'timestamp');
                        console.log('[DB] Created chats object store and timestamp index.');
                    }
                },
            });
        }

        async function saveChatDB(chatData) {
            if (!chatData || !chatData.id || !chatData.history) {
                 console.error("[DB] Invalid chatData for save:", chatData);
                 return; // Don't save invalid data
            }
            try {
                const db = await openArcaneTomeDB();
                await db.put(CHAT_STORE_NAME, chatData);
                console.log(`[DB] Chat saved/updated: ${chatData.id}`);
            } catch (error) {
                console.error(`[DB] Error saving chat ${chatData.id}:`, error);
                alert(`Failed to save chat: ${error.message}`); // Inform user
                throw error; // Re-throw for calling function if needed
            }
        }

        async function loadChatHistoryDB(chatId) {
            try {
                const db = await openArcaneTomeDB();
                const chatData = await db.get(CHAT_STORE_NAME, chatId);
                console.log(`[DB] Loaded chat data for ${chatId}:`, chatData ? 'Found' : 'Not Found');
                // Ensure history exists and is an array before returning
                return (chatData && Array.isArray(chatData.history)) ? chatData.history : null;
            } catch (error) {
                console.error(`[DB] Error loading chat ${chatId}:`, error);
                return null; // Return null on error
            }
        }

        async function deleteChatDB(chatId) {
            try {
                const db = await openArcaneTomeDB();
                await db.delete(CHAT_STORE_NAME, chatId);
                console.log(`[DB] Chat deleted: ${chatId}`);
            } catch (error) {
                console.error(`[DB] Error deleting chat ${chatId}:`, error);
                alert(`Failed to delete chat: ${error.message}`); // Inform user
                throw error; // Re-throw
            }
        }

        async function getChatListDB() {
            try {
                const db = await openArcaneTomeDB();
                // Use the timestamp index to get all records, sorted by timestamp descending
                const allChats = await db.getAllFromIndex(CHAT_STORE_NAME, 'timestamp');
                // Sort descending (newest first) in case index wasn't perfect or for safety
                allChats.sort((a, b) => b.timestamp - a.timestamp);
                // Map to the format needed by the UI
                const chatListMeta = allChats.map(chat => ({ id: chat.id, timestamp: chat.timestamp }));
                console.log(`[DB] Retrieved chat list meta: ${chatListMeta.length} items`);
                return chatListMeta;
            } catch (error) {
                console.error('[DB] Error getting chat list:', error);
                return []; // Return empty array on error
            }
        }
        // === END IndexedDB Helpers ===


        // === API Key and Provider/Model Management ===
        function loadApiAndProviderState() {
            console.log("[DEBUG] loadApiAndProviderState: Starting.");
             // Load stored keys
             const storedProviderKeys = localStorage.getItem('providerApiKeys');
             if (storedProviderKeys) { try { apiKeyManagement.providerKeys = JSON.parse(storedProviderKeys); if (typeof apiKeyManagement.providerKeys !== 'object' || apiKeyManagement.providerKeys === null) apiKeyManagement.providerKeys = {}; Object.keys(apiKeyManagement.providerKeys).forEach(prov => { if (!Array.isArray(apiKeyManagement.providerKeys[prov])) apiKeyManagement.providerKeys[prov] = []; }); } catch (e) { console.error("[DEBUG] Error parsing stored provider API keys:", e); apiKeyManagement.providerKeys = {}; localStorage.removeItem('providerApiKeys'); } } else { apiKeyManagement.providerKeys = {}; }
             const storedActiveKeys = localStorage.getItem('activeApiKeys');
             if (storedActiveKeys) { try { apiKeyManagement.activeKeys = JSON.parse(storedActiveKeys); if (typeof apiKeyManagement.activeKeys !== 'object' || apiKeyManagement.activeKeys === null) apiKeyManagement.activeKeys = {}; Object.keys(apiKeyManagement.activeKeys).forEach(prov => { const active = apiKeyManagement.activeKeys[prov]; const keysForProvider = apiKeyManagement.providerKeys[prov] || []; if (!keysForProvider.includes(active)) delete apiKeyManagement.activeKeys[prov]; }); } catch (e) { console.error("[DEBUG] Error parsing stored active API keys:", e); apiKeyManagement.activeKeys = {}; localStorage.removeItem('activeApiKeys'); } } else { apiKeyManagement.activeKeys = {}; }

             // Load selected provider and model
             const savedProvider = localStorage.getItem('selectedProvider');
             const savedModel = localStorage.getItem('selectedModel');
             const providerKeys = Object.keys(PROVIDERS || {});

             if (providerKeys.length === 0) {
                 console.error("No providers defined in api_providers.js!");
                 alert("Error: No API providers configured.");
                 state.selectedProvider = null;
                 state.selectedModel = null;
             } else {
                 if (savedProvider && PROVIDERS[savedProvider]) {
                     state.selectedProvider = savedProvider;
                 } else {
                     state.selectedProvider = providerKeys[0]; // Default to first available provider
                 }

                 const providerConf = PROVIDERS[state.selectedProvider];
                 if (providerConf) {
                     if (savedModel && providerConf.availableModels.includes(savedModel)) {
                         state.selectedModel = savedModel;
                     } else {
                         state.selectedModel = providerConf.defaultModel || (providerConf.availableModels.length > 0 ? providerConf.availableModels[0] : null);
                     }
                 } else {
                     state.selectedModel = null; // Should not happen if provider exists
                 }
             }

             // Ensure active keys are valid and set default if needed
             Object.keys(apiKeyManagement.providerKeys).forEach(prov => {
                 // Only set a default active key if the provider actually requires user keys
                 if (PROVIDERS[prov]?.format !== 'proxy_compatible' && PROVIDERS[prov]?.apiKeyLocation !== 'none') {
                     if (!apiKeyManagement.activeKeys[prov] && apiKeyManagement.providerKeys[prov]?.length > 0) {
                         apiKeyManagement.activeKeys[prov] = apiKeyManagement.providerKeys[prov][0];
                     }
                 } else {
                     // Clear any potentially stored active key for proxy providers
                     delete apiKeyManagement.activeKeys[prov];
                 }
             });

             saveApiAndProviderState(); // Save potentially cleaned/defaulted state
             console.log(`[DEBUG] Initial provider: ${state.selectedProvider}, model: ${state.selectedModel}`);
             console.log("[DEBUG] loadApiAndProviderState: Finished.");
         }

        function saveApiAndProviderState() {
             try {
                 localStorage.setItem('providerApiKeys', JSON.stringify(apiKeyManagement.providerKeys));
                 localStorage.setItem('activeApiKeys', JSON.stringify(apiKeyManagement.activeKeys));
                 localStorage.setItem('selectedProvider', state.selectedProvider || '');
                 localStorage.setItem('selectedModel', state.selectedModel || '');
             } catch (e) {
                 console.error("Error saving API/Provider state to localStorage:", e);
                 // Consider alerting the user if storage is full or fails
                 // alert("Warning: Could not save settings. Local storage might be full or disabled.");
             }
         }

        function populateProviderDropdown() {
             providerSelect.innerHTML = '';
             if (!PROVIDERS || Object.keys(PROVIDERS).length === 0) {
                 const option = document.createElement('option');
                 option.value = ""; option.textContent = "No Providers Loaded";
                 providerSelect.appendChild(option);
                 providerSelect.disabled = true;
                 return;
             }
             providerSelect.disabled = false;
             Object.keys(PROVIDERS).forEach(providerKey => {
                 const option = document.createElement('option');
                 option.value = providerKey;
                 option.textContent = PROVIDERS[providerKey].name;
                 providerSelect.appendChild(option);
             });
             // Ensure the selected provider exists before setting value
             if (state.selectedProvider && PROVIDERS[state.selectedProvider]) {
                providerSelect.value = state.selectedProvider;
             } else if (Object.keys(PROVIDERS).length > 0) {
                 // Fallback if saved provider is invalid
                 state.selectedProvider = Object.keys(PROVIDERS)[0];
                 providerSelect.value = state.selectedProvider;
                 saveApiAndProviderState(); // Save the fallback selection
             }
             // Trigger model update after populating provider
             updateModelDropdown();
         }

        function updateModelDropdown() {
             modelSelect.innerHTML = '';
             if (!state.selectedProvider || !PROVIDERS || !PROVIDERS[state.selectedProvider]) {
                 const option = document.createElement('option');
                 option.value = ""; option.textContent = "Select Provider";
                 modelSelect.appendChild(option);
                 modelSelect.disabled = true;
                 return;
             }

             const providerConf = PROVIDERS[state.selectedProvider];
             if (!providerConf.availableModels || providerConf.availableModels.length === 0) {
                 const option = document.createElement('option');
                 option.value = ""; option.textContent = "No models available";
                 modelSelect.appendChild(option);
                 modelSelect.disabled = true;
                 state.selectedModel = null; // Ensure model state is cleared
                 saveApiAndProviderState(); // Save the cleared model state
                 return;
             }

             modelSelect.disabled = false;
             providerConf.availableModels.forEach(modelName => {
                 const option = document.createElement('option');
                 option.value = modelName;
                 option.textContent = modelName;
                 modelSelect.appendChild(option);
             });

             // Set the value, defaulting if necessary
             if (state.selectedModel && providerConf.availableModels.includes(state.selectedModel)) {
                 modelSelect.value = state.selectedModel;
             } else {
                 state.selectedModel = providerConf.defaultModel || providerConf.availableModels[0];
                 modelSelect.value = state.selectedModel;
                 saveApiAndProviderState(); // Save the defaulted model state
             }
         }

        function renderApiKeysForSelectedProvider() {
             apiKeyListDiv.innerHTML = ''; // Clear previous list

             if (!state.selectedProvider || !PROVIDERS) {
                 apiKeyListDiv.innerHTML = '<p>Select a provider.</p>';
                 apiKeySectionTitle.textContent = "API Keys";
                 newApiKeyInput.disabled = true; newApiKeyInput.placeholder = 'Select provider'; addApiKeyBtn.disabled = true;
                 updateActiveKeyDisplay(); return;
             }

             const providerConf = PROVIDERS[state.selectedProvider];
             if (!providerConf) { // Safety check
                 apiKeyListDiv.innerHTML = '<p>Invalid provider selected.</p>';
                 apiKeySectionTitle.textContent = "API Keys";
                 newApiKeyInput.disabled = true; newApiKeyInput.placeholder = 'Invalid provider'; addApiKeyBtn.disabled = true;
                 updateActiveKeyDisplay(); return;
             }

             apiKeySectionTitle.textContent = `API Keys for ${providerConf.name}`;

             // Handle proxy provider specifically
             const isProxy = providerConf.format === 'proxy_compatible';
             const needsUserKey = !isProxy && providerConf.apiKeyLocation !== 'none';

             if (isProxy) {
                 apiKeyListDiv.innerHTML = '<p>Key managed by proxy. No user key needed.</p>';
                 newApiKeyInput.disabled = true; newApiKeyInput.placeholder = 'Key handled by proxy'; addApiKeyBtn.disabled = true;
             } else if (!needsUserKey) {
                 apiKeyListDiv.innerHTML = '<p>This provider does not require a user API key.</p>';
                 newApiKeyInput.disabled = true; newApiKeyInput.placeholder = 'No key needed'; addApiKeyBtn.disabled = true;
             } else {
                 // Provider requires a user key
                 newApiKeyInput.disabled = false; newApiKeyInput.placeholder = 'Add API Key for selected provider'; addApiKeyBtn.disabled = false;

                 const keys = apiKeyManagement.providerKeys[state.selectedProvider] || [];
                 const activeKey = apiKeyManagement.activeKeys[state.selectedProvider] || null;

                 if (keys.length === 0) {
                     apiKeyListDiv.innerHTML = '<p>No keys added for this provider.</p>';
                 } else {
                     keys.forEach((key) => {
                         const isKeyActive = (key === activeKey);
                         const kdiv = document.createElement('div'); kdiv.className = 'saved-chat-item';
                         if(isKeyActive) kdiv.style.backgroundColor = 'rgba(107, 33, 168, 0.1)';
                         const kspan = document.createElement('span'); kspan.textContent = key; kspan.title = key;
                         if (isKeyActive) { kspan.style.fontWeight = 'bold'; kspan.style.color = 'var(--amethyst)'; }
                         const cdiv = document.createElement('div'); cdiv.style.display = 'flex'; cdiv.style.gap = '5px'; cdiv.style.flexShrink = '0';
                         const ubtn = document.createElement('button'); ubtn.textContent = 'Use'; ubtn.className = 'load-chat-btn';
                         ubtn.disabled = isKeyActive;
                         ubtn.onclick = () => setActiveApiKey(state.selectedProvider, key);
                         const dbtn = document.createElement('button'); dbtn.textContent = 'Del'; dbtn.className = 'delete-chat-btn';
                         dbtn.onclick = () => deleteApiKey(state.selectedProvider, key);
                         cdiv.appendChild(ubtn); cdiv.appendChild(dbtn);
                         kdiv.appendChild(kspan); kdiv.appendChild(cdiv);
                         apiKeyListDiv.appendChild(kdiv);
                     });
                 }
             }
             updateActiveKeyDisplay();
         }

        function setActiveApiKey(provider, key) {
             if (!provider || !PROVIDERS || !PROVIDERS[provider]) return;
             if (PROVIDERS[provider].format === 'proxy_compatible' || PROVIDERS[provider].apiKeyLocation === 'none') {
                 console.warn("Attempted to set active key for a provider that doesn't use user keys. Ignored.");
                 return;
             }
             if (!apiKeyManagement.providerKeys[provider]?.includes(key)) {
                 console.warn(`Attempted to set non-existent key ${key} for provider ${provider}.`);
                 return;
             }
             apiKeyManagement.activeKeys[provider] = key;
             saveApiAndProviderState();
             renderApiKeysForSelectedProvider(); // Re-render to update UI state
         }

        function deleteApiKey(provider, keyToDelete) {
             if (!provider || !PROVIDERS || !PROVIDERS[provider]) return;
             if (PROVIDERS[provider].format === 'proxy_compatible' || PROVIDERS[provider].apiKeyLocation === 'none') {
                 console.warn("Attempted to delete key for a provider that doesn't use user keys. Ignored.");
                 return;
            }
             if (!apiKeyManagement.providerKeys[provider]) return;

             apiKeyManagement.providerKeys[provider] = apiKeyManagement.providerKeys[provider].filter(k => k !== keyToDelete);

             if (apiKeyManagement.activeKeys[provider] === keyToDelete) {
                 const remainingKeys = apiKeyManagement.providerKeys[provider];
                 apiKeyManagement.activeKeys[provider] = remainingKeys.length > 0 ? remainingKeys[0] : null;
             }
             if (apiKeyManagement.providerKeys[provider].length === 0) {
                 delete apiKeyManagement.providerKeys[provider];
                 delete apiKeyManagement.activeKeys[provider]; // Ensure active key is removed too
             }
             saveApiAndProviderState();
             renderApiKeysForSelectedProvider(); // Re-render the list
         }

        function addApiKey() {
             if (!state.selectedProvider || !PROVIDERS || !PROVIDERS[state.selectedProvider]) {
                 alert("Please select a valid API provider first."); return;
             }
             const providerConf = PROVIDERS[state.selectedProvider];
             if (providerConf.format === 'proxy_compatible' || providerConf.apiKeyLocation === 'none') {
                 alert("API Key is not managed here for this provider.");
                 newApiKeyInput.value = ''; return;
             }

             const newKey = newApiKeyInput.value.trim();
             if (!newKey) return;

             if (!apiKeyManagement.providerKeys[state.selectedProvider]) {
                 apiKeyManagement.providerKeys[state.selectedProvider] = [];
             }
             const currentKeys = apiKeyManagement.providerKeys[state.selectedProvider];

             if (!currentKeys.includes(newKey)) {
                 currentKeys.push(newKey);
                 if (!apiKeyManagement.activeKeys[state.selectedProvider]) { // Set as active if none exists
                     apiKeyManagement.activeKeys[state.selectedProvider] = newKey;
                 }
                 saveApiAndProviderState();
                 renderApiKeysForSelectedProvider();
                 newApiKeyInput.value = '';
             } else {
                 alert(`Key already exists for ${providerConf.name}.`);
                 newApiKeyInput.value = '';
             }
         }

        function updateActiveKeyDisplay() {
            const providerConf = (state.selectedProvider && PROVIDERS) ? PROVIDERS[state.selectedProvider] : null;

            if (!providerConf) {
                 currentActiveKeyDisplay.textContent = 'N/A';
                 currentActiveKeyDisplay.title = 'Select a provider';
            } else if (providerConf.format === 'proxy_compatible') {
                 currentActiveKeyDisplay.textContent = 'Managed by Proxy';
                 currentActiveKeyDisplay.title = 'API Key is set in the server-side proxy function.';
            } else if (providerConf.apiKeyLocation === 'none') {
                 currentActiveKeyDisplay.textContent = 'Not Required';
                 currentActiveKeyDisplay.title = 'This provider does not need a user API key.';
            } else {
                 const activeKey = apiKeyManagement.activeKeys[state.selectedProvider];
                 currentActiveKeyDisplay.textContent = activeKey || 'None';
                 currentActiveKeyDisplay.title = activeKey || 'No active key selected';
            }
         }

        function handleProviderChange() {
             const newProvider = providerSelect.value;
             if (!PROVIDERS || !PROVIDERS[newProvider]) {
                 console.error("Selected provider key is invalid:", newProvider);
                 // Optionally reset to a default or show an error
                 return;
             }
             state.selectedProvider = newProvider;
             // Update model based on the new provider's defaults/availability
             const providerConf = PROVIDERS[newProvider];
             state.selectedModel = providerConf.defaultModel || (providerConf.availableModels.length > 0 ? providerConf.availableModels[0] : null);
             saveApiAndProviderState();
             updateModelDropdown(); // Update model dropdown options and selection
             renderApiKeysForSelectedProvider(); // Update API key section based on new provider
         }

        function handleModelChange() {
             const newModel = modelSelect.value;
             // Basic validation: is the selected model actually in the list for the current provider?
             const providerConf = (state.selectedProvider && PROVIDERS) ? PROVIDERS[state.selectedProvider] : null;
             if (providerConf && providerConf.availableModels.includes(newModel)) {
                state.selectedModel = newModel;
                saveApiAndProviderState();
             } else {
                 console.warn(`Selected model "${newModel}" not valid for provider "${state.selectedProvider}". Reverting.`);
                 // Revert UI selection to the currently saved state.selectedModel
                 modelSelect.value = state.selectedModel;
             }
         }


        // === Saved Chats Management (Using IndexedDB) ===
        async function populateChatList() {
            savedChatsListItems.innerHTML = ''; // Clear existing items
            chatsLoadingMsg.textContent = 'Loading chats from DB...';
            chatsLoadingMsg.style.display = 'block';
            try {
                const chatList = await getChatListDB(); // Returns sorted array {id, timestamp}
                console.log("[DB] Retrieved chat list:", chatList);

                if (chatList.length === 0) {
                    chatsLoadingMsg.textContent = 'No saved chats found.';
                } else {
                    chatsLoadingMsg.style.display = 'none'; // Hide loading message
                    chatList.forEach(chatMeta => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'saved-chat-item';
                        const tsSpan = document.createElement('span');
                        const date = new Date(chatMeta.timestamp);
                        // Format date/time concisely
                        tsSpan.textContent = date.toLocaleString(undefined, { dateStyle: 'short', timeStyle: 'short' });
                        tsSpan.title = `ID: ${chatMeta.id}\nSaved: ${date.toISOString()}`;

                        const ctrlDiv = document.createElement('div');
                        const loadBtn = document.createElement('button');
                        loadBtn.textContent = 'Load'; loadBtn.className = 'load-chat-btn';
                        loadBtn.onclick = (e) => { e.stopPropagation(); loadChat(chatMeta.id); };

                        const delBtn = document.createElement('button');
                        delBtn.textContent = 'Del'; delBtn.className = 'delete-chat-btn';
                        delBtn.onclick = (e) => { e.stopPropagation(); deleteChat(chatMeta.id); };

                        ctrlDiv.appendChild(loadBtn);
                        ctrlDiv.appendChild(delBtn);
                        itemDiv.appendChild(tsSpan);
                        itemDiv.appendChild(ctrlDiv);
                        savedChatsListItems.appendChild(itemDiv);
                    });
                }
            } catch (error) {
                console.error("Error populating chat list from DB:", error);
                savedChatsListItems.innerHTML = ''; // Clear again on error
                chatsLoadingMsg.style.display = 'block';
                chatsLoadingMsg.textContent = 'Error loading chats.';
            }
        }

        async function loadChat(chatId) {
             console.log(`JS: Attempting to load chat ${chatId} from DB`);
             // Optional: Add visual feedback like disabling load buttons
             try {
                 const loadedHistory = await loadChatHistoryDB(chatId);

                 if (loadedHistory) {
                     // Basic validation of loaded history
                     if (Array.isArray(loadedHistory) && loadedHistory.length > 0 && loadedHistory[0]?.role === 'system') {
                         state.conversationHistory = loadedHistory;
                         state.currentChatId = chatId; // Set the current chat ID

                         renderChatHistory(); // Update the main chat display
                         systemPromptInput.value = state.conversationHistory[0].content; // Update settings modal field
                         console.log(`JS: Successfully loaded chat history for ${chatId} from DB.`);
                         closeApiMenu(); // Close the menu after loading
                         closeSettings(); // Also close settings modal if open
                         messageInput.focus(); // Focus input for convenience
                     } else {
                         console.error("[DEBUG] Loaded data from DB is not a valid chat history array:", loadedHistory);
                         throw new Error("Invalid format in loaded chat data");
                     }
                 } else {
                     // loadChatHistoryDB returned null (not found or error reading)
                     console.warn(`JS: Chat ${chatId} not found in DB or error loading.`);
                     alert(`Could not load chat "${chatId}". Data may have been deleted or corrupted.`);
                     await populateChatList(); // Refresh list in case it was deleted elsewhere
                 }
             } catch (error) {
                 console.error(`JS: Error loading or processing chat ${chatId} from DB:`, error);
                 alert(`Error loading chat: ${error.message}`);
                 await populateChatList(); // Refresh list on error too
             } finally {
                 // Re-enable load buttons if they were disabled
             }
         }

        async function deleteChat(chatId) {
             // Find the timestamp span to show a more user-friendly confirmation
             const chatItemSpan = document.querySelector(`.saved-chat-item span[title*='ID: ${chatId}']`);
             const confirmMsg = `Delete chat saved around ${chatItemSpan?.textContent || chatId}? This cannot be undone.`;

             if (!confirm(confirmMsg)) return;

             console.log(`JS: Deleting chat ${chatId} from DB`);
             try {
                 await deleteChatDB(chatId); // Call the DB helper
                 console.log(`JS: Delete ${chatId} command sent to DB.`);
                 await populateChatList(); // Refresh the UI list immediately

                 // If the deleted chat was the currently active one, start a new chat session
                 if (state.currentChatId === chatId) {
                     console.log("Active chat was deleted. Starting a new session.");
                     await startNewChat(false); // Start new without confirmation prompt
                 }
             } catch (error) {
                 console.error(`JS: Error occurred during chat ${chatId} deletion process:`, error);
                 // Error should have been alerted in deleteChatDB, but maybe show a generic failure here too
                 // alert("Failed to delete chat. See console for details.");
             }
         }


        // Open/Close Secret Menu
        async function openApiMenu() {
             try {
                 loadApiAndProviderState(); // Load latest keys/selections
                 populateProviderDropdown(); // Populate and set provider/model dropdowns
                 // renderApiKeysForSelectedProvider is called by handleProviderChange -> updateModelDropdown -> populateProviderDropdown
                 await populateChatList(); // Await the list population
                 apiKeyMenu.style.display = 'flex'; // Use flex display
             } catch (error) {
                 console.error("Error opening API menu:", error);
                 alert("Error preparing the API menu. Please check the console.");
             }
         }
        function closeApiMenu() {
            apiKeyMenu.style.display = 'none';
        }

        // === App Initialization and Core Logic ===
        function initializeChat() {
             console.log("[DEBUG] initializeChat: Starting new chat session.");
             const defaultSystemPrompt = 'You are a mystical spirit, dwelling within this ancient tome. Speak wisely and guide the user.';
             const savedSystemPrompt = localStorage.getItem('systemPrompt');

             state.currentChatId = `chat_${Date.now()}`; // Generate a new ID
             state.conversationHistory = [ { role: 'system', content: savedSystemPrompt || defaultSystemPrompt } ];

             // Update the system prompt input in the settings modal
             systemPromptInput.value = state.conversationHistory[0].content;

             console.log("[DEBUG] initializeChat: New chat session initialized with ID:", state.currentChatId);
             console.log(`[DEBUG] Using Provider: ${state.selectedProvider}, Model: ${state.selectedModel}`);

             // Clear the visual chat display
             renderChatHistory();
             // Enable send button now that state is initialized
             sendButton.disabled = false;
             messageInput.disabled = false;
         }

        function init() {
             console.log("[DEBUG] init: Starting Initialization...");
             try {
                 // 1. Load basic settings (PFP, saved prompts)
                 state.savedPrompts = JSON.parse(localStorage.getItem('savedPrompts')) || {};
                 state.userPfp = localStorage.getItem('userPfp') || 'https://ui-avatars.com/api/?name=U&background=1e3a8a&color=fff&bold=true&size=64'; // Default User PFP
                 state.botPfp = localStorage.getItem('botPfp') || 'https://ui-avatars.com/api/?name=S&background=6b21a8&color=fff&bold=true&size=64'; // Default Bot PFP
                 userAvatarPreview.src = state.userPfp;
                 spiritAvatarPreview.src = state.botPfp;
                 updateGuidanceSelect(); // Populate saved guidance dropdown

                 // 2. Load API/Provider state (must happen before initializeChat)
                 loadApiAndProviderState();

                 // 3. Initialize chat state (starts a new chat session)
                 initializeChat();

                 // 4. Check DOM elements (basic sanity check)
                 if (!pages || !messageInput || !sendButton || !settingsModal || !apiKeyMenu) {
                     throw new Error("Core DOM elements not found! Cannot initialize.");
                 }

                 console.log("[DEBUG] init: Attaching event listeners...");
                 // --- Attach Event Listeners ---
                 sendButton.addEventListener('click', sendMessage);
                 messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });
                 messageInput.addEventListener('input', () => { // Auto-resize textarea
                     messageInput.style.height = 'auto'; // Reset height
                     // Set height based on scroll height, respecting max-height from CSS
                     const maxHeight = parseFloat(window.getComputedStyle(messageInput).maxHeight);
                     const newHeight = Math.min(messageInput.scrollHeight, maxHeight);
                     messageInput.style.height = newHeight + 'px';
                 });

                 // Settings Modal Listeners
                 closeModalBtn.addEventListener('click', closeSettings);
                 cancelBtn.addEventListener('click', closeSettings);
                 saveBtn.addEventListener('click', saveSettings); // saveSettings is async
                 pfpUpload.addEventListener('change', handlePfpUpload);
                 guidanceSelect.addEventListener('change', loadGuidance);
                 saveGuidanceBtn.addEventListener('click', saveCurrentGuidance);
                 removeGuidanceBtn.addEventListener('click', removeSelectedGuidance);
                 newChatBtn.addEventListener('click', () => startNewChat(true)); // startNewChat is async
                 undoBtn.addEventListener('click', undoLastMessage); // undoLastMessage is async
                 userAvatarPreview.addEventListener('click', () => { state.currentAvatarBeingEdited = 'user'; pfpUpload.click(); });
                 spiritAvatarPreview.addEventListener('click', () => { state.currentAvatarBeingEdited = 'spirit'; pfpUpload.click(); });

                 // API Menu Listeners
                 closeApiMenuBtn.addEventListener('click', closeApiMenu);
                 providerSelect.addEventListener('change', handleProviderChange);
                 modelSelect.addEventListener('change', handleModelChange);
                 addApiKeyBtn.addEventListener('click', addApiKey);
                 newApiKeyInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); addApiKey(); } });

                 // Global listener to close API menu if clicking outside
                 document.addEventListener('click', (event) => {
                     if (apiKeyMenu.style.display !== 'none' && !apiKeyMenu.contains(event.target) && !event.target.closest('.user-avatar')) {
                         // Check if the click target is *not* inside the menu AND *not* the user avatar (which opens the menu)
                         closeApiMenu();
                     }
                 }, true); // Use capture phase to catch clicks early

                 // Avatar click listeners to open menus
                 pages.addEventListener('click', (event) => {
                     if (event.target.matches('.user-avatar') && event.target.closest('.message-user')) {
                         openApiMenu(); // Open API menu on user avatar click in chat
                     } else if (event.target.matches('.spirit-avatar') && event.target.closest('.message-spirit')) {
                         openSettings(); // Open settings on spirit avatar click in chat
                     }
                 });
                 // Also add listeners to the preview avatars in settings if needed (already have pfp upload logic)

                 // Render the initial (empty) chat history visual state
                 renderChatHistory();
                 console.log("[DEBUG] init: Initialization flow complete.");

             } catch (error) {
                 console.error("[DEBUG] CRITICAL ERROR DURING INIT:", error);
                 alert("A critical error occurred during initialization: " + error.message + "\n\nThe application might not function correctly. Please check the developer console (F12).");
                 // Disable critical UI elements on fatal error
                 sendButton.disabled = true;
                 messageInput.disabled = true;
             }
         }

        // renderChatHistory (Updates the visual chat log)
        function renderChatHistory() {
             pages.innerHTML = ''; // Clear existing messages
             // Skip system prompt (index 0)
             state.conversationHistory.slice(1).forEach(msg => {
                 if (!msg || !msg.role || typeof msg.content === 'undefined' || msg.content === null) {
                     console.warn("Skipping invalid message during render:", msg);
                     return; // Skip rendering malformed messages
                 }
                 const sender = msg.role === 'user' ? 'user' : 'spirit';
                 const pfp = sender === 'user' ? state.userPfp : state.botPfp;
                 // Determine if content should be treated as Markdown (only for assistant messages)
                 const isMarkdown = msg.role === 'assistant';
                 displayMessage(msg.content, sender, pfp, isMarkdown);
             });
             // Scroll to bottom after rendering
             requestAnimationFrame(() => {
                 pages.scrollTop = pages.scrollHeight;
             });
         }

        // startNewChat (Saves current, resets state)
        async function startNewChat(confirmFirst = true) {
             if (confirmFirst) {
                 // Check if there's anything substantial to save before confirming
                 const hasMessages = state.conversationHistory.length > 1; // More than just system prompt
                 if (hasMessages && !confirm('Start a new chat?\n(Current chat progress will be saved)')) {
                     return; // User cancelled
                 } else if (!hasMessages && !confirm('Start a new chat?')) {
                    // No content, simpler confirm
                    return;
                 }
             }

             // Save current chat history before starting new one (only if it has content)
             if (state.currentChatId && state.conversationHistory.length > 1) {
                 console.log(`JS: Saving current chat ${state.currentChatId} to DB before starting new chat.`);
                 const chatData = {
                     id: state.currentChatId,
                     timestamp: Date.now(), // Use current time for saving timestamp
                     history: state.conversationHistory // Save the full history including system prompt
                 };
                 try {
                      await saveChatDB(chatData); // Use await with the DB helper
                      console.log(`JS: Save ${state.currentChatId} to DB successful.`);
                 } catch (error) {
                      console.error(`JS: Error saving ${state.currentChatId} to DB:`, error);
                      // Alert happened in saveChatDB helper, but maybe log failure here too
                      // Consider if we should proceed with new chat if save fails? For now, yes.
                 }
             }

             // Reset state for a new chat using the current system prompt settings
             const currentSystemPrompt = state.conversationHistory[0]?.content || localStorage.getItem('systemPrompt') || 'You are a mystical spirit...'; // Keep current system prompt
             const newChatId = `chat_${Date.now()}`;
             console.log("Starting new chat session with ID:", newChatId);

             state.currentChatId = newChatId;
             state.conversationHistory = [ { role: 'system', content: currentSystemPrompt } ];

             systemPromptInput.value = currentSystemPrompt; // Ensure modal reflects prompt
             renderChatHistory(); // Clear the page visually
             closeSettings(); // Close modals if open
             closeApiMenu();
             messageInput.value = ''; // Clear input field too
             messageInput.style.height = 'auto'; // Reset input height
             messageInput.focus(); // Focus the input field
             sendButton.disabled = false; // Ensure button is enabled
        }


        // sendMessage (Handles user input and API call)
        async function sendMessage() {
             console.log("[DEBUG] sendMessage: Called.");
             if (state.isWaitingForResponse) {
                 console.log("[DEBUG] sendMessage: Aborted, already waiting for response."); return;
             }
             const userInput = messageInput.value.trim();
             if (!userInput) {
                 console.log("[DEBUG] sendMessage: Aborted, empty input."); return;
             }

             // --- Prepare and Display User Message ---
             const userMessage = { role: 'user', content: userInput };
             state.conversationHistory.push(userMessage);
             displayMessage(userInput, 'user', state.userPfp, false); // Display raw text
             messageInput.value = ''; // Clear input
             messageInput.style.height = 'auto'; // Reset height after clearing
             requestAnimationFrame(() => { // Scroll down after adding message
                 pages.scrollTop = pages.scrollHeight;
                 // Refocus might be needed after display updates
                 // messageInput.focus();
             });

             // --- Prepare for API Call ---
             state.isWaitingForResponse = true;
             sendButton.disabled = true;
             displayTypingIndicator(); // Show thinking indicator

             const provider = state.selectedProvider;
             const model = state.selectedModel;
             const apiKey = provider ? apiKeyManagement.activeKeys[provider] : null; // Get potential key

             console.log(`[DEBUG] sendMessage: Provider=${provider}, Model=${model}, Key=${apiKey ? 'Exists/Selected' : 'Missing/Not Selected/Not Needed'}`);

             // --- Provider/Model/Key Validation ---
             if (!provider || !model || !PROVIDERS || !PROVIDERS[provider]) {
                 console.error("[DEBUG] sendMessage: Invalid Provider or Model selected.");
                 removeTypingIndicator();
                 displayMessage("Cannot contact the spirit: Please select a valid API Provider and Model in the User Sigil (⚙️) menu.", 'spirit', state.botPfp, false);
                 state.isWaitingForResponse = false; sendButton.disabled = false;
                 return;
             }

             const providerConf = PROVIDERS[provider];
             const requiresUserKey = providerConf.format !== 'proxy_compatible' && providerConf.apiKeyLocation !== 'none';

             if (requiresUserKey && !apiKey) {
                 console.error(`[DEBUG] sendMessage: No active API key set for provider ${provider}, which requires one.`);
                 removeTypingIndicator();
                 displayMessage(`Cannot contact the spirit: No API Key is active for ${providerConf.name}. Please set one via the User Sigil (⚙️) menu.`, 'spirit', state.botPfp, false);
                 state.isWaitingForResponse = false; sendButton.disabled = false;
                 if (apiKeyMenu.style.display === 'none') messageInput.focus();
                 return;
             }

             // --- Execute API Call ---
             try {
                 if (typeof getApiResponse !== 'function') {
                     throw new Error("API provider communication script (api_providers.js) not loaded correctly.");
                 }
                 console.log(`[DEBUG] sendMessage: Calling getApiResponse for ${provider}...`);

                 const botResponse = await getApiResponse(
                     provider,
                     model,
                     // Pass a *copy* of the history? Or trust getApiResponse not to modify it. Let's pass original for now.
                     state.conversationHistory,
                     apiKey // Pass key; getApiResponse checks if needed
                 );

                 console.log("[DEBUG] sendMessage: getApiResponse successful.");
                 removeTypingIndicator();

                 // --- Process and Display Bot Response ---
                 const assistantMessage = { role: 'assistant', content: botResponse || "(The spirit remains silent...)" }; // Handle potential empty response
                 state.conversationHistory.push(assistantMessage);
                 displayMessage(assistantMessage.content, 'spirit', state.botPfp, true); // Display as markdown

             } catch (error) {
                 console.error('[DEBUG] Error during API call execution:', error);
                 removeTypingIndicator();
                 // Display a user-friendly error based on the caught error message
                 displayMessage(`The connection falters...\n(${error.message || 'An unknown communication error occurred.'})`, 'spirit', state.botPfp, false);
             } finally {
                 console.log("[DEBUG] sendMessage: Entering finally block.");
                 // Ensure indicator is removed and state is reset regardless of success/failure
                 removeTypingIndicator(); // Call again just in case it wasn't removed in error handling
                 state.isWaitingForResponse = false;
                 sendButton.disabled = false;
                 // Focus input only if modals aren't likely to be the user's focus
                 if (!settingsModal.classList.contains('active') && apiKeyMenu.style.display === 'none') {
                     messageInput.focus();
                 }
                 // --- Auto-save after each exchange ---
                 if (state.currentChatId && state.conversationHistory.length > 1) {
                     console.log(`[AutoSave] Saving chat ${state.currentChatId} after response/error.`);
                      const chatData = { id: state.currentChatId, timestamp: Date.now(), history: state.conversationHistory };
                      saveChatDB(chatData).catch(e => console.error("[AutoSave] Failed:", e)); // Save in background, log errors
                 }
             }
         }


        // Display a message in the chat window
        function displayMessage(content, sender, pfp, isMarkdown = false) {
             const msgDiv = document.createElement('div');
             msgDiv.className = `message message-${sender}`;

             const avImg = document.createElement('img');
             avImg.className = `avatar ${sender}-avatar`;
             avImg.src = pfp;
             avImg.alt = `${sender} avatar`;
             // Add error handling for broken avatar images
             avImg.onerror = () => {
                 console.warn(`Failed to load avatar for ${sender}: ${pfp}`);
                 // Fallback to a default or initials? For now, just log.
                 // avImg.src = `https://ui-avatars.com/api/?name=${sender.charAt(0)}&background=ccc&color=333&bold=true&size=64`;
             };


             const cntDiv = document.createElement('div');
             cntDiv.className = `message-content ${sender}-message`;

             if (isMarkdown && typeof marked === 'function') {
                 try {
                     let htmlContent = marked.parse(content || ''); // Ensure content is not null/undefined
                     // Use DOMPurify if available
                     if (typeof DOMPurify !== 'undefined') {
                         cntDiv.innerHTML = DOMPurify.sanitize(htmlContent);
                     } else {
                         cntDiv.innerHTML = htmlContent;
                         // Basic script tag removal if DOMPurify is not present
                         if (cntDiv.innerHTML.includes('<script')) {
                             console.warn("Potential XSS vector detected without DOMPurify. Removing script tags.");
                             cntDiv.innerHTML = cntDiv.innerHTML.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
                         }
                     }
                     // Add copy buttons to code blocks after content is set
                     setTimeout(() => { // Use setTimeout to ensure elements are in DOM
                         cntDiv.querySelectorAll('pre').forEach(pre => {
                             if (pre.querySelector('.copy-code-btn')) return; // Don't add if already exists
                             const btn = document.createElement('button');
                             btn.className = 'copy-code-btn'; btn.textContent = 'Copy'; btn.title = 'Copy code';
                             btn.addEventListener('click', (e) => {
                                 e.stopPropagation();
                                 const codeElement = pre.querySelector('code');
                                 const textToCopy = codeElement ? codeElement.textContent : pre.textContent;
                                 navigator.clipboard.writeText(textToCopy).then(() => {
                                     btn.textContent = 'Copied!'; btn.classList.add('copied');
                                     setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 1500);
                                 }).catch(err => {
                                     console.error('Failed to copy code to clipboard:', err);
                                     btn.textContent = 'Error';
                                     setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
                                 });
                             });
                             pre.style.position = 'relative'; // Needed for absolute positioning of button
                             pre.insertBefore(btn, pre.firstChild); // Add button inside pre
                         });
                     }, 0);
                 } catch (e) {
                     console.error("Error parsing Markdown:", e);
                     cntDiv.textContent = content; // Fallback to plain text on error
                 }
             } else {
                 // Display as plain text
                 cntDiv.textContent = content;
             }

             // Append elements based on sender
             if (sender === 'user') {
                 msgDiv.appendChild(cntDiv);
                 msgDiv.appendChild(avImg);
             } else { // spirit or other
                 msgDiv.appendChild(avImg);
                 msgDiv.appendChild(cntDiv);
             }

             pages.appendChild(msgDiv);

             // Scroll to bottom smoothly
             requestAnimationFrame(() => {
                // Check if the user is scrolled up significantly
                const isScrolledUp = pages.scrollHeight - pages.scrollTop - pages.clientHeight > 150; // Threshold
                if (!isScrolledUp) {
                    pages.scrollTo({ top: pages.scrollHeight, behavior: 'smooth' });
                }
             });
         }

        // Show/Remove typing indicator
        function displayTypingIndicator() {
             if(document.getElementById('typing-indicator')) return; // Already showing

             const typDiv = document.createElement('div');
             typDiv.className = 'message message-spirit'; // Use message structure for layout
             typDiv.id = 'typing-indicator';
             typDiv.style.opacity = '0.8'; // Slightly faded

             const avImg = document.createElement('img');
             avImg.className = 'avatar spirit-avatar';
             avImg.src = state.botPfp;
             avImg.alt = 'spirit avatar typing';
             avImg.style.cursor = 'default'; // Not clickable

             const cntDiv = document.createElement('div');
             cntDiv.className = 'typing-indicator'; // Specific styling class
             // Use textContent for safety if runes cause issues
             cntDiv.innerHTML = `<span>The spirit is responding</span><span class="rune" style="animation-delay: 0s;">ᛟ</span><span class="rune" style="animation-delay: 0.2s;">ᛞ</span><span class="rune" style="animation-delay: 0.4s;">ᛝ</span>`;

             typDiv.appendChild(avImg);
             typDiv.appendChild(cntDiv);
             pages.appendChild(typDiv);

             // Scroll down immediately
             requestAnimationFrame(()=>{
                 pages.scrollTo({ top: pages.scrollHeight, behavior: 'smooth' });
             });
         }
        function removeTypingIndicator() {
             const ti = document.getElementById('typing-indicator');
             if(ti) {
                 // Optional: Add a fade-out effect?
                 // ti.style.transition = 'opacity 0.3s ease';
                 // ti.style.opacity = '0';
                 // setTimeout(() => ti.remove(), 300);
                 ti.remove(); // Remove immediately for now
             }
         }

        // --- Settings Modal / Guidance / PFP Logic ---
        function openSettings() {
             // Load current system prompt into the input
             systemPromptInput.value = state.conversationHistory[0]?.content || '';
             // Load current PFPs into previews
             userAvatarPreview.src = state.userPfp;
             spiritAvatarPreview.src = state.botPfp;
             // Update and select current guidance in dropdown
             updateGuidanceSelect();
             const currentPromptName = Object.keys(state.savedPrompts).find(name => state.savedPrompts[name] === systemPromptInput.value);
             guidanceSelect.value = currentPromptName || "";
             // Show the modal
             settingsModal.classList.add('active');
             // Prevent body scrolling while modal is open (optional, handled by overlay typically)
             // document.body.style.overflow = 'hidden';
         }
        function closeSettings() {
             settingsModal.classList.remove('active');
             // Restore body scrolling if it was disabled
             // document.body.style.overflow = '';
         }
        async function saveSettings() {
             console.log("[DEBUG] saveSettings called.");
             const newSysPrompt = systemPromptInput.value.trim();
             const defaultPrompt = 'You are a mystical spirit...'; // Fallback if empty
             const finalPrompt = newSysPrompt || defaultPrompt;

             let promptChanged = false;
             // Update system prompt in conversation history if needed
             if (!state.conversationHistory || state.conversationHistory.length === 0) {
                 // Should not happen if initialized correctly, but handle defensively
                 state.conversationHistory = [{ role: 'system', content: finalPrompt }];
                 promptChanged = true;
                 console.warn("Conversation history was empty during settings save. Reinitialized.");
             } else if (state.conversationHistory[0]?.content !== finalPrompt) {
                 state.conversationHistory[0] = { role: 'system', content: finalPrompt };
                 promptChanged = true;
             }

             if (promptChanged) {
                 console.log("[DEBUG] System prompt changed.");
                 localStorage.setItem('systemPrompt', finalPrompt); // Save for future sessions
             }

             // Save PFPs to localStorage (state.userPfp/botPfp updated directly by handlePfpUpload)
             localStorage.setItem('userPfp', state.userPfp);
             localStorage.setItem('botPfp', state.botPfp);

             // Update avatars currently displayed in the chat log
             document.querySelectorAll('.user-avatar').forEach(img => {
                 if (img.closest('.message') || img.id === 'user-avatar-preview') img.src = state.userPfp;
             });
             document.querySelectorAll('.spirit-avatar').forEach(img => {
                 if (img.closest('.message') || img.closest('#typing-indicator') || img.id === 'spirit-avatar-preview') img.src = state.botPfp;
             });

             // Save updated history to DB if prompt changed and chat exists
             if (promptChanged && state.currentChatId) {
                 const chatData = {
                     id: state.currentChatId,
                     timestamp: Date.now(), // Update timestamp on save
                     history: state.conversationHistory
                 };
                 try {
                     await saveChatDB(chatData); // Use await for async save
                     console.log(`[DEBUG] Saved chat ${state.currentChatId} to DB after settings change.`);
                 } catch (e) {
                     console.error("[DEBUG] DB Save error after settings save:", e);
                     // Alert might have happened in saveChatDB
                 }
             }
             closeSettings(); // Close modal after saving
         }

        function updateGuidanceSelect() {
             const currentVal = guidanceSelect.value; // Store current selection if any
             guidanceSelect.innerHTML = '<option value="">Select saved guidance...</option>';
             // Sort prompts alphabetically by name for easier selection
             const sortedPrompts = Object.entries(state.savedPrompts).sort((a, b) => a[0].localeCompare(b[0]));

             sortedPrompts.forEach(([name, prompt]) => {
                 const opt = document.createElement('option');
                 opt.value = name;
                 opt.textContent = name;
                 // Add title attribute to see full prompt on hover (optional)
                 opt.title = prompt.substring(0, 100) + (prompt.length > 100 ? '...' : '');
                 guidanceSelect.appendChild(opt);
             });
             // Restore selection if it still exists
             if (currentVal && state.savedPrompts[currentVal]) {
                 guidanceSelect.value = currentVal;
             }
         }

        function loadGuidance() {
             const selectedName = guidanceSelect.value;
             if (selectedName && state.savedPrompts[selectedName]) {
                 systemPromptInput.value = state.savedPrompts[selectedName];
             }
         }

        function saveCurrentGuidance() {
             const currentPrompt = systemPromptInput.value.trim();
             if (!currentPrompt) {
                 alert("Guidance cannot be empty."); return;
             }
             // Suggest a name, trying to find existing name first
             const existingName = Object.keys(state.savedPrompts).find(name => state.savedPrompts[name] === currentPrompt);
             const suggestedName = existingName || `Guidance ${Object.keys(state.savedPrompts).length + 1}`;

             const promptName = prompt('Enter a name for this guidance:', suggestedName);
             if (promptName && promptName.trim()) { // Ensure name is not empty
                 const finalName = promptName.trim();
                 state.savedPrompts[finalName] = currentPrompt;
                 localStorage.setItem('savedPrompts', JSON.stringify(state.savedPrompts));
                 updateGuidanceSelect(); // Refresh dropdown
                 guidanceSelect.value = finalName; // Select the newly saved prompt
                 alert(`Guidance saved as "${finalName}".`);
             } else if (promptName !== null) { // User entered empty string and pressed OK
                 alert("Guidance name cannot be empty.");
             } // If promptName is null, user cancelled
         }

        function removeSelectedGuidance() {
             const selectedName = guidanceSelect.value;
             if (selectedName && state.savedPrompts[selectedName]) {
                 if (confirm(`Are you sure you want to delete the saved guidance "${selectedName}"?`)) {
                     const promptValue = state.savedPrompts[selectedName];
                     delete state.savedPrompts[selectedName];
                     localStorage.setItem('savedPrompts', JSON.stringify(state.savedPrompts));
                     updateGuidanceSelect(); // Refresh dropdown
                     // If the deleted prompt was loaded in the textarea, clear the textarea
                     if (systemPromptInput.value === promptValue) {
                         systemPromptInput.value = '';
                     }
                     guidanceSelect.value = ''; // Reset dropdown selection
                     alert(`Guidance "${selectedName}" deleted.`);
                 }
             } else {
                 alert("Please select a saved guidance from the dropdown to remove.");
             }
         }

        function handlePfpUpload(event) {
             const file = event.target.files[0];
             if (!file || !file.type.startsWith('image/')) {
                 alert("Please select a valid image file."); return;
             }
             // Optional: Check file size?
             // const maxSize = 2 * 1024 * 1024; // 2MB example limit
             // if (file.size > maxSize) {
             //     alert("Image file is too large (Max 2MB)."); return;
             // }

             const reader = new FileReader();
             reader.onload = (e) => {
                 const imageUrl = e.target.result;
                 // Check if the result is a valid data URL (basic check)
                 if (imageUrl && typeof imageUrl === 'string' && imageUrl.startsWith('data:image/')) {
                     if (state.currentAvatarBeingEdited === 'user') {
                         state.userPfp = imageUrl;
                         userAvatarPreview.src = imageUrl;
                         // No immediate save to LS here, happens on modal save
                     } else if (state.currentAvatarBeingEdited === 'spirit') {
                         state.botPfp = imageUrl;
                         spiritAvatarPreview.src = imageUrl;
                         // No immediate save to LS here, happens on modal save
                     }
                 } else {
                     console.error("Failed to read image data correctly.");
                     alert("Error reading image file.");
                 }
             };
             reader.onerror = (e) => {
                 console.error("Error reading file:", e);
                 alert("An error occurred while reading the image file.");
             };
             reader.readAsDataURL(file);
             // Reset file input to allow selecting the same file again
             pfpUpload.value = null;
             state.currentAvatarBeingEdited = null; // Reset editing state
         }

        async function undoLastMessage() {
            if (state.isWaitingForResponse) {
                alert("Please wait for the spirit to finish responding before undoing.");
                return;
            }
             if (state.conversationHistory.length <= 1) { // Only system prompt left
                 alert("Nothing to undo.");
                 return;
             }

             // Find the last two messages (usually user and assistant)
             let messagesToRemove = 0;
             const lastMsg = state.conversationHistory[state.conversationHistory.length - 1];
             const secondLastMsg = state.conversationHistory[state.conversationHistory.length - 2];

             // Common case: Undo user message + assistant response
             if (lastMsg?.role === 'assistant' && secondLastMsg?.role === 'user') {
                 messagesToRemove = 2;
             }
             // Case: Only a user message was sent, no response yet (or response failed)
             else if (lastMsg?.role === 'user') {
                 messagesToRemove = 1;
             }
              // Case: Only an assistant message exists (less common, maybe after error/manual add?)
             else if (lastMsg?.role === 'assistant') {
                 messagesToRemove = 1;
             }


             if (messagesToRemove > 0) {
                 console.log(`[DEBUG] Undoing last ${messagesToRemove} message(s).`);
                 // Remove the messages from the history array
                 state.conversationHistory.splice(-messagesToRemove);

                 renderChatHistory(); // Update the visual display

                 // Save the modified history to DB
                 if (state.currentChatId) {
                     const chatData = {
                         id: state.currentChatId,
                         timestamp: Date.now(), // Update timestamp on modification
                         history: state.conversationHistory
                     };
                     try {
                         await saveChatDB(chatData);
                         console.log(`[DEBUG] Saved chat ${state.currentChatId} to DB after undo.`);
                     } catch(e) {
                         console.error("DB Save error after undo:", e);
                         alert("Error saving chat history after undo operation.");
                     }
                 }
                 // Optional: Put the last user message back into the input?
                 // if (messagesToRemove === 2 && secondLastMsg?.role === 'user') {
                 //    messageInput.value = secondLastMsg.content;
                 //    messageInput.focus();
                 // }
             } else {
                 console.log("[DEBUG] Undo called but logic couldn't determine messages to remove.", state.conversationHistory.slice(-2));
                 alert("Could not perform undo operation.");
             }
         }

        // --- Initialization ---
        // Add listener to run init() once the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', init);

    </script>

</body>
</html>
