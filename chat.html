<!DOCTYPE html>
<html lang="en"> <!-- Language set by JS -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Title set by JS -->
    <title data-translate="chat_page_title">Arcane Tome</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.8/purify.min.js"></script> -->

    <!-- Link to the THEME CSS file - href will be changed by JS -->
    <link id="theme-style-link" rel="stylesheet" href="chat-fantasy.css"> <!-- Default theme -->

</head>
<body>
    <div class="tome">
        <div class="pages" id="pages"></div>
        <div class="writing-area">
            <textarea class="message-input" id="message-input" placeholder="Write your message here..." rows="1" data-translate-placeholder="chat_placeholder_message"></textarea>
            <button class="send-button" id="send-button">
                <span data-translate="chat_send_button">Send</span>
                <span>✒</span>
            </button>
        </div>
    </div>

    <!-- Settings Modal - MODIFIED HEADER -->
    <div class="modal-overlay" id="settings-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" data-translate="chat_settings_title">Tome Settings</h3>
                <!-- ADDED: Wrapper for selectors -->
                <div class="modal-header-controls">
                    <select id="theme-selector" title="Select Theme">
                        <option value="chat-fantasy.css" data-translate="theme_fantasy">Fantasy</option>
                        <option value="chat-cyberpunk.css" data-translate="theme_cyberpunk">Cyberpunk</option>
                        <option value="chat-corpo.css" data-translate="theme_corpo">Corpo</option>
                        <option value="chat-gothic.css" data-translate="theme_gothic">Gothic</option>
                        <option value="chat-cute.css" data-translate="theme_cute">Cute</option>
                        <option value="chat-retro.css" data-translate="theme_retro">Retro</option>
                        <option value="chat-fitness.css" data-translate="theme_fitness">Fitness</option>
                    </select>
                    <select id="language-selector" title="Select Language">
                        <option value="en">🇬🇧 EN</option>
                        <option value="pt">🇧🇷 PT</option>
                        <option value="zh">🇨🇳 ZH</option>
                    </select>
                </div>
                <button class="close-btn" id="close-modal" title="Close Settings">×</button>
            </div>
            <div class="modal-body">
                <!-- Guidance -->
                <div class="settings-section">
                    <h4 class="settings-section-title">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" /></svg>
                        <span data-translate="chat_guidance_title">Spirit Guidance</span>
                    </h4>
                    <div class="guidance-controls">
                        <select class="guidance-select" id="guidance-select" data-translate-title="chat_select_guidance_title" title="Select saved guidance...">
                            <option value="" data-translate="chat_select_guidance_option">Select saved guidance...</option>
                        </select>
                        <button class="small-button button-primary" id="save-guidance-btn" data-translate="chat_button_save">Save</button>
                        <button class="small-button button-danger" id="remove-guidance-btn" data-translate="chat_button_remove">Remove</button>
                    </div>
                    <textarea class="system-prompt-input" id="system-prompt-input" placeholder="How should the spirit behave?" data-translate-placeholder="chat_placeholder_guidance"></textarea>
                </div>
                <!-- Tools -->
                <div class="settings-section">
                    <h4 class="settings-section-title">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
                        <span data-translate="chat_tools_title">Conversation Tools</span>
                    </h4>
                    <div style="display: flex; gap: 10px;">
                        <button class="small-button button-danger" id="new-chat-btn" data-translate="chat_button_new_chat">Start New Chat</button>
                        <button class="small-button button-primary" id="undo-btn" data-translate="chat_button_undo">Undo Last Message</button>
                    </div>
                </div>
                <!-- Avatars -->
                <div class="settings-section">
                    <h4 class="settings-section-title">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.121 17.804A13.937 13.937 0 0112 16c2.5 0 4.847.655 6.879 1.804M15 10a3 3 0 11-6 0 3 3 0 016 0zm6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                        <span data-translate="chat_avatar_title">Avatar Settings</span>
                    </h4>
                    <div class="avatar-preview-container">
                        <div class="avatar-preview">
                            <span class="avatar-preview-label" data-translate="chat_avatar_user_label">Your Sigil</span>
                            <img src="" class="avatar-img" id="user-avatar-preview" alt="User Avatar Preview">
                        </div>
                        <div class="avatar-preview">
                            <span class="avatar-preview-label" data-translate="chat_avatar_spirit_label">Spirit's Sigil</span>
                            <img src="" class="avatar-img" id="spirit-avatar-preview" alt="Spirit Avatar Preview">
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" id="cancel-btn" data-translate="chat_button_cancel">Cancel</button>
                <button class="modal-btn modal-btn-primary" id="save-btn" data-translate="chat_button_save_settings">Save Settings</button> <!-- Changed label for clarity -->
            </div>
        </div>
    </div>
    <!-- Hidden File Input -->
    <input type="file" class="pfp-upload" id="pfp-upload" accept="image/*">

    <!-- Secret Menu -->
    <div id="api-key-menu"> <!-- style attribute removed -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <span style="font-weight: bold; font-family: 'Cinzel Decorative', cursive;" data-translate="chat_secrets_title">Secrets & Providers</span>
            <button id="close-api-menu" style="background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0 5px; color: var(--ink-light);" title="Close Menu">×</button>
        </div>
        <div style="margin-bottom: 15px; border-bottom: 1px dashed var(--ink-light); padding-bottom: 15px;">
            <label for="provider-select" data-translate="chat_provider_label">API Provider:</label>
            <select id="provider-select"></select>
            <label for="model-select" data-translate="chat_model_label">Model:</label>
            <select id="model-select"></select>
        </div>
        <div style="margin-bottom: 15px;">
             <span style="font-weight: bold; display: block; margin-bottom: 5px; font-family: 'Cinzel Decorative', cursive; font-size: 1rem;" id="api-key-section-title" data-translate="chat_api_keys_title">API Keys for [Provider]</span> <!-- Title updated by JS -->
             <div id="api-key-list">
                 <p style="font-style: italic; color: var(--ink-light); text-align: center; padding: 5px 0;" data-translate="chat_select_provider_prompt">Select a provider.</p>
             </div>
             <div class="api-key-controls">
                 <input type="text" id="new-api-key-input" placeholder="Add API Key for selected provider" data-translate-placeholder="chat_placeholder_add_key">
                 <button id="add-api-key-btn" data-translate="chat_button_add">Add</button>
             </div>
             <p class="active-key-line">
                <span data-translate="chat_active_key_label">Active Key:</span>
                <strong id="current-active-key-display">None</strong> <!-- Updated by JS -->
            </p>
        </div>
        <div id="saved-chats-section">
             <span style="font-weight: bold; display: block; margin-bottom: 5px; font-family: 'Cinzel Decorative', cursive; font-size: 1rem;" data-translate="chat_saved_chats_title">Saved Chats</span>
             <div id="saved-chats-list-items">
                 <p style="font-style: italic; color: var(--ink-light); text-align: center; padding: 10px 0;" id="chats-loading-msg" data-translate="chat_chats_loading">Checking storage...</p>
             </div>
        </div>
    </div>

    <!-- Reference to the external script file for API definitions -->
    <script src="api_providers.js"></script>

    <!-- Your main script with Theme/Language logic added -->
    <script>
        // Ensure libraries are available
        if (typeof PROVIDERS === 'undefined') { alert("Critical Error: api_providers.js failed to load."); }
        if (typeof idb === 'undefined') { alert("Critical Error: idb library failed to load."); }

        // Configure marked.js
        marked.setOptions({ breaks: true, gfm: true, smartypants: true });

        // === Translation Data ===
        // Integrate chat-specific keys into your existing translations object
        const translations = {
            en: {
                // Page Meta
                "chat_page_title": "Arcane Tome",
                // Themes
                "theme_fantasy": "Fantasy", "theme_cyberpunk": "Cyberpunk", "theme_corpo": "Corpo", "theme_gothic": "Gothic", "theme_cute": "Cute", "theme_retro": "Retro", "theme_fitness": "Fitness",
                // Settings Modal
                "chat_settings_title": "Tome Settings",
                "chat_guidance_title": "Spirit Guidance",
                "chat_select_guidance_title": "Select saved guidance...",
                "chat_select_guidance_option": "Select saved guidance...",
                "chat_button_save": "Save",
                "chat_button_remove": "Remove",
                "chat_placeholder_guidance": "How should the spirit behave?",
                "chat_tools_title": "Conversation Tools",
                "chat_button_new_chat": "Start New Chat",
                "chat_button_undo": "Undo Last Message",
                "chat_avatar_title": "Avatar Settings",
                "chat_avatar_user_label": "Your Sigil",
                "chat_avatar_spirit_label": "Spirit's Sigil",
                "chat_button_cancel": "Cancel",
                "chat_button_save_settings": "Save Settings",
                // API Key / Secret Menu
                "chat_secrets_title": "Secrets & Providers",
                "chat_provider_label": "API Provider:",
                "chat_model_label": "Model:",
                "chat_api_keys_title": "API Keys for {provider}", // Placeholder for JS
                "chat_select_provider_prompt": "Select a provider.",
                "chat_placeholder_add_key": "Add API Key for selected provider",
                "chat_button_add": "Add",
                "chat_active_key_label": "Active Key:",
                "chat_saved_chats_title": "Saved Chats",
                "chat_chats_loading": "Checking storage...",
                "chat_no_chats_found": "No saved chats found.",
                "chat_chats_error": "Error loading chats.",
                "chat_key_exists_alert": "Key already exists for {provider}.",
                "chat_no_provider_alert": "Please select an API provider first.",
                "chat_proxy_key_alert": "API Key is managed by the proxy function for this provider and cannot be added here.",
                "chat_confirm_delete_guidance": "Delete guidance \"{name}\"?",
                "chat_confirm_delete_chat": "Delete chat saved around {time}?",
                "chat_confirm_new_chat": "Start a new chat?\n(Current chat will be saved automatically if needed)",
                "chat_guidance_empty_alert": "Guidance cannot be empty.",
                "chat_prompt_guidance_name": "Enter a name for this guidance:",
                "chat_load_chat_error_alert": "Error loading chat: {error}",
                "chat_load_chat_not_found_alert": "Could not load chat \"{id}\". Data not found.",
                 // Message Area
                "chat_placeholder_message": "Write your message here...",
                "chat_send_button": "Send",
                // API Error Messages
                "chat_error_api_connection": "The connection falters or the spirit is silent...\n({error})",
                "chat_error_no_provider_model": "Cannot contact the spirit: Please select a valid API Provider and Model in the User Sigil menu.",
                "chat_error_no_api_key": "Cannot contact the spirit: No API Key is active for {provider}. Please add or select one via the User Sigil menu.",
                // Typing Indicator
                "chat_typing_indicator": "The spirit is responding",
                // Tooltips
                "chat_tooltip_user_avatar": "Open Secrets & Providers",
                "chat_tooltip_spirit_avatar": "Open Tome Settings",
                "chat_tooltip_copy_code": "Copy code",
                "chat_tooltip_copied": "Copied!",
                "chat_tooltip_copy_error": "Error",
                "chat_tooltip_close_settings": "Close Settings",
                "chat_tooltip_close_secrets": "Close Menu",
                "chat_tooltip_select_theme": "Select Theme",
                "chat_tooltip_select_language": "Select Language",
                // Other UI Text
                "chat_label_none": "None",
                 "chat_label_managed_proxy": "Managed by Proxy",
                 "chat_label_key_handled_proxy": "Key handled by proxy",
                 "chat_label_no_keys_added": "No keys added for this provider.",
                 "chat_label_no_models": "No models available",
                 "chat_key_use": "Use",
                 "chat_key_del": "Del",
                 "chat_chat_load": "Load",
                 "chat_chat_del": "Del",

            },
            pt: {
                 // Page Meta
                "chat_page_title": "Tomo Arcano",
                 // Themes
                "theme_fantasy": "Fantasia", "theme_cyberpunk": "Cyberpunk", "theme_corpo": "Corporativo", "theme_gothic": "Gótico", "theme_cute": "Fofo", "theme_retro": "Retrô", "theme_fitness": "Fitness",
                // Settings Modal
                "chat_settings_title": "Configurações do Tomo",
                "chat_guidance_title": "Guia do Espírito",
                "chat_select_guidance_title": "Selecione uma guia salva...",
                "chat_select_guidance_option": "Selecione uma guia salva...",
                "chat_button_save": "Salvar",
                "chat_button_remove": "Remover",
                "chat_placeholder_guidance": "Como o espírito deve se comportar?",
                "chat_tools_title": "Ferramentas de Conversa",
                "chat_button_new_chat": "Iniciar Nova Conversa",
                "chat_button_undo": "Desfazer Última Mensagem",
                "chat_avatar_title": "Configurações de Avatar",
                "chat_avatar_user_label": "Seu Sigilo",
                "chat_avatar_spirit_label": "Sigilo do Espírito",
                "chat_button_cancel": "Cancelar",
                "chat_button_save_settings": "Salvar Configurações",
                // API Key / Secret Menu
                "chat_secrets_title": "Segredos & Provedores",
                "chat_provider_label": "Provedor de API:",
                "chat_model_label": "Modelo:",
                "chat_api_keys_title": "Chaves de API para {provider}",
                "chat_select_provider_prompt": "Selecione um provedor.",
                "chat_placeholder_add_key": "Adicionar Chave de API para provedor selecionado",
                "chat_button_add": "Adicionar",
                "chat_active_key_label": "Chave Ativa:",
                "chat_saved_chats_title": "Conversas Salvas",
                "chat_chats_loading": "Verificando armazenamento...",
                "chat_no_chats_found": "Nenhuma conversa salva encontrada.",
                "chat_chats_error": "Erro ao carregar conversas.",
                "chat_key_exists_alert": "Chave já existe para {provider}.",
                "chat_no_provider_alert": "Por favor, selecione um provedor de API primeiro.",
                "chat_proxy_key_alert": "A Chave de API é gerenciada pela função proxy para este provedor e não pode ser adicionada aqui.",
                "chat_confirm_delete_guidance": "Excluir guia \"{name}\"?",
                "chat_confirm_delete_chat": "Excluir conversa salva por volta de {time}?",
                "chat_confirm_new_chat": "Iniciar uma nova conversa?\n(A conversa atual será salva automaticamente se necessário)",
                "chat_guidance_empty_alert": "A guia não pode estar vazia.",
                "chat_prompt_guidance_name": "Digite um nome para esta guia:",
                "chat_load_chat_error_alert": "Erro ao carregar conversa: {error}",
                "chat_load_chat_not_found_alert": "Não foi possível carregar a conversa \"{id}\". Dados não encontrados.",
                 // Message Area
                "chat_placeholder_message": "Escreva sua mensagem aqui...",
                "chat_send_button": "Enviar",
                // API Error Messages
                "chat_error_api_connection": "A conexão falha ou o espírito está silencioso...\n({error})",
                "chat_error_no_provider_model": "Não é possível contatar o espírito: Por favor, selecione um Provedor de API e Modelo válidos no menu do Sigilo do Usuário.",
                "chat_error_no_api_key": "Não é possível contatar o espírito: Nenhuma Chave de API está ativa para {provider}. Por favor, adicione ou selecione uma através do menu do Sigilo do Usuário.",
                 // Typing Indicator
                "chat_typing_indicator": "O espírito está respondendo",
                 // Tooltips
                "chat_tooltip_user_avatar": "Abrir Segredos & Provedores",
                "chat_tooltip_spirit_avatar": "Abrir Configurações do Tomo",
                "chat_tooltip_copy_code": "Copiar código",
                "chat_tooltip_copied": "Copiado!",
                "chat_tooltip_copy_error": "Erro",
                "chat_tooltip_close_settings": "Fechar Configurações",
                "chat_tooltip_close_secrets": "Fechar Menu",
                "chat_tooltip_select_theme": "Selecionar Tema",
                "chat_tooltip_select_language": "Selecionar Idioma",
                // Other UI Text
                "chat_label_none": "Nenhuma",
                "chat_label_managed_proxy": "Gerenciado por Proxy",
                "chat_label_key_handled_proxy": "Chave gerenciada por proxy",
                "chat_label_no_keys_added": "Nenhuma chave adicionada para este provedor.",
                "chat_label_no_models": "Nenhum modelo disponível",
                "chat_key_use": "Usar",
                "chat_key_del": "Excl", // Short for Excluir
                "chat_chat_load": "Carregar",
                "chat_chat_del": "Excl",

            },
            zh: {
                 // Page Meta
                "chat_page_title": "奥术魔典",
                 // Themes
                "theme_fantasy": "奇幻", "theme_cyberpunk": "赛博朋克", "theme_corpo": "企业", "theme_gothic": "哥特", "theme_cute": "可爱", "theme_retro": "复古", "theme_fitness": "健身",
                // Settings Modal
                "chat_settings_title": "魔典设置",
                "chat_guidance_title": "灵体指引",
                "chat_select_guidance_title": "选择已保存的指引...",
                "chat_select_guidance_option": "选择已保存的指引...",
                "chat_button_save": "保存",
                "chat_button_remove": "移除",
                "chat_placeholder_guidance": "灵体应该如何行动？",
                "chat_tools_title": "对话工具",
                "chat_button_new_chat": "开始新对话",
                "chat_button_undo": "撤销上一条消息",
                "chat_avatar_title": "头像设置",
                "chat_avatar_user_label": "你的印记",
                "chat_avatar_spirit_label": "灵体的印记",
                "chat_button_cancel": "取消",
                "chat_button_save_settings": "保存设置",
                // API Key / Secret Menu
                "chat_secrets_title": "密钥 & 提供商",
                "chat_provider_label": "API 提供商:",
                "chat_model_label": "模型:",
                "chat_api_keys_title": "{provider} 的 API 密钥",
                "chat_select_provider_prompt": "选择一个提供商。",
                "chat_placeholder_add_key": "为所选提供商添加 API 密钥",
                "chat_button_add": "添加",
                "chat_active_key_label": "当前密钥:",
                "chat_saved_chats_title": "已保存的对话",
                "chat_chats_loading": "检查存储中...",
                "chat_no_chats_found": "未找到已保存的对话。",
                "chat_chats_error": "加载对话时出错。",
                "chat_key_exists_alert": "{provider} 的密钥已存在。",
                "chat_no_provider_alert": "请先选择一个 API 提供商。",
                "chat_proxy_key_alert": "此提供商的 API 密钥由代理功能管理，无法在此处添加。",
                "chat_confirm_delete_guidance": "删除指引 \"{name}\"？",
                "chat_confirm_delete_chat": "删除保存在 {time} 左右的对话？",
                "chat_confirm_new_chat": "开始新的对话？\n(如果需要，当前对话将自动保存)",
                "chat_guidance_empty_alert": "指引不能为空。",
                "chat_prompt_guidance_name": "为此指引输入名称：",
                "chat_load_chat_error_alert": "加载对话时出错：{error}",
                "chat_load_chat_not_found_alert": "无法加载对话 \"{id}\"。未找到数据。",
                 // Message Area
                "chat_placeholder_message": "在此处输入您的消息...",
                "chat_send_button": "发送",
                // API Error Messages
                "chat_error_api_connection": "连接失败或灵体沉默...\n({error})",
                "chat_error_no_provider_model": "无法联系灵体：请在用户印记菜单中选择有效的 API 提供商和模型。",
                "chat_error_no_api_key": "{provider} 没有活动的 API 密钥。请通过用户印记菜单添加或选择一个。",
                 // Typing Indicator
                "chat_typing_indicator": "灵体正在回应",
                 // Tooltips
                "chat_tooltip_user_avatar": "打开密钥 & 提供商",
                "chat_tooltip_spirit_avatar": "打开魔典设置",
                "chat_tooltip_copy_code": "复制代码",
                "chat_tooltip_copied": "已复制！",
                "chat_tooltip_copy_error": "错误",
                "chat_tooltip_close_settings": "关闭设置",
                "chat_tooltip_close_secrets": "关闭菜单",
                "chat_tooltip_select_theme": "选择主题",
                "chat_tooltip_select_language": "选择语言",
                // Other UI Text
                "chat_label_none": "无",
                 "chat_label_managed_proxy": "由代理管理",
                 "chat_label_key_handled_proxy": "密钥由代理处理",
                 "chat_label_no_keys_added": "未为此提供商添加密钥。",
                 "chat_label_no_models": "无可用模型",
                 "chat_key_use": "使用",
                 "chat_key_del": "删除",
                 "chat_chat_load": "加载",
                 "chat_chat_del": "删除",
            }
        };


        // State Management (Unchanged)
        const state = { conversationHistory: [], userPfp: '', botPfp: '', currentAvatarBeingEdited: null, isWaitingForResponse: false, savedPrompts: {}, currentChatId: null, selectedProvider: null, selectedModel: null };
        const apiKeyManagement = { providerKeys: {}, activeKeys: {} };

        // DOM Elements (Add new selectors, theme link)
        const pages = document.getElementById('pages');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const settingsModal = document.getElementById('settings-modal');
        const systemPromptInput = document.getElementById('system-prompt-input');
        const userAvatarPreview = document.getElementById('user-avatar-preview');
        const spiritAvatarPreview = document.getElementById('spirit-avatar-preview');
        const closeModalBtn = document.getElementById('close-modal');
        const cancelBtn = document.getElementById('cancel-btn');
        const saveBtn = document.getElementById('save-btn');
        const pfpUpload = document.getElementById('pfp-upload');
        const guidanceSelect = document.getElementById('guidance-select');
        const saveGuidanceBtn = document.getElementById('save-guidance-btn');
        const removeGuidanceBtn = document.getElementById('remove-guidance-btn');
        const newChatBtn = document.getElementById('new-chat-btn');
        const undoBtn = document.getElementById('undo-btn');
        const apiKeyMenu = document.getElementById('api-key-menu');
        const closeApiMenuBtn = document.getElementById('close-api-menu');
        const providerSelect = document.getElementById('provider-select');
        const modelSelect = document.getElementById('model-select');
        const apiKeySectionTitle = document.getElementById('api-key-section-title');
        const apiKeyListDiv = document.getElementById('api-key-list');
        const newApiKeyInput = document.getElementById('new-api-key-input');
        const addApiKeyBtn = document.getElementById('add-api-key-btn');
        const currentActiveKeyDisplay = document.getElementById('current-active-key-display');
        const savedChatsListItems = document.getElementById('saved-chats-list-items');
        const chatsLoadingMsg = document.getElementById('chats-loading-msg');
        // --- NEW Elements ---
        const themeSelector = document.getElementById('theme-selector');
        const languageSelector = document.getElementById('language-selector');
        const themeStyleLink = document.getElementById('theme-style-link');
        // --- End NEW Elements ---

        // === IndexedDB Setup and Helpers === (Unchanged)
        const DB_NAME = 'ArcaneTomeDB';
        const DB_VERSION = 1;
        const CHAT_STORE_NAME = 'chats';
        async function openArcaneTomeDB() { /* ... */ return idb.openDB(DB_NAME, DB_VERSION, { upgrade(db, oldV, newV, tx) { console.log(`Upgrading DB from ${oldV} to ${newV}`); if (oldV < 1) { const st = db.createObjectStore(CHAT_STORE_NAME, { keyPath: 'id' }); st.createIndex('timestamp', 'timestamp'); } } }); }
        async function saveChatDB(chatData) { /* ... */ try { const db = await openArcaneTomeDB(); await db.put(CHAT_STORE_NAME, chatData); console.log(`[DB] Saved: ${chatData.id}`); } catch (e) { console.error(`[DB] Save Err ${chatData.id}:`, e); alert(`Failed Save: ${e.message}`); throw e; } }
        async function loadChatHistoryDB(chatId) { /* ... */ try { const db = await openArcaneTomeDB(); const d = await db.get(CHAT_STORE_NAME, chatId); return d ? d.history : null; } catch (e) { console.error(`[DB] Load Err ${chatId}:`, e); return null; } }
        async function deleteChatDB(chatId) { /* ... */ try { const db = await openArcaneTomeDB(); await db.delete(CHAT_STORE_NAME, chatId); } catch (e) { console.error(`[DB] Delete Err ${chatId}:`, e); alert(`Failed Delete: ${e.message}`); throw e; } }
        async function getChatListDB() { /* ... */ try { const db = await openArcaneTomeDB(); const all = await db.getAllFromIndex(CHAT_STORE_NAME, 'timestamp'); all.sort((a, b) => b.timestamp - a.timestamp); return all.map(c => ({ id: c.id, timestamp: c.timestamp })); } catch (e) { console.error('[DB] List Err:', e); return []; } }
        // === END IndexedDB ===


        // === Language Functions (Adapting your provided code) ===
        function getStoredLanguage() {
            const storedLang = localStorage.getItem('userLanguage'); // Use same key as your site
            if (storedLang && translations[storedLang]) return storedLang;
            const browserLang = navigator.language || navigator.userLanguage;
            if (browserLang.startsWith('pt')) return 'pt';
            if (browserLang.startsWith('zh')) return 'zh';
            return 'en'; // Default to English
        }

        function setLanguage(lang) {
             if (!translations[lang]) lang = 'en'; // Fallback
             localStorage.setItem('userLanguage', lang);
             document.documentElement.lang = lang; // Set lang attribute on <html>
             translatePage(lang);
             // Update language selector dropdown
             if (languageSelector) languageSelector.value = lang;
        }

        // MODIFIED translatePage to include placeholders and error messages
        function translatePage(lang) {
            if (!translations[lang]) lang = 'en'; // Fallback

            document.querySelectorAll('[data-translate]').forEach(el => {
                const key = el.getAttribute('data-translate');
                let translation = translations[lang]?.[key] ?? translations['en']?.[key]; // Get translation or fallback to English

                // Handle dynamic placeholders like {provider}
                if (translation && translation.includes('{provider}') && state.selectedProvider) {
                    const providerName = PROVIDERS[state.selectedProvider]?.name || state.selectedProvider;
                    translation = translation.replace('{provider}', providerName);
                }
                 // Handle dynamic placeholders like {name} - used in confirm dialogs
                if (translation && translation.includes('{name}')) {
                   // This needs context, usually handled when the function needing it calls translateKey
                   // Keeping it simple here, assume it's handled elsewhere or remove placeholder if not used directly on elements
                }
                 // Handle dynamic placeholders like {time} - used in confirm dialogs
                if (translation && translation.includes('{time}')) {
                    // This also needs context
                }
                 // Handle dynamic placeholders like {error} - used in error messages
                if (translation && translation.includes('{error}')) {
                   // This also needs context
                }
                // Handle dynamic placeholders like {id} - used in error messages
                if (translation && translation.includes('{id}')) {
                    // This also needs context
                }


                if (translation) {
                    // Handle specific elements like title vs others
                    if (el.tagName === 'TITLE') {
                        el.textContent = translation;
                    } else if (el.tagName === 'OPTION' && el.value === "") {
                         // Handle the default "Select..." option text if needed
                         el.textContent = translation;
                    }
                    else {
                        // Use textContent for most elements to avoid potential HTML injection
                        el.textContent = translation;
                    }
                }
            });

            // Handle placeholders separately
            document.querySelectorAll('[data-translate-placeholder]').forEach(el => {
                const key = el.getAttribute('data-translate-placeholder');
                const translation = translations[lang]?.[key] ?? translations['en']?.[key];
                if (translation) {
                    el.placeholder = translation;
                }
            });

             // Handle titles/tooltips
            document.querySelectorAll('[data-translate-title]').forEach(el => {
                const key = el.getAttribute('data-translate-title');
                const translation = translations[lang]?.[key] ?? translations['en']?.[key];
                if (translation) {
                    el.title = translation;
                }
            });

             // Translate dynamic UI text elements (like status messages)
            if (chatsLoadingMsg) {
                if (chatsLoadingMsg.textContent.includes('...')) { // Check if it's the loading message
                     chatsLoadingMsg.textContent = translateKey('chat_chats_loading', lang);
                 } // Don't overwrite error/no chats messages here
             }
              if (currentActiveKeyDisplay) {
                  if (currentActiveKeyDisplay.textContent === 'None') {
                      currentActiveKeyDisplay.textContent = translateKey('chat_label_none', lang);
                  } else if (currentActiveKeyDisplay.textContent === 'Managed by Proxy') {
                      currentActiveKeyDisplay.textContent = translateKey('chat_label_managed_proxy', lang);
                  }
             }
              // Translate default text in API key list
              const apiKeyDefaultMsg = apiKeyListDiv.querySelector('p');
              if (apiKeyDefaultMsg) {
                  if(apiKeyDefaultMsg.textContent.includes('Select a provider')) {
                     apiKeyDefaultMsg.textContent = translateKey('chat_select_provider_prompt', lang);
                  } else if (apiKeyDefaultMsg.textContent.includes('handled by proxy')) {
                     apiKeyDefaultMsg.textContent = translateKey('chat_label_key_handled_proxy', lang);
                  } else if (apiKeyDefaultMsg.textContent.includes('No keys added')) {
                     apiKeyDefaultMsg.textContent = translateKey('chat_label_no_keys_added', lang);
                  }
              }
              // Translate default text in model dropdown
              const modelDefaultMsg = modelSelect.querySelector('option[value=""]');
              if(modelDefaultMsg) {
                  modelDefaultMsg.textContent = translateKey('chat_label_no_models', lang);
              }
               // Translate button text within lists (needs re-render ideally, but quick fix)
              document.querySelectorAll('.load-chat-btn').forEach(btn => btn.textContent = translateKey('chat_chat_load', lang));
              document.querySelectorAll('.delete-chat-btn').forEach(btn => btn.textContent = translateKey('chat_chat_del', lang));
              document.querySelectorAll('#api-key-list .load-chat-btn').forEach(btn => btn.textContent = translateKey('chat_key_use', lang));
              document.querySelectorAll('#api-key-list .delete-chat-btn').forEach(btn => btn.textContent = translateKey('chat_key_del', lang));

        }

        // Helper function to get a specific translation key
        function translateKey(key, lang, replacements = {}) {
            if (!lang || !translations[lang]) lang = 'en'; // Fallback
            let translation = translations[lang]?.[key] ?? translations['en']?.[key] ?? key; // Fallback to key itself if not found

             // Apply replacements
             for (const placeholder in replacements) {
                translation = translation.replace(`{${placeholder}}`, replacements[placeholder]);
            }
            return translation;
        }
        // === END Language Functions ===


        // === Theme Switching Functions ===
        function applyTheme(themeFilename) {
            if (!themeFilename) themeFilename = 'chat-fantasy.css'; // Default fallback
            if (themeStyleLink) {
                themeStyleLink.setAttribute('href', themeFilename);
                localStorage.setItem('selectedThemeFile', themeFilename); // Persist choice
                console.log(`[Theme] Applied: ${themeFilename}`);
            } else {
                console.error("Theme link element not found!");
            }
        }

        function loadTheme() {
            const savedThemeFile = localStorage.getItem('selectedThemeFile') || 'chat-fantasy.css'; // Default
            applyTheme(savedThemeFile);
            // Update theme selector dropdown
            if (themeSelector) themeSelector.value = savedThemeFile;
        }
        // === END Theme Switching ===


        // === API Key / Provider / Model Management === (Mostly unchanged, added translation calls)
         function loadApiAndProviderState() { /* ... */ console.log("[DEBUG] loadApiAndProviderState: Starting."); const storedProviderKeys = localStorage.getItem('providerApiKeys'); if (storedProviderKeys) { try { apiKeyManagement.providerKeys = JSON.parse(storedProviderKeys); if (typeof apiKeyManagement.providerKeys !== 'object' || apiKeyManagement.providerKeys === null) { apiKeyManagement.providerKeys = {}; } Object.keys(apiKeyManagement.providerKeys).forEach(prov => { if (!Array.isArray(apiKeyManagement.providerKeys[prov])) { apiKeyManagement.providerKeys[prov] = []; } }); } catch (e) { console.error("[DEBUG] Error parsing stored provider API keys:", e); apiKeyManagement.providerKeys = {}; localStorage.removeItem('providerApiKeys'); } } else { apiKeyManagement.providerKeys = {}; } const storedActiveKeys = localStorage.getItem('activeApiKeys'); if (storedActiveKeys) { try { apiKeyManagement.activeKeys = JSON.parse(storedActiveKeys); if (typeof apiKeyManagement.activeKeys !== 'object' || apiKeyManagement.activeKeys === null) { apiKeyManagement.activeKeys = {}; } Object.keys(apiKeyManagement.activeKeys).forEach(prov => { const active = apiKeyManagement.activeKeys[prov]; const keysForProvider = apiKeyManagement.providerKeys[prov] || []; if (!keysForProvider.includes(active)) { delete apiKeyManagement.activeKeys[prov]; } }); } catch (e) { console.error("[DEBUG] Error parsing stored active API keys:", e); apiKeyManagement.activeKeys = {}; localStorage.removeItem('activeApiKeys'); } } else { apiKeyManagement.activeKeys = {}; } const savedProvider = localStorage.getItem('selectedProvider'); const savedModel = localStorage.getItem('selectedModel'); if (savedProvider && PROVIDERS[savedProvider]) { state.selectedProvider = savedProvider; } else { state.selectedProvider = Object.keys(PROVIDERS)[0]; } const providerConf = PROVIDERS[state.selectedProvider]; if (savedModel && providerConf && providerConf.availableModels.includes(savedModel)) { state.selectedModel = savedModel; } else { state.selectedModel = providerConf?.defaultModel || null; } Object.keys(apiKeyManagement.providerKeys).forEach(prov => { if (!apiKeyManagement.activeKeys[prov] && apiKeyManagement.providerKeys[prov]?.length > 0) { apiKeyManagement.activeKeys[prov] = apiKeyManagement.providerKeys[prov][0]; } }); saveApiAndProviderState(); console.log(`[DEBUG] Initial provider: ${state.selectedProvider}, model: ${state.selectedModel}`); console.log("[DEBUG] loadApiAndProviderState: Finished."); }
         function saveApiAndProviderState() { /* ... */ localStorage.setItem('providerApiKeys', JSON.stringify(apiKeyManagement.providerKeys)); localStorage.setItem('activeApiKeys', JSON.stringify(apiKeyManagement.activeKeys)); localStorage.setItem('selectedProvider', state.selectedProvider || ''); localStorage.setItem('selectedModel', state.selectedModel || ''); }
         function populateProviderDropdown() { /* ... */ providerSelect.innerHTML = ''; Object.keys(PROVIDERS).forEach(providerKey => { const option = document.createElement('option'); option.value = providerKey; option.textContent = PROVIDERS[providerKey].name; providerSelect.appendChild(option); }); providerSelect.value = state.selectedProvider; }
         function updateModelDropdown() { /* ... */ modelSelect.innerHTML = ''; if (!state.selectedProvider || !PROVIDERS[state.selectedProvider]) { modelSelect.disabled = true; return; } const providerConf = PROVIDERS[state.selectedProvider]; if (!providerConf.availableModels || providerConf.availableModels.length === 0) { const option = document.createElement('option'); option.value = ""; option.textContent = translateKey('chat_label_no_models', getStoredLanguage()); modelSelect.appendChild(option); modelSelect.disabled = true; state.selectedModel = null; return; } modelSelect.disabled = false; providerConf.availableModels.forEach(modelName => { const option = document.createElement('option'); option.value = modelName; option.textContent = modelName; modelSelect.appendChild(option); }); if (state.selectedModel && providerConf.availableModels.includes(state.selectedModel)) { modelSelect.value = state.selectedModel; } else { state.selectedModel = providerConf.defaultModel; modelSelect.value = state.selectedModel; saveApiAndProviderState(); } }
         function renderApiKeysForSelectedProvider() {
             const lang = getStoredLanguage();
             apiKeyListDiv.innerHTML = '';
             if (!state.selectedProvider) {
                 apiKeyListDiv.innerHTML = `<p style="font-style: italic; color: var(--ink-light); text-align: center; padding: 5px 0;">${translateKey('chat_select_provider_prompt', lang)}</p>`;
                 apiKeySectionTitle.textContent = translateKey('chat_api_keys_title', lang, {provider: ''}).replace(' for ',''); // Basic title
                 newApiKeyInput.disabled = true; newApiKeyInput.placeholder = translateKey('chat_select_provider_prompt', lang); addApiKeyBtn.disabled = true;
                 updateActiveKeyDisplay(); return;
             }
             const providerConf = PROVIDERS[state.selectedProvider];
             const providerName = providerConf?.name || state.selectedProvider;
             apiKeySectionTitle.textContent = translateKey('chat_api_keys_title', lang, {provider: providerName});

             if (providerConf?.format === 'proxy_compatible') {
                 apiKeyListDiv.innerHTML = `<p style="font-style: italic; color: var(--ink-light); text-align: center; padding: 5px 0;">${translateKey('chat_proxy_key_alert', lang)}</p>`;
                 newApiKeyInput.disabled = true; newApiKeyInput.placeholder = translateKey('chat_label_key_handled_proxy', lang); addApiKeyBtn.disabled = true;
                 updateActiveKeyDisplay(); return;
             }
             newApiKeyInput.disabled = false; newApiKeyInput.placeholder = translateKey('chat_placeholder_add_key', lang); addApiKeyBtn.disabled = false;
             const keys = apiKeyManagement.providerKeys[state.selectedProvider] || [];
             const activeKey = apiKeyManagement.activeKeys[state.selectedProvider] || null;
             if (keys.length === 0) {
                 apiKeyListDiv.innerHTML = `<p style="font-style: italic; color: var(--ink-light); text-align: center; padding: 5px 0;">${translateKey('chat_label_no_keys_added', lang)}</p>`;
             } else {
                 keys.forEach((key) => { /* ... create elements ... */
                     const kdiv = document.createElement('div'); kdiv.className = 'saved-chat-item'; const isKeyActive = (key === activeKey); if(isKeyActive) kdiv.style.backgroundColor = 'rgba(107, 33, 168, 0.1)';
                     const kspan = document.createElement('span'); kspan.textContent = key; kspan.title = key; if (isKeyActive) { kspan.style.fontWeight = 'bold'; kspan.style.color = 'var(--amethyst)'; }
                     const cdiv = document.createElement('div'); cdiv.style.display = 'flex'; cdiv.style.gap = '5px'; cdiv.style.flexShrink = '0';
                     const ubtn = document.createElement('button'); ubtn.textContent = translateKey('chat_key_use', lang); ubtn.className = 'load-chat-btn'; ubtn.style.backgroundColor = isKeyActive ? 'var(--parchment-dark)' : 'var(--gold)'; ubtn.style.color = isKeyActive ? 'var(--ink-light)' : 'var(--ink)'; ubtn.disabled = isKeyActive; ubtn.onclick = () => setActiveApiKey(state.selectedProvider, key);
                     const dbtn = document.createElement('button'); dbtn.textContent = translateKey('chat_key_del', lang); dbtn.className = 'delete-chat-btn'; dbtn.onclick = () => deleteApiKey(state.selectedProvider, key);
                     cdiv.appendChild(ubtn); cdiv.appendChild(dbtn); kdiv.appendChild(kspan); kdiv.appendChild(cdiv); apiKeyListDiv.appendChild(kdiv);
                 });
             } updateActiveKeyDisplay();
         }
         function setActiveApiKey(provider, key) { /* ... unchanged ... */ if (PROVIDERS[provider]?.format === 'proxy_compatible') return; if (!apiKeyManagement.providerKeys[provider]?.includes(key)) return; apiKeyManagement.activeKeys[provider] = key; saveApiAndProviderState(); renderApiKeysForSelectedProvider(); }
         function deleteApiKey(provider, keyToDelete) { /* ... unchanged ... */ if (PROVIDERS[provider]?.format === 'proxy_compatible') return; if (!apiKeyManagement.providerKeys[provider]) return; apiKeyManagement.providerKeys[provider] = apiKeyManagement.providerKeys[provider].filter(k => k !== keyToDelete); if (apiKeyManagement.activeKeys[provider] === keyToDelete) { const rK = apiKeyManagement.providerKeys[provider]; apiKeyManagement.activeKeys[provider] = rK.length > 0 ? rK[0] : null; } if (apiKeyManagement.providerKeys[provider].length === 0) { delete apiKeyManagement.providerKeys[provider]; delete apiKeyManagement.activeKeys[provider]; } saveApiAndProviderState(); renderApiKeysForSelectedProvider(); }
         function addApiKey() { /* ... uses translateKey for alerts ... */ if (!state.selectedProvider) { alert(translateKey('chat_no_provider_alert', getStoredLanguage())); return; } if (PROVIDERS[state.selectedProvider]?.format === 'proxy_compatible') { alert(translateKey('chat_proxy_key_alert', getStoredLanguage())); newApiKeyInput.value = ''; return; } const newKey = newApiKeyInput.value.trim(); if (!newKey) return; if (!apiKeyManagement.providerKeys[state.selectedProvider]) { apiKeyManagement.providerKeys[state.selectedProvider] = []; } const currentKeys = apiKeyManagement.providerKeys[state.selectedProvider]; if (!currentKeys.includes(newKey)) { currentKeys.push(newKey); if (!apiKeyManagement.activeKeys[state.selectedProvider]) { apiKeyManagement.activeKeys[state.selectedProvider] = newKey; } saveApiAndProviderState(); renderApiKeysForSelectedProvider(); newApiKeyInput.value = ''; } else { alert(translateKey('chat_key_exists_alert', getStoredLanguage(), {provider: PROVIDERS[state.selectedProvider].name})); newApiKeyInput.value = ''; } }
         function updateActiveKeyDisplay() { /* ... uses translateKey for labels ... */ const lang = getStoredLanguage(); const providerConf = state.selectedProvider ? PROVIDERS[state.selectedProvider] : null; if (providerConf?.format === 'proxy_compatible') { currentActiveKeyDisplay.textContent = translateKey('chat_label_managed_proxy', lang); currentActiveKeyDisplay.title = translateKey('chat_label_key_handled_proxy', lang); return; } const activeKey = state.selectedProvider ? apiKeyManagement.activeKeys[state.selectedProvider] : null; currentActiveKeyDisplay.textContent = activeKey || translateKey('chat_label_none', lang); currentActiveKeyDisplay.title = activeKey || ''; }
         function handleProviderChange() { /* ... unchanged ... */ const newProvider = providerSelect.value; state.selectedProvider = newProvider; state.selectedModel = PROVIDERS[newProvider]?.defaultModel || null; saveApiAndProviderState(); updateModelDropdown(); renderApiKeysForSelectedProvider(); }
         function handleModelChange() { /* ... unchanged ... */ const newModel = modelSelect.value; state.selectedModel = newModel; saveApiAndProviderState(); }
        // === END API Key / Provider / Model ===


        // === Saved Chats Management === (Uses translateKey)
        async function populateChatList() { /* ... uses translateKey ... */ const lang = getStoredLanguage(); savedChatsListItems.innerHTML = ''; chatsLoadingMsg.textContent = translateKey('chat_chats_loading', lang); chatsLoadingMsg.style.display = 'block'; try { const chatList = await getChatListDB(); if (chatList.length === 0) { chatsLoadingMsg.textContent = translateKey('chat_no_chats_found', lang); } else { chatsLoadingMsg.style.display = 'none'; chatList.forEach(chatMeta => { /* ... create elements ... */ const itemDiv = document.createElement('div'); itemDiv.className = 'saved-chat-item'; const tsSpan = document.createElement('span'); const date = new Date(chatMeta.timestamp); tsSpan.textContent = date.toLocaleString(undefined, { dateStyle: 'short', timeStyle: 'short' }); tsSpan.title = `ID: ${chatMeta.id}\nSaved: ${date.toISOString()}`; const ctrlDiv = document.createElement('div'); ctrlDiv.style.display = 'flex'; ctrlDiv.style.gap = '5px'; const loadBtn = document.createElement('button'); loadBtn.textContent = translateKey('chat_chat_load', lang); loadBtn.className = 'load-chat-btn'; loadBtn.onclick = (e) => { e.stopPropagation(); loadChat(chatMeta.id); }; const delBtn = document.createElement('button'); delBtn.textContent = translateKey('chat_chat_del', lang); delBtn.className = 'delete-chat-btn'; delBtn.onclick = (e) => { e.stopPropagation(); deleteChat(chatMeta.id); }; ctrlDiv.appendChild(loadBtn); ctrlDiv.appendChild(delBtn); itemDiv.appendChild(tsSpan); itemDiv.appendChild(ctrlDiv); savedChatsListItems.appendChild(itemDiv); }); } } catch (error) { console.error("Error populating chat list from DB:", error); savedChatsListItems.innerHTML = ''; chatsLoadingMsg.style.display = 'block'; chatsLoadingMsg.textContent = translateKey('chat_chats_error', lang); } }
        async function loadChat(chatId) { /* ... uses translateKey ... */ const lang = getStoredLanguage(); console.log(`JS: Attempting to load ${chatId}`); try { const loadedHistory = await loadChatHistoryDB(chatId); if (loadedHistory) { if (Array.isArray(loadedHistory) && loadedHistory.length > 0 && loadedHistory[0]?.role === 'system') { state.conversationHistory = loadedHistory; state.currentChatId = chatId; renderChatHistory(); systemPromptInput.value = state.conversationHistory[0].content; console.log(`JS: Loaded ${chatId}`); closeApiMenu(); } else { throw new Error("Invalid format in loaded chat data"); } } else { console.warn(`JS: Chat ${chatId} not found`); alert(translateKey('chat_load_chat_not_found_alert', lang, {id: chatId})); await populateChatList(); } } catch (error) { console.error(`JS: Error loading ${chatId}:`, error); alert(translateKey('chat_load_chat_error_alert', lang, {error: error.message})); await populateChatList(); } }
        async function deleteChat(chatId) { /* ... uses translateKey ... */ const lang = getStoredLanguage(); const chatItemSpan = document.querySelector(`.saved-chat-item span[title*='ID: ${chatId}']`); const time = chatItemSpan?.textContent || chatId; if (!confirm(translateKey('chat_confirm_delete_chat', lang, {time: time}))) return; console.log(`JS: Deleting ${chatId}`); try { await deleteChatDB(chatId); await populateChatList(); if (state.currentChatId === chatId) { await startNewChat(false); } } catch (error) { console.error(`JS: Error deleting ${chatId}:`, error); } }
        // === END Saved Chats ===


        // === Secret Menu Toggle === (Unchanged)
        async function openApiMenu() { /* ... */ loadApiAndProviderState(); populateProviderDropdown(); updateModelDropdown(); renderApiKeysForSelectedProvider(); await populateChatList(); apiKeyMenu.classList.add('active'); }
        function closeApiMenu() { /* ... */ apiKeyMenu.classList.remove('active'); }
        // === END Secret Menu ===

        // === App Initialization and Core Logic ===
        function initializeChat() { /* ... unchanged ... */ state.currentChatId = `chat_${Date.now()}`; const initPrompt = localStorage.getItem('systemPrompt') || translateKey('default_system_prompt', getStoredLanguage(), {}); state.conversationHistory = [ { role: 'system', content: initPrompt } ]; systemPromptInput.value = initPrompt; console.log(`Init Chat: ${state.currentChatId}`); }

        function init() {
             console.log("[DEBUG] init: Starting...");
             try {
                 // Load persisted state
                 state.savedPrompts = JSON.parse(localStorage.getItem('savedPrompts')) || {};
                 state.userPfp = localStorage.getItem('userPfp') || 'https://ui-avatars.com/api/?name=User&background=1e3a8a&color=fff&bold=true&size=64';
                 state.botPfp = localStorage.getItem('botPfp') || 'https://ui-avatars.com/api/?name=Spirit&background=6b21a8&color=fff&bold=true&size=64';
                 userAvatarPreview.src = state.userPfp; spiritAvatarPreview.src = state.botPfp;

                 // --- NEW: Load Theme ---
                 loadTheme();

                 // --- Initialize Language ---
                 const initialLang = getStoredLanguage();
                 setLanguage(initialLang); // This calls translatePage

                 // Load API/Chat state AFTER language is set for potential defaults
                 loadApiAndProviderState();
                 initializeChat(); // Uses translated default prompt if necessary

                 // Check core elements (Add new selectors)
                 if (!pages || !messageInput || !sendButton || !settingsModal || !apiKeyMenu || !themeSelector || !languageSelector || !themeStyleLink) {
                     throw new Error("Core DOM elements not found!");
                 }

                 console.log("[DEBUG] init: Attaching listeners...");

                 // --- NEW Listeners ---
                 themeSelector.addEventListener('change', (e) => applyTheme(e.target.value));
                 languageSelector.addEventListener('change', (e) => setLanguage(e.target.value));
                 // --- End NEW ---

                 // Existing Listeners (Unchanged structure)
                 closeApiMenuBtn.addEventListener('click', closeApiMenu);
                 providerSelect.addEventListener('change', handleProviderChange);
                 modelSelect.addEventListener('change', handleModelChange);
                 addApiKeyBtn.addEventListener('click', addApiKey);
                 newApiKeyInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); addApiKey(); } });
                 document.addEventListener('click', (event) => { if (apiKeyMenu.classList.contains('active') && !apiKeyMenu.contains(event.target) && !event.target.matches('.user-avatar') && !event.target.closest('#user-avatar-preview')) { closeApiMenu(); } }, true);
                 sendButton.addEventListener('click', sendMessage);
                 messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });
                 messageInput.addEventListener('input', () => { messageInput.style.height = 'auto'; messageInput.style.height = (messageInput.scrollHeight) + 'px'; });
                 closeModalBtn.addEventListener('click', closeSettings);
                 cancelBtn.addEventListener('click', closeSettings);
                 saveBtn.addEventListener('click', saveSettings);
                 pfpUpload.addEventListener('change', handlePfpUpload);
                 guidanceSelect.addEventListener('change', loadGuidance);
                 saveGuidanceBtn.addEventListener('click', saveCurrentGuidance);
                 removeGuidanceBtn.addEventListener('click', removeSelectedGuidance);
                 newChatBtn.addEventListener('click', () => startNewChat(true));
                 undoBtn.addEventListener('click', undoLastMessage);
                 userAvatarPreview.addEventListener('click', () => { state.currentAvatarBeingEdited = 'user'; pfpUpload.click(); });
                 spiritAvatarPreview.addEventListener('click', () => { state.currentAvatarBeingEdited = 'spirit'; pfpUpload.click(); });
                 pages.addEventListener('click', (event) => { if (event.target.matches('.user-avatar') && event.target.closest('.message-user')) { openApiMenu(); } else if (event.target.matches('.spirit-avatar') && event.target.closest('.message-spirit')) { openSettings(); } });

                 renderChatHistory(); // Render initial chat
                 updateGuidanceSelect(); // Populate guidance dropdown after state load

                 console.log("[DEBUG] init: Complete.");
             } catch (error) { console.error("[DEBUG] CRITICAL INIT ERROR:", error); alert(`Initialization Error: ${error.message}`); }
         }

        function renderChatHistory() { /* ... uses translateKey for tooltips ... */ pages.innerHTML = ''; state.conversationHistory.slice(1).forEach(msg => { if (!msg || !msg.role || typeof msg.content === 'undefined') { console.warn("Skip invalid msg:", msg); return; } const sender = msg.role === 'user' ? 'user' : 'spirit'; const pfp = sender === 'user' ? state.userPfp : state.botPfp; const isMarkdown = (msg.role === 'assistant'); displayMessage(msg.content, sender, pfp, isMarkdown); }); requestAnimationFrame(() => { pages.scrollTop = pages.scrollHeight; }); }
        async function startNewChat(confirmFirst = true) { /* ... uses translateKey for confirm ... */ const lang = getStoredLanguage(); if (confirmFirst && !confirm(translateKey('chat_confirm_new_chat', lang))) { return; } if (state.currentChatId && state.conversationHistory.length > 1) { console.log(`Saving chat ${state.currentChatId}`); const chatData = { id: state.currentChatId, timestamp: Date.now(), history: state.conversationHistory }; try { await saveChatDB(chatData); } catch (error) { console.error(`Save Err:`, error); } } const currentPrompt = state.conversationHistory[0]?.content || localStorage.getItem('systemPrompt') || translateKey('default_system_prompt', lang, {}); const newChatId = `chat_${Date.now()}`; state.currentChatId = newChatId; state.conversationHistory = [ { role: 'system', content: currentPrompt } ]; systemPromptInput.value = currentPrompt; renderChatHistory(); closeSettings(); closeApiMenu(); messageInput.focus(); }
        async function sendMessage() { /* ... uses translateKey for error messages ... */ const lang = getStoredLanguage(); console.log("SendMessage"); if (state.isWaitingForResponse) return; const userInput = messageInput.value.trim(); if (!userInput) return; const userMessage = { role: 'user', content: userInput }; state.conversationHistory.push(userMessage); displayMessage(userInput, 'user', state.userPfp, false); messageInput.value = ''; messageInput.style.height = 'auto'; requestAnimationFrame(() => { messageInput.style.height = (messageInput.scrollHeight) + 'px'; }); state.isWaitingForResponse = true; sendButton.disabled = true; const provider = state.selectedProvider; const model = state.selectedModel; const apiKey = provider ? apiKeyManagement.activeKeys[provider] : null; if (!provider || !model) { displayMessage(translateKey('chat_error_no_provider_model', lang), 'spirit', state.botPfp, false); state.isWaitingForResponse = false; sendButton.disabled = false; return; } const providerConf = PROVIDERS[provider]; const requiresUserKey = providerConf?.format !== 'proxy_compatible' && providerConf?.apiKeyLocation !== 'none'; if (requiresUserKey && !apiKey) { const providerName = providerConf?.name || provider; displayMessage(translateKey('chat_error_no_api_key', lang, {provider: providerName}), 'spirit', state.botPfp, false); state.isWaitingForResponse = false; sendButton.disabled = false; if (!apiKeyMenu.classList.contains('active')) messageInput.focus(); return; } displayTypingIndicator(); try { if (typeof getApiResponse !== 'function') throw new Error("getApiResponse not loaded"); const messagesForApi = state.conversationHistory; const botResponse = await getApiResponse(provider, model, messagesForApi, apiKey); removeTypingIndicator(); const assistantMessage = { role: 'assistant', content: botResponse }; state.conversationHistory.push(assistantMessage); displayMessage(botResponse, 'spirit', state.botPfp, true); if (state.currentChatId) { const chatData = { id: state.currentChatId, timestamp: Date.now(), history: state.conversationHistory }; await saveChatDB(chatData).catch(e => console.error("Auto-save failed:", e)); } } catch (error) { console.error('API Error:', error); removeTypingIndicator(); displayMessage(translateKey('chat_error_api_connection', lang, {error: error.message || 'Unknown API error'}), 'spirit', state.botPfp, false); } finally { removeTypingIndicator(); state.isWaitingForResponse = false; sendButton.disabled = false; if (!settingsModal.classList.contains('active') && !apiKeyMenu.classList.contains('active')) { messageInput.focus(); } } }
        function displayMessage(content, sender, pfp, isMarkdown = false) { /* ... uses translateKey for tooltips ... */ const lang = getStoredLanguage(); const msgDiv = document.createElement('div'); msgDiv.className = `message message-${sender}`; const avImg = document.createElement('img'); avImg.className = `avatar ${sender}-avatar`; avImg.src = pfp; avImg.alt = `${sender} avatar`; avImg.title = sender === 'user' ? translateKey('chat_tooltip_user_avatar', lang) : translateKey('chat_tooltip_spirit_avatar', lang); const cntDiv = document.createElement('div'); cntDiv.className = `message-content ${sender}-message`; if (isMarkdown) { let htmlContent = marked.parse(content); if (typeof DOMPurify !== 'undefined') { htmlContent = DOMPurify.sanitize(htmlContent); } else { if (htmlContent.includes('<script')) { console.warn("DOMPurify not loaded!"); htmlContent = htmlContent.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, ''); } } cntDiv.innerHTML = htmlContent; setTimeout(() => { cntDiv.querySelectorAll('pre code').forEach(codeBlock => { const preElement = codeBlock.parentElement; if (preElement?.tagName === 'PRE' && !preElement.querySelector('.copy-code-btn')) { const btn = document.createElement('button'); btn.className = 'copy-code-btn'; btn.textContent = translateKey('chat_tooltip_copy_code', lang); btn.title = translateKey('chat_tooltip_copy_code', lang); btn.addEventListener('click', (e) => { e.stopPropagation(); navigator.clipboard.writeText(codeBlock.textContent).then(() => { btn.textContent = translateKey('chat_tooltip_copied', lang); btn.classList.add('copied'); setTimeout(() => { btn.textContent = translateKey('chat_tooltip_copy_code', lang); btn.classList.remove('copied'); }, 1500); }).catch(err => { btn.textContent = translateKey('chat_tooltip_copy_error', lang); setTimeout(() => { btn.textContent = translateKey('chat_tooltip_copy_code', lang); }, 1500); }); }); preElement.style.position = 'relative'; preElement.appendChild(btn); } }); }, 0); } else { cntDiv.textContent = content; } if (sender === 'user') { msgDiv.appendChild(cntDiv); msgDiv.appendChild(avImg); } else { msgDiv.appendChild(avImg); msgDiv.appendChild(cntDiv); } pages.appendChild(msgDiv); requestAnimationFrame(() => { pages.scrollTo({ top: pages.scrollHeight, behavior: 'smooth' }); }); }
        function displayTypingIndicator() { /* ... uses translateKey ... */ if(document.getElementById('typing-indicator')) return; const lang = getStoredLanguage(); const typDiv = document.createElement('div'); typDiv.className = 'message message-spirit'; typDiv.id = 'typing-indicator'; typDiv.style.opacity = '0.8'; const avImg = document.createElement('img'); avImg.className = 'avatar spirit-avatar'; avImg.src = state.botPfp; avImg.alt = 'spirit avatar'; avImg.style.cursor = 'default'; const cntDiv = document.createElement('div'); cntDiv.className = 'typing-indicator'; cntDiv.innerHTML = `<span>${translateKey('chat_typing_indicator', lang)}</span><span class="rune" style="animation-delay: 0s;">ᛟ</span><span class="rune" style="animation-delay: 0.2s;">ᛞ</span><span class="rune" style="animation-delay: 0.4s;">ᛝ</span>`; typDiv.appendChild(avImg); typDiv.appendChild(cntDiv); pages.appendChild(typDiv); requestAnimationFrame(()=>{ pages.scrollTo({ top: pages.scrollHeight, behavior: 'smooth' }); });}
        function removeTypingIndicator() { /* ... */ const ti=document.getElementById('typing-indicator'); if(ti) ti.remove(); }

        // === Settings Modal / Guidance / PFP Logic === (Uses translateKey)
        function openSettings() { /* ... */ systemPromptInput.value = state.conversationHistory[0]?.content || ''; userAvatarPreview.src = state.userPfp; spiritAvatarPreview.src = state.botPfp; updateGuidanceSelect(); const currentPromptName = Object.keys(state.savedPrompts).find(name => state.savedPrompts[name] === systemPromptInput.value); guidanceSelect.value = currentPromptName || ""; settingsModal.classList.add('active'); }
        function closeSettings() { /* ... */ settingsModal.classList.remove('active'); }
        async function saveSettings() { /* ... */ console.log("Save Settings"); const newSysPrompt = systemPromptInput.value.trim(); const defaultPrompt = translateKey('default_system_prompt', getStoredLanguage(), {}); const finalPrompt = newSysPrompt || defaultPrompt; let promptChanged = false; if (!state.conversationHistory || state.conversationHistory.length === 0) { state.conversationHistory = [{ role: 'system', content: finalPrompt }]; promptChanged = true; } else if (state.conversationHistory[0]?.content !== finalPrompt) { state.conversationHistory[0] = { role: 'system', content: finalPrompt }; promptChanged = true; } if (promptChanged) { localStorage.setItem('systemPrompt', finalPrompt); } localStorage.setItem('userPfp', state.userPfp); localStorage.setItem('botPfp', state.botPfp); document.querySelectorAll('.user-avatar').forEach(img => { if(img.closest('.message') || img.id === 'user-avatar-preview') img.src = state.userPfp; }); document.querySelectorAll('.spirit-avatar').forEach(img => { if(img.closest('.message') || img.closest('#typing-indicator') || img.id === 'spirit-avatar-preview') img.src = state.botPfp; }); if (promptChanged && state.currentChatId) { const chatData = { id: state.currentChatId, timestamp: Date.now(), history: state.conversationHistory }; try { await saveChatDB(chatData); } catch (e) { console.error("Save Err:", e); } } closeSettings(); }
        function updateGuidanceSelect() { /* ... */ const lang = getStoredLanguage(); const currentVal = guidanceSelect.value; guidanceSelect.innerHTML = `<option value="">${translateKey('chat_select_guidance_option', lang)}</option>`; Object.entries(state.savedPrompts).forEach(([name, prompt]) => { const opt = document.createElement('option'); opt.value = name; opt.textContent = name; guidanceSelect.appendChild(opt); }); if (state.savedPrompts[currentVal]) { guidanceSelect.value = currentVal; } }
        function loadGuidance() { /* ... */ const selectedName = guidanceSelect.value; if (selectedName && state.savedPrompts[selectedName]) { systemPromptInput.value = state.savedPrompts[selectedName]; } }
        function saveCurrentGuidance() { /* ... uses translateKey ... */ const lang = getStoredLanguage(); const currentPrompt = systemPromptInput.value.trim(); if (!currentPrompt) { alert(translateKey('chat_guidance_empty_alert', lang)); return; } const currentName = Object.keys(state.savedPrompts).find(name => state.savedPrompts[name] === currentPrompt); const promptName = prompt(translateKey('chat_prompt_guidance_name', lang), currentName || ''); if (promptName) { state.savedPrompts[promptName] = currentPrompt; localStorage.setItem('savedPrompts', JSON.stringify(state.savedPrompts)); updateGuidanceSelect(); guidanceSelect.value = promptName; } }
        function removeSelectedGuidance() { /* ... uses translateKey ... */ const lang = getStoredLanguage(); const selectedName = guidanceSelect.value; if (selectedName && state.savedPrompts[selectedName]) { if (confirm(translateKey('chat_confirm_delete_guidance', lang, {name: selectedName}))) { const promptValue = state.savedPrompts[selectedName]; delete state.savedPrompts[selectedName]; localStorage.setItem('savedPrompts', JSON.stringify(state.savedPrompts)); updateGuidanceSelect(); if (systemPromptInput.value === promptValue) { systemPromptInput.value = ''; } guidanceSelect.value = ''; } } else { alert(translateKey('chat_select_guidance_option', lang)); } }
        function handlePfpUpload(event) { /* ... unchanged ... */ const file = event.target.files[0]; if (!file || !file.type.startsWith('image/')) return; const reader = new FileReader(); reader.onload = (e) => { const url = e.target.result; if (state.currentAvatarBeingEdited === 'user') { state.userPfp = url; userAvatarPreview.src = url; } else if (state.currentAvatarBeingEdited === 'spirit') { state.botPfp = url; spiritAvatarPreview.src = url; } }; reader.onerror = (e) => console.error("PFP Read Err:", e); reader.readAsDataURL(file); pfpUpload.value = null; }
        async function undoLastMessage() { /* ... unchanged ... */ if (state.conversationHistory.length <= 1) return; let messagesRemoved = 0; const lastMessage = state.conversationHistory.pop(); if (lastMessage) { messagesRemoved = 1; if (lastMessage.role === 'assistant' && state.conversationHistory.length > 1 && state.conversationHistory[state.conversationHistory.length - 1]?.role === 'user') { state.conversationHistory.pop(); messagesRemoved = 2; } } if (messagesRemoved > 0) { console.log(`Undo removed ${messagesRemoved}`); renderChatHistory(); if (state.isWaitingForResponse) { state.isWaitingForResponse = false; sendButton.disabled = false; removeTypingIndicator(); } if (state.currentChatId) { const chatData = { id: state.currentChatId, timestamp: Date.now(), history: state.conversationHistory }; try { await saveChatDB(chatData); } catch(e) { console.error("Undo Save error:", e); } } } }
        // === END Settings/Guidance/PFP ===

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', init);

    </script>

</body>
</html>
