<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcane Tome</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- ### ADD IDB LIBRARY ### -->
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
    <!-- Optional: Add DOMPurify for security -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.8/purify.min.js"></script> -->

    <!-- Link to the external CSS file -->
    <link rel="stylesheet" href="chat-styles.css">

</head>
<body>
    <div class="tome">
        <div class="pages" id="pages"></div>
        <div class="writing-area">
            <textarea class="message-input" id="message-input" placeholder="Write your message here..." rows="1"></textarea>
            <button class="send-button" id="send-button"><span>Send</span><span>✒</span></button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settings-modal"> <div class="modal-content"> <div class="modal-header"> <h3 class="modal-title">Tome Settings</h3> <button class="close-btn" id="close-modal">×</button> </div> <div class="modal-body"> <!-- Guidance --> <div class="settings-section"> <h4 class="settings-section-title"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" /></svg> Spirit Guidance </h4> <div class="guidance-controls"> <select class="guidance-select" id="guidance-select"><option value="">Select saved guidance...</option></select> <button class="small-button button-primary" id="save-guidance-btn">Save</button> <button class="small-button button-danger" id="remove-guidance-btn">Remove</button> </div> <textarea class="system-prompt-input" id="system-prompt-input" placeholder="How should the spirit behave?"></textarea> </div> <!-- Tools --> <div class="settings-section"> <h4 class="settings-section-title"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg> Conversation Tools </h4> <div style="display: flex; gap: 10px;"> <button class="small-button button-danger" id="new-chat-btn">Start New Chat</button> <button class="small-button button-primary" id="undo-btn">Undo Last Message</button> </div> </div> <!-- Avatars --> <div class="settings-section"> <h4 class="settings-section-title"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.121 17.804A13.937 13.937 0 0112 16c2.5 0 4.847.655 6.879 1.804M15 10a3 3 0 11-6 0 3 3 0 016 0zm6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg> Avatar Settings </h4> <div class="avatar-preview-container"> <div class="avatar-preview"><span class="avatar-preview-label">Your Sigil</span><img src="" class="avatar-img" id="user-avatar-preview"></div> <div class="avatar-preview"><span class="avatar-preview-label">Spirit's Sigil</span><img src="" class="avatar-img" id="spirit-avatar-preview"></div> </div> </div> </div> <div class="modal-footer"> <button class="modal-btn modal-btn-secondary" id="cancel-btn">Cancel</button> <button class="modal-btn modal-btn-primary" id="save-btn">Save</button> </div> </div> </div>
    <!-- Hidden File Input -->
    <input type="file" class="pfp-upload" id="pfp-upload" accept="image/*">

    <!-- Secret Menu (Inline style removed) -->
    <div id="api-key-menu">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;"> <span style="font-weight: bold; font-family: 'Cinzel Decorative', cursive;">Secrets & Providers</span> <button id="close-api-menu" style="background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0 5px; color: var(--ink-light);">×</button> </div>
        <div style="margin-bottom: 15px; border-bottom: 1px dashed var(--ink-light); padding-bottom: 15px;"> <label for="provider-select">API Provider:</label> <select id="provider-select"></select> <label for="model-select">Model:</label> <select id="model-select"></select> </div>
        <div style="margin-bottom: 15px;"> <span style="font-weight: bold; display: block; margin-bottom: 5px; font-family: 'Cinzel Decorative', cursive; font-size: 1rem;" id="api-key-section-title">API Keys for [Provider]</span> <div id="api-key-list"> <p style="font-style: italic; color: var(--ink-light); text-align: center; padding: 5px 0;">Select a provider.</p> </div> <div class="api-key-controls"> <input type="text" id="new-api-key-input" placeholder="Add API Key for selected provider"> <button id="add-api-key-btn">Add</button> </div> <p class="active-key-line">Active Key: <strong id="current-active-key-display">None</strong></p> </div>
        <div id="saved-chats-section"> <span style="font-weight: bold; display: block; margin-bottom: 5px; font-family: 'Cinzel Decorative', cursive; font-size: 1rem;">Saved Chats</span> <div id="saved-chats-list-items"> <p style="font-style: italic; color: var(--ink-light); text-align: center; padding: 10px 0;" id="chats-loading-msg">Checking storage...</p> </div> </div>
        <!-- Danger Zone Section REMOVED -->
    </div>

    <!-- Reference to the external script file for API definitions -->
    <script src="api_providers.js"></script>

    <!-- Your main script with IndexedDB (MODIFIED JS for menu toggle) -->
    <script>
        // Ensure PROVIDERS is available
        if (typeof PROVIDERS === 'undefined') { alert("Critical Error: api_providers.js failed to load."); }
        // Ensure idb library is available
        if (typeof idb === 'undefined') { alert("Critical Error: idb library failed to load."); }

        // Configure marked.js
        marked.setOptions({ breaks: true, gfm: true, smartypants: true });

        // State Management
        const state = { conversationHistory: [], userPfp: '', botPfp: '', currentAvatarBeingEdited: null, isWaitingForResponse: false, savedPrompts: {}, currentChatId: null, selectedProvider: null, selectedModel: null };
        const apiKeyManagement = { providerKeys: {}, activeKeys: {} };

        // DOM Elements
        const pages = document.getElementById('pages');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const settingsModal = document.getElementById('settings-modal');
        const systemPromptInput = document.getElementById('system-prompt-input');
        const userAvatarPreview = document.getElementById('user-avatar-preview');
        const spiritAvatarPreview = document.getElementById('spirit-avatar-preview');
        const closeModalBtn = document.getElementById('close-modal');
        const cancelBtn = document.getElementById('cancel-btn');
        const saveBtn = document.getElementById('save-btn');
        const pfpUpload = document.getElementById('pfp-upload');
        const guidanceSelect = document.getElementById('guidance-select');
        const saveGuidanceBtn = document.getElementById('save-guidance-btn');
        const removeGuidanceBtn = document.getElementById('remove-guidance-btn');
        const newChatBtn = document.getElementById('new-chat-btn');
        const undoBtn = document.getElementById('undo-btn');
        const apiKeyMenu = document.getElementById('api-key-menu');
        const closeApiMenuBtn = document.getElementById('close-api-menu');
        const providerSelect = document.getElementById('provider-select');
        const modelSelect = document.getElementById('model-select');
        const apiKeySectionTitle = document.getElementById('api-key-section-title');
        const apiKeyListDiv = document.getElementById('api-key-list');
        const newApiKeyInput = document.getElementById('new-api-key-input');
        const addApiKeyBtn = document.getElementById('add-api-key-btn');
        const currentActiveKeyDisplay = document.getElementById('current-active-key-display');
        const savedChatsListItems = document.getElementById('saved-chats-list-items');
        const chatsLoadingMsg = document.getElementById('chats-loading-msg');

        // === IndexedDB Setup and Helpers === (Unchanged from previous version)
        const DB_NAME = 'ArcaneTomeDB';
        const DB_VERSION = 1;
        const CHAT_STORE_NAME = 'chats';

        async function openArcaneTomeDB() {
            return idb.openDB(DB_NAME, DB_VERSION, {
                upgrade(db, oldVersion, newVersion, transaction) {
                    console.log(`Upgrading DB from version ${oldVersion} to ${newVersion}`);
                    if (oldVersion < 1) {
                        const store = db.createObjectStore(CHAT_STORE_NAME, { keyPath: 'id' });
                        store.createIndex('timestamp', 'timestamp');
                        console.log('Created chats object store and timestamp index.');
                    }
                },
            });
        }

        async function saveChatDB(chatData) {
            try {
                const db = await openArcaneTomeDB();
                await db.put(CHAT_STORE_NAME, chatData);
                console.log(`[DB] Chat saved/updated: ${chatData.id}`);
            } catch (error) {
                console.error(`[DB] Error saving chat ${chatData.id}:`, error);
                alert(`Failed to save chat: ${error.message}`);
                throw error;
            }
        }

        async function loadChatHistoryDB(chatId) {
            try {
                const db = await openArcaneTomeDB();
                const chatData = await db.get(CHAT_STORE_NAME, chatId);
                console.log(`[DB] Loaded chat data for ${chatId}:`, chatData ? 'Found' : 'Not Found');
                return chatData ? chatData.history : null;
            } catch (error) {
                console.error(`[DB] Error loading chat ${chatId}:`, error);
                return null;
            }
        }

        async function deleteChatDB(chatId) {
            try {
                const db = await openArcaneTomeDB();
                await db.delete(CHAT_STORE_NAME, chatId);
                console.log(`[DB] Chat deleted: ${chatId}`);
            } catch (error) {
                console.error(`[DB] Error deleting chat ${chatId}:`, error);
                alert(`Failed to delete chat: ${error.message}`);
                throw error;
            }
        }

        async function getChatListDB() {
            try {
                const db = await openArcaneTomeDB();
                const allChats = await db.getAllFromIndex(CHAT_STORE_NAME, 'timestamp');
                allChats.sort((a, b) => b.timestamp - a.timestamp);
                const chatListMeta = allChats.map(chat => ({ id: chat.id, timestamp: chat.timestamp }));
                console.log(`[DB] Retrieved chat list meta: ${chatListMeta.length} items`);
                return chatListMeta;
            } catch (error) {
                console.error('[DB] Error getting chat list:', error);
                return [];
            }
        }
        // === END IndexedDB Helpers ===


        // === API Key and Provider/Model Management === (Unchanged from previous version)
        function loadApiAndProviderState() { /* ... */ console.log("[DEBUG] loadApiAndProviderState: Starting."); const storedProviderKeys = localStorage.getItem('providerApiKeys'); if (storedProviderKeys) { try { apiKeyManagement.providerKeys = JSON.parse(storedProviderKeys); if (typeof apiKeyManagement.providerKeys !== 'object' || apiKeyManagement.providerKeys === null) { apiKeyManagement.providerKeys = {}; } Object.keys(apiKeyManagement.providerKeys).forEach(prov => { if (!Array.isArray(apiKeyManagement.providerKeys[prov])) { apiKeyManagement.providerKeys[prov] = []; } }); } catch (e) { console.error("[DEBUG] Error parsing stored provider API keys:", e); apiKeyManagement.providerKeys = {}; localStorage.removeItem('providerApiKeys'); } } else { apiKeyManagement.providerKeys = {}; } const storedActiveKeys = localStorage.getItem('activeApiKeys'); if (storedActiveKeys) { try { apiKeyManagement.activeKeys = JSON.parse(storedActiveKeys); if (typeof apiKeyManagement.activeKeys !== 'object' || apiKeyManagement.activeKeys === null) { apiKeyManagement.activeKeys = {}; } Object.keys(apiKeyManagement.activeKeys).forEach(prov => { const active = apiKeyManagement.activeKeys[prov]; const keysForProvider = apiKeyManagement.providerKeys[prov] || []; if (!keysForProvider.includes(active)) { delete apiKeyManagement.activeKeys[prov]; } }); } catch (e) { console.error("[DEBUG] Error parsing stored active API keys:", e); apiKeyManagement.activeKeys = {}; localStorage.removeItem('activeApiKeys'); } } else { apiKeyManagement.activeKeys = {}; } const savedProvider = localStorage.getItem('selectedProvider'); const savedModel = localStorage.getItem('selectedModel'); if (savedProvider && PROVIDERS[savedProvider]) { state.selectedProvider = savedProvider; } else { state.selectedProvider = Object.keys(PROVIDERS)[0]; } const providerConf = PROVIDERS[state.selectedProvider]; if (savedModel && providerConf && providerConf.availableModels.includes(savedModel)) { state.selectedModel = savedModel; } else { state.selectedModel = providerConf?.defaultModel || null; } Object.keys(apiKeyManagement.providerKeys).forEach(prov => { if (!apiKeyManagement.activeKeys[prov] && apiKeyManagement.providerKeys[prov]?.length > 0) { apiKeyManagement.activeKeys[prov] = apiKeyManagement.providerKeys[prov][0]; } }); saveApiAndProviderState(); console.log(`[DEBUG] Initial provider: ${state.selectedProvider}, model: ${state.selectedModel}`); console.log("[DEBUG] loadApiAndProviderState: Finished."); }
        function saveApiAndProviderState() { localStorage.setItem('providerApiKeys', JSON.stringify(apiKeyManagement.providerKeys)); localStorage.setItem('activeApiKeys', JSON.stringify(apiKeyManagement.activeKeys)); localStorage.setItem('selectedProvider', state.selectedProvider || ''); localStorage.setItem('selectedModel', state.selectedModel || ''); }
        function populateProviderDropdown() { /* ... */ providerSelect.innerHTML = ''; Object.keys(PROVIDERS).forEach(providerKey => { const option = document.createElement('option'); option.value = providerKey; option.textContent = PROVIDERS[providerKey].name; providerSelect.appendChild(option); }); providerSelect.value = state.selectedProvider; }
        function updateModelDropdown() { /* ... */ modelSelect.innerHTML = ''; if (!state.selectedProvider || !PROVIDERS[state.selectedProvider]) { modelSelect.disabled = true; return; } const providerConf = PROVIDERS[state.selectedProvider]; if (!providerConf.availableModels || providerConf.availableModels.length === 0) { const option = document.createElement('option'); option.value = ""; option.textContent = "No models available"; modelSelect.appendChild(option); modelSelect.disabled = true; state.selectedModel = null; return; } modelSelect.disabled = false; providerConf.availableModels.forEach(modelName => { const option = document.createElement('option'); option.value = modelName; option.textContent = modelName; modelSelect.appendChild(option); }); if (state.selectedModel && providerConf.availableModels.includes(state.selectedModel)) { modelSelect.value = state.selectedModel; } else { state.selectedModel = providerConf.defaultModel; modelSelect.value = state.selectedModel; saveApiAndProviderState(); } }
        function renderApiKeysForSelectedProvider() { /* ... */ apiKeyListDiv.innerHTML = ''; if (!state.selectedProvider) { apiKeyListDiv.innerHTML = '<p style="font-style: italic; color: var(--ink-light); text-align: center; padding: 5px 0;">Select a provider.</p>'; apiKeySectionTitle.textContent = "API Keys"; newApiKeyInput.disabled = true; newApiKeyInput.placeholder = 'Select provider first'; addApiKeyBtn.disabled = true; updateActiveKeyDisplay(); return; } const providerConf = PROVIDERS[state.selectedProvider]; apiKeySectionTitle.textContent = `API Keys for ${providerConf?.name || state.selectedProvider}`; if (providerConf?.format === 'proxy_compatible') { apiKeyListDiv.innerHTML = '<p style="font-style: italic; color: var(--ink-light); text-align: center; padding: 5px 0;">API Key managed by proxy function. No user key needed.</p>'; newApiKeyInput.disabled = true; newApiKeyInput.placeholder = 'Key handled by proxy'; addApiKeyBtn.disabled = true; updateActiveKeyDisplay(); return; } newApiKeyInput.disabled = false; newApiKeyInput.placeholder = 'Add API Key for selected provider'; addApiKeyBtn.disabled = false; const keys = apiKeyManagement.providerKeys[state.selectedProvider] || []; const activeKey = apiKeyManagement.activeKeys[state.selectedProvider] || null; if (keys.length === 0) { apiKeyListDiv.innerHTML = '<p style="font-style: italic; color: var(--ink-light); text-align: center; padding: 5px 0;">No keys added for this provider.</p>'; } else { keys.forEach((key) => { const isKeyActive = (key === activeKey); const kdiv = document.createElement('div'); kdiv.className = 'saved-chat-item'; if(isKeyActive) kdiv.style.backgroundColor = 'rgba(107, 33, 168, 0.1)'; const kspan = document.createElement('span'); kspan.textContent = key; kspan.title = key; if (isKeyActive) { kspan.style.fontWeight = 'bold'; kspan.style.color = 'var(--amethyst)'; } const cdiv = document.createElement('div'); cdiv.style.display = 'flex'; cdiv.style.gap = '5px'; cdiv.style.flexShrink = '0'; const ubtn = document.createElement('button'); ubtn.textContent = 'Use'; ubtn.className = 'load-chat-btn'; ubtn.style.backgroundColor = isKeyActive ? 'var(--parchment-dark)' : 'var(--gold)'; ubtn.style.color = isKeyActive ? 'var(--ink-light)' : 'var(--ink)'; ubtn.disabled = isKeyActive; ubtn.onclick = () => setActiveApiKey(state.selectedProvider, key); const dbtn = document.createElement('button'); dbtn.textContent = 'Del'; dbtn.className = 'delete-chat-btn'; dbtn.onclick = () => deleteApiKey(state.selectedProvider, key); cdiv.appendChild(ubtn); cdiv.appendChild(dbtn); kdiv.appendChild(kspan); kdiv.appendChild(cdiv); apiKeyListDiv.appendChild(kdiv); }); } updateActiveKeyDisplay(); }
        function setActiveApiKey(provider, key) { /* ... */ if (PROVIDERS[provider]?.format === 'proxy_compatible') { console.warn("Attempted to set active key for a proxy provider. Ignored."); return; } if (!apiKeyManagement.providerKeys[provider]?.includes(key)) { console.warn(`Attempted to set non-existent key ${key} for provider ${provider}.`); return; } apiKeyManagement.activeKeys[provider] = key; saveApiAndProviderState(); renderApiKeysForSelectedProvider(); }
        function deleteApiKey(provider, keyToDelete) { /* ... */ if (PROVIDERS[provider]?.format === 'proxy_compatible') { console.warn("Attempted to delete key for a proxy provider. Ignored."); return; } if (!apiKeyManagement.providerKeys[provider]) return; apiKeyManagement.providerKeys[provider] = apiKeyManagement.providerKeys[provider].filter(k => k !== keyToDelete); if (apiKeyManagement.activeKeys[provider] === keyToDelete) { const remainingKeys = apiKeyManagement.providerKeys[provider]; apiKeyManagement.activeKeys[provider] = remainingKeys.length > 0 ? remainingKeys[0] : null; } if (apiKeyManagement.providerKeys[provider].length === 0) { delete apiKeyManagement.providerKeys[provider]; delete apiKeyManagement.activeKeys[provider]; } saveApiAndProviderState(); renderApiKeysForSelectedProvider(); }
        function addApiKey() { /* ... */ if (!state.selectedProvider) { alert("Please select an API provider first."); return; } if (PROVIDERS[state.selectedProvider]?.format === 'proxy_compatible') { alert("API Key is managed by the proxy function for this provider and cannot be added here."); newApiKeyInput.value = ''; return; } const newKey = newApiKeyInput.value.trim(); if (!newKey) return; if (!apiKeyManagement.providerKeys[state.selectedProvider]) { apiKeyManagement.providerKeys[state.selectedProvider] = []; } const currentKeys = apiKeyManagement.providerKeys[state.selectedProvider]; if (!currentKeys.includes(newKey)) { currentKeys.push(newKey); if (!apiKeyManagement.activeKeys[state.selectedProvider]) { apiKeyManagement.activeKeys[state.selectedProvider] = newKey; } saveApiAndProviderState(); renderApiKeysForSelectedProvider(); newApiKeyInput.value = ''; } else { alert(`Key already exists for ${PROVIDERS[state.selectedProvider].name}.`); newApiKeyInput.value = ''; } }
        function updateActiveKeyDisplay() { /* ... */ const providerConf = state.selectedProvider ? PROVIDERS[state.selectedProvider] : null; if (providerConf?.format === 'proxy_compatible') { currentActiveKeyDisplay.textContent = 'Managed by Proxy'; currentActiveKeyDisplay.title = 'API Key is set in the server-side proxy function.'; return; } const activeKey = state.selectedProvider ? apiKeyManagement.activeKeys[state.selectedProvider] : null; currentActiveKeyDisplay.textContent = activeKey || 'None'; currentActiveKeyDisplay.title = activeKey || ''; }
        function handleProviderChange() { /* ... */ const newProvider = providerSelect.value; state.selectedProvider = newProvider; state.selectedModel = PROVIDERS[newProvider]?.defaultModel || null; saveApiAndProviderState(); updateModelDropdown(); renderApiKeysForSelectedProvider(); }
        function handleModelChange() { /* ... */ const newModel = modelSelect.value; state.selectedModel = newModel; saveApiAndProviderState(); }
        // === END API Key Management ===

        // === Saved Chats Management (Using IndexedDB) === (Unchanged from previous version)
        async function populateChatList() { /* ... */ savedChatsListItems.innerHTML = ''; chatsLoadingMsg.textContent = 'Loading chats from DB...'; chatsLoadingMsg.style.display = 'block'; try { const chatList = await getChatListDB(); console.log("[DB] Retrieved chat list:", chatList); if (chatList.length === 0) { chatsLoadingMsg.textContent = 'No saved chats found.'; } else { chatsLoadingMsg.style.display = 'none'; chatList.forEach(chatMeta => { const itemDiv = document.createElement('div'); itemDiv.className = 'saved-chat-item'; const tsSpan = document.createElement('span'); const date = new Date(chatMeta.timestamp); tsSpan.textContent = date.toLocaleString(undefined, { dateStyle: 'short', timeStyle: 'short' }); tsSpan.title = `ID: ${chatMeta.id}\nSaved: ${date.toISOString()}`; const ctrlDiv = document.createElement('div'); ctrlDiv.style.display = 'flex'; ctrlDiv.style.gap = '5px'; const loadBtn = document.createElement('button'); loadBtn.textContent = 'Load'; loadBtn.className = 'load-chat-btn'; loadBtn.onclick = (e) => { e.stopPropagation(); loadChat(chatMeta.id); }; const delBtn = document.createElement('button'); delBtn.textContent = 'Del'; delBtn.className = 'delete-chat-btn'; delBtn.onclick = (e) => { e.stopPropagation(); deleteChat(chatMeta.id); }; ctrlDiv.appendChild(loadBtn); ctrlDiv.appendChild(delBtn); itemDiv.appendChild(tsSpan); itemDiv.appendChild(ctrlDiv); savedChatsListItems.appendChild(itemDiv); }); } } catch (error) { console.error("Error populating chat list from DB:", error); savedChatsListItems.innerHTML = ''; chatsLoadingMsg.style.display = 'block'; chatsLoadingMsg.textContent = 'Error loading chats.'; } }
        async function loadChat(chatId) { /* ... */ console.log(`JS: Attempting to load ${chatId} from DB`); try { const loadedHistory = await loadChatHistoryDB(chatId); if (loadedHistory) { if (Array.isArray(loadedHistory) && loadedHistory.length > 0 && loadedHistory[0]?.role === 'system') { state.conversationHistory = loadedHistory; state.currentChatId = chatId; renderChatHistory(); systemPromptInput.value = state.conversationHistory[0].content; console.log(`JS: Successfully loaded chat history for ${chatId} from DB.`); closeApiMenu(); } else { console.error("[DEBUG] Loaded data from DB is not a valid chat history array:", loadedHistory); throw new Error("Invalid format in loaded chat data"); } } else { console.warn(`JS: Chat ${chatId} not found in DB or error loading.`); alert(`Could not load chat "${chatId}". Data not found.`); await populateChatList(); } } catch (error) { console.error(`JS: Error loading or processing ${chatId} from DB:`, error); alert(`Error loading chat: ${error.message}`); await populateChatList(); } }
        async function deleteChat(chatId) { /* ... */ const chatItemSpan = document.querySelector(`.saved-chat-item span[title*='ID: ${chatId}']`); const confirmMsg = `Delete chat saved around ${chatItemSpan?.textContent || chatId}?`; if (!confirm(confirmMsg)) return; console.log(`JS: Deleting ${chatId} from DB`); try { await deleteChatDB(chatId); console.log(`JS: Delete ${chatId} command sent to DB.`); await populateChatList(); if (state.currentChatId === chatId) { console.log("Active chat deleted. Starting a new chat."); await startNewChat(false); } } catch (error) { console.error(`JS: Error deleting ${chatId} from DB:`, error); } }
        // === END Saved Chats Management ===


        // === MODIFIED: Secret Menu Toggle ===
        async function openApiMenu() {
            loadApiAndProviderState();
            populateProviderDropdown();
            updateModelDropdown();
            renderApiKeysForSelectedProvider();
            await populateChatList();
            apiKeyMenu.classList.add('active'); // Use classList
        }
        function closeApiMenu() {
            apiKeyMenu.classList.remove('active'); // Use classList
        }
        // === END Secret Menu Toggle ===

        // === App Initialization and Core Logic === (Unchanged from previous version)
        function initializeChat() { /* ... */ console.log("[DEBUG] initializeChat: Starting new chat session."); state.currentChatId = `chat_${Date.now()}`; const initialSystemPrompt = localStorage.getItem('systemPrompt') || 'You are a mystical spirit, ancient and wise, speaking through this digital tome. Offer guidance, inspiration, and thoughtful responses. Keep your answers concise but meaningful.'; state.conversationHistory = [ { role: 'system', content: initialSystemPrompt } ]; systemPromptInput.value = initialSystemPrompt; console.log("[DEBUG] initializeChat: New chat session initialized with ID:", state.currentChatId); console.log(`[DEBUG] Using Provider: ${state.selectedProvider}, Model: ${state.selectedModel}`); }

        // --- MODIFIED: init() to use classList for menu closing ---
        function init() {
             console.log("[DEBUG] init: Starting Initialization...");
             try {
                 state.savedPrompts = JSON.parse(localStorage.getItem('savedPrompts')) || {};
                 state.userPfp = localStorage.getItem('userPfp') || 'https://ui-avatars.com/api/?name=User&background=1e3a8a&color=fff&bold=true&size=64';
                 state.botPfp = localStorage.getItem('botPfp') || 'https://ui-avatars.com/api/?name=Spirit&background=6b21a8&color=fff&bold=true&size=64';
                 userAvatarPreview.src = state.userPfp;
                 spiritAvatarPreview.src = state.botPfp;
                 updateGuidanceSelect();
                 loadApiAndProviderState();
                 initializeChat();
                 if (!pages || !messageInput || !sendButton || !settingsModal || !apiKeyMenu) { throw new Error("Core DOM elements not found!"); }
                 console.log("[DEBUG] init: Attaching event listeners...");
                 closeApiMenuBtn.addEventListener('click', closeApiMenu);
                 providerSelect.addEventListener('change', handleProviderChange);
                 modelSelect.addEventListener('change', handleModelChange);
                 addApiKeyBtn.addEventListener('click', addApiKey);
                 newApiKeyInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); addApiKey(); } });
                 // MODIFIED: Close API menu if clicking outside it (check class)
                 document.addEventListener('click', (event) => {
                     if (apiKeyMenu.classList.contains('active') && // Check class
                         !apiKeyMenu.contains(event.target) &&
                         !event.target.matches('.user-avatar') &&
                         !event.target.closest('#user-avatar-preview')) {
                         closeApiMenu();
                     }
                 }, true);
                 sendButton.addEventListener('click', sendMessage);
                 messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });
                 messageInput.addEventListener('input', () => { messageInput.style.height = 'auto'; messageInput.style.height = (messageInput.scrollHeight) + 'px'; });
                 closeModalBtn.addEventListener('click', closeSettings);
                 cancelBtn.addEventListener('click', closeSettings);
                 saveBtn.addEventListener('click', saveSettings);
                 pfpUpload.addEventListener('change', handlePfpUpload);
                 guidanceSelect.addEventListener('change', loadGuidance);
                 saveGuidanceBtn.addEventListener('click', saveCurrentGuidance);
                 removeGuidanceBtn.addEventListener('click', removeSelectedGuidance);
                 newChatBtn.addEventListener('click', () => startNewChat(true));
                 undoBtn.addEventListener('click', undoLastMessage);
                 userAvatarPreview.addEventListener('click', () => { state.currentAvatarBeingEdited = 'user'; pfpUpload.click(); });
                 spiritAvatarPreview.addEventListener('click', () => { state.currentAvatarBeingEdited = 'spirit'; pfpUpload.click(); });
                 pages.addEventListener('click', (event) => { if (event.target.matches('.user-avatar') && event.target.closest('.message-user')) { openApiMenu(); } else if (event.target.matches('.spirit-avatar') && event.target.closest('.message-spirit')) { openSettings(); } });
                 renderChatHistory();
                 console.log("[DEBUG] init: Initialization flow complete.");
             } catch (error) { console.error("[DEBUG] CRITICAL ERROR DURING INIT:", error); alert("A critical error occurred during initialization: " + error.message + ". Check the developer console."); }
         }
         // --- END MODIFIED init() ---

        function renderChatHistory() { /* ... */ pages.innerHTML = ''; state.conversationHistory.slice(1).forEach(msg => { if (!msg || !msg.role || typeof msg.content === 'undefined') { console.warn("Skipping invalid message object during render:", msg); return; } const sender = msg.role === 'user' ? 'user' : 'spirit'; const pfp = sender === 'user' ? state.userPfp : state.botPfp; const isMarkdown = (msg.role === 'assistant'); displayMessage(msg.content, sender, pfp, isMarkdown); }); requestAnimationFrame(() => { pages.scrollTop = pages.scrollHeight; }); }
        async function startNewChat(confirmFirst = true) { /* ... */ if (confirmFirst && !confirm('Start a new chat?\n(Current chat will be saved automatically if needed)')) { return; } if (state.currentChatId && state.conversationHistory.length > 1) { console.log(`JS: Saving current chat ${state.currentChatId} to DB before starting new.`); const chatData = { id: state.currentChatId, timestamp: Date.now(), history: state.conversationHistory }; try { await saveChatDB(chatData); console.log(`JS: Save ${state.currentChatId} to DB successful.`); } catch (error) { console.error(`JS: Error saving ${state.currentChatId} to DB:`, error); } } const currentSystemPrompt = state.conversationHistory[0]?.content || localStorage.getItem('systemPrompt') || 'You are a mystical spirit...'; const newChatId = `chat_${Date.now()}`; console.log("Starting new chat:", newChatId); state.currentChatId = newChatId; state.conversationHistory = [ { role: 'system', content: currentSystemPrompt } ]; systemPromptInput.value = currentSystemPrompt; renderChatHistory(); closeSettings(); closeApiMenu(); messageInput.focus(); }

        // --- MODIFIED: sendMessage() to use classList for menu checking ---
        async function sendMessage() {
             console.log("[DEBUG] sendMessage: Called.");
             if (state.isWaitingForResponse) { console.log("[DEBUG] sendMessage: Aborted, waiting."); return; }
             const userInput = messageInput.value.trim();
             if (!userInput) { console.log("[DEBUG] sendMessage: Aborted, empty input."); return; }
             const userMessage = { role: 'user', content: userInput };
             state.conversationHistory.push(userMessage);
             displayMessage(userInput, 'user', state.userPfp, false);
             messageInput.value = ''; messageInput.style.height = 'auto'; requestAnimationFrame(() => { messageInput.style.height = (messageInput.scrollHeight) + 'px'; });
             state.isWaitingForResponse = true; sendButton.disabled = true;
             const provider = state.selectedProvider; const model = state.selectedModel; const apiKey = provider ? apiKeyManagement.activeKeys[provider] : null;
             console.log(`[DEBUG] sendMessage: Provider=${provider}, Model=${model}, Key=${apiKey ? 'Exists/Selected' : 'Missing/Not Selected'}`);
             if (!provider || !model) { /* ... error handling ... */ displayMessage("Cannot contact the spirit: Please select a valid API Provider and Model in the User Sigil menu.", 'spirit', state.botPfp, false); state.isWaitingForResponse = false; sendButton.disabled = false; return; }
             const providerConf = PROVIDERS[provider]; const requiresUserKey = providerConf?.format !== 'proxy_compatible' && providerConf?.apiKeyLocation !== 'none';
             if (requiresUserKey && !apiKey) { /* ... error handling ... */ displayMessage(`Cannot contact the spirit: No API Key is active for ${providerConf?.name || provider}. Please add or select one via the User Sigil menu.`, 'spirit', state.botPfp, false); state.isWaitingForResponse = false; sendButton.disabled = false; if (!apiKeyMenu.classList.contains('active')) { messageInput.focus(); } return; } // Check class
             displayTypingIndicator();
             try {
                 if (typeof getApiResponse !== 'function') { throw new Error("API provider function (getApiResponse) not found."); }
                 console.log(`[DEBUG] sendMessage: Calling getApiResponse for ${provider}...`);
                 const messagesForApi = state.conversationHistory;
                 const botResponse = await getApiResponse(provider, model, messagesForApi, apiKey);
                 console.log("[DEBUG] sendMessage: getApiResponse successful.");
                 removeTypingIndicator();
                 const assistantMessage = { role: 'assistant', content: botResponse };
                 state.conversationHistory.push(assistantMessage);
                 displayMessage(botResponse, 'spirit', state.botPfp, true);
                 if (state.currentChatId) { console.log(`[DEBUG] Auto-saving chat ${state.currentChatId} after response.`); const chatData = { id: state.currentChatId, timestamp: Date.now(), history: state.conversationHistory }; await saveChatDB(chatData).catch(e => console.error("[DEBUG] Auto-save failed:", e)); }
             } catch (error) { console.error('[DEBUG] Error during API call execution:', error); removeTypingIndicator(); displayMessage(`The connection falters or the spirit is silent...\n(${error.message || 'Unknown API error'})`, 'spirit', state.botPfp, false); }
              finally { console.log("[DEBUG] sendMessage: Entering finally block."); removeTypingIndicator(); state.isWaitingForResponse = false; sendButton.disabled = false; if (!settingsModal.classList.contains('active') && !apiKeyMenu.classList.contains('active')) { messageInput.focus(); } } // Check class
         }
         // --- END MODIFIED sendMessage() ---

        function displayMessage(content, sender, pfp, isMarkdown = false) { /* ... */ const msgDiv = document.createElement('div'); msgDiv.className = `message message-${sender}`; const avImg = document.createElement('img'); avImg.className = `avatar ${sender}-avatar`; avImg.src = pfp; avImg.alt = `${sender} avatar`; avImg.title = sender === 'user' ? 'Open Secrets & Providers' : 'Open Tome Settings'; const cntDiv = document.createElement('div'); cntDiv.className = `message-content ${sender}-message`; if (isMarkdown) { let htmlContent = marked.parse(content); if (typeof DOMPurify !== 'undefined') { htmlContent = DOMPurify.sanitize(htmlContent); } else { if (htmlContent.includes('<script')) { console.warn("Potential XSS vector detected."); htmlContent = htmlContent.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, ''); } } cntDiv.innerHTML = htmlContent; setTimeout(() => { cntDiv.querySelectorAll('pre code').forEach(codeBlock => { const preElement = codeBlock.parentElement; if (preElement && preElement.tagName === 'PRE' && !preElement.querySelector('.copy-code-btn')) { const btn = document.createElement('button'); btn.className = 'copy-code-btn'; btn.textContent = 'Copy'; btn.title = 'Copy code'; btn.addEventListener('click', (e) => { e.stopPropagation(); navigator.clipboard.writeText(codeBlock.textContent).then(() => { btn.textContent = 'Copied!'; btn.classList.add('copied'); setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 1500); }).catch(err => { console.error('Failed to copy code:', err); btn.textContent = 'Error'; setTimeout(() => { btn.textContent = 'Copy'; }, 1500); }); }); preElement.style.position = 'relative'; preElement.appendChild(btn); } }); }, 0); } else { cntDiv.textContent = content; } if (sender === 'user') { msgDiv.appendChild(cntDiv); msgDiv.appendChild(avImg); } else { msgDiv.appendChild(avImg); msgDiv.appendChild(cntDiv); } pages.appendChild(msgDiv); requestAnimationFrame(() => { pages.scrollTo({ top: pages.scrollHeight, behavior: 'smooth' }); }); }
        function displayTypingIndicator() { /* ... */ if(document.getElementById('typing-indicator')) return; const typDiv = document.createElement('div'); typDiv.className = 'message message-spirit'; typDiv.id = 'typing-indicator'; typDiv.style.opacity = '0.8'; const avImg = document.createElement('img'); avImg.className = 'avatar spirit-avatar'; avImg.src = state.botPfp; avImg.alt = 'spirit avatar'; avImg.style.cursor = 'default'; const cntDiv = document.createElement('div'); cntDiv.className = 'typing-indicator'; cntDiv.innerHTML = `<span>The spirit is responding</span><span class="rune" style="animation-delay: 0s;">ᛟ</span><span class="rune" style="animation-delay: 0.2s;">ᛞ</span><span class="rune" style="animation-delay: 0.4s;">ᛝ</span>`; typDiv.appendChild(avImg); typDiv.appendChild(cntDiv); pages.appendChild(typDiv); requestAnimationFrame(() => { pages.scrollTo({ top: pages.scrollHeight, behavior: 'smooth' }); }); }
        function removeTypingIndicator() { /* ... */ const ti = document.getElementById('typing-indicator'); if(ti) ti.remove(); }

        // --- Settings Modal / Guidance / PFP Logic --- (Unchanged from previous version)
        function openSettings() { /* ... */ systemPromptInput.value = state.conversationHistory[0]?.content || ''; userAvatarPreview.src = state.userPfp; spiritAvatarPreview.src = state.botPfp; updateGuidanceSelect(); const currentPromptName = Object.keys(state.savedPrompts).find(name => state.savedPrompts[name] === systemPromptInput.value); guidanceSelect.value = currentPromptName || ""; settingsModal.classList.add('active'); }
        function closeSettings() { /* ... */ settingsModal.classList.remove('active'); }
        async function saveSettings() { /* ... */ console.log("[DEBUG] saveSettings called."); const newSysPrompt = systemPromptInput.value.trim(); const defaultPrompt = 'You are a mystical spirit...'; const finalPrompt = newSysPrompt || defaultPrompt; let promptChanged = false; if (!state.conversationHistory || state.conversationHistory.length === 0) { state.conversationHistory = [{ role: 'system', content: finalPrompt }]; promptChanged = true; } else if (state.conversationHistory[0]?.content !== finalPrompt) { state.conversationHistory[0] = { role: 'system', content: finalPrompt }; promptChanged = true; } if (promptChanged) { console.log("[DEBUG] System prompt changed."); localStorage.setItem('systemPrompt', finalPrompt); } localStorage.setItem('userPfp', state.userPfp); localStorage.setItem('botPfp', state.botPfp); document.querySelectorAll('.user-avatar').forEach(img => { if(img.closest('.message') || img.id === 'user-avatar-preview') { img.src = state.userPfp; } }); document.querySelectorAll('.spirit-avatar').forEach(img => { if(img.closest('.message') || img.closest('#typing-indicator') || img.id === 'spirit-avatar-preview') { img.src = state.botPfp; } }); if (promptChanged && state.currentChatId) { const chatData = { id: state.currentChatId, timestamp: Date.now(), history: state.conversationHistory }; try { await saveChatDB(chatData); console.log(`[DEBUG] Saved chat ${state.currentChatId} to DB after settings save.`); } catch (e) { console.error("[DEBUG] Save error after settings save:", e); } } closeSettings(); }
        function updateGuidanceSelect() { /* ... */ const currentVal = guidanceSelect.value; guidanceSelect.innerHTML = '<option value="">Select saved guidance...</option>'; Object.entries(state.savedPrompts).forEach(([name, prompt]) => { const opt = document.createElement('option'); opt.value = name; opt.textContent = name; guidanceSelect.appendChild(opt); }); if (state.savedPrompts[currentVal]) { guidanceSelect.value = currentVal; } }
        function loadGuidance() { /* ... */ const selectedName = guidanceSelect.value; if (selectedName && state.savedPrompts[selectedName]) { systemPromptInput.value = state.savedPrompts[selectedName]; } }
        function saveCurrentGuidance() { /* ... */ const currentPrompt = systemPromptInput.value.trim(); if (!currentPrompt) { alert("Guidance cannot be empty."); return; } const currentName = Object.keys(state.savedPrompts).find(name => state.savedPrompts[name] === currentPrompt); const promptName = prompt('Enter a name for this guidance:', currentName || ''); if (promptName) { state.savedPrompts[promptName] = currentPrompt; localStorage.setItem('savedPrompts', JSON.stringify(state.savedPrompts)); updateGuidanceSelect(); guidanceSelect.value = promptName; } }
        function removeSelectedGuidance() { /* ... */ const selectedName = guidanceSelect.value; if (selectedName && state.savedPrompts[selectedName]) { if (confirm(`Delete guidance "${selectedName}"?`)) { const promptValue = state.savedPrompts[selectedName]; delete state.savedPrompts[selectedName]; localStorage.setItem('savedPrompts', JSON.stringify(state.savedPrompts)); updateGuidanceSelect(); if (systemPromptInput.value === promptValue) { systemPromptInput.value = ''; } guidanceSelect.value = ''; } } else { alert("Select a saved guidance from the dropdown to remove."); } }
        function handlePfpUpload(event) { /* ... */ const file = event.target.files[0]; if (!file || !file.type.startsWith('image/')) return; const reader = new FileReader(); reader.onload = (e) => { const url = e.target.result; if (state.currentAvatarBeingEdited === 'user') { state.userPfp = url; userAvatarPreview.src = url; } else if (state.currentAvatarBeingEdited === 'spirit') { state.botPfp = url; spiritAvatarPreview.src = url; } }; reader.onerror = (e) => console.error("Error reading PFP file:", e); reader.readAsDataURL(file); pfpUpload.value = null; }
        async function undoLastMessage() { /* ... */ if (state.conversationHistory.length <= 1) return; let messagesRemoved = 0; const lastMessage = state.conversationHistory.pop(); if (lastMessage) { messagesRemoved = 1; if (lastMessage.role === 'assistant' && state.conversationHistory.length > 1 && state.conversationHistory[state.conversationHistory.length - 1]?.role === 'user') { state.conversationHistory.pop(); messagesRemoved = 2; } } if (messagesRemoved > 0) { console.log(`[DEBUG] Undo removed ${messagesRemoved} message(s).`); renderChatHistory(); if (state.isWaitingForResponse) { console.log("[DEBUG] Undo while waiting - cancelling response state."); state.isWaitingForResponse = false; sendButton.disabled = false; removeTypingIndicator(); } if (state.currentChatId) { const chatData = { id: state.currentChatId, timestamp: Date.now(), history: state.conversationHistory }; try { await saveChatDB(chatData); console.log(`[DEBUG] Saved chat ${state.currentChatId} to DB after undo.`); } catch(e) { console.error("Save error after undo:", e); } } } else { console.log("[DEBUG] Undo called but no messages to remove."); } }
        // === END Settings Modal Logic ===

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', init);

    </script>

</body>
</html>
