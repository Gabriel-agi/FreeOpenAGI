<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcane Tome</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- ### ADD IDB LIBRARY ### -->
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
    <!-- Optional: Add DOMPurify for security -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.8/purify.min.js"></script> -->

    <!-- Link to the external CSS file -->
    <link rel="stylesheet" href="chat-styles.css">

</head>
<body>
    <div class="tome">
        <div class="pages" id="pages"></div>
        <div class="writing-area">
            <textarea class="message-input" id="message-input" placeholder="Write your message here..." rows="1"></textarea>
            <button class="send-button" id="send-button"><span>Send</span><span>✒</span></button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settings-modal"> <div class="modal-content"> <div class="modal-header"> <h3 class="modal-title">Tome Settings</h3> <button class="close-btn" id="close-modal">×</button> </div> <div class="modal-body"> <!-- Guidance --> <div class="settings-section"> <h4 class="settings-section-title"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" /></svg> Spirit Guidance </h4> <div class="guidance-controls"> <select class="guidance-select" id="guidance-select"><option value="">Select saved guidance...</option></select> <button class="small-button button-primary" id="save-guidance-btn">Save</button> <button class="small-button button-danger" id="remove-guidance-btn">Remove</button> </div> <textarea class="system-prompt-input" id="system-prompt-input" placeholder="How should the spirit behave?"></textarea> </div> <!-- Tools --> <div class="settings-section"> <h4 class="settings-section-title"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg> Conversation Tools </h4> <div style="display: flex; gap: 10px;"> <button class="small-button button-danger" id="new-chat-btn">Start New Chat</button> <button class="small-button button-primary" id="undo-btn">Undo Last Message</button> </div> </div> <!-- Avatars --> <div class="settings-section"> <h4 class="settings-section-title"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.121 17.804A13.937 13.937 0 0112 16c2.5 0 4.847.655 6.879 1.804M15 10a3 3 0 11-6 0 3 3 0 016 0zm6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg> Avatar Settings </h4> <div class="avatar-preview-container"> <div class="avatar-preview"><span class="avatar-preview-label">Your Sigil</span><img src="" class="avatar-img" id="user-avatar-preview"></div> <div class="avatar-preview"><span class="avatar-preview-label">Spirit's Sigil</span><img src="" class="avatar-img" id="spirit-avatar-preview"></div> </div> </div> </div> <div class="modal-footer"> <button class="modal-btn modal-btn-secondary" id="cancel-btn">Cancel</button> <button class="modal-btn modal-btn-primary" id="save-btn">Save</button> </div> </div> </div>
    <!-- Hidden File Input -->
    <input type="file" class="pfp-upload" id="pfp-upload" accept="image/*">

    <!-- Secret Menu -->
    <div id="api-key-menu" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--parchment-dark); border: 1px solid var(--ink); padding: 15px; font-size: 0.9rem; z-index: 200; box-shadow: 0 5px 15px rgba(0,0,0,0.4); border-radius: 4px; min-width: 350px; max-width: 90%; max-height: 80vh; overflow-y: auto; color: var(--ink);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;"> <span style="font-weight: bold; font-family: 'Cinzel Decorative', cursive;">Secrets & Providers</span> <button id="close-api-menu" style="background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0 5px; color: var(--ink-light);">×</button> </div>
        <div style="margin-bottom: 15px; border-bottom: 1px dashed var(--ink-light); padding-bottom: 15px;"> <label for="provider-select">API Provider:</label> <select id="provider-select"></select> <label for="model-select">Model:</label> <select id="model-select"></select> </div>
        <div style="margin-bottom: 15px;"> <span style="font-weight: bold; display: block; margin-bottom: 5px; font-family: 'Cinzel Decorative', cursive; font-size: 1rem;" id="api-key-section-title">API Keys for [Provider]</span> <div id="api-key-list"> <p style="font-style: italic; color: var(--ink-light); text-align: center; padding: 5px 0;">Select a provider.</p> </div> <div class="api-key-controls"> <input type="text" id="new-api-key-input" placeholder="Add API Key for selected provider"> <button id="add-api-key-btn">Add</button> </div> <p class="active-key-line">Active Key: <strong id="current-active-key-display">None</strong></p> </div>
        <div id="saved-chats-section"> <span style="font-weight: bold; display: block; margin-bottom: 5px; font-family: 'Cinzel Decorative', cursive; font-size: 1rem;">Saved Chats</span> <div id="saved-chats-list-items"> <p style="font-style: italic; color: var(--ink-light); text-align: center; padding: 10px 0;" id="chats-loading-msg">Checking storage...</p> </div> </div>
        <!-- Danger Zone Section REMOVED -->
    </div>

    <!-- Reference to the external script file for API definitions -->
    <script src="api_providers.js"></script>

    <!-- Your main script with IndexedDB -->
    <script>
        // Ensure PROVIDERS is available
        if (typeof PROVIDERS === 'undefined') { alert("Critical Error: api_providers.js failed to load."); }
        // Ensure idb library is available
        if (typeof idb === 'undefined') { alert("Critical Error: idb library failed to load."); }

        // Configure marked.js
        marked.setOptions({ breaks: true, gfm: true, smartypants: true });

        // State Management
        const state = { conversationHistory: [], userPfp: '', botPfp: '', currentAvatarBeingEdited: null, isWaitingForResponse: false, savedPrompts: {}, currentChatId: null, selectedProvider: null, selectedModel: null };
        const apiKeyManagement = { providerKeys: {}, activeKeys: {} };

        // DOM Elements
        const pages = document.getElementById('pages');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const settingsModal = document.getElementById('settings-modal');
        const systemPromptInput = document.getElementById('system-prompt-input');
        const userAvatarPreview = document.getElementById('user-avatar-preview');
        const spiritAvatarPreview = document.getElementById('spirit-avatar-preview');
        const closeModalBtn = document.getElementById('close-modal');
        const cancelBtn = document.getElementById('cancel-btn');
        const saveBtn = document.getElementById('save-btn');
        const pfpUpload = document.getElementById('pfp-upload');
        const guidanceSelect = document.getElementById('guidance-select');
        const saveGuidanceBtn = document.getElementById('save-guidance-btn');
        const removeGuidanceBtn = document.getElementById('remove-guidance-btn');
        const newChatBtn = document.getElementById('new-chat-btn');
        const undoBtn = document.getElementById('undo-btn');
        const apiKeyMenu = document.getElementById('api-key-menu');
        const closeApiMenuBtn = document.getElementById('close-api-menu');
        const providerSelect = document.getElementById('provider-select');
        const modelSelect = document.getElementById('model-select');
        const apiKeySectionTitle = document.getElementById('api-key-section-title');
        const apiKeyListDiv = document.getElementById('api-key-list');
        const newApiKeyInput = document.getElementById('new-api-key-input');
        const addApiKeyBtn = document.getElementById('add-api-key-btn');
        const currentActiveKeyDisplay = document.getElementById('current-active-key-display');
        const savedChatsListItems = document.getElementById('saved-chats-list-items');
        const chatsLoadingMsg = document.getElementById('chats-loading-msg');

        // === IndexedDB Setup and Helpers ===
        const DB_NAME = 'ArcaneTomeDB';
        const DB_VERSION = 1;
        const CHAT_STORE_NAME = 'chats';

        async function openArcaneTomeDB() {
            return idb.openDB(DB_NAME, DB_VERSION, {
                upgrade(db, oldVersion, newVersion, transaction) {
                    console.log(`Upgrading DB from version ${oldVersion} to ${newVersion}`);
                    if (oldVersion < 1) {
                        // Create the 'chats' object store
                        const store = db.createObjectStore(CHAT_STORE_NAME, { keyPath: 'id' });
                        // Create an index on 'timestamp' for sorting
                        store.createIndex('timestamp', 'timestamp');
                        console.log('Created chats object store and timestamp index.');
                    }
                    // Add future upgrade logic here based on oldVersion
                },
            });
        }

        async function saveChatDB(chatData) {
            try {
                const db = await openArcaneTomeDB();
                await db.put(CHAT_STORE_NAME, chatData);
                console.log(`[DB] Chat saved/updated: ${chatData.id}`);
            } catch (error) {
                console.error(`[DB] Error saving chat ${chatData.id}:`, error);
                alert(`Failed to save chat: ${error.message}`); // Inform user
                throw error; // Re-throw for calling function if needed
            }
        }

        async function loadChatHistoryDB(chatId) {
            try {
                const db = await openArcaneTomeDB();
                const chatData = await db.get(CHAT_STORE_NAME, chatId);
                console.log(`[DB] Loaded chat data for ${chatId}:`, chatData ? 'Found' : 'Not Found');
                return chatData ? chatData.history : null; // Return only the history array
            } catch (error) {
                console.error(`[DB] Error loading chat ${chatId}:`, error);
                return null; // Return null on error
            }
        }

        async function deleteChatDB(chatId) {
            try {
                const db = await openArcaneTomeDB();
                await db.delete(CHAT_STORE_NAME, chatId);
                console.log(`[DB] Chat deleted: ${chatId}`);
            } catch (error) {
                console.error(`[DB] Error deleting chat ${chatId}:`, error);
                alert(`Failed to delete chat: ${error.message}`); // Inform user
                throw error; // Re-throw
            }
        }

        async function getChatListDB() {
            try {
                const db = await openArcaneTomeDB();
                const allChats = await db.getAllFromIndex(CHAT_STORE_NAME, 'timestamp');
                // Sort descending (newest first)
                allChats.sort((a, b) => b.timestamp - a.timestamp);
                const chatListMeta = allChats.map(chat => ({ id: chat.id, timestamp: chat.timestamp }));
                console.log(`[DB] Retrieved chat list meta: ${chatListMeta.length} items`);
                return chatListMeta;
            } catch (error) {
                console.error('[DB] Error getting chat list:', error);
                return []; // Return empty array on error
            }
        }
        // === END IndexedDB Helpers ===


        // === API Key and Provider/Model Management ===
        function loadApiAndProviderState() {
            console.log("[DEBUG] loadApiAndProviderState: Starting.");
            const storedProviderKeys = localStorage.getItem('providerApiKeys');
            if (storedProviderKeys) {
                try {
                    apiKeyManagement.providerKeys = JSON.parse(storedProviderKeys);
                    if (typeof apiKeyManagement.providerKeys !== 'object' || apiKeyManagement.providerKeys === null) {
                        apiKeyManagement.providerKeys = {};
                    }
                    // Ensure all stored provider keys are arrays
                    Object.keys(apiKeyManagement.providerKeys).forEach(prov => {
                        if (!Array.isArray(apiKeyManagement.providerKeys[prov])) {
                            apiKeyManagement.providerKeys[prov] = [];
                        }
                    });
                } catch (e) {
                    console.error("[DEBUG] Error parsing stored provider API keys:", e);
                    apiKeyManagement.providerKeys = {}; // Reset on error
                    localStorage.removeItem('providerApiKeys'); // Clear invalid data
                }
            } else {
                apiKeyManagement.providerKeys = {}; // Initialize if nothing stored
            }

            const storedActiveKeys = localStorage.getItem('activeApiKeys');
            if (storedActiveKeys) {
                try {
                    apiKeyManagement.activeKeys = JSON.parse(storedActiveKeys);
                    if (typeof apiKeyManagement.activeKeys !== 'object' || apiKeyManagement.activeKeys === null) {
                        apiKeyManagement.activeKeys = {};
                    }
                     // Validate active keys against existing keys
                     Object.keys(apiKeyManagement.activeKeys).forEach(prov => {
                        const active = apiKeyManagement.activeKeys[prov];
                        const keysForProvider = apiKeyManagement.providerKeys[prov] || [];
                        if (!keysForProvider.includes(active)) {
                            delete apiKeyManagement.activeKeys[prov]; // Remove invalid active key
                        }
                    });
                } catch (e) {
                    console.error("[DEBUG] Error parsing stored active API keys:", e);
                    apiKeyManagement.activeKeys = {}; // Reset on error
                    localStorage.removeItem('activeApiKeys'); // Clear invalid data
                }
            } else {
                apiKeyManagement.activeKeys = {}; // Initialize if nothing stored
            }

            // Load selected provider and model
            const savedProvider = localStorage.getItem('selectedProvider');
            const savedModel = localStorage.getItem('selectedModel');

            if (savedProvider && PROVIDERS[savedProvider]) {
                state.selectedProvider = savedProvider;
            } else {
                 // Default to the first provider in the list if saved one is invalid or not set
                state.selectedProvider = Object.keys(PROVIDERS)[0];
            }

            const providerConf = PROVIDERS[state.selectedProvider];
            if (savedModel && providerConf && providerConf.availableModels.includes(savedModel)) {
                state.selectedModel = savedModel;
            } else {
                // Default to provider's default model if saved one is invalid or not set
                state.selectedModel = providerConf?.defaultModel || null;
            }

            // Ensure every provider with keys has an active key (default to first if needed)
            Object.keys(apiKeyManagement.providerKeys).forEach(prov => {
                if (!apiKeyManagement.activeKeys[prov] && apiKeyManagement.providerKeys[prov]?.length > 0) {
                    apiKeyManagement.activeKeys[prov] = apiKeyManagement.providerKeys[prov][0];
                }
            });

            saveApiAndProviderState(); // Save potentially updated state (defaults)
            console.log(`[DEBUG] Initial provider: ${state.selectedProvider}, model: ${state.selectedModel}`);
            console.log("[DEBUG] loadApiAndProviderState: Finished.");
        }

        function saveApiAndProviderState() {
            localStorage.setItem('providerApiKeys', JSON.stringify(apiKeyManagement.providerKeys));
            localStorage.setItem('activeApiKeys', JSON.stringify(apiKeyManagement.activeKeys));
            localStorage.setItem('selectedProvider', state.selectedProvider || '');
            localStorage.setItem('selectedModel', state.selectedModel || '');
        }

        function populateProviderDropdown() {
             providerSelect.innerHTML = ''; // Clear existing options
             Object.keys(PROVIDERS).forEach(providerKey => {
                 const option = document.createElement('option');
                 option.value = providerKey;
                 option.textContent = PROVIDERS[providerKey].name;
                 providerSelect.appendChild(option);
             });
             providerSelect.value = state.selectedProvider; // Set dropdown to current state
         }

        function updateModelDropdown() {
             modelSelect.innerHTML = ''; // Clear existing options
             if (!state.selectedProvider || !PROVIDERS[state.selectedProvider]) {
                 modelSelect.disabled = true;
                 return; // No provider selected or invalid provider
             }

             const providerConf = PROVIDERS[state.selectedProvider];
             if (!providerConf.availableModels || providerConf.availableModels.length === 0) {
                 const option = document.createElement('option');
                 option.value = "";
                 option.textContent = "No models available";
                 modelSelect.appendChild(option);
                 modelSelect.disabled = true;
                 state.selectedModel = null; // No model can be selected
                 return;
             }

             modelSelect.disabled = false;
             providerConf.availableModels.forEach(modelName => {
                 const option = document.createElement('option');
                 option.value = modelName;
                 option.textContent = modelName;
                 modelSelect.appendChild(option);
             });

             // Set dropdown value based on state, defaulting if necessary
             if (state.selectedModel && providerConf.availableModels.includes(state.selectedModel)) {
                 modelSelect.value = state.selectedModel;
             } else {
                 state.selectedModel = providerConf.defaultModel; // Fallback to default
                 modelSelect.value = state.selectedModel;
                 saveApiAndProviderState(); // Save the updated default selection
             }
         }

        function renderApiKeysForSelectedProvider() {
            apiKeyListDiv.innerHTML = ''; // Clear previous list

            if (!state.selectedProvider) {
                apiKeyListDiv.innerHTML = '<p style="font-style: italic; color: var(--ink-light); text-align: center; padding: 5px 0;">Select a provider.</p>';
                apiKeySectionTitle.textContent = "API Keys";
                newApiKeyInput.disabled = true;
                newApiKeyInput.placeholder = 'Select provider first';
                addApiKeyBtn.disabled = true;
                updateActiveKeyDisplay();
                return;
            }

            const providerConf = PROVIDERS[state.selectedProvider];
            apiKeySectionTitle.textContent = `API Keys for ${providerConf?.name || state.selectedProvider}`;

            if (providerConf?.format === 'proxy_compatible') {
                apiKeyListDiv.innerHTML = '<p style="font-style: italic; color: var(--ink-light); text-align: center; padding: 5px 0;">API Key managed by proxy function. No user key needed.</p>';
                newApiKeyInput.disabled = true;
                newApiKeyInput.placeholder = 'Key handled by proxy';
                addApiKeyBtn.disabled = true;
                updateActiveKeyDisplay();
                return;
            }

            // Enable controls for providers requiring user keys
            newApiKeyInput.disabled = false;
            newApiKeyInput.placeholder = 'Add API Key for selected provider';
            addApiKeyBtn.disabled = false;

            const keys = apiKeyManagement.providerKeys[state.selectedProvider] || [];
            const activeKey = apiKeyManagement.activeKeys[state.selectedProvider] || null;

            if (keys.length === 0) {
                apiKeyListDiv.innerHTML = '<p style="font-style: italic; color: var(--ink-light); text-align: center; padding: 5px 0;">No keys added for this provider.</p>';
            } else {
                keys.forEach((key) => {
                    const isKeyActive = (key === activeKey);
                    const kdiv = document.createElement('div');
                    kdiv.className = 'saved-chat-item'; // Use existing class for structure
                     // Highlight active key (using inline style for simplicity here)
                    if(isKeyActive) kdiv.style.backgroundColor = 'rgba(107, 33, 168, 0.1)'; // Subtle amethyst highlight

                    const kspan = document.createElement('span');
                    // Display a masked version or prefix/suffix for security/privacy if desired
                    // For now, displaying the full key (consider masking in production)
                    kspan.textContent = key;
                    kspan.title = key; // Show full key on hover
                    if (isKeyActive) {
                        kspan.style.fontWeight = 'bold';
                        kspan.style.color = 'var(--amethyst)';
                    }

                    const cdiv = document.createElement('div'); // Control buttons div
                    cdiv.style.display = 'flex'; cdiv.style.gap = '5px'; cdiv.style.flexShrink = '0';

                    // "Use" button (Set Active)
                    const ubtn = document.createElement('button');
                    ubtn.textContent = 'Use';
                    ubtn.className = 'load-chat-btn'; // Re-use styling
                    // Visually indicate if active or not
                    ubtn.style.backgroundColor = isKeyActive ? 'var(--parchment-dark)' : 'var(--gold)';
                    ubtn.style.color = isKeyActive ? 'var(--ink-light)' : 'var(--ink)';
                    ubtn.disabled = isKeyActive; // Disable if already active
                    ubtn.onclick = () => setActiveApiKey(state.selectedProvider, key);

                    // "Delete" button
                    const dbtn = document.createElement('button');
                    dbtn.textContent = 'Del';
                    dbtn.className = 'delete-chat-btn'; // Re-use styling
                    dbtn.onclick = () => deleteApiKey(state.selectedProvider, key);

                    cdiv.appendChild(ubtn);
                    cdiv.appendChild(dbtn);
                    kdiv.appendChild(kspan);
                    kdiv.appendChild(cdiv);
                    apiKeyListDiv.appendChild(kdiv);
                });
            }
            updateActiveKeyDisplay();
        }


        function setActiveApiKey(provider, key) {
             // Prevent setting key for proxy providers
             if (PROVIDERS[provider]?.format === 'proxy_compatible') {
                 console.warn("Attempted to set active key for a proxy provider. Ignored.");
                 return;
             }
             // Ensure the key actually exists for the provider before setting
             if (!apiKeyManagement.providerKeys[provider]?.includes(key)) {
                 console.warn(`Attempted to set non-existent key ${key} for provider ${provider}.`);
                 return;
             }
             apiKeyManagement.activeKeys[provider] = key;
             saveApiAndProviderState();
             renderApiKeysForSelectedProvider(); // Update the list UI
         }

        function deleteApiKey(provider, keyToDelete) {
             // Prevent deleting keys for proxy providers
             if (PROVIDERS[provider]?.format === 'proxy_compatible') {
                  console.warn("Attempted to delete key for a proxy provider. Ignored.");
                  return;
             }
             if (!apiKeyManagement.providerKeys[provider]) return; // No keys for this provider

             // Filter out the key to delete
             apiKeyManagement.providerKeys[provider] = apiKeyManagement.providerKeys[provider].filter(k => k !== keyToDelete);

             // If the deleted key was the active one, update the active key
             if (apiKeyManagement.activeKeys[provider] === keyToDelete) {
                 const remainingKeys = apiKeyManagement.providerKeys[provider];
                 // Set active to the first remaining key, or null if none remain
                 apiKeyManagement.activeKeys[provider] = remainingKeys.length > 0 ? remainingKeys[0] : null;
             }

             // Optional: Clean up provider entry if no keys are left
             if (apiKeyManagement.providerKeys[provider].length === 0) {
                 delete apiKeyManagement.providerKeys[provider];
                 // Also remove active key entry if provider list is empty
                 delete apiKeyManagement.activeKeys[provider];
             }

             saveApiAndProviderState();
             renderApiKeysForSelectedProvider(); // Update the list UI
         }

        function addApiKey() {
            if (!state.selectedProvider) {
                alert("Please select an API provider first.");
                return;
            }
             // Prevent adding keys for proxy providers
             if (PROVIDERS[state.selectedProvider]?.format === 'proxy_compatible') {
                 alert("API Key is managed by the proxy function for this provider and cannot be added here.");
                 newApiKeyInput.value = ''; // Clear input
                 return;
             }

             const newKey = newApiKeyInput.value.trim();
             if (!newKey) return; // Ignore empty input

             // Initialize provider key array if it doesn't exist
             if (!apiKeyManagement.providerKeys[state.selectedProvider]) {
                 apiKeyManagement.providerKeys[state.selectedProvider] = [];
             }
             const currentKeys = apiKeyManagement.providerKeys[state.selectedProvider];

             // Add key only if it doesn't already exist
             if (!currentKeys.includes(newKey)) {
                 currentKeys.push(newKey);
                 // If this is the first key added, make it active
                 if (!apiKeyManagement.activeKeys[state.selectedProvider]) {
                     apiKeyManagement.activeKeys[state.selectedProvider] = newKey;
                 }
                 saveApiAndProviderState();
                 renderApiKeysForSelectedProvider(); // Refresh the list
                 newApiKeyInput.value = ''; // Clear input field
             } else {
                 alert(`Key already exists for ${PROVIDERS[state.selectedProvider].name}.`);
                 newApiKeyInput.value = ''; // Clear input even if duplicate
             }
         }

        function updateActiveKeyDisplay() {
             const providerConf = state.selectedProvider ? PROVIDERS[state.selectedProvider] : null;

             // Handle display for proxy providers
             if (providerConf?.format === 'proxy_compatible') {
                 currentActiveKeyDisplay.textContent = 'Managed by Proxy';
                 currentActiveKeyDisplay.title = 'API Key is set in the server-side proxy function.';
                 return;
             }

             // Handle display for other providers
             const activeKey = state.selectedProvider ? apiKeyManagement.activeKeys[state.selectedProvider] : null;
             // Display masked key or placeholder
             // For now, displaying placeholder or the key itself (consider masking)
             currentActiveKeyDisplay.textContent = activeKey || 'None';
             currentActiveKeyDisplay.title = activeKey || ''; // Show full key on hover if set
         }

        function handleProviderChange() {
            const newProvider = providerSelect.value;
            state.selectedProvider = newProvider;
            // Reset model to the default for the new provider
            state.selectedModel = PROVIDERS[newProvider]?.defaultModel || null;
            saveApiAndProviderState(); // Save changes
            updateModelDropdown(); // Update model choices
            renderApiKeysForSelectedProvider(); // Update API key list
         }

        function handleModelChange() {
             const newModel = modelSelect.value;
             state.selectedModel = newModel;
             saveApiAndProviderState(); // Save the new model selection
         }

        // === Saved Chats Management (Using IndexedDB) ===
        async function populateChatList() {
            savedChatsListItems.innerHTML = ''; // Clear existing list
            chatsLoadingMsg.textContent = 'Loading chats from DB...';
            chatsLoadingMsg.style.display = 'block';
            try {
                const chatList = await getChatListDB();
                console.log("[DB] Retrieved chat list:", chatList);
                if (chatList.length === 0) {
                    chatsLoadingMsg.textContent = 'No saved chats found.';
                } else {
                    chatsLoadingMsg.style.display = 'none'; // Hide loading message
                    chatList.forEach(chatMeta => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'saved-chat-item';

                        const tsSpan = document.createElement('span');
                        const date = new Date(chatMeta.timestamp);
                        // Format timestamp nicely
                        tsSpan.textContent = date.toLocaleString(undefined, { dateStyle: 'short', timeStyle: 'short' });
                        tsSpan.title = `ID: ${chatMeta.id}\nSaved: ${date.toISOString()}`;

                        const ctrlDiv = document.createElement('div');
                        ctrlDiv.style.display = 'flex'; ctrlDiv.style.gap = '5px';

                        const loadBtn = document.createElement('button');
                        loadBtn.textContent = 'Load';
                        loadBtn.className = 'load-chat-btn'; // Use existing style
                        loadBtn.onclick = (e) => { e.stopPropagation(); loadChat(chatMeta.id); };

                        const delBtn = document.createElement('button');
                        delBtn.textContent = 'Del';
                        delBtn.className = 'delete-chat-btn'; // Use existing style
                        delBtn.onclick = (e) => { e.stopPropagation(); deleteChat(chatMeta.id); };

                        ctrlDiv.appendChild(loadBtn);
                        ctrlDiv.appendChild(delBtn);
                        itemDiv.appendChild(tsSpan);
                        itemDiv.appendChild(ctrlDiv);
                        savedChatsListItems.appendChild(itemDiv);
                    });
                }
            } catch (error) {
                console.error("Error populating chat list from DB:", error);
                savedChatsListItems.innerHTML = ''; // Clear on error
                chatsLoadingMsg.style.display = 'block';
                chatsLoadingMsg.textContent = 'Error loading chats.';
            }
        }

        async function loadChat(chatId) {
            console.log(`JS: Attempting to load ${chatId} from DB`);
            try {
                const loadedHistory = await loadChatHistoryDB(chatId);
                if (loadedHistory) {
                     // Basic validation: ensure it's an array and has a system message
                    if (Array.isArray(loadedHistory) && loadedHistory.length > 0 && loadedHistory[0]?.role === 'system') {
                        state.conversationHistory = loadedHistory;
                        state.currentChatId = chatId; // Set the loaded chat as current
                        renderChatHistory(); // Update the UI
                        systemPromptInput.value = state.conversationHistory[0].content; // Update settings modal field
                        console.log(`JS: Successfully loaded chat history for ${chatId} from DB.`);
                        closeApiMenu(); // Close the menu after loading
                    } else {
                         console.error("[DEBUG] Loaded data from DB is not a valid chat history array:", loadedHistory);
                         throw new Error("Invalid format in loaded chat data");
                    }
                } else {
                    console.warn(`JS: Chat ${chatId} not found in DB or error loading.`);
                    alert(`Could not load chat "${chatId}". Data not found.`);
                    await populateChatList(); // Refresh list in case it was deleted elsewhere
                }
            } catch (error) {
                console.error(`JS: Error loading or processing ${chatId} from DB:`, error);
                alert(`Error loading chat: ${error.message}`);
                await populateChatList(); // Refresh list on error
            }
        }

        async function deleteChat(chatId) {
            // Find the timestamp span to show in the confirm dialog
            const chatItemSpan = document.querySelector(`.saved-chat-item span[title*='ID: ${chatId}']`);
            const confirmMsg = `Delete chat saved around ${chatItemSpan?.textContent || chatId}?`;

            if (!confirm(confirmMsg)) return; // User cancelled

            console.log(`JS: Deleting ${chatId} from DB`);
            try {
                await deleteChatDB(chatId);
                console.log(`JS: Delete ${chatId} command sent to DB.`);
                await populateChatList(); // Refresh the list in the menu

                // If the currently active chat was deleted, start a new one
                if (state.currentChatId === chatId) {
                    console.log("Active chat deleted. Starting a new chat.");
                    await startNewChat(false); // Start new without confirmation
                }
            } catch (error) {
                console.error(`JS: Error deleting ${chatId} from DB:`, error);
                // Alerting the user is handled within deleteChatDB
            }
        }


        // === Secret Menu Toggle ===
        async function openApiMenu() {
            loadApiAndProviderState(); // Ensure latest state is loaded
            populateProviderDropdown();
            updateModelDropdown();
            renderApiKeysForSelectedProvider();
            await populateChatList(); // Refresh saved chats list
            apiKeyMenu.style.display = 'block'; // Show the menu
        }
        function closeApiMenu() {
            apiKeyMenu.style.display = 'none'; // Hide the menu
        }

        // === App Initialization and Core Logic ===
        function initializeChat() {
            console.log("[DEBUG] initializeChat: Starting new chat session.");
            state.currentChatId = `chat_${Date.now()}`; // Generate unique ID for new chat
            // Load system prompt from localStorage or use default
            const initialSystemPrompt = localStorage.getItem('systemPrompt') || 'You are a mystical spirit, ancient and wise, speaking through this digital tome. Offer guidance, inspiration, and thoughtful responses. Keep your answers concise but meaningful.';
            state.conversationHistory = [
                { role: 'system', content: initialSystemPrompt }
            ];
            systemPromptInput.value = initialSystemPrompt; // Sync settings modal input
            console.log("[DEBUG] initializeChat: New chat session initialized with ID:", state.currentChatId);
            console.log(`[DEBUG] Using Provider: ${state.selectedProvider}, Model: ${state.selectedModel}`);
        }

        function init() {
             console.log("[DEBUG] init: Starting Initialization...");
             try {
                 // Load saved prompts and PFP URLs
                 state.savedPrompts = JSON.parse(localStorage.getItem('savedPrompts')) || {};
                 state.userPfp = localStorage.getItem('userPfp') || 'https://ui-avatars.com/api/?name=User&background=1e3a8a&color=fff&bold=true&size=64'; // Default user PFP
                 state.botPfp = localStorage.getItem('botPfp') || 'https://ui-avatars.com/api/?name=Spirit&background=6b21a8&color=fff&bold=true&size=64'; // Default spirit PFP
                 userAvatarPreview.src = state.userPfp;
                 spiritAvatarPreview.src = state.botPfp;

                 updateGuidanceSelect(); // Populate saved prompts dropdown
                 loadApiAndProviderState(); // Load API keys, provider, model
                 initializeChat(); // Setup initial chat state

                 // Basic check for essential elements
                 if (!pages || !messageInput || !sendButton || !settingsModal || !apiKeyMenu) {
                     throw new Error("Core DOM elements not found!");
                 }

                 console.log("[DEBUG] init: Attaching event listeners...");

                 // API/Secret Menu Listeners
                 closeApiMenuBtn.addEventListener('click', closeApiMenu);
                 providerSelect.addEventListener('change', handleProviderChange);
                 modelSelect.addEventListener('change', handleModelChange);
                 addApiKeyBtn.addEventListener('click', addApiKey);
                 newApiKeyInput.addEventListener('keydown', (e) => {
                     if (e.key === 'Enter') { e.preventDefault(); addApiKey(); }
                 });
                 // Close API menu if clicking outside it
                 document.addEventListener('click', (event) => {
                     if (apiKeyMenu.style.display === 'block' &&
                         !apiKeyMenu.contains(event.target) &&
                         !event.target.matches('.user-avatar') && // Allow clicking avatar to open
                         !event.target.closest('#user-avatar-preview')) { // Allow clicking preview in settings
                         closeApiMenu();
                     }
                 }, true); // Use capture phase

                 // Chat Interaction Listeners
                 sendButton.addEventListener('click', sendMessage);
                 messageInput.addEventListener('keydown', (e) => {
                     if (e.key === 'Enter' && !e.shiftKey) { // Send on Enter (not Shift+Enter)
                         e.preventDefault();
                         sendMessage();
                     }
                 });
                 // Auto-resize textarea
                 messageInput.addEventListener('input', () => {
                     messageInput.style.height = 'auto'; // Reset height
                     messageInput.style.height = (messageInput.scrollHeight) + 'px'; // Set to scroll height
                 });

                 // Settings Modal Listeners
                 closeModalBtn.addEventListener('click', closeSettings);
                 cancelBtn.addEventListener('click', closeSettings);
                 saveBtn.addEventListener('click', saveSettings);
                 pfpUpload.addEventListener('change', handlePfpUpload);
                 guidanceSelect.addEventListener('change', loadGuidance);
                 saveGuidanceBtn.addEventListener('click', saveCurrentGuidance);
                 removeGuidanceBtn.addEventListener('click', removeSelectedGuidance);
                 newChatBtn.addEventListener('click', () => startNewChat(true)); // Confirm before starting new
                 undoBtn.addEventListener('click', undoLastMessage);
                 // Open PFP upload dialog
                 userAvatarPreview.addEventListener('click', () => { state.currentAvatarBeingEdited = 'user'; pfpUpload.click(); });
                 spiritAvatarPreview.addEventListener('click', () => { state.currentAvatarBeingEdited = 'spirit'; pfpUpload.click(); });

                 // Avatar Click Listeners (Open Menus)
                 pages.addEventListener('click', (event) => {
                     // Use matches for flexibility and closest to ensure click is within a message
                     if (event.target.matches('.user-avatar') && event.target.closest('.message-user')) {
                         openApiMenu(); // Click user avatar in chat -> open API menu
                     } else if (event.target.matches('.spirit-avatar') && event.target.closest('.message-spirit')) {
                         openSettings(); // Click spirit avatar in chat -> open settings
                     }
                 });

                 renderChatHistory(); // Initial render of any loaded/new chat
                 console.log("[DEBUG] init: Initialization flow complete.");

             } catch (error) {
                 console.error("[DEBUG] CRITICAL ERROR DURING INIT:", error);
                 alert("A critical error occurred during initialization: " + error.message + ". The application may not function correctly. Check the developer console for details.");
             }
         }


        function renderChatHistory() {
            pages.innerHTML = ''; // Clear current messages
            // Render all messages except the system prompt (index 0)
            state.conversationHistory.slice(1).forEach(msg => {
                // Basic validation of message object
                if (!msg || !msg.role || typeof msg.content === 'undefined') {
                    console.warn("Skipping invalid message object during render:", msg);
                    return;
                }
                const sender = msg.role === 'user' ? 'user' : 'spirit';
                const pfp = sender === 'user' ? state.userPfp : state.botPfp;
                const isMarkdown = (msg.role === 'assistant'); // Assume assistant messages are markdown
                displayMessage(msg.content, sender, pfp, isMarkdown);
            });
            // Scroll to bottom after rendering
            // Use requestAnimationFrame to ensure DOM is updated before scrolling
            requestAnimationFrame(() => {
                pages.scrollTop = pages.scrollHeight;
            });
        }

        async function startNewChat(confirmFirst = true) {
             if (confirmFirst && !confirm('Start a new chat?\n(Current chat will be saved automatically if needed)')) {
                 return; // User cancelled
             }

             // Save the current chat before starting new, if it has content
             if (state.currentChatId && state.conversationHistory.length > 1) { // >1 means more than just system prompt
                 console.log(`JS: Saving current chat ${state.currentChatId} to DB before starting new.`);
                 const chatData = {
                     id: state.currentChatId,
                     timestamp: Date.now(), // Update timestamp on save
                     history: state.conversationHistory
                 };
                 try {
                     await saveChatDB(chatData);
                     console.log(`JS: Save ${state.currentChatId} to DB successful.`);
                 } catch (error) {
                      // Log error, but proceed with new chat creation
                     console.error(`JS: Error saving ${state.currentChatId} to DB:`, error);
                 }
             }

             // Keep the current system prompt for the new chat
             const currentSystemPrompt = state.conversationHistory[0]?.content || localStorage.getItem('systemPrompt') || 'You are a mystical spirit...'; // Default fallback

             // Initialize new chat state
             const newChatId = `chat_${Date.now()}`;
             console.log("Starting new chat:", newChatId);
             state.currentChatId = newChatId;
             state.conversationHistory = [
                 { role: 'system', content: currentSystemPrompt }
             ];
             systemPromptInput.value = currentSystemPrompt; // Ensure settings modal reflects current prompt

             renderChatHistory(); // Clear the display for the new chat
             closeSettings(); // Close modals if open
             closeApiMenu();
             messageInput.focus(); // Focus the input field
         }


        async function sendMessage() {
             console.log("[DEBUG] sendMessage: Called.");
             if (state.isWaitingForResponse) {
                 console.log("[DEBUG] sendMessage: Aborted, waiting for previous response.");
                 return;
             }
             const userInput = messageInput.value.trim();
             if (!userInput) {
                 console.log("[DEBUG] sendMessage: Aborted, empty input.");
                 return;
             }

             const userMessage = { role: 'user', content: userInput };
             state.conversationHistory.push(userMessage);
             displayMessage(userInput, 'user', state.userPfp, false); // Display user message immediately

             // Clear input and adjust height
             messageInput.value = '';
             messageInput.style.height = 'auto';
             requestAnimationFrame(() => { // Ensure reflow before calculating scrollHeight
                 messageInput.style.height = (messageInput.scrollHeight) + 'px';
             });

             state.isWaitingForResponse = true;
             sendButton.disabled = true;

             const provider = state.selectedProvider;
             const model = state.selectedModel;
             const apiKey = provider ? apiKeyManagement.activeKeys[provider] : null;

             console.log(`[DEBUG] sendMessage: Provider=${provider}, Model=${model}, Key=${apiKey ? 'Exists/Selected' : 'Missing/Not Selected'}`);

             // --- Pre-API Call Checks ---
             if (!provider || !model) {
                 console.error("[DEBUG] sendMessage: Provider or Model not selected.");
                 displayMessage("Cannot contact the spirit: Please select a valid API Provider and Model in the User Sigil menu.", 'spirit', state.botPfp, false);
                 state.isWaitingForResponse = false; sendButton.disabled = false;
                 return;
             }

             const providerConf = PROVIDERS[provider];
             const requiresUserKey = providerConf?.format !== 'proxy_compatible' && providerConf?.apiKeyLocation !== 'none';

             if (requiresUserKey && !apiKey) {
                 console.error(`[DEBUG] sendMessage: No active API key set for provider ${provider}, which requires one.`);
                 const providerName = providerConf?.name || provider;
                 displayMessage(`Cannot contact the spirit: No API Key is active for ${providerName}. Please add or select one via the User Sigil menu.`, 'spirit', state.botPfp, false);
                 state.isWaitingForResponse = false; sendButton.disabled = false;
                 // Optionally, automatically open the API menu
                 // if (apiKeyMenu.style.display === 'none') openApiMenu();
                 return;
             }
             // --- End Pre-API Call Checks ---

             displayTypingIndicator();

             try {
                 // Check if the API function exists (it should be in api_providers.js)
                 if (typeof getApiResponse !== 'function') {
                     throw new Error("API provider function (getApiResponse) not found. Check api_providers.js.");
                 }
                 console.log(`[DEBUG] sendMessage: Calling getApiResponse for ${provider}...`);

                 // Prepare message history for the API call
                 const messagesForApi = state.conversationHistory; // Send the whole history

                 // Call the API
                 const botResponse = await getApiResponse(
                     provider,
                     model,
                     messagesForApi,
                     apiKey // Pass the key; getApiResponse handles if it's needed
                 );

                 console.log("[DEBUG] sendMessage: getApiResponse successful.");
                 removeTypingIndicator();
                 const assistantMessage = { role: 'assistant', content: botResponse };
                 state.conversationHistory.push(assistantMessage);
                 displayMessage(botResponse, 'spirit', state.botPfp, true); // Display as markdown

                 // --- Auto-save chat after successful response ---
                 if (state.currentChatId) {
                     console.log(`[DEBUG] Auto-saving chat ${state.currentChatId} after response.`);
                     const chatData = {
                         id: state.currentChatId,
                         timestamp: Date.now(),
                         history: state.conversationHistory
                     };
                     await saveChatDB(chatData).catch(e => console.error("[DEBUG] Auto-save failed:", e)); // Log error but don't block
                 }
                 // --- End Auto-save ---

             } catch (error) {
                 console.error('[DEBUG] Error during API call execution:', error);
                 removeTypingIndicator();
                 // Display a user-friendly error message
                 displayMessage(`The connection falters or the spirit is silent...\n(${error.message || 'Unknown API error'})`, 'spirit', state.botPfp, false);
             } finally {
                 console.log("[DEBUG] sendMessage: Entering finally block.");
                 // Always ensure UI is reset correctly
                 removeTypingIndicator(); // Ensure it's removed even on error before display
                 state.isWaitingForResponse = false;
                 sendButton.disabled = false;
                 // Focus input only if modals aren't open, allowing user to type next message
                 if (!settingsModal.classList.contains('active') && apiKeyMenu.style.display === 'none') {
                     messageInput.focus();
                 }
             }
         }


        function displayMessage(content, sender, pfp, isMarkdown = false) {
             const msgDiv = document.createElement('div');
             msgDiv.className = `message message-${sender}`;

             const avImg = document.createElement('img');
             avImg.className = `avatar ${sender}-avatar`;
             avImg.src = pfp;
             avImg.alt = `${sender} avatar`;
             avImg.title = sender === 'user' ? 'Open Secrets & Providers' : 'Open Tome Settings'; // Add tooltips

             const cntDiv = document.createElement('div');
             cntDiv.className = `message-content ${sender}-message`;

             if (isMarkdown) {
                 let htmlContent = marked.parse(content);
                 // Basic check for DOMPurify if loaded
                 if (typeof DOMPurify !== 'undefined') {
                     htmlContent = DOMPurify.sanitize(htmlContent);
                 } else {
                      // Very basic script tag removal if DOMPurify isn't present
                     if (htmlContent.includes('<script')) {
                         console.warn("Potential XSS vector detected. DOMPurify is recommended for security.");
                         // A simple regex might miss complex cases, but better than nothing
                         htmlContent = htmlContent.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
                     }
                 }
                 cntDiv.innerHTML = htmlContent;

                 // Add copy buttons to code blocks after rendering
                 // Use setTimeout to ensure elements are in the DOM
                 setTimeout(() => {
                     cntDiv.querySelectorAll('pre code').forEach(codeBlock => {
                         const preElement = codeBlock.parentElement; // Get the parent <pre> tag
                         if (preElement && preElement.tagName === 'PRE' && !preElement.querySelector('.copy-code-btn')) {
                             const btn = document.createElement('button');
                             btn.className = 'copy-code-btn';
                             btn.textContent = 'Copy';
                             btn.title = 'Copy code';
                             btn.addEventListener('click', (e) => {
                                 e.stopPropagation(); // Prevent event bubbling
                                 navigator.clipboard.writeText(codeBlock.textContent).then(() => {
                                     btn.textContent = 'Copied!';
                                     btn.classList.add('copied');
                                     setTimeout(() => { // Reset button after a delay
                                         btn.textContent = 'Copy';
                                         btn.classList.remove('copied');
                                     }, 1500);
                                 }).catch(err => {
                                     console.error('Failed to copy code:', err);
                                     btn.textContent = 'Error';
                                     setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
                                 });
                             });
                             preElement.style.position = 'relative'; // Needed for absolute positioning of button
                             preElement.appendChild(btn);
                         }
                     });
                 }, 0);
             } else {
                 // For plain text content (user messages)
                 cntDiv.textContent = content;
             }

             // Append avatar and content in correct order based on sender
             if (sender === 'user') {
                 msgDiv.appendChild(cntDiv);
                 msgDiv.appendChild(avImg);
             } else {
                 msgDiv.appendChild(avImg);
                 msgDiv.appendChild(cntDiv);
             }

             pages.appendChild(msgDiv);

             // Scroll to bottom smoothly
             requestAnimationFrame(() => {
                 pages.scrollTo({ top: pages.scrollHeight, behavior: 'smooth' });
             });
         }

        function displayTypingIndicator() {
            if(document.getElementById('typing-indicator')) return; // Don't add multiple

            const typDiv = document.createElement('div');
            typDiv.className = 'message message-spirit'; // Mimic spirit message layout
            typDiv.id = 'typing-indicator';
            typDiv.style.opacity = '0.8'; // Slightly faded

            const avImg = document.createElement('img');
            avImg.className = 'avatar spirit-avatar';
            avImg.src = state.botPfp;
            avImg.alt = 'spirit avatar';
            avImg.style.cursor = 'default'; // Not interactive

            const cntDiv = document.createElement('div');
            cntDiv.className = 'typing-indicator'; // Specific class for styling
            // Add runes with animation delays
            cntDiv.innerHTML = `<span>The spirit is responding</span><span class="rune" style="animation-delay: 0s;">ᛟ</span><span class="rune" style="animation-delay: 0.2s;">ᛞ</span><span class="rune" style="animation-delay: 0.4s;">ᛝ</span>`;

            typDiv.appendChild(avImg);
            typDiv.appendChild(cntDiv);
            pages.appendChild(typDiv);

            // Scroll to show indicator
            requestAnimationFrame(() => {
                 pages.scrollTo({ top: pages.scrollHeight, behavior: 'smooth' });
            });
        }
        function removeTypingIndicator() {
            const ti = document.getElementById('typing-indicator');
            if(ti) ti.remove();
        }

        // --- Settings Modal / Guidance / PFP Logic ---
        function openSettings() {
            // Sync system prompt input with current state
            systemPromptInput.value = state.conversationHistory[0]?.content || '';
            // Sync avatar previews
            userAvatarPreview.src = state.userPfp;
            spiritAvatarPreview.src = state.botPfp;
            // Update and set the guidance dropdown
            updateGuidanceSelect();
            const currentPromptName = Object.keys(state.savedPrompts).find(name => state.savedPrompts[name] === systemPromptInput.value);
            guidanceSelect.value = currentPromptName || ""; // Select if current prompt is saved

            settingsModal.classList.add('active'); // Show modal
            // Prevent body scrolling while modal is open (optional, CSS can also handle this)
            // document.body.style.overflow = 'hidden';
        }

        function closeSettings() {
            settingsModal.classList.remove('active'); // Hide modal
            // Restore body scrolling
            // document.body.style.overflow = '';
        }

        async function saveSettings() {
            console.log("[DEBUG] saveSettings called.");
            const newSysPrompt = systemPromptInput.value.trim();
            const defaultPrompt = 'You are a mystical spirit...'; // Fallback default
            const finalPrompt = newSysPrompt || defaultPrompt;

            let promptChanged = false;
            // Update system prompt in conversation history
            if (!state.conversationHistory || state.conversationHistory.length === 0) {
                // Should not happen if initialized correctly, but handle defensively
                state.conversationHistory = [{ role: 'system', content: finalPrompt }];
                promptChanged = true;
            } else if (state.conversationHistory[0]?.content !== finalPrompt) {
                state.conversationHistory[0] = { role: 'system', content: finalPrompt };
                promptChanged = true;
            }

            // Save changed system prompt to localStorage for persistence
            if (promptChanged) {
                console.log("[DEBUG] System prompt changed.");
                localStorage.setItem('systemPrompt', finalPrompt);
            }

            // Save PFPs to localStorage
            localStorage.setItem('userPfp', state.userPfp);
            localStorage.setItem('botPfp', state.botPfp);

            // Update avatars currently displayed in the chat
             document.querySelectorAll('.user-avatar').forEach(img => {
                // Update only avatars within messages or the preview itself
                if(img.closest('.message') || img.id === 'user-avatar-preview') {
                    img.src = state.userPfp;
                }
            });
             document.querySelectorAll('.spirit-avatar').forEach(img => {
                if(img.closest('.message') || img.closest('#typing-indicator') || img.id === 'spirit-avatar-preview') {
                    img.src = state.botPfp;
                }
            });


            // If the prompt changed, save the current chat to update its system message in DB
            if (promptChanged && state.currentChatId) {
                const chatData = {
                    id: state.currentChatId,
                    timestamp: Date.now(), // Update timestamp on save
                    history: state.conversationHistory
                };
                try {
                    await saveChatDB(chatData);
                    console.log(`[DEBUG] Saved chat ${state.currentChatId} to DB after settings save.`);
                } catch (e) {
                    console.error("[DEBUG] Save error after settings save:", e);
                    // Inform user? Or just log? For now, just log.
                }
            }

            closeSettings(); // Close the modal
        }

        function updateGuidanceSelect() {
            const currentVal = guidanceSelect.value; // Preserve selection if possible
            guidanceSelect.innerHTML = '<option value="">Select saved guidance...</option>'; // Reset dropdown
            Object.entries(state.savedPrompts).forEach(([name, prompt]) => {
                const opt = document.createElement('option');
                opt.value = name;
                opt.textContent = name;
                guidanceSelect.appendChild(opt);
            });
            // Try to restore previous selection if it still exists
             if (state.savedPrompts[currentVal]) {
                 guidanceSelect.value = currentVal;
             }
        }

        function loadGuidance() {
            const selectedName = guidanceSelect.value;
            if (selectedName && state.savedPrompts[selectedName]) {
                systemPromptInput.value = state.savedPrompts[selectedName];
            }
        }

        function saveCurrentGuidance() {
            const currentPrompt = systemPromptInput.value.trim();
            if (!currentPrompt) {
                alert("Guidance cannot be empty.");
                return;
            }
            // Suggest current name if editing an existing saved prompt
            const currentName = Object.keys(state.savedPrompts).find(name => state.savedPrompts[name] === currentPrompt);
            const promptName = prompt('Enter a name for this guidance:', currentName || '');

            if (promptName) { // User entered a name and didn't cancel
                state.savedPrompts[promptName] = currentPrompt;
                localStorage.setItem('savedPrompts', JSON.stringify(state.savedPrompts));
                updateGuidanceSelect(); // Refresh dropdown
                guidanceSelect.value = promptName; // Select the newly saved/updated prompt
            }
        }

        function removeSelectedGuidance() {
            const selectedName = guidanceSelect.value;
            if (selectedName && state.savedPrompts[selectedName]) {
                if (confirm(`Delete guidance "${selectedName}"?`)) {
                    const promptValue = state.savedPrompts[selectedName]; // Store value before deleting
                    delete state.savedPrompts[selectedName];
                    localStorage.setItem('savedPrompts', JSON.stringify(state.savedPrompts));
                    updateGuidanceSelect(); // Refresh dropdown

                    // If the deleted prompt is currently in the textarea, clear the textarea
                    if (systemPromptInput.value === promptValue) {
                        systemPromptInput.value = '';
                    }
                    guidanceSelect.value = ''; // Deselect in dropdown
                }
            } else {
                alert("Select a saved guidance from the dropdown to remove.");
            }
        }

        function handlePfpUpload(event) {
            const file = event.target.files[0];
            if (!file || !file.type.startsWith('image/')) return; // Basic validation

            const reader = new FileReader();
            reader.onload = (e) => {
                const url = e.target.result; // Base64 Data URL
                if (state.currentAvatarBeingEdited === 'user') {
                    state.userPfp = url;
                    userAvatarPreview.src = url; // Update preview in settings
                } else if (state.currentAvatarBeingEdited === 'spirit') {
                    state.botPfp = url;
                    spiritAvatarPreview.src = url; // Update preview in settings
                }
                // Note: Avatars in the chat log are updated when settings are *saved*
            };
            reader.onerror = (e) => console.error("Error reading PFP file:", e);
            reader.readAsDataURL(file);

            // Reset file input to allow uploading the same file again if needed
            pfpUpload.value = null;
        }

        async function undoLastMessage() {
            // Can only undo if there's more than just the system prompt
            if (state.conversationHistory.length <= 1) return;

            let messagesRemoved = 0;
            const lastMessage = state.conversationHistory.pop(); // Remove the last message

            if (lastMessage) {
                messagesRemoved = 1;
                // If the last message was from the assistant, check if the one before it was the corresponding user message
                if (lastMessage.role === 'assistant' && state.conversationHistory.length > 1 && state.conversationHistory[state.conversationHistory.length - 1]?.role === 'user') {
                    state.conversationHistory.pop(); // Remove the preceding user message as well
                    messagesRemoved = 2;
                }
            }

            if (messagesRemoved > 0) {
                console.log(`[DEBUG] Undo removed ${messagesRemoved} message(s).`);
                renderChatHistory(); // Update the display

                // If we were waiting for a response, cancel that state
                if (state.isWaitingForResponse) {
                    console.log("[DEBUG] Undo while waiting - cancelling response state.");
                    state.isWaitingForResponse = false;
                    sendButton.disabled = false;
                    removeTypingIndicator(); // Ensure indicator is gone
                }

                // Save the updated history to the database
                if (state.currentChatId) {
                    const chatData = {
                        id: state.currentChatId,
                        timestamp: Date.now(),
                        history: state.conversationHistory
                    };
                    try {
                        await saveChatDB(chatData);
                        console.log(`[DEBUG] Saved chat ${state.currentChatId} to DB after undo.`);
                    } catch(e) {
                        console.error("Save error after undo:", e);
                    }
                }
            } else {
                console.log("[DEBUG] Undo called but no messages to remove.");
            }
        }

        // --- Initialization ---
        // Ensure init runs after the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', init);

    </script>

</body>
</html>
