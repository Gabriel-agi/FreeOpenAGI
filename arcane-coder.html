<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcane Tome (Provider Enhanced - Reliable Font)</title>
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- API Provider Definitions (MUST be before main script) -->
    <script src="api_providers.js"></script>

    <style>
        /* --- Arcane Tome Base Styles --- */
        :root {
             --parchment: #f5e7d0; --parchment-dark: #e3d5b8; --ink: #3a3129; --ink-light: #5a4e42; --gold: #c9a227; --crimson: #8b0000; --sapphire: #1e3a8a; --amethyst: #6b21a8; --emerald: #21a853; --shadow-light: 0 1px 3px rgba(0,0,0,0.15); --code-bg: #e8e0cf; --code-border: #d1c3a9;
             /* Using Georgia as primary, Times New Roman as fallback/heading */
             --font-body: Georgia, 'Times New Roman', Times, serif;
             --font-heading: 'Times New Roman', Times, serif; /* Replaced Cinzel Decorative */
        }
        html, body { height: 100%; margin: 0; padding: 0; }
        * { box-sizing: border-box; }
        /* --- Body uses Georgia --- */
        body { font-family: var(--font-body); font-size: 1.1rem; line-height: 1.6; background-color: var(--parchment); color: var(--ink); width: 100vw; overflow: hidden; }
        .tome { width: 100%; height: 100%; display: flex; flex-direction: column; position: relative; background-color: var(--parchment); }
        .pages { flex: 1; min-height: 0; padding: 20px; overflow-y: auto; scrollbar-width: none; display: flex; flex-direction: column; gap: 15px; border-bottom: 2px solid var(--ink-light); }
        .pages::-webkit-scrollbar { display: none; }
        .message { display: flex; gap: 10px; max-width: 85%; animation: fadeIn 0.5s ease-in-out;}
        .message-user { align-self: flex-end; flex-direction: row-reverse; }
        .message-spirit { align-self: flex-start; }
        .avatar { width: 45px; height: 45px; border-radius: 50%; flex-shrink: 0; border: 2px solid var(--parchment-dark); box-shadow: var(--shadow-light); display: flex; align-items: center; justify-content: center; overflow: hidden; background-color: var(--parchment-dark); cursor: pointer; }
        .avatar img { width: 100%; height: 100%; object-fit: cover; }
        .user-avatar { background-color: var(--sapphire); }
        .spirit-avatar { background-color: var(--amethyst); }
        .message-content-wrapper { display: flex; flex-direction: column; max-width: 100%; }
        .message-content { padding: 12px 18px; border-radius: 8px; line-height: 1.5; word-break: break-word; box-shadow: var(--shadow-light); max-width: fit-content; }
        .message-user .message-content { background-color: var(--sapphire); color: white; border-top-right-radius: 0; }
        .message-spirit .message-content { background-color: white; color: var(--ink); border: 1px solid var(--ink-light); border-top-left-radius: 0; }
        .message-content p { margin: 0 0 0.5em 0; } .message-content p:last-child { margin-bottom: 0; }
        .typing-indicator { align-self: flex-start; color: var(--ink-light); font-style: italic; padding: 10px 15px; background-color: rgba(227,213,184,0.5); border-radius: 8px; font-size: 1rem; }
        .writing-area { padding: 12px; background-color: var(--parchment-dark); display: flex; flex-wrap: wrap; gap: 8px; align-items: flex-end; flex-shrink: 0; }
        .message-input { flex: 1 1 250px; padding: 10px; background-color: var(--parchment); border: 2px solid var(--ink-light); border-radius: 5px; font-family: inherit; font-size: 1.1rem; resize: none; outline: none; color: var(--ink); min-height: 48px; max-height: 150px; line-height: 1.5; }
        .message-input:focus { border-color: var(--gold); }
        .writing-controls { display: flex; align-items: flex-end; gap: 8px; flex-wrap: nowrap; margin-left: auto; }
        /* --- Footer buttons use Georgia --- */
        .footer-button { background-color: var(--ink-light); color: var(--parchment); border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; padding: 8px 10px; font-size: 0.9em; flex-shrink: 0; white-space: nowrap; height: 48px; font-family: var(--font-body); display:flex; align-items:center; justify-content:center; }
        .footer-button:hover { background-color: var(--ink); }
        #settings-button { background-color: var(--gold); color: var(--ink); font-size: 1.2em; padding: 0 12px; }
        #settings-button:hover { background-color: var(--crimson); color: white; }
        #clear-chat-button { background-color: var(--crimson); color: white;}
        #clear-chat-button:hover { background-color: darkred; }
        #upload-file-button { font-size: 1.1em; padding: 0 12px; }
        .response-count-input { width: 45px; padding: 10px; border: 2px solid var(--ink-light); border-radius: 5px; text-align: center; flex-shrink: 0; height: 48px; font-size: 1rem; background-color: var(--parchment); color: var(--ink); }
        /* --- Send button uses Heading Font --- */
        .send-button { background-color: var(--gold); color: var(--ink); border: none; border-radius: 5px; padding: 0 18px; height: 48px; font-family: var(--font-heading); font-weight: bold; cursor: pointer; box-shadow: var(--shadow-light); display: flex; align-items: center; gap: 8px; font-size: 1.1rem; transition: background-color 0.2s ease; flex-shrink: 0; }
        .send-button:hover:not(:disabled) { background-color: var(--crimson); color: white; }
        .send-button:disabled { opacity: 0.7; cursor: not-allowed; background-color: var(--ink-light); color: var(--parchment); }
        .response-navigation { display: flex; align-items: center; justify-content: flex-start; margin-top: 5px; gap: 5px; width: fit-content; }
        .response-navigation button { background-color: var(--parchment-dark); border: 1px solid var(--ink-light); color: var(--ink); border-radius: 4px; padding: 2px 6px; cursor: pointer; font-size: 0.9em; line-height: 1; }
        .response-navigation button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #ccc; }
        .response-navigation span { font-size: 0.8em; color: var(--ink-light); margin: 0 5px; user-select: none; }
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(58,49,41,0.7); justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--parchment); border: 3px solid var(--gold); color: var(--ink); padding: 25px; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.4); max-height: 90vh; width: 90%; display: flex; flex-direction: column; overflow-y: auto; }
        /* --- Modal Headings use Heading Font --- */
        .modal-content h3 { font-family: var(--font-heading); margin-top: 0; text-align: center; color: var(--ink); border-bottom: 1px solid var(--gold); padding-bottom: 10px; margin-bottom: 20px; flex-shrink: 0; }
        .modal-content .form-group { margin-bottom: 15px; display: flex; flex-wrap: wrap; align-items: center; gap: 8px 15px; flex-shrink: 0; }
        .modal-content label { display: block; margin-bottom: 5px; font-weight: bold; color: var(--ink-light); flex-basis: 100%; }
        .modal-content input[type="checkbox"] { cursor: pointer; margin-right: 5px; flex-shrink: 0; }
        .modal-content label[for*="checkbox"] { flex-basis: auto; margin-bottom: 0; font-weight: normal; }
        .modal-content input[type="password"], .modal-content textarea, .modal-content input[type="number"], .modal-content select { width: 100%; padding: 10px; border: 1px solid var(--ink-light); border-radius: 4px; outline: none; box-sizing: border-box; background-color: white; color: var(--ink); font-family: var(--font-body); font-size: 1rem; }
        .modal-content select { cursor: pointer; height: 44px; padding: 0 10px;}
        .modal-content textarea { resize: vertical; min-height: 80px; }
        .modal-content .modal-buttons { margin-top: 20px; text-align: right; display: flex; justify-content: flex-end; gap: 10px; flex-shrink: 0; border-top: 1px solid var(--gold); padding-top: 15px; }
        /* --- Modal Buttons use Heading Font --- */
        .modal-content button { background-color: var(--gold); color: var(--ink); border: none; padding: 10px 18px; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; font-family: var(--font-heading); font-weight: bold; }
        .modal-content button:hover { background-color: var(--crimson); color: white; }
        /* --- Specific overrides for buttons that should use body font --- */
        .modal-content button.cancel-button { font-family: var(--font-body); background-color: var(--ink-light); color: var(--parchment); }
        .modal-content button.cancel-button:hover { background-color: var(--ink); }
        .modal-content .small-button { font-family: var(--font-body); /* Ensure small buttons also use body font */ padding: 4px 8px; font-size: 0.8em; height: auto; background-color: var(--ink-light); color: var(--parchment); border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s ease; flex-shrink: 0; }
        .modal-content .small-button:hover { background-color: var(--ink); }
        /* ... rest of styles ... */
        .provider-selector { display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; align-items: flex-end; }
        .provider-selector > div { flex: 1; min-width: 150px; }
        .api-key-manager { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-top: 5px; }
        .api-key-manager input[type="password"] { flex-grow: 1; min-width: 200px; }
        .api-key-manager button { padding: 8px 12px; font-size: 0.9em; height: 44px; flex-shrink: 0; }
        .api-key-status { font-size: 0.9em; color: var(--ink-light); margin-top: 5px; flex-basis: 100%; }
        #clear-keys-button { background-color: var(--crimson); color: white; margin-left: auto; }
        #clear-keys-button:hover { background-color: darkred; }
        #code-edit-modal .modal-content { max-width: 650px; }
        #edit-snippet-textarea { font-family: Consolas, Monaco, monospace; min-height: 150px; max-height: 40vh; flex-grow: 1; flex-shrink: 1; overflow-y: auto; margin-bottom: 5px; background-color: white; }
        .modal-content .line-inputs { display: flex; gap: 15px; align-items: center; margin-bottom: 10px; flex-shrink: 0; flex-wrap: wrap; }
        .modal-content .line-inputs div { flex-grow: 1; min-width: 80px; }
        .modal-content .line-inputs input[type="number"] { width: 100%; padding: 8px; }
        #edit-snippet-counter { font-size: 0.9em; color: var(--ink-light); text-align: right; margin-bottom: 15px; flex-shrink: 0; flex-basis: 100%; }
        #edit-snippet-line-count { font-weight: bold; color: var(--ink); }
        .edit-context-note { font-style: italic; color: var(--ink-light); font-size: 0.85em; margin-bottom: 15px; flex-shrink: 0; border-top: 1px dashed var(--ink-light); padding-top: 10px; margin-top: 5px; }
        .edit-instructions-area { flex-shrink: 0; margin-bottom: 15px; }
        .edit-instructions-controls { display: flex; gap: 8px; align-items: center; margin-top: 5px; }
        #edit-instructions { width: 100%; min-height: 60px; max-height: 25vh; resize: vertical; background-color: white; }
        #edit-response-count { width: 40px; padding: 6px; font-size: 0.9rem; height: auto; border: 1px solid var(--ink-light); margin-left: auto; background-color: white; }
        #html-runner-modal .modal-content { max-width: 90vw; width: 85%; }
        .html-runner-container { display: flex; flex-grow: 1; gap: 15px; min-height: 0; margin-bottom: 15px; }
        .runner-editor, .runner-preview { flex: 1; display: flex; flex-direction: column; border: 1px solid var(--ink-light); border-radius: 5px; background-color: var(--parchment-dark); overflow: hidden; }
        .runner-header { margin: 0; padding: 8px 12px; background-color: var(--ink-light); color: var(--parchment); border-bottom: 1px solid var(--ink); font-size: 0.9em; font-weight: bold; flex-shrink: 0; text-align: center; }
        #html-runner-input { flex: 1; border: none; padding: 10px; font-family: Consolas, Monaco, monospace; font-size: 0.9em; resize: none; outline: none; background-color: white; color: var(--ink); }
        #html-runner-frame { flex: 1; border: none; width: 100%; height: 100%; background-color: white; }
        #html-runner-modal .modal-buttons button { padding: 8px 15px; }
        .message-content pre { border: 1px solid var(--code-border); background-color: var(--code-bg); position: relative; margin-top: 10px; margin-bottom: 5px; }
        .message-content pre code.hljs { display: block; overflow-x: auto; padding: 1em; background: transparent; color: var(--ink); border-radius: 5px; }
        .hljs-comment, .hljs-quote { color: #7a7061; font-style: italic; }
        .hljs-keyword, .hljs-selector-tag, .hljs-subst { color: var(--crimson); font-weight: bold; }
        .hljs-number, .hljs-literal, .hljs-variable, .hljs-template-variable, .hljs-tag .hljs-attr { color: var(--sapphire); }
        .hljs-string, .hljs-doctag { color: #4b8350; }
        .hljs-title, .hljs-section, .hljs-selector-id { color: var(--gold); font-weight: bold; }
        .message-content code:not(.hljs) { background-color: var(--code-bg); border: 1px solid var(--code-border); padding: 0.2em 0.4em; border-radius: 3px; font-size: 85%; font-family: Consolas, Monaco, monospace; }
        .cat-placeholder { display: none; font-size: 1.2em; cursor: default; user-select: none; padding: 2px 5px; background-color: var(--parchment-dark); border-radius: 3px; border: 1px solid var(--ink-light); margin-right: 5px; margin-bottom: 3px; }
        .message-actions { margin-top: 8px; text-align: left; display: flex; gap: 5px; flex-wrap: wrap; }
        .action-button { background-color: var(--ink-light); color: var(--parchment); border: none; padding: 4px 8px; font-size: 0.8em; border-radius: 4px; cursor: pointer; opacity: 0.9; transition: opacity 0.2s ease, background-color 0.2s ease; font-family: var(--font-body); } /* Use body font for actions */
        .action-button:hover { opacity: 1; background-color: var(--ink); }
        .copy-code-button.copied { background-color: #3a9a41; color: white; }
        .download-code-button { background-color: #17a2b8; }
        .download-code-button:hover { background-color: #138496; }
        .run-html-button { background-color: var(--emerald); }
        .run-html-button:hover { background-color: darkgreen; }
        .tome.code-hidden .message pre { display: none; }
        .tome.code-hidden .message .cat-placeholder { display: inline-block; }
        .download-code-button { display: none; }
        .tome.download-code-active .download-code-button { display: inline-block; }
        .run-html-button { display: none; }
        .tome.run-html-active .run-html-button { display: inline-block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @media (max-width: 768px) { /* ... (responsive styles unchanged) ... */ }
        .visually-hidden { position: absolute !important; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px); white-space: nowrap; }
    </style>
</head>
<body>
    <!-- HTML Structure (Unchanged) -->
    <div class="tome" id="chat-container">
        <div class="pages" id="pages"></div>
        <div class="writing-area">
            <textarea class="message-input" id="message-input" placeholder="Inscribe thy query..." rows="1"></textarea>
            <div class="writing-controls">
                 <button id="settings-button" class="footer-button" title="Settings"> <i class="fas fa-cog"></i> </button>
                 <button id="upload-file-button" class="footer-button" title="Attach Parchment (No logic yet)"> <i class="fas fa-paperclip"></i> </button>
                 <button id="add-iterator-button" class="footer-button" title="Insert {i}">Add {i}</button>
                 <button id="clear-chat-button" class="footer-button" title="Clear Scroll">Clear</button>
                 <button id="edit-code-button" class="footer-button" title="Edit Snippet">Edit</button>
                 <input type="number" class="response-count-input" id="main-response-count" value="1" min="0" max="5" title="Responses (0 to send no query)">
                 <button class="send-button" id="send-button" title="Send Query"> <span>Send</span> <span>✒</span> </button>
            </div>
        </div>
    </div>
    <!-- Settings Modal (HTML Unchanged) -->
    <div class="modal-overlay" id="system-prompt-modal">
         <div class="modal-content">
             <h3>Tome Settings</h3>
             <div class="provider-selector form-group">
                 <div> <label for="provider-select">Spirit Provider:</label> <select id="provider-select"></select> </div>
                 <div> <label for="model-select">Spirit Model:</label> <select id="model-select"></select> </div>
             </div>
             <div class="form-group">
                 <label for="api-key-input">Add Spirit Essence (API Key) for <span id="selected-provider-label">Provider</span>:</label>
                 <div class="api-key-manager">
                      <input type="password" id="api-key-input" placeholder="Paste new key...">
                      <button id="add-key-button" title="Add this key to the list for the selected provider">Add Key</button>
                      <button id="clear-keys-button" title="Remove all stored keys for the selected provider">Clear Keys for Provider</button>
                 </div>
                 <span id="api-key-status" class="api-key-status">Keys Loaded: 0</span>
             </div>
             <div class="form-group">
                 <label for="system-prompt-input">Spirit's Nature (System Prompt):</label>
                 <textarea id="system-prompt-input" placeholder="Define the spirit's core nature..."></textarea>
             </div>
             <div class="form-group">
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="hide-code-checkbox"> <label for="hide-code-checkbox">Veil Glyphs</label> </div>
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="download-code-checkbox"> <label for="download-code-checkbox">Enable Download</label> </div>
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="enable-run-html-checkbox"> <label for="enable-run-html-checkbox">Enable Run HTML</label> </div>
             </div>
             <div class="modal-buttons">
                <button id="cancel-settings" class="cancel-button">Cancel</button>
                <button id="save-settings-button">Seal Settings</button>
             </div>
         </div>
    </div>
    <!-- Code Edit Modal (HTML Unchanged) -->
    <div class="modal-overlay" id="code-edit-modal">
        <div class="modal-content">
            <h3>Transcribe & Alter Glyphs</h3>
            <p style="font-size: 0.9em; color: var(--ink-light); margin-bottom: 10px; flex-shrink: 0;">Inscribe the glyphs below. Select lines for alteration.</p>
            <textarea id="edit-snippet-textarea" placeholder="Place glyphs here..."></textarea>
            <p class="edit-context-note"> Only the selected lines are sent. Context should be included in previous messages. </p>
            <div class="line-inputs">
                 <div> <label for="edit-start-line">Start Line:</label> <input type="number" id="edit-start-line" min="1" value="1"> </div>
                 <div> <label for="edit-end-line">End Line:</label> <input type="number" id="edit-end-line" min="1" value="1"> </div>
                 <div id="edit-snippet-counter" style="margin-left: auto;"> Lines: <span id="edit-snippet-line-count">0</span> </div>
            </div>
            <div class="edit-instructions-area">
                <label for="edit-instructions">Instructions for Spirit (applies to selected lines):</label>
                <textarea id="edit-instructions" rows="3" placeholder="e.g., Reforge these lines, mend the flaw..."></textarea>
                <div class="edit-instructions-controls">
                    <button id="edit-add-iterator-button" class="small-button" title="Insert {i}">Add {i}</button>
                    <label for="edit-response-count" style="margin-left: auto; flex-basis: auto; margin-bottom: 0; font-weight: normal; color: var(--ink-light); font-size: 0.9em;">Variations:</label>
                    <input type="number" class="response-count-input" id="edit-response-count" value="1" min="1" max="5" title="Number of edit variations">
                </div>
            </div>
            <div class="modal-buttons">
                <button id="cancel-edit-request" class="cancel-button">Cancel</button>
                <button id="send-edit-request">Request Alteration</button>
            </div>
        </div>
    </div>
    <!-- HTML Runner Modal (HTML Unchanged) -->
    <div class="modal-overlay" id="html-runner-modal">
        <div class="modal-content">
            <h3>HTML Runner</h3>
            <div class="html-runner-container">
                 <div class="runner-editor"> <div class="runner-header">HTML Input</div> <textarea id="html-runner-input" placeholder="Paste HTML code here..."></textarea> </div>
                 <div class="runner-preview"> <div class="runner-header">Preview</div> <iframe id="html-runner-frame" title="HTML Output Preview" sandbox="allow-scripts allow-same-origin"></iframe> </div>
            </div>
             <div class="modal-buttons">
                 <button id="html-runner-render-button">Render</button>
                 <button id="html-runner-close-button" class="cancel-button">Close</button>
             </div>
        </div>
    </div>
    <!-- Hidden Helpers (HTML Unchanged) -->
    <textarea class="visually-hidden" id="copy-helper" aria-hidden="true"></textarea>
    <input type="file" id="file-upload-input" accept="*/*" style="display:none;">
    <input type="file" class="pfp-upload" accept="image/*" style="display:none;">

    <script>
        // --- Global State & Constants ---
        let conversationHistory = [];
        let userPfp = localStorage.getItem('userPfp') || 'https://ui-avatars.com/api/?name=U&background=1e3a8a&color=fff&font-size=0.6&bold=true';
        let botPfp = localStorage.getItem('botPfp') || 'https://ui-avatars.com/api/?name=S&background=6b21a8&color=fff&font-size=0.6&bold=true';
        let currentPfpElementToUpdate = null;
        let turnCounter = 0;
        const iterationPlaceholder = '{i}';
        const DEFAULT_SYSTEM_PROMPT = 'You are a mystical spirit from another realm...';

        // --- Provider/Key State ---
        let selectedProvider = '';
        let selectedModel = '';
        let apiKeys = {};
        let currentApiKeyIndex = {};

        // --- Other State ---
        let hideCodeBlocks = true;
        let downloadCodeMode = false;
        let enableRunHtmlMode = false;
        let isWaitingForResponse = false;

        // --- DOM Elements ---
        const chatContainerElement = document.getElementById('chat-container');
        const pages = document.getElementById('pages');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const mainResponseCountInput = document.getElementById('main-response-count');
        const pfpUploadInput = document.querySelector('.pfp-upload');
        const settingsButton = document.getElementById('settings-button');
        const systemPromptModal = document.getElementById('system-prompt-modal');
        const providerSelect = document.getElementById('provider-select');
        const modelSelect = document.getElementById('model-select');
        const selectedProviderLabel = document.getElementById('selected-provider-label');
        const systemPromptInput = document.getElementById('system-prompt-input');
        const apiKeyInput = document.getElementById('api-key-input');
        const addKeyButton = document.getElementById('add-key-button');
        const clearKeysButton = document.getElementById('clear-keys-button');
        const apiKeyStatus = document.getElementById('api-key-status');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const hideCodeCheckbox = document.getElementById('hide-code-checkbox');
        const downloadCodeCheckbox = document.getElementById('download-code-checkbox');
        const enableRunHtmlCheckbox = document.getElementById('enable-run-html-checkbox');
        const cancelSettingsButton = document.getElementById('cancel-settings');
        const editCodeButton = document.getElementById('edit-code-button');
        const codeEditModal = document.getElementById('code-edit-modal');
        const editSnippetTextarea = document.getElementById('edit-snippet-textarea');
        const editStartLineInput = document.getElementById('edit-start-line');
        const editEndLineInput = document.getElementById('edit-end-line');
        const editSnippetLineCount = document.getElementById('edit-snippet-line-count');
        const editInstructionsInput = document.getElementById('edit-instructions');
        const editAddIteratorButton = document.getElementById('edit-add-iterator-button');
        const editResponseCountInput = document.getElementById('edit-response-count');
        const sendEditRequestButton = document.getElementById('send-edit-request');
        const cancelEditRequestButton = document.getElementById('cancel-edit-request');
        const htmlRunnerModal = document.getElementById('html-runner-modal');
        const htmlRunnerInput = document.getElementById('html-runner-input');
        const htmlRunnerFrame = document.getElementById('html-runner-frame');
        const htmlRunnerRenderButton = document.getElementById('html-runner-render-button');
        const htmlRunnerCloseButton = document.getElementById('html-runner-close-button');
        const clearChatButton = document.getElementById('clear-chat-button');
        const addIteratorButton = document.getElementById('add-iterator-button');
        const uploadFileButton = document.getElementById('upload-file-button');
        const fileUploadInput = document.getElementById('file-upload-input');
        const copyHelper = document.getElementById('copy-helper');

        // --- Configure Markdown & Highlighting ---
        marked.setOptions({
            highlight: function(code, lang) {
                const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                try { return hljs.highlight(code, { language: language, ignoreIllegals: true }).value; }
                catch (e) { return hljs.highlight(code, { language: 'plaintext', ignoreIllegals: true }).value; }
            },
            langPrefix: 'hljs language-', gfm: true, breaks: true
        });

        // --- All Function Definitions ---

        function updateApiKeyStatus(provider = selectedProvider) {
            const keysForProvider = apiKeys[provider] || []; const count = keysForProvider.length;
            if (apiKeyStatus) { apiKeyStatus.textContent = `Keys Loaded: ${count}`; }
            if(selectedProviderLabel && typeof PROVIDERS !== 'undefined') { selectedProviderLabel.textContent = (PROVIDERS[provider]?.name || provider) ?? 'Unknown Provider'; }
            else if (selectedProviderLabel) { selectedProviderLabel.textContent = provider || 'Unknown Provider'; }
            if (sendButton) { sendButton.disabled = !hasSelectedProviderApiKeys() || isWaitingForResponse; }
        }

        function addApiKey() {
             const provider = selectedProvider; const newKey = apiKeyInput.value.trim();
             if (!provider) { alert("Please select a provider first."); return; }
             if (typeof PROVIDERS === 'undefined' || !PROVIDERS[provider]) { alert(`Invalid provider selected or PROVIDERS missing: ${provider}`); return; }
             const providerConfig = PROVIDERS[provider];
             if (providerConfig.apiKeyLocation === 'none' && providerConfig.format !== 'proxy_compatible') { alert(`${providerConfig.name} does not require client-side API keys.`); apiKeyInput.value = ''; return; }
             if (newKey) { if (!apiKeys[provider]) apiKeys[provider] = []; if (!apiKeys[provider].includes(newKey)) { apiKeys[provider].push(newKey); apiKeyInput.value = ''; updateApiKeyStatus(provider); console.log(`Added key for ${provider}. Total keys: ${apiKeys[provider].length}`); try { localStorage.setItem('apiKeys', JSON.stringify(apiKeys)); } catch (e) { console.error("Failed to save API keys after adding:", e); }} else { alert(`This API key is already in the list for ${providerConfig.name}.`); }}
             else { alert("Please paste an API key before adding."); }
        }

        function clearApiKeysForProvider() {
             const provider = selectedProvider; if (!provider) { alert("Please select a provider first."); return; }
             if (typeof PROVIDERS === 'undefined' || !PROVIDERS[provider]) { alert(`Please select a valid provider first or PROVIDERS missing.`); return; }
             const providerName = PROVIDERS[provider]?.name || provider;
             if (confirm(`Are you sure you want to remove ALL keys for ${providerName}?`)) { apiKeys[provider] = []; currentApiKeyIndex[provider] = 0; updateApiKeyStatus(provider); console.log(`Cleared all API keys for ${provider}.`); try { localStorage.setItem('apiKeys', JSON.stringify(apiKeys)); localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex)); } catch (e) { console.error("Failed to save cleared API keys/indices:", e); }}
        }

        function getNextApiKey(provider) {
            if (typeof PROVIDERS === 'undefined' || !PROVIDERS[provider]) { console.error(`Provider config missing for ${provider} in getNextApiKey`); return null; }
            const keysForProvider = apiKeys[provider] || []; const providerConfig = PROVIDERS[provider];
            if (providerConfig.apiKeyLocation === 'none' && providerConfig.format !== 'proxy_compatible') { return null; }
            if (keysForProvider.length === 0) { if (!(providerConfig.apiKeyLocation === 'none' && providerConfig.format !== 'proxy_compatible')) { console.error(`No API keys available for provider: ${provider}`); } return null; }
            let index = currentApiKeyIndex[provider] || 0; if (index >= keysForProvider.length) index = 0;
            const keyToUse = keysForProvider[index]; currentApiKeyIndex[provider] = (index + 1) % keysForProvider.length;
            try { localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex)); } catch (e) { console.warn("Could not save API key index object:", e); }
            return keyToUse;
        }

        function hasSelectedProviderApiKeys() {
             if (typeof PROVIDERS === 'undefined') { console.error("PROVIDERS object not available in hasSelectedProviderApiKeys."); return false; }
             const providerConfig = PROVIDERS[selectedProvider]; if (!providerConfig) return false;
             if (providerConfig.apiKeyLocation === 'none' && providerConfig.format !== 'proxy_compatible') return true;
             const keysForCurrent = apiKeys[selectedProvider] || []; return keysForCurrent.length > 0;
        }

        async function handleSendMessage() {
             if (!hasSelectedProviderApiKeys()) { const providerName = (typeof PROVIDERS !== 'undefined' && PROVIDERS[selectedProvider]?.name) ? PROVIDERS[selectedProvider].name : selectedProvider || "the selected provider"; alert(`No API Key loaded for ${providerName}. Please add one in Settings.`); return; }
             if (isWaitingForResponse) return;
             const userInput = messageInput.value.trim(); const responseCount = parseInt(mainResponseCountInput.value, 10);
             if (userInput === '') return;
             const numResponses = isNaN(responseCount) || responseCount < 0 ? 0 : Math.min(responseCount, 5);
             const turnId = `turn-${turnCounter++}`; const containsPlaceholder = userInput.includes(iterationPlaceholder);
             isWaitingForResponse = true; if (sendButton) sendButton.disabled = true; messageInput.value = ''; autoGrowTextarea();
             const userEntry = { role: 'user', content: userInput, turnId: turnId }; conversationHistory.push(userEntry); displayMessage(userEntry, 'user'); saveHistoryToLocalStorage(); scrollToBottom();
             if (numResponses > 0) {
                 showTypingIndicator(); const baseHistory = prepareHistoryForApi(conversationHistory); const responses = []; let errorOccurred = false; const provider = selectedProvider; const model = selectedModel;
                 console.log(`Sending ${numResponses} requests to ${provider} (${model})`);
                 for (let i = 0; i < numResponses; i++) {
                     const iteration = i + 1; const currentKey = getNextApiKey(provider);
                     if (typeof PROVIDERS === 'undefined') { responses.push(`[Config Error: PROVIDERS object missing]`); errorOccurred = true; break; }
                     const providerConfigCheck = PROVIDERS[provider]; if (!providerConfigCheck) { responses.push(`[Config Error: Provider '${provider}' missing]`); errorOccurred = true; break; }
                     if (providerConfigCheck.apiKeyLocation !== 'none' && providerConfigCheck.format !== 'proxy_compatible' && !currentKey) { responses.push(`[Config Error: No Key for ${provider}]`); errorOccurred = true; break; }
                     let currentHistory = [...baseHistory];
                     if (containsPlaceholder && numResponses > 1) {
                         const userMessageIndex = currentHistory.findLastIndex(m => m.role === 'user');
                         if (userMessageIndex > -1) { const substitutedContent = currentHistory[userMessageIndex].content.replace(new RegExp(iterationPlaceholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g'), iteration.toString()); currentHistory[userMessageIndex] = { ...currentHistory[userMessageIndex], content: substitutedContent }; console.log(`Substituted placeholder for iteration ${iteration}`);}
                         else { console.warn("Could not find user message to substitute placeholder."); }
                     }
                     try { if (typeof getApiResponse !== 'function') { throw new Error("getApiResponse function is not defined."); } const messageContent = await getApiResponse(provider, model, currentHistory, currentKey, { temperature: 0.7, top_p: 0.9 }); responses.push(messageContent || "[Silence]"); }
                     catch (e) { console.error(`API Call Error (Provider: ${provider}, Model: ${model}, Iteration: ${iteration}):`, e); responses.push(`[Spirit Disturbance: ${e instanceof Error ? e.message : String(e)}]`); errorOccurred = true; }
                 }
                 hideTypingIndicator();
                 if (responses.length > 0) { const botEntry = { role: 'assistant', variants: responses, selectedIndex: 0, turnId: turnId }; conversationHistory.push(botEntry); saveHistoryToLocalStorage(); displayBotMessage(botEntry, 'spirit'); scrollToBottom(); }
             } else { console.log("Query added to history, 0 responses requested."); }
             isWaitingForResponse = false; if (sendButton) sendButton.disabled = !hasSelectedProviderApiKeys(); messageInput.focus();
        }

        async function handleSendEditRequest() {
             if (!hasSelectedProviderApiKeys()) { const providerName = (typeof PROVIDERS !== 'undefined' && PROVIDERS[selectedProvider]?.name) ? PROVIDERS[selectedProvider].name : (selectedProvider || "the selected provider"); alert(`No API Key loaded for ${providerName}. Please add one in Settings.`); return; }
             if (isWaitingForResponse) return;
             const pastedCode = editSnippetTextarea.value; const startLine = parseInt(editStartLineInput.value, 10); const endLine = parseInt(editEndLineInput.value, 10); const instructions = editInstructionsInput.value.trim(); const numVariations = parseInt(editResponseCountInput.value, 10); const pastedLines = pastedCode.split('\n'); const totalLines = pastedLines.length;
             if (pastedCode.trim() === '') { alert("Please inscribe the glyphs to be altered."); editSnippetTextarea.focus(); return; } if (!instructions) { alert("Instructions are required."); editInstructionsInput.focus(); return; }
             if (isNaN(startLine) || isNaN(endLine) || startLine < 1 || endLine < startLine || endLine > totalLines) { alert(`Invalid line selection (1-${totalLines}).`); editStartLineInput.focus(); return; }
             const numResponses = isNaN(numVariations) || numVariations < 1 ? 1 : Math.min(numVariations, 5); const containsPlaceholder = instructions.includes(iterationPlaceholder);
             codeEditModal.style.display = 'none'; isWaitingForResponse = true; if (sendButton) sendButton.disabled = true; const turnId = `turn-${turnCounter++}`; const userRequestSummary = `[Glyph Alteration Request: Lines ${startLine}-${endLine}, ${numResponses} variation(s)]`;
             const userEntry = { role: 'user', content: userRequestSummary, turnId: turnId }; conversationHistory.push(userEntry); displayMessage(userEntry, 'user'); saveHistoryToLocalStorage(); scrollToBottom(); showTypingIndicator();
             const startIndex = startLine - 1; const endIndex = endLine; const snippetToAlter = pastedLines.slice(startIndex, endIndex).join('\n'); const historyUpToEdit = conversationHistory.slice(0, -1); const baseApiHistory = prepareHistoryForApi(historyUpToEdit);
             const editResponses = []; let errorOccurred = false; const provider = selectedProvider; const model = selectedModel; console.log(`Sending ${numResponses} EDIT requests to ${provider} (${model})`);
             for (let i = 0; i < numResponses; i++) {
                 const iteration = i + 1; const currentKey = getNextApiKey(provider);
                 if (typeof PROVIDERS === 'undefined') { editResponses.push(`--- ERROR: PROVIDERS missing ---`); errorOccurred = true; break; } const providerConfigCheck = PROVIDERS[provider]; if (!providerConfigCheck) { editResponses.push(`--- ERROR: Provider '${provider}' missing ---`); errorOccurred = true; break; } if (providerConfigCheck.apiKeyLocation !== 'none' && providerConfigCheck.format !== 'proxy_compatible' && !currentKey) { editResponses.push(`--- ERROR: No Key for ${provider} ---`); errorOccurred = true; break; }
                 let currentInstructions = instructions; if (containsPlaceholder && numResponses > 1) { currentInstructions = instructions.replace(new RegExp(iterationPlaceholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g'), iteration.toString()); }
                 const prompt = `You are tasked with editing a code snippet.\n Context from previous conversation may be relevant.\n You MUST ONLY return the modified lines based on the instructions provided.\n Do NOT include the original line numbers or markdown code blocks unless instructed.\n\n Original lines ${startLine} to ${endLine}:\n \`\`\`\n ${snippetToAlter}\n \`\`\`\n\n Instructions: ${currentInstructions}\n\n Return ONLY the altered lines.`;
                 let apiHistoryForThisCall = [...baseApiHistory, { role: 'user', content: prompt }];
                 try { if (typeof getApiResponse !== 'function') { throw new Error("getApiResponse function is not defined."); } const rawResponse = await getApiResponse(provider, model, apiHistoryForThisCall, currentKey, { temperature: 0.5, top_p: 0.9 }); const editedLines = (rawResponse || "").split('\n'); const reconstructedLines = [...pastedLines.slice(0, startIndex), ...editedLines, ...pastedLines.slice(endIndex)]; editResponses.push(reconstructedLines.join('\n')); }
                 catch (e) { console.error(`Edit Request API Error (Provider: ${provider}, Model: ${model}, Variation ${iteration}):`, e); const errorMarker = `--- ERROR Altering Variation ${iteration} ---\n${e instanceof Error ? e.message : String(e)}\n--- ORIGINAL LINES ${startLine}-${endLine} ---`; const reconstructedLines = [...pastedLines.slice(0, startIndex), errorMarker, ...pastedLines.slice(startIndex, endIndex), ...pastedLines.slice(endIndex)]; editResponses.push(reconstructedLines.join('\n')); errorOccurred = true; }
             }
             hideTypingIndicator(); const botEntry = { role: 'assistant', variants: editResponses.length > 0 ? editResponses : ["[Edit Failed]"], selectedIndex: 0, turnId: turnId, isCodeEdit: true };
             conversationHistory.push(botEntry); saveHistoryToLocalStorage(); displayBotMessage(botEntry, 'spirit');
             isWaitingForResponse = false; if (sendButton) sendButton.disabled = !hasSelectedProviderApiKeys(); scrollToBottom(); messageInput.focus();
        }

        function populateProviderSelect() {
            if (!providerSelect) { console.error("providerSelect missing."); return; } providerSelect.innerHTML = '';
            if (typeof PROVIDERS === 'undefined' || Object.keys(PROVIDERS).length === 0) { console.error("PROVIDERS missing or empty."); providerSelect.innerHTML = '<option value="" disabled>Error</option>'; return; }
            for (const providerKey in PROVIDERS) { const option = document.createElement('option'); option.value = providerKey; option.textContent = PROVIDERS[providerKey].name || providerKey; providerSelect.appendChild(option); }
            if (!PROVIDERS[selectedProvider]) { selectedProvider = Object.keys(PROVIDERS)[0] || ''; localStorage.setItem('selectedProvider', selectedProvider); }
            providerSelect.value = selectedProvider; populateModelSelect(selectedProvider);
        }

        function populateModelSelect(providerKey) {
            if (!modelSelect) { console.error("modelSelect missing."); return; } modelSelect.innerHTML = '';
            if (typeof PROVIDERS === 'undefined' || !providerKey || !PROVIDERS[providerKey]) { modelSelect.innerHTML = '<option value="" disabled>Select Provider</option>'; selectedModel = ''; localStorage.setItem('selectedModel', ''); return; }
            const providerConf = PROVIDERS[providerKey]; if (!providerConf.availableModels || providerConf.availableModels.length === 0) { modelSelect.innerHTML = '<option value="" disabled>No models</option>'; selectedModel = ''; localStorage.setItem('selectedModel', ''); return; }
            providerConf.availableModels.forEach(modelInfo => { const modelKey = typeof modelInfo === 'string' ? modelInfo : modelInfo.key; const modelName = typeof modelInfo === 'string' ? modelInfo : modelInfo.name || modelInfo.key; if (!modelKey) return; const option = document.createElement('option'); option.value = modelKey; option.textContent = modelName; modelSelect.appendChild(option); });
            const savedModel = localStorage.getItem('selectedModel'); const isValidSavedModel = savedModel && providerConf.availableModels.some(m => (typeof m === 'string' ? m === savedModel : m.key === savedModel));
            if (isValidSavedModel) { modelSelect.value = savedModel; selectedModel = savedModel; }
            else if (providerConf.defaultModel && providerConf.availableModels.some(m => (typeof m === 'string' ? m === providerConf.defaultModel : m.key === providerConf.defaultModel))) { modelSelect.value = providerConf.defaultModel; selectedModel = providerConf.defaultModel; }
            else { const firstModelKey = typeof providerConf.availableModels[0] === 'string' ? providerConf.availableModels[0] : providerConf.availableModels[0]?.key; if (firstModelKey) { modelSelect.value = firstModelKey; selectedModel = firstModelKey; } else { modelSelect.innerHTML = '<option value="" disabled>Error</option>'; selectedModel = ''; } }
            localStorage.setItem('selectedModel', selectedModel); console.log(`Model set: ${selectedModel} for ${selectedProvider}`);
        }

        function handleProviderChange() { selectedProvider = providerSelect.value; localStorage.setItem('selectedProvider', selectedProvider); populateModelSelect(selectedProvider); updateApiKeyStatus(selectedProvider); if (sendButton) sendButton.disabled = !hasSelectedProviderApiKeys() || isWaitingForResponse; }

        function handleModelChange() { selectedModel = modelSelect.value; localStorage.setItem('selectedModel', selectedModel); console.log(`Model set: ${selectedModel} for ${selectedProvider}`); }

        function openSystemPromptModal() {
             console.log("openSystemPromptModal called");
             if (!systemPromptModal) { console.error("Settings modal element missing!"); return; }
             if (systemPromptInput) systemPromptInput.value = conversationHistory[0]?.content || localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
             populateProviderSelect(); updateApiKeyStatus(selectedProvider);
             if (apiKeyInput) apiKeyInput.value = '';
             if (hideCodeCheckbox) hideCodeCheckbox.checked = hideCodeBlocks;
             if (downloadCodeCheckbox) downloadCodeCheckbox.checked = downloadCodeMode;
             if (enableRunHtmlCheckbox) enableRunHtmlCheckbox.checked = enableRunHtmlMode;
             systemPromptModal.style.display = 'flex';
             console.log("System prompt modal display attempt finished.");
         }

        function saveSettings() {
             console.log("saveSettings called"); const sp = systemPromptInput.value.trim() || DEFAULT_SYSTEM_PROMPT;
             if (conversationHistory.length === 0 || conversationHistory[0]?.role !== 'system') { conversationHistory.unshift({ role: 'system', content: sp }); } else { conversationHistory[0].content = sp; }
             localStorage.setItem('systemPrompt', sp); localStorage.setItem('selectedProvider', selectedProvider); localStorage.setItem('selectedModel', selectedModel);
             try { localStorage.setItem('apiKeys', JSON.stringify(apiKeys)); localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex)); console.log(`Settings saved. Provider: ${selectedProvider}, Model: ${selectedModel}`); }
             catch (e) { console.error("Failed to save API keys/indices:", e); alert("Error saving API keys."); }
             saveHistoryToLocalStorage(); if (sendButton) sendButton.disabled = !hasSelectedProviderApiKeys(); systemPromptModal.style.display = 'none';
        }

        function handleHideCodeToggle() { if (!hideCodeCheckbox || !chatContainerElement) return; hideCodeBlocks = hideCodeCheckbox.checked; localStorage.setItem('hideCodeBlocks', String(hideCodeBlocks)); chatContainerElement.classList.toggle('code-hidden', hideCodeBlocks); }

        function handleDownloadCodeToggle() { if (!downloadCodeCheckbox || !chatContainerElement) return; downloadCodeMode = downloadCodeCheckbox.checked; localStorage.setItem('downloadCodeMode', String(downloadCodeMode)); chatContainerElement.classList.toggle('download-code-active', downloadCodeMode); }

        function handleEnableRunHtmlToggle() { if (!enableRunHtmlCheckbox || !chatContainerElement) return; enableRunHtmlMode = enableRunHtmlCheckbox.checked; localStorage.setItem('enableRunHtmlMode', String(enableRunHtmlMode)); chatContainerElement.classList.toggle('run-html-active', enableRunHtmlMode); }

        function handleClearChat() {
             console.log("handleClearChat called");
             if (confirm("Disperse all echoes? (Cannot be undone)")) { console.log("Clear confirmed"); const sp = conversationHistory[0]?.content || localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT; conversationHistory = [{ role: 'system', content: sp }]; turnCounter = 1; saveHistoryToLocalStorage(); rebuildChatFromHistory(); displayInitialGreeting(); console.log("Chat cleared."); }
             else { console.log("Clear cancelled"); }
        }

        function insertIteratorPlaceholder(targetInput) {
             console.log("insertIteratorPlaceholder called for target:", targetInput?.id); if (!targetInput) { console.error("Target input is null!"); return; }
             const start = targetInput.selectionStart; const end = targetInput.selectionEnd; const value = targetInput.value;
             const newValue = value.substring(0, start) + iterationPlaceholder + value.substring(end); targetInput.value = newValue;
             const newPos = start + iterationPlaceholder.length; targetInput.selectionStart = newPos; targetInput.selectionEnd = newPos; targetInput.focus(); targetInput.dispatchEvent(new Event('input', { bubbles: true })); console.log(`Iterator inserted into ${targetInput.id}`);
        }

        function autoGrowTextarea() {
            if (!messageInput) return; const input = messageInput; const maxHeightStyle = window.getComputedStyle(input).maxHeight; const maxHeight = parseFloat(maxHeightStyle) || 150; input.style.height = 'auto'; const scrollHeight = input.scrollHeight; input.style.height = Math.min(scrollHeight, maxHeight) + 'px'; input.style.overflowY = scrollHeight > maxHeight ? 'auto' : 'hidden';
        }

        function openEditCodeModal() {
             console.log("openEditCodeModal called"); if (!codeEditModal) { console.error("Code edit modal missing!"); return; }
             if (editSnippetTextarea) editSnippetTextarea.value = ''; if (editStartLineInput) editStartLineInput.value = 1; if (editEndLineInput) editEndLineInput.value = 1; if (editInstructionsInput) editInstructionsInput.value = ''; if (editResponseCountInput) editResponseCountInput.value = 1;
             updateSnippetLineCount(); codeEditModal.style.display = 'flex'; if (editSnippetTextarea) editSnippetTextarea.focus();
             console.log("Code edit modal display attempt finished.");
        }

        function updateSnippetLineCount() {
             if (!editSnippetTextarea || !editSnippetLineCount || !editStartLineInput || !editEndLineInput) return;
             const lines = editSnippetTextarea.value.split('\n'); const count = editSnippetTextarea.value === '' ? 0 : lines.length; if (editSnippetLineCount) editSnippetLineCount.textContent = count;
             const maxVal = count > 0 ? count : 1; editStartLineInput.max = maxVal; editEndLineInput.max = maxVal;
             if (parseInt(editEndLineInput.value) > maxVal) editEndLineInput.value = maxVal; if (parseInt(editStartLineInput.value) > maxVal) editStartLineInput.value = maxVal; if (parseInt(editEndLineInput.value) < parseInt(editStartLineInput.value)) editEndLineInput.value = editStartLineInput.value;
        }

        function renderRunnerHTML() {
             if (!htmlRunnerInput || !htmlRunnerFrame) { console.error("HTML Runner elements missing."); return; } const htmlCode = htmlRunnerInput.value;
             if (/<script.*?>.*?window\.location.*?<\/script>/i.test(htmlCode) || /<script.*?>.*?document\.cookie.*?<\/script>/i.test(htmlCode) || /<script.*?>.*?localStorage.*?<\/script>/i.test(htmlCode) || /<script.*?>.*?sessionStorage.*?<\/script>/i.test(htmlCode)) { console.warn("Harmful script detected. Blocking render."); try { const d = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow?.document; if (d) { d.open(); d.write('<html><body>Blocked</body></html>'); d.close(); } } catch (e) { /* ignore */ } return; }
             try { const d = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow?.document; if (d) { d.open(); d.write(htmlCode); d.close(); } else { console.error("Cannot access iframe document."); } } catch (e) { console.error("Error rendering HTML:", e); try { const d = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow?.document; if (d) { d.open(); d.write(`<html><body>Error:<pre>${e.message}</pre></body></html>`); d.close(); } } catch (e2) { /* ignore */ } }
        }

        function openHtmlRunner(initialCode = '') { if (!htmlRunnerModal || !htmlRunnerInput) { console.error("HTML Runner modal/input missing."); return; } htmlRunnerInput.value = initialCode; renderRunnerHTML(); htmlRunnerModal.style.display = 'flex'; }

        function createPfpElement(sender, pfpUrl) {
             const d=document.createElement('div'); d.className=`avatar ${sender}-avatar`; d.dataset.senderType=sender; const i=document.createElement('img'); i.src=pfpUrl; i.alt=`${sender} avatar`;
             i.onerror = () => { console.warn(`Failed avatar load: ${pfpUrl}`); const fb='https://ui-avatars.com/api/?name='+(sender==='user'?'U&background=1e3a8a':'S&background=6b21a8')+'&color=fff&font-size=0.6&bold=true'; i.src=fb; i.onerror=null; };
             d.addEventListener('click', () => { currentPfpElementToUpdate=i; if (pfpUploadInput) pfpUploadInput.click(); else console.error("pfpUploadInput missing."); }); d.appendChild(i); return d;
        }

        function displayBotMessage(entry, sender = 'spirit') {
            if (!entry || !entry.variants) { console.warn("Invalid bot entry:", entry); return; } const variants = Array.isArray(entry.variants) ? entry.variants : [entry.variants]; const selectedIndex = entry.selectedIndex ?? 0;
            if (variants.length > 1) displayMultipleMessages({ ...entry, variants: variants, selectedIndex: selectedIndex }, sender);
            else if (variants.length === 1) displayMessage({ ...entry, variants: variants, selectedIndex: 0 }, sender);
            else displayMessage({ ...entry, variants: ["[Silence]"], selectedIndex: 0 }, sender);
        }

        function displayMessage(entry, sender) {
            const content = (sender === 'user') ? (entry.content || "") : (entry.variants?.[entry.selectedIndex ?? 0] || "[Error]");
            const msgDiv = document.createElement('div'); msgDiv.className = `message message-${sender}`; if (entry.turnId) msgDiv.dataset.turnId = entry.turnId;
            const pfpUrl = (sender === 'user') ? userPfp : botPfp; const avatarEl = createPfpElement(sender, pfpUrl); const wrapper = document.createElement('div'); wrapper.classList.add('message-content-wrapper');
            const contentDiv = document.createElement('div'); contentDiv.className = 'message-content';
            if (sender === 'spirit') { try { contentDiv.innerHTML = marked.parse(content); } catch (e) { console.error("Markdown error:", e); contentDiv.textContent = content; contentDiv.style.whiteSpace = 'pre-wrap'; } }
            else { contentDiv.textContent = content; contentDiv.style.whiteSpace = 'pre-wrap'; }
            wrapper.appendChild(contentDiv); if (sender === 'spirit') addCodeActionButtons(contentDiv, wrapper, entry.turnId, entry.selectedIndex ?? 0);
            if (sender === 'user') { msgDiv.appendChild(wrapper); msgDiv.appendChild(avatarEl); } else { msgDiv.appendChild(avatarEl); msgDiv.appendChild(wrapper); }
            if (pages) { pages.appendChild(msgDiv); if (sender === 'spirit') contentDiv.querySelectorAll('pre code').forEach((block) => { try { hljs.highlightElement(block); } catch (e) { console.warn("Highlight error:", e); } }); }
            else console.error("Pages container missing."); return msgDiv;
        }

        function displayMultipleMessages(entry, sender = 'spirit') {
            if (!pages) { console.error("Pages container missing."); return null; } if (!entry || !Array.isArray(entry.variants) || entry.variants.length === 0) { console.warn("Invalid multi-entry:", entry); return null; }
            const tid = entry.turnId; const vars = entry.variants; let idx = entry.selectedIndex ?? 0; if (idx < 0 || idx >= vars.length) idx = 0;
            const msgDiv = document.createElement('div'); msgDiv.className = `message message-${sender}`; if (tid) msgDiv.dataset.turnId = tid; const pfpUrl = (sender === 'user') ? userPfp : botPfp; const avatarEl = createPfpElement(sender, pfpUrl);
            const wrapper = document.createElement('div'); wrapper.classList.add('message-content-wrapper'); const contentDiv = document.createElement('div'); contentDiv.className = 'message-content'; const nav = document.createElement('div'); nav.classList.add('response-navigation');
            const prev = document.createElement('button'); prev.textContent = '<'; prev.title = "Previous"; const span = document.createElement('span'); span.title = "Variant"; const next = document.createElement('button'); next.textContent = '>'; next.title = "Next";
            nav.appendChild(prev); nav.appendChild(span); nav.appendChild(next); let actsContainer = document.createElement('div'); actsContainer.classList.add('message-actions'); wrapper.appendChild(contentDiv); wrapper.appendChild(actsContainer); wrapper.appendChild(nav);
            function update(currentIndex) { const c = vars[currentIndex] || "[Error]"; try { contentDiv.innerHTML = marked.parse(c); } catch (e) { console.error("Markdown error:", e); contentDiv.textContent = c; contentDiv.style.whiteSpace = 'pre-wrap'; } addCodeActionButtons(contentDiv, wrapper, tid, currentIndex); span.textContent = `${currentIndex + 1} / ${vars.length}`; prev.disabled = currentIndex === 0; next.disabled = currentIndex === vars.length - 1; contentDiv.querySelectorAll('pre code').forEach((block) => { try { hljs.highlightElement(block); } catch (e) { console.warn("Highlight error:", e); } }); contentDiv.style.animation = 'none'; void contentDiv.offsetWidth; contentDiv.style.animation = 'fadeIn 0.3s ease-in-out'; }
            prev.addEventListener('click', () => { if (idx > 0) { idx--; update(idx); updateHistorySelection(tid, idx); } }); next.addEventListener('click', () => { if (idx < vars.length - 1) { idx++; update(idx); updateHistorySelection(tid, idx); } });
            if (sender === 'user') { msgDiv.appendChild(wrapper); msgDiv.appendChild(avatarEl); } else { msgDiv.appendChild(avatarEl); msgDiv.appendChild(wrapper); } pages.appendChild(msgDiv); update(idx); return msgDiv;
        }

        function addCodeActionButtons(contentDiv, wrapper, turnId, variantIndex) {
             let acts = wrapper.querySelector('.message-actions'); if (!acts) { acts = document.createElement('div'); acts.classList.add('message-actions'); const nav = wrapper.querySelector('.response-navigation'); if (nav) wrapper.insertBefore(acts, nav); else wrapper.appendChild(acts); } acts.innerHTML = '';
             contentDiv.querySelectorAll('.cat-placeholder').forEach(c => c.remove()); const codeBlocks = contentDiv.querySelectorAll('pre'); if (codeBlocks.length === 0 && !acts.hasChildNodes()) { if(acts.parentNode) acts.remove(); return; }
             codeBlocks.forEach((pre, preIdx) => {
                 const uid = `pre-${turnId || 'g'}-${variantIndex}-${preIdx}`; pre.id = uid; const cat = document.createElement('span'); cat.className = 'cat-placeholder'; cat.textContent = '🐱'; cat.dataset.preId = uid; pre.parentNode.insertBefore(cat, pre);
                 const code = pre.querySelector('code'); const txt = code ? code.textContent : ''; const lang = code?.className.match(/language-(\w+)/)?.[1]?.toLowerCase() || 'txt'; const fn = `tome_${turnId || 'c'}_${variantIndex + 1}_${preIdx + 1}.${lang}`;
                 const cp = document.createElement('button'); cp.textContent='Copy'; cp.title=`Copy ${lang}`; cp.className='copy-code-button action-button'; cp.onclick=()=>copyCodeFromPre(uid, cp); acts.appendChild(cp);
                 const dl = document.createElement('button'); dl.textContent='Download'; dl.title=`Download ${fn}`; dl.className='download-code-button action-button'; dl.onclick=()=>downloadCode(txt, fn); acts.appendChild(dl);
                 if (lang==='html') { const rn = document.createElement('button'); rn.textContent='Run HTML'; rn.className='run-html-button action-button'; rn.title="Run HTML"; rn.onclick=()=>openHtmlRunner(txt); acts.appendChild(rn); }
             }); if (!acts.hasChildNodes() && acts.parentNode) acts.remove();
        }

        function copyCodeFromPre(preId, btn) {
             const pre = document.getElementById(preId); const code = pre ? pre.querySelector('code') : null; if (!code) { console.error(`Code element missing for ${preId}`); if (btn) btn.textContent='Err'; return; }
             const txt = code.textContent || ''; if (!copyHelper) { console.error("Copy helper missing."); if (btn) btn.textContent='Err'; return; } copyHelper.value = txt; copyHelper.select(); copyHelper.setSelectionRange(0, 99999); let ok = false; try { ok = document.execCommand('copy'); } catch (e) { ok = false; } window.getSelection()?.removeAllRanges();
             if (btn) { if (ok) { btn.textContent = 'Copied!'; btn.classList.add('copied'); setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 1500); } else { btn.textContent = 'Failed!'; setTimeout(() => { btn.textContent = 'Copy'; }, 2500); } }
        }

        function downloadCode(codeText, filename) { try { const b = new Blob([codeText], { type: 'text/plain;charset=utf-8' }); const u = URL.createObjectURL(b); const a = document.createElement('a'); a.href = u; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(u); } catch (e) { console.error("Download err:", e); alert("Download failed."); } }

        function showTypingIndicator() { if (document.getElementById('typing-indicator')) return; if (!pages) { console.error("Pages missing for typing indicator."); return; } const ind = document.createElement('div'); ind.className = 'typing-indicator message message-spirit'; ind.id = 'typing-indicator'; const av = createPfpElement('spirit', botPfp); const wr = document.createElement('div'); wr.className = 'message-content-wrapper'; const cd = document.createElement('div'); cd.className = 'message-content'; cd.style.cssText = 'font-style: italic; color: var(--ink-light);'; cd.textContent = 'The spirit whispers...'; wr.appendChild(cd); ind.appendChild(av); ind.appendChild(wr); pages.appendChild(ind); scrollToBottom(); }

        function hideTypingIndicator() { const ind = document.getElementById('typing-indicator'); if (ind) ind.remove(); }

        function scrollToBottom() { if (!pages) return; setTimeout(() => { pages.scrollTop = pages.scrollHeight; }, 50); }

        function prepareHistoryForApi(hist) { if (!Array.isArray(hist)) return []; return hist.map(m => { if (!m || !m.role) return null; if (m.role === 'system') return { role: 'system', content: m.content || "" }; if (m.role === 'user') return { role: 'user', content: m.content || "" }; if (m.role === 'assistant') { const c = m.variants?.[m.selectedIndex ?? 0]; return c ? { role: 'assistant', content: c } : null; } return null; }).filter(Boolean); }

        function updateHistorySelection(turnId, newIndex) { if (!turnId) return; const idx = conversationHistory.findIndex(m => m.turnId === turnId && m.role === 'assistant'); if (idx > -1) { const msg = conversationHistory[idx]; if (msg.variants && newIndex >= 0 && newIndex < msg.variants.length) { msg.selectedIndex = newIndex; saveHistoryToLocalStorage(); } else { console.warn(`Invalid index ${newIndex} for turn ${turnId}`); } } }

        function saveHistoryToLocalStorage() { try { localStorage.setItem('conversationHistory', JSON.stringify(conversationHistory)); } catch (e) { console.error("Save history error:", e); } }

        function loadHistoryFromLocalStorage() {
             let providerOk = false; try { if (typeof PROVIDERS === 'undefined' || Object.keys(PROVIDERS).length === 0) throw new Error("PROVIDERS missing."); const sp = localStorage.getItem('selectedProvider'); selectedProvider = (sp && PROVIDERS[sp]) ? sp : (Object.keys(PROVIDERS)[0] || ''); selectedModel = localStorage.getItem('selectedModel') || ''; providerOk = true; } catch (e) { console.error("Provider init error:", e); selectedProvider = localStorage.getItem('selectedProvider') || ''; selectedModel = localStorage.getItem('selectedModel') || ''; }
             try { const sk = localStorage.getItem('apiKeys'); apiKeys = sk ? JSON.parse(sk) : {}; const si = localStorage.getItem('currentApiKeyIndex'); currentApiKeyIndex = si ? JSON.parse(si) : {}; if (typeof apiKeys !== 'object' || apiKeys === null) apiKeys = {}; if (typeof currentApiKeyIndex !== 'object' || currentApiKeyIndex === null) currentApiKeyIndex = {}; } catch (e) { console.warn("Key/Index load error:", e); apiKeys = {}; currentApiKeyIndex = {}; }
             let historyOk = false; try { const sh = localStorage.getItem('conversationHistory'); if (!sh) throw new Error('No history'); const ph = JSON.parse(sh); if (!Array.isArray(ph)) throw new Error('History not array'); if (ph.length > 0 && ph[0]?.role !== 'system') { const sys = localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT; ph.unshift({ role: 'system', content: sys }); } else if (ph.length === 0) { const sys = localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT; ph.push({ role: 'system', content: sys }); }
                 conversationHistory = ph.map(m => { if (m && m.role === 'assistant') { const v = Array.isArray(m.variants) ? m.variants : (m.content ? [m.content] : []); let s = m.selectedIndex ?? 0; if (!Number.isInteger(s) || s < 0 || s >= v.length) s = 0; return { ...m, variants: v, selectedIndex: s, content: undefined }; } return m; }).filter(Boolean);
                 const lt = conversationHistory.slice().reverse().find(m => m.turnId?.startsWith('turn-')); turnCounter = lt?.turnId ? (parseInt(lt.turnId.split('-')[1], 10) || 0) + 1 : 1; historyOk = true; console.log(`History loaded. Next turn: ${turnCounter}`); }
             catch (e) { console.warn("History load error:", e); const sys = localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT; conversationHistory = [{ role: 'system', content: sys }]; turnCounter = 1; }
             return providerOk && historyOk;
        }

        function rebuildChatFromHistory() { if (!pages) return; pages.innerHTML = ''; for (let i = 1; i < conversationHistory.length; i++) { const e = conversationHistory[i]; if (e.role === 'user') displayMessage(e, 'user'); else if (e.role === 'assistant') displayBotMessage(e, 'spirit'); } scrollToBottom(); }

        function displayInitialGreeting() { if (!pages) return; if (conversationHistory.length <= 1) { const g = "The ancient tome awaits..."; const e = { role: 'assistant', variants: [g], selectedIndex: 0, turnId: 'turn-0' }; displayBotMessage(e, 'spirit'); turnCounter = Math.max(turnCounter, 1); } }

        // --- Initial Load Function ---
        function initialLoad() {
            console.log("InitialLoad started.");
            if (typeof PROVIDERS === 'undefined') { console.error("FATAL: PROVIDERS missing."); alert("Error: PROVIDERS definitions missing."); return; }
            if (typeof getApiResponse !== 'function') { console.error("FATAL: getApiResponse missing."); alert("Error: API function missing."); return; }

            loadHistoryFromLocalStorage();
            populateProviderSelect();
            updateApiKeyStatus(selectedProvider);

            hideCodeBlocks = localStorage.getItem('hideCodeBlocks') === 'true';
            downloadCodeMode = localStorage.getItem('downloadCodeMode') === 'true';
            enableRunHtmlMode = localStorage.getItem('enableRunHtmlMode') === 'true';
            if (chatContainerElement) { chatContainerElement.classList.toggle('code-hidden', hideCodeBlocks); chatContainerElement.classList.toggle('download-code-active', downloadCodeMode); chatContainerElement.classList.toggle('run-html-active', enableRunHtmlMode); }
            if (hideCodeCheckbox) hideCodeCheckbox.checked = hideCodeBlocks; if (downloadCodeCheckbox) downloadCodeCheckbox.checked = downloadCodeMode; if (enableRunHtmlCheckbox) enableRunHtmlCheckbox.checked = enableRunHtmlMode;

            if (sendButton) sendButton.disabled = !hasSelectedProviderApiKeys();
            rebuildChatFromHistory();
            displayInitialGreeting();
            console.log("Arcane Tome Initialized.");
        }

        // --- Event Listeners (Attached Globally AFTER functions defined) ---
        if (sendButton) sendButton.addEventListener('click', handleSendMessage); else console.error("sendButton missing");
        if (messageInput) { messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } }); messageInput.addEventListener('input', autoGrowTextarea); } else console.error("messageInput missing");
        if (settingsButton) settingsButton.addEventListener('click', openSystemPromptModal); else console.error("settingsButton missing");
        if (providerSelect) providerSelect.addEventListener('change', handleProviderChange); else console.error("providerSelect missing");
        if (modelSelect) modelSelect.addEventListener('change', handleModelChange); else console.error("modelSelect missing");
        if (addKeyButton) addKeyButton.addEventListener('click', addApiKey); else console.error("addKeyButton missing");
        if (clearKeysButton) clearKeysButton.addEventListener('click', clearApiKeysForProvider); else console.error("clearKeysButton missing");
        if (saveSettingsButton) saveSettingsButton.addEventListener('click', saveSettings); else console.error("saveSettingsButton missing");
        if (cancelSettingsButton) cancelSettingsButton.addEventListener('click', () => { if (systemPromptModal) systemPromptModal.style.display = 'none'; }); else console.error("cancelSettingsButton missing");
        if (systemPromptModal) systemPromptModal.addEventListener('click', (e) => { if (e.target === systemPromptModal) systemPromptModal.style.display = 'none'; }); else console.error("systemPromptModal missing");
        if (hideCodeCheckbox) hideCodeCheckbox.addEventListener('change', handleHideCodeToggle); else console.error("hideCodeCheckbox missing");
        if (downloadCodeCheckbox) downloadCodeCheckbox.addEventListener('change', handleDownloadCodeToggle); else console.error("downloadCodeCheckbox missing");
        if (enableRunHtmlCheckbox) enableRunHtmlCheckbox.addEventListener('change', handleEnableRunHtmlToggle); else console.error("enableRunHtmlCheckbox missing");
        if (editCodeButton) editCodeButton.addEventListener('click', openEditCodeModal); else console.error("editCodeButton missing"); // Check this
        if (sendEditRequestButton) sendEditRequestButton.addEventListener('click', handleSendEditRequest); else console.error("sendEditRequestButton missing");
        if (cancelEditRequestButton) cancelEditRequestButton.addEventListener('click', () => { if (codeEditModal) codeEditModal.style.display = 'none'; }); else console.error("cancelEditRequestButton missing");
        if (codeEditModal) codeEditModal.addEventListener('click', (e) => { if (e.target === codeEditModal) codeEditModal.style.display = 'none'; }); else console.error("codeEditModal missing");
        if (editSnippetTextarea) editSnippetTextarea.addEventListener('input', updateSnippetLineCount); else console.error("editSnippetTextarea missing");
        if (editAddIteratorButton) editAddIteratorButton.addEventListener('click', () => insertIteratorPlaceholder(editInstructionsInput)); else console.error("editAddIteratorButton missing");
        if (htmlRunnerRenderButton) htmlRunnerRenderButton.addEventListener('click', renderRunnerHTML); else console.error("htmlRunnerRenderButton missing");
        if (htmlRunnerCloseButton) htmlRunnerCloseButton.addEventListener('click', () => { if (htmlRunnerModal) htmlRunnerModal.style.display = 'none'; }); else console.error("htmlRunnerCloseButton missing");
        if (htmlRunnerModal) htmlRunnerModal.addEventListener('click', (e) => { if (e.target === htmlRunnerModal) htmlRunnerModal.style.display = 'none'; }); else console.error("htmlRunnerModal missing");
        if (clearChatButton) clearChatButton.addEventListener('click', handleClearChat); else console.error("clearChatButton missing"); // Check this
        if (addIteratorButton) addIteratorButton.addEventListener('click', () => insertIteratorPlaceholder(messageInput)); else console.error("addIteratorButton missing"); // Check this
        if (uploadFileButton) uploadFileButton.addEventListener('click', () => { if (fileUploadInput) fileUploadInput.click(); }); else console.error("uploadFileButton missing");
        if (pfpUploadInput) pfpUploadInput.addEventListener('change', function(event) { const f=event.target.files[0];if(!f||!currentPfpElementToUpdate)return;const r=new FileReader();r.onload=function(e){const u=e.target.result;currentPfpElementToUpdate.src=u;const t=currentPfpElementToUpdate.closest('.avatar').dataset.senderType; if(t==='user'){userPfp=u;localStorage.setItem('userPfp',u);document.querySelectorAll('.avatar.user-avatar img').forEach(i=>i.src=u);}else if(t==='spirit'){botPfp=u;localStorage.setItem('botPfp',u);document.querySelectorAll('.avatar.spirit-avatar img').forEach(i=>i.src=u);}currentPfpElementToUpdate=null;};r.readAsDataURL(f); }); else console.error("pfpUploadInput missing");


        // --- Start the application ---
        document.addEventListener('DOMContentLoaded', initialLoad);

    </script>
</body>
</html>
