<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcane Tome (Provider Enhanced - Fixed)</title>
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=Georgia&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- API Provider Definitions (MUST be before main script) -->
    <script src="api_providers.js"></script>

    <style>
        /* --- Arcane Tome Base Styles (Mostly Unchanged) --- */
        :root { /* ... same color variables ... */
             --parchment: #f5e7d0; --parchment-dark: #e3d5b8; --ink: #3a3129; --ink-light: #5a4e42; --gold: #c9a227; --crimson: #8b0000; --sapphire: #1e3a8a; --amethyst: #6b21a8; --emerald: #21a853; --shadow-light: 0 1px 3px rgba(0,0,0,0.15); --code-bg: #e8e0cf; --code-border: #d1c3a9;
        }
        html, body { height: 100%; margin: 0; padding: 0; }
        * { box-sizing: border-box; }
        body { font-family: Georgia,'Times New Roman',Times,serif; font-size: 1.1rem; line-height: 1.6; background-color: var(--parchment); color: var(--ink); width: 100vw; overflow: hidden; }
        .tome { width: 100%; height: 100%; display: flex; flex-direction: column; position: relative; background-color: var(--parchment); }
        .pages { flex: 1; min-height: 0; padding: 20px; overflow-y: auto; scrollbar-width: none; display: flex; flex-direction: column; gap: 15px; border-bottom: 2px solid var(--ink-light); }
        .pages::-webkit-scrollbar { display: none; }
        .message { display: flex; gap: 10px; max-width: 85%; animation: fadeIn 0.5s ease-in-out;}
        .message-user { align-self: flex-end; flex-direction: row-reverse; }
        .message-spirit { align-self: flex-start; }
        .avatar { width: 45px; height: 45px; border-radius: 50%; flex-shrink: 0; border: 2px solid var(--parchment-dark); box-shadow: var(--shadow-light); display: flex; align-items: center; justify-content: center; overflow: hidden; background-color: var(--parchment-dark); cursor: pointer; }
        .avatar img { width: 100%; height: 100%; object-fit: cover; }
        .user-avatar { background-color: var(--sapphire); }
        .spirit-avatar { background-color: var(--amethyst); }
        .message-content-wrapper { display: flex; flex-direction: column; max-width: 100%; }
        .message-content { padding: 12px 18px; border-radius: 8px; line-height: 1.5; word-break: break-word; box-shadow: var(--shadow-light); max-width: fit-content; }
        .message-user .message-content { background-color: var(--sapphire); color: white; border-top-right-radius: 0; }
        .message-spirit .message-content { background-color: white; color: var(--ink); border: 1px solid var(--ink-light); border-top-left-radius: 0; }
        .message-content p { margin: 0 0 0.5em 0; } .message-content p:last-child { margin-bottom: 0; }
        .typing-indicator { align-self: flex-start; color: var(--ink-light); font-style: italic; padding: 10px 15px; background-color: rgba(227,213,184,0.5); border-radius: 8px; font-size: 1rem; }
        .writing-area { padding: 12px; background-color: var(--parchment-dark); display: flex; flex-wrap: wrap; gap: 8px; align-items: flex-end; flex-shrink: 0; }
        .message-input { flex: 1 1 250px; padding: 10px; background-color: var(--parchment); border: 2px solid var(--ink-light); border-radius: 5px; font-family: inherit; font-size: 1.1rem; resize: none; outline: none; color: var(--ink); min-height: 48px; max-height: 150px; line-height: 1.5; }
        .message-input:focus { border-color: var(--gold); }
        .writing-controls { display: flex; align-items: flex-end; gap: 8px; flex-wrap: nowrap; margin-left: auto; }
        .footer-button { background-color: var(--ink-light); color: var(--parchment); border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; padding: 8px 10px; font-size: 0.9em; flex-shrink: 0; white-space: nowrap; height: 48px; font-family: Georgia,serif; display:flex; align-items:center; justify-content:center; }
        .footer-button:hover { background-color: var(--ink); }
        #settings-button { background-color: var(--gold); color: var(--ink); font-size: 1.2em; padding: 0 12px; }
        #settings-button:hover { background-color: var(--crimson); color: white; }
        #clear-chat-button { background-color: var(--crimson); color: white;}
        #clear-chat-button:hover { background-color: darkred; }
        #upload-file-button { font-size: 1.1em; padding: 0 12px; }
        .response-count-input { width: 45px; padding: 10px; border: 2px solid var(--ink-light); border-radius: 5px; text-align: center; flex-shrink: 0; height: 48px; font-size: 1rem; background-color: var(--parchment); color: var(--ink); }
        .send-button { background-color: var(--gold); color: var(--ink); border: none; border-radius: 5px; padding: 0 18px; height: 48px; font-family: 'Cinzel Decorative',cursive; font-weight: bold; cursor: pointer; box-shadow: var(--shadow-light); display: flex; align-items: center; gap: 8px; font-size: 1.1rem; transition: background-color 0.2s ease; flex-shrink: 0; }
        .send-button:hover:not(:disabled) { background-color: var(--crimson); color: white; }
        .send-button:disabled { opacity: 0.7; cursor: not-allowed; background-color: var(--ink-light); color: var(--parchment); }
        .response-navigation { display: flex; align-items: center; justify-content: flex-start; margin-top: 5px; gap: 5px; width: fit-content; }
        .response-navigation button { background-color: var(--parchment-dark); border: 1px solid var(--ink-light); color: var(--ink); border-radius: 4px; padding: 2px 6px; cursor: pointer; font-size: 0.9em; line-height: 1; }
        .response-navigation button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #ccc; }
        .response-navigation span { font-size: 0.8em; color: var(--ink-light); margin: 0 5px; user-select: none; }
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(58,49,41,0.7); justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--parchment); border: 3px solid var(--gold); color: var(--ink); padding: 25px; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.4); max-height: 90vh; width: 90%; display: flex; flex-direction: column; overflow-y: auto; }
        .modal-content h3 { font-family: 'Cinzel Decorative',cursive; margin-top: 0; text-align: center; color: var(--ink); border-bottom: 1px solid var(--gold); padding-bottom: 10px; margin-bottom: 20px; flex-shrink: 0; }
        .modal-content .form-group { margin-bottom: 15px; display: flex; flex-wrap: wrap; align-items: center; gap: 8px 15px; flex-shrink: 0; }
        .modal-content label { display: block; margin-bottom: 5px; font-weight: bold; color: var(--ink-light); flex-basis: 100%; }
        .modal-content input[type="checkbox"] { cursor: pointer; margin-right: 5px; flex-shrink: 0; }
        .modal-content label[for*="checkbox"] { flex-basis: auto; margin-bottom: 0; font-weight: normal; }
        .modal-content input[type="password"], .modal-content textarea, .modal-content input[type="number"], .modal-content select { width: 100%; padding: 10px; border: 1px solid var(--ink-light); border-radius: 4px; outline: none; box-sizing: border-box; background-color: white; color: var(--ink); font-family: Georgia,serif; font-size: 1rem; }
        .modal-content select { cursor: pointer; height: 44px; padding: 0 10px;}
        .modal-content textarea { resize: vertical; min-height: 80px; }
        .modal-content .modal-buttons { margin-top: 20px; text-align: right; display: flex; justify-content: flex-end; gap: 10px; flex-shrink: 0; border-top: 1px solid var(--gold); padding-top: 15px; }
        .modal-content button { background-color: var(--gold); color: var(--ink); border: none; padding: 10px 18px; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; font-family: 'Cinzel Decorative',cursive; font-weight: bold; }
        .modal-content button:hover { background-color: var(--crimson); color: white; }
        .modal-content button.cancel-button { background-color: var(--ink-light); color: var(--parchment); }
        .modal-content button.cancel-button:hover { background-color: var(--ink); }
        .provider-selector { display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; align-items: flex-end; }
        .provider-selector > div { flex: 1; min-width: 150px; }
        .api-key-manager { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-top: 5px; }
        .api-key-manager input[type="password"] { flex-grow: 1; min-width: 200px; }
        .api-key-manager button { padding: 8px 12px; font-size: 0.9em; height: 44px; flex-shrink: 0; }
        .api-key-status { font-size: 0.9em; color: var(--ink-light); margin-top: 5px; flex-basis: 100%; }
        #clear-keys-button { background-color: var(--crimson); color: white; margin-left: auto; }
        #clear-keys-button:hover { background-color: darkred; }
        #code-edit-modal .modal-content { max-width: 650px; }
        #edit-snippet-textarea { font-family: Consolas, Monaco, monospace; min-height: 150px; max-height: 40vh; flex-grow: 1; flex-shrink: 1; overflow-y: auto; margin-bottom: 5px; background-color: white; }
        .modal-content .line-inputs { display: flex; gap: 15px; align-items: center; margin-bottom: 10px; flex-shrink: 0; flex-wrap: wrap; }
        .modal-content .line-inputs div { flex-grow: 1; min-width: 80px; }
        .modal-content .line-inputs input[type="number"] { width: 100%; padding: 8px; }
        #edit-snippet-counter { font-size: 0.9em; color: var(--ink-light); text-align: right; margin-bottom: 15px; flex-shrink: 0; flex-basis: 100%; }
        #edit-snippet-line-count { font-weight: bold; color: var(--ink); }
        .edit-context-note { font-style: italic; color: var(--ink-light); font-size: 0.85em; margin-bottom: 15px; flex-shrink: 0; border-top: 1px dashed var(--ink-light); padding-top: 10px; margin-top: 5px; }
        .edit-instructions-area { flex-shrink: 0; margin-bottom: 15px; }
        .edit-instructions-controls { display: flex; gap: 8px; align-items: center; margin-top: 5px; }
        #edit-instructions { width: 100%; min-height: 60px; max-height: 25vh; resize: vertical; background-color: white; }
        .modal-content .small-button { padding: 4px 8px; font-size: 0.8em; height: auto; background-color: var(--ink-light); color: var(--parchment); border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s ease; font-family: Georgia,serif; flex-shrink: 0; }
        .modal-content .small-button:hover { background-color: var(--ink); }
        #edit-response-count { width: 40px; padding: 6px; font-size: 0.9rem; height: auto; border: 1px solid var(--ink-light); margin-left: auto; background-color: white; }
        #html-runner-modal .modal-content { max-width: 90vw; width: 85%; }
        .html-runner-container { display: flex; flex-grow: 1; gap: 15px; min-height: 0; margin-bottom: 15px; }
        .runner-editor, .runner-preview { flex: 1; display: flex; flex-direction: column; border: 1px solid var(--ink-light); border-radius: 5px; background-color: var(--parchment-dark); overflow: hidden; }
        .runner-header { margin: 0; padding: 8px 12px; background-color: var(--ink-light); color: var(--parchment); border-bottom: 1px solid var(--ink); font-size: 0.9em; font-weight: bold; flex-shrink: 0; text-align: center; }
        #html-runner-input { flex: 1; border: none; padding: 10px; font-family: Consolas, Monaco, monospace; font-size: 0.9em; resize: none; outline: none; background-color: white; color: var(--ink); }
        #html-runner-frame { flex: 1; border: none; width: 100%; height: 100%; background-color: white; }
        #html-runner-modal .modal-buttons button { padding: 8px 15px; }
        .message-content pre { border: 1px solid var(--code-border); background-color: var(--code-bg); position: relative; margin-top: 10px; margin-bottom: 5px; }
        .message-content pre code.hljs { display: block; overflow-x: auto; padding: 1em; background: transparent; color: var(--ink); border-radius: 5px; }
        .hljs-comment, .hljs-quote { color: #7a7061; font-style: italic; }
        .hljs-keyword, .hljs-selector-tag, .hljs-subst { color: var(--crimson); font-weight: bold; }
        .hljs-number, .hljs-literal, .hljs-variable, .hljs-template-variable, .hljs-tag .hljs-attr { color: var(--sapphire); }
        .hljs-string, .hljs-doctag { color: #4b8350; }
        .hljs-title, .hljs-section, .hljs-selector-id { color: var(--gold); font-weight: bold; }
        .message-content code:not(.hljs) { background-color: var(--code-bg); border: 1px solid var(--code-border); padding: 0.2em 0.4em; border-radius: 3px; font-size: 85%; font-family: Consolas, Monaco, monospace; }
        .cat-placeholder { display: none; font-size: 1.2em; cursor: default; user-select: none; padding: 2px 5px; background-color: var(--parchment-dark); border-radius: 3px; border: 1px solid var(--ink-light); margin-right: 5px; margin-bottom: 3px; }
        .message-actions { margin-top: 8px; text-align: left; display: flex; gap: 5px; flex-wrap: wrap; }
        .action-button { background-color: var(--ink-light); color: var(--parchment); border: none; padding: 4px 8px; font-size: 0.8em; border-radius: 4px; cursor: pointer; opacity: 0.9; transition: opacity 0.2s ease, background-color 0.2s ease; font-family: Georgia,serif; }
        .action-button:hover { opacity: 1; background-color: var(--ink); }
        .copy-code-button.copied { background-color: #3a9a41; color: white; }
        .download-code-button { background-color: #17a2b8; }
        .download-code-button:hover { background-color: #138496; }
        .run-html-button { background-color: var(--emerald); }
        .run-html-button:hover { background-color: darkgreen; }
        .tome.code-hidden .message pre { display: none; }
        .tome.code-hidden .message .cat-placeholder { display: inline-block; }
        .download-code-button { display: none; }
        .tome.download-code-active .download-code-button { display: inline-block; }
        .run-html-button { display: none; }
        .tome.run-html-active .run-html-button { display: inline-block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @media (max-width: 768px) { /* ... (responsive styles mostly unchanged) ... */
            body { font-size: 1rem; } .pages { padding: 15px; } .message { max-width: 95%; } .message-content { padding: 10px 15px; } .writing-area { padding: 10px; flex-direction: column; align-items: stretch; } .message-input { flex-basis: 100%; margin-right: 0; } .writing-controls { width: 100%; justify-content: space-between; margin-left: 0; margin-top: 8px; flex-wrap: wrap; } .footer-button { font-size: 0.8em; padding: 6px 8px; height: 40px; margin-bottom: 5px; } .response-count-input { height: 40px; margin-bottom: 5px; } .send-button { height: 45px; padding: 0 15px; font-size: 1rem; flex-grow: 1; margin-top: 5px;} .avatar { width: 40px; height: 40px; } .modal-content { padding: 15px; width: 95%; } .modal-content .form-group { flex-direction: column; align-items: flex-start; } .modal-content .form-group > div { width: auto; margin-bottom: 5px; } .provider-selector { flex-direction: column; align-items: stretch; gap: 10px; } .api-key-manager { gap: 5px; } .api-key-manager button { font-size: 0.85em; padding: 6px 10px; height: 40px;} .api-key-manager input[type="password"] { height: 40px; } #clear-keys-button { margin-left: 0; width: 100%; margin-top: 5px; } .modal-content .line-inputs { flex-direction: column; align-items: stretch; gap: 10px; } .modal-content .line-inputs input[type="number"] { width: 100%; } .edit-instructions-controls { flex-wrap: wrap; } #edit-response-count { margin-left: 0; margin-top: 5px;} .html-runner-container { flex-direction: column; } .runner-editor, .runner-preview { min-height: 35vh; } #html-runner-modal .modal-content { max-width: 95vw; }
         }
        .visually-hidden { position: absolute !important; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px); white-space: nowrap; }
    </style>
</head>
<body>
    <!-- Arcane Tome Structure -->
    <div class="tome" id="chat-container">
        <div class="pages" id="pages"></div>
        <div class="writing-area">
            <textarea class="message-input" id="message-input" placeholder="Inscribe thy query..." rows="1"></textarea>
            <div class="writing-controls">
                 <button id="settings-button" class="footer-button" title="Settings"> <i class="fas fa-cog"></i> </button>
                 <button id="upload-file-button" class="footer-button" title="Attach Parchment (No logic yet)"> <i class="fas fa-paperclip"></i> </button>
                 <button id="add-iterator-button" class="footer-button" title="Insert {i}">Add {i}</button>
                 <button id="clear-chat-button" class="footer-button" title="Clear Scroll">Clear</button>
                 <button id="edit-code-button" class="footer-button" title="Edit Snippet">Edit</button>
                 <input type="number" class="response-count-input" id="main-response-count" value="1" min="0" max="5" title="Responses (0 to send no query)">
                 <button class="send-button" id="send-button" title="Send Query"> <span>Send</span> <span>✒</span> </button>
            </div>
        </div>
    </div>

     <!-- Settings Modal -->
    <div class="modal-overlay" id="system-prompt-modal">
         <div class="modal-content">
             <h3>Tome Settings</h3>
             <div class="provider-selector form-group">
                 <div> <label for="provider-select">Spirit Provider:</label> <select id="provider-select"></select> </div>
                 <div> <label for="model-select">Spirit Model:</label> <select id="model-select"></select> </div>
             </div>
             <div class="form-group">
                 <label for="api-key-input">Add Spirit Essence (API Key) for <span id="selected-provider-label">Provider</span>:</label>
                 <div class="api-key-manager">
                      <input type="password" id="api-key-input" placeholder="Paste new key...">
                      <button id="add-key-button" title="Add this key to the list for the selected provider">Add Key</button>
                      <button id="clear-keys-button" title="Remove all stored keys for the selected provider">Clear Keys for Provider</button>
                 </div>
                 <span id="api-key-status" class="api-key-status">Keys Loaded: 0</span>
             </div>
             <div class="form-group">
                 <label for="system-prompt-input">Spirit's Nature (System Prompt):</label>
                 <textarea id="system-prompt-input" placeholder="Define the spirit's core nature..."></textarea>
             </div>
             <div class="form-group">
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="hide-code-checkbox"> <label for="hide-code-checkbox">Veil Glyphs</label> </div>
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="download-code-checkbox"> <label for="download-code-checkbox">Enable Download</label> </div>
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="enable-run-html-checkbox"> <label for="enable-run-html-checkbox">Enable Run HTML</label> </div>
             </div>
             <div class="modal-buttons">
                <button id="cancel-settings" class="cancel-button">Cancel</button>
                <button id="save-settings-button">Seal Settings</button>
             </div>
         </div>
    </div>

    <!-- Code Edit Modal -->
    <div class="modal-overlay" id="code-edit-modal">
        <div class="modal-content">
            <h3>Transcribe & Alter Glyphs</h3>
            <p style="font-size: 0.9em; color: var(--ink-light); margin-bottom: 10px; flex-shrink: 0;">Inscribe the glyphs below. Select lines for alteration.</p>
            <textarea id="edit-snippet-textarea" placeholder="Place glyphs here..."></textarea>
            <p class="edit-context-note"> Only the selected lines are sent. Context should be included in previous messages. </p>
            <div class="line-inputs">
                 <div> <label for="edit-start-line">Start Line:</label> <input type="number" id="edit-start-line" min="1" value="1"> </div>
                 <div> <label for="edit-end-line">End Line:</label> <input type="number" id="edit-end-line" min="1" value="1"> </div>
                 <div id="edit-snippet-counter" style="margin-left: auto;"> Lines: <span id="edit-snippet-line-count">0</span> </div>
            </div>
            <div class="edit-instructions-area">
                <label for="edit-instructions">Instructions for Spirit (applies to selected lines):</label>
                <textarea id="edit-instructions" rows="3" placeholder="e.g., Reforge these lines, mend the flaw..."></textarea>
                <div class="edit-instructions-controls">
                    <button id="edit-add-iterator-button" class="small-button" title="Insert {i}">Add {i}</button>
                    <label for="edit-response-count" style="margin-left: auto; flex-basis: auto; margin-bottom: 0; font-weight: normal; color: var(--ink-light); font-size: 0.9em;">Variations:</label>
                    <input type="number" class="response-count-input" id="edit-response-count" value="1" min="1" max="5" title="Number of edit variations">
                </div>
            </div>
            <div class="modal-buttons">
                <button id="cancel-edit-request" class="cancel-button">Cancel</button>
                <button id="send-edit-request">Request Alteration</button>
            </div>
        </div>
    </div>

    <!-- HTML Runner Modal -->
    <div class="modal-overlay" id="html-runner-modal">
        <div class="modal-content">
            <h3>HTML Runner</h3>
            <div class="html-runner-container">
                 <div class="runner-editor"> <div class="runner-header">HTML Input</div> <textarea id="html-runner-input" placeholder="Paste HTML code here..."></textarea> </div>
                 <div class="runner-preview"> <div class="runner-header">Preview</div> <iframe id="html-runner-frame" title="HTML Output Preview" sandbox="allow-scripts allow-same-origin"></iframe> </div>
            </div>
             <div class="modal-buttons">
                 <button id="html-runner-render-button">Render</button>
                 <button id="html-runner-close-button" class="cancel-button">Close</button>
             </div>
        </div>
    </div>

    <!-- Hidden Helpers -->
    <textarea class="visually-hidden" id="copy-helper" aria-hidden="true"></textarea>
    <input type="file" id="file-upload-input" accept="*/*" style="display:none;">
    <input type="file" class="pfp-upload" accept="image/*" style="display:none;">


    <script>
        // --- Global State & Constants ---
        let conversationHistory = [];
        let userPfp = localStorage.getItem('userPfp') || 'https://ui-avatars.com/api/?name=U&background=1e3a8a&color=fff&font-size=0.6&bold=true';
        let botPfp = localStorage.getItem('botPfp') || 'https://ui-avatars.com/api/?name=S&background=6b21a8&color=fff&font-size=0.6&bold=true';
        let currentPfpElementToUpdate = null;
        let turnCounter = 0;
        const iterationPlaceholder = '{i}';
        const DEFAULT_SYSTEM_PROMPT = 'You are a mystical spirit from another realm...'; // Shortened for brevity

        // --- Provider/Key State (Initialized in initialLoad) ---
        let selectedProvider = '';
        let selectedModel = '';
        let apiKeys = {}; // { providerName: ['key1', 'key2'], ... }
        let currentApiKeyIndex = {}; // { providerName: index, ... }

        // --- Other State ---
        let hideCodeBlocks = true; // Default values set in initialLoad from localStorage
        let downloadCodeMode = false;
        let enableRunHtmlMode = false;
        let isWaitingForResponse = false;

        // --- DOM Elements ---
        // (Define all element variables here as before)
        const chatContainerElement = document.getElementById('chat-container');
        const pages = document.getElementById('pages');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const mainResponseCountInput = document.getElementById('main-response-count');
        const pfpUploadInput = document.querySelector('.pfp-upload');
        // Settings Modal
        const settingsButton = document.getElementById('settings-button');
        const systemPromptModal = document.getElementById('system-prompt-modal');
        const providerSelect = document.getElementById('provider-select');
        const modelSelect = document.getElementById('model-select');
        const selectedProviderLabel = document.getElementById('selected-provider-label');
        const systemPromptInput = document.getElementById('system-prompt-input');
        const apiKeyInput = document.getElementById('api-key-input');
        const addKeyButton = document.getElementById('add-key-button');
        const clearKeysButton = document.getElementById('clear-keys-button');
        const apiKeyStatus = document.getElementById('api-key-status');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const hideCodeCheckbox = document.getElementById('hide-code-checkbox');
        const downloadCodeCheckbox = document.getElementById('download-code-checkbox');
        const enableRunHtmlCheckbox = document.getElementById('enable-run-html-checkbox');
        const cancelSettingsButton = document.getElementById('cancel-settings');
        // Code Edit Modal
        const editCodeButton = document.getElementById('edit-code-button'); // *** PROBLEM BUTTON ELEMENT ***
        const codeEditModal = document.getElementById('code-edit-modal');
        const editSnippetTextarea = document.getElementById('edit-snippet-textarea');
        const editStartLineInput = document.getElementById('edit-start-line');
        const editEndLineInput = document.getElementById('edit-end-line');
        const editSnippetLineCount = document.getElementById('edit-snippet-line-count');
        const editInstructionsInput = document.getElementById('edit-instructions');
        const editAddIteratorButton = document.getElementById('edit-add-iterator-button');
        const editResponseCountInput = document.getElementById('edit-response-count');
        const sendEditRequestButton = document.getElementById('send-edit-request');
        const cancelEditRequestButton = document.getElementById('cancel-edit-request');
        // HTML Runner Modal
        const htmlRunnerModal = document.getElementById('html-runner-modal');
        const htmlRunnerInput = document.getElementById('html-runner-input');
        const htmlRunnerFrame = document.getElementById('html-runner-frame');
        const htmlRunnerRenderButton = document.getElementById('html-runner-render-button');
        const htmlRunnerCloseButton = document.getElementById('html-runner-close-button');
        // Other Controls
        const clearChatButton = document.getElementById('clear-chat-button'); // *** PROBLEM BUTTON ELEMENT ***
        const addIteratorButton = document.getElementById('add-iterator-button'); // *** PROBLEM BUTTON ELEMENT ***
        const uploadFileButton = document.getElementById('upload-file-button');
        const fileUploadInput = document.getElementById('file-upload-input');
        // Helpers
        const copyHelper = document.getElementById('copy-helper');

        // --- Configure Markdown & Highlighting ---
        marked.setOptions({ highlight:function(c,l){const lang=hljs.getLanguage(l)?l:'plaintext';try{return hljs.highlight(c,{language:lang,ignoreIllegals:true}).value;}catch(e){return hljs.highlight(c,{language:'plaintext',ignoreIllegals:true}).value;}},langPrefix:'hljs language-',gfm:true,breaks:true });

        // --- PFP Handling (Listener moved to attachEventListeners) ---
        // function handlePfpChange(event) { ... } // Define the handler if needed separately

        // --- Event Listener Attachment Function ---
        function attachEventListeners() {
            console.log("Attaching event listeners...");

            // --- PFP Handling ---
             if (pfpUploadInput) {
                 pfpUploadInput.addEventListener('change', function(event) {
                     const f=event.target.files[0];
                     if(!f||!currentPfpElementToUpdate) return;
                     const r=new FileReader();
                     r.onload=function(e){
                        const u=e.target.result;
                        currentPfpElementToUpdate.src=u;
                        const t=currentPfpElementToUpdate.closest('.avatar').dataset.senderType;
                        if(t==='user'){userPfp=u;localStorage.setItem('userPfp',u);document.querySelectorAll('.avatar.user-avatar img').forEach(i=>i.src=u);}
                        else if(t==='spirit'){botPfp=u;localStorage.setItem('botPfp',u);document.querySelectorAll('.avatar.spirit-avatar img').forEach(i=>i.src=u);}
                        currentPfpElementToUpdate=null;
                     };
                     r.readAsDataURL(f);
                 });
             } else {
                 console.error("pfpUploadInput element not found!");
             }

            // --- Main Controls ---
            if (sendButton) sendButton.addEventListener('click', handleSendMessage);
            else console.error("sendButton element not found!");

            if (messageInput) {
                messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } });
                messageInput.addEventListener('input', autoGrowTextarea);
            } else { console.error("messageInput element not found!"); }

            if (settingsButton) settingsButton.addEventListener('click', openSystemPromptModal);
            else console.error("settingsButton element not found!");

            // --- Settings Modal ---
            if (providerSelect) providerSelect.addEventListener('change', handleProviderChange);
            else console.error("providerSelect element not found!");

            if (modelSelect) modelSelect.addEventListener('change', handleModelChange);
            else console.error("modelSelect element not found!");

            if (addKeyButton) addKeyButton.addEventListener('click', addApiKey);
            else console.error("addKeyButton element not found!");

            if (clearKeysButton) clearKeysButton.addEventListener('click', clearApiKeysForProvider);
            else console.error("clearKeysButton element not found!");

            if (saveSettingsButton) saveSettingsButton.addEventListener('click', saveSettings);
            else console.error("saveSettingsButton element not found!");

            if (cancelSettingsButton) cancelSettingsButton.addEventListener('click', () => systemPromptModal.style.display = 'none');
            else console.error("cancelSettingsButton element not found!");

            if (systemPromptModal) systemPromptModal.addEventListener('click', (e) => { if (e.target === systemPromptModal) { systemPromptModal.style.display = 'none'; } });
            else console.error("systemPromptModal element not found!");

            if (hideCodeCheckbox) hideCodeCheckbox.addEventListener('change', handleHideCodeToggle);
            else console.error("hideCodeCheckbox element not found!");

            if (downloadCodeCheckbox) downloadCodeCheckbox.addEventListener('change', handleDownloadCodeToggle);
            else console.error("downloadCodeCheckbox element not found!");

            if (enableRunHtmlCheckbox) enableRunHtmlCheckbox.addEventListener('change', handleEnableRunHtmlToggle);
             else console.error("enableRunHtmlCheckbox element not found!");


            // --- Code Edit Modal ---
            if (editCodeButton) { // *** FIX: Attach listener here ***
                editCodeButton.addEventListener('click', openEditCodeModal);
                console.log("Listener attached to editCodeButton"); // Debug log
            } else { console.error("editCodeButton element not found!"); }

            if (sendEditRequestButton) sendEditRequestButton.addEventListener('click', handleSendEditRequest);
            else console.error("sendEditRequestButton element not found!");

            if (cancelEditRequestButton) cancelEditRequestButton.addEventListener('click', () => codeEditModal.style.display = 'none');
            else console.error("cancelEditRequestButton element not found!");

            if (codeEditModal) codeEditModal.addEventListener('click', (e) => { if (e.target === codeEditModal) { codeEditModal.style.display = 'none'; } });
            else console.error("codeEditModal element not found!");

            if (editSnippetTextarea) editSnippetTextarea.addEventListener('input', updateSnippetLineCount);
            else console.error("editSnippetTextarea element not found!");

            if (editAddIteratorButton) editAddIteratorButton.addEventListener('click', () => insertIteratorPlaceholder(editInstructionsInput));
            else console.error("editAddIteratorButton element not found!");


            // --- HTML Runner Modal ---
            if (htmlRunnerRenderButton) htmlRunnerRenderButton.addEventListener('click', renderRunnerHTML);
            else console.error("htmlRunnerRenderButton element not found!");

            if (htmlRunnerCloseButton) htmlRunnerCloseButton.addEventListener('click', () => htmlRunnerModal.style.display = 'none');
            else console.error("htmlRunnerCloseButton element not found!");

            if (htmlRunnerModal) htmlRunnerModal.addEventListener('click', (e) => { if (e.target === htmlRunnerModal) { htmlRunnerModal.style.display = 'none'; } });
            else console.error("htmlRunnerModal element not found!");


            // --- Other Controls ---
            if (clearChatButton) { // *** FIX: Attach listener here ***
                clearChatButton.addEventListener('click', handleClearChat);
                 console.log("Listener attached to clearChatButton"); // Debug log
            } else { console.error("clearChatButton element not found!"); }

            if (addIteratorButton) { // *** FIX: Attach listener here ***
                 addIteratorButton.addEventListener('click', () => insertIteratorPlaceholder(messageInput));
                 console.log("Listener attached to addIteratorButton"); // Debug log
            } else { console.error("addIteratorButton element not found!"); }

            if (uploadFileButton) uploadFileButton.addEventListener('click', () => {
                 if (fileUploadInput) fileUploadInput.click();
                 else console.error("fileUploadInput element not found for triggering click!");
            });
            else console.error("uploadFileButton element not found!");

            // Note: The fileUploadInput 'change' listener would also go here if needed

            console.log("Event listeners attachment finished.");
        }

        // --- API Key Management Functions (Provider Specific) ---
        function updateApiKeyStatus(provider = selectedProvider) {
            // Ensure provider key exists in apiKeys before accessing length
            const keysForProvider = apiKeys[provider] || [];
            const count = keysForProvider.length;
            if (apiKeyStatus) { // Check if element exists
                 apiKeyStatus.textContent = `Keys Loaded: ${count}`;
            }
             if(selectedProviderLabel && PROVIDERS) { // Check if elements exist
                 selectedProviderLabel.textContent = (PROVIDERS[provider]?.name || provider) ?? 'Unknown Provider';
             } else if (selectedProviderLabel) {
                 selectedProviderLabel.textContent = provider || 'Unknown Provider'; // Fallback if PROVIDERS is missing
             }
            // Disable send button if selected provider has no keys (and button exists)
            if (sendButton) {
                 sendButton.disabled = !hasSelectedProviderApiKeys() || isWaitingForResponse;
            }
        }

        function addApiKey() {
             const provider = selectedProvider;
             if (!provider) { alert("Please select a provider first."); return; }
             if (typeof PROVIDERS === 'undefined' || !PROVIDERS[provider]) { alert(`Invalid provider selected or PROVIDERS missing: ${provider}`); return; } // Check provider validity and PROVIDERS object

             const providerConfig = PROVIDERS[provider];
             const newKey = apiKeyInput.value.trim();

            // Check if the provider requires API keys from the client
            if (providerConfig.apiKeyLocation === 'none' && providerConfig.format !== 'proxy_compatible') {
                 alert(`${providerConfig.name} does not require client-side API keys.`);
                 apiKeyInput.value = '';
                 return;
            }

            if (newKey) {
                 if (!apiKeys[provider]) { apiKeys[provider] = []; }
                if (!apiKeys[provider].includes(newKey)) {
                    apiKeys[provider].push(newKey);
                    apiKeyInput.value = '';
                    updateApiKeyStatus(provider);
                    console.log(`Added key for ${provider}. Total keys for provider: ${apiKeys[provider].length}`);
                } else {
                     alert(`This API key is already in the list for ${providerConfig.name}.`);
                }
            } else {
                 alert("Please paste an API key before adding.");
            }
        }

        function clearApiKeysForProvider() {
            const provider = selectedProvider;
             if (!provider) { alert("Please select a provider first."); return; }
             if (typeof PROVIDERS === 'undefined' || !PROVIDERS[provider]) { alert(`Please select a valid provider first or PROVIDERS missing.`); return; }
             const providerName = PROVIDERS[provider]?.name || provider;

            if (confirm(`Are you sure you want to remove ALL keys for ${providerName}?`)) {
                apiKeys[provider] = [];
                currentApiKeyIndex[provider] = 0;
                updateApiKeyStatus(provider);
                console.log(`Cleared all API keys for ${provider}.`);
                 // Immediately save this change
                try {
                     localStorage.setItem('apiKeys', JSON.stringify(apiKeys));
                     localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex));
                } catch (e) { console.error("Failed to save cleared API keys/indices:", e); }
            }
        }

        function getNextApiKey(provider) {
            if (typeof PROVIDERS === 'undefined' || !PROVIDERS[provider]) {
                 console.error(`Provider config missing for ${provider} in getNextApiKey`);
                 return null;
             }
             const keysForProvider = apiKeys[provider] || [];
             const providerConfig = PROVIDERS[provider];

             // Return null immediately if the provider doesn't need a key sent from here
             if (providerConfig.apiKeyLocation === 'none' && providerConfig.format !== 'proxy_compatible') {
                  console.log(`Provider ${provider} does not use client-side keys.`);
                  return null;
             }

            if (keysForProvider.length === 0) {
                 // Only log error if keys are actually required
                if (!(providerConfig.apiKeyLocation === 'none' && providerConfig.format !== 'proxy_compatible')) {
                    console.error(`No API keys available for provider: ${provider}`);
                 }
                return null; // Explicitly return null if no keys for this provider
            }

            let index = currentApiKeyIndex[provider] || 0;
            if (index >= keysForProvider.length) { index = 0; }
            const keyToUse = keysForProvider[index];
            currentApiKeyIndex[provider] = (index + 1) % keysForProvider.length; // Rotate index

            // Save the updated index state
            try { localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex)); }
            catch (e) { console.warn("Could not save API key index object:", e); }
            return keyToUse;
        }

        function hasSelectedProviderApiKeys() {
             // Check if PROVIDERS exists first
             if (typeof PROVIDERS === 'undefined') {
                 console.error("PROVIDERS object not available in hasSelectedProviderApiKeys.");
                 return false; // Cannot determine if keys are needed or present
             }
            const providerConfig = PROVIDERS[selectedProvider];
            if (!providerConfig) return false; // Invalid provider selected
            // Check if the provider *requires* keys first
            if (providerConfig.apiKeyLocation === 'none' && providerConfig.format !== 'proxy_compatible') {
                 return true; // No keys needed, so effectively "has keys"
            }
             // Otherwise, check if keys actually exist for this provider
             const keysForCurrent = apiKeys[selectedProvider] || [];
             return keysForCurrent.length > 0;
        }


        // --- Core Functions (Modified for Provider/Model Selection & API Call) ---
        async function handleSendMessage() {
            if (!hasSelectedProviderApiKeys()) {
                const providerName = (typeof PROVIDERS !== 'undefined' && PROVIDERS[selectedProvider]?.name)
                                     ? PROVIDERS[selectedProvider].name
                                     : selectedProvider || "the selected provider";
                 alert(`No API Key loaded for ${providerName}. Please add one in Settings (unless this provider doesn't require one).`);
                 return;
            }
            if (isWaitingForResponse) return;

            const userInput = messageInput.value.trim();
            const responseCount = parseInt(mainResponseCountInput.value, 10);
            if (userInput === '') return;
            const numResponses = isNaN(responseCount) || responseCount < 0 ? 0 : Math.min(responseCount, 5);
            const turnId = `turn-${turnCounter++}`;
            const containsPlaceholder = userInput.includes(iterationPlaceholder);

            isWaitingForResponse = true;
            if (sendButton) sendButton.disabled = true;
            messageInput.value = '';
            autoGrowTextarea(); // Adjust height after clearing

            const userEntry = { role: 'user', content: userInput, turnId: turnId };
            conversationHistory.push(userEntry);
            displayMessage(userEntry, 'user');
            saveHistoryToLocalStorage();
            scrollToBottom();

            if (numResponses > 0) {
                showTypingIndicator();
                const baseHistory = prepareHistoryForApi(conversationHistory);
                const responses = [];
                let errorOccurred = false;
                const provider = selectedProvider; // Capture current selections
                const model = selectedModel;

                console.log(`Sending ${numResponses} requests to ${provider} (${model})`);

                for (let i = 0; i < numResponses; i++) {
                    const iteration = i + 1;
                    const currentKey = getNextApiKey(provider); // Rotate key for this provider

                    // Basic check before calling getApiResponse
                    if (typeof PROVIDERS === 'undefined') {
                         responses.push(`[Config Error: PROVIDERS object missing]`); errorOccurred = true; break;
                    }
                    const providerConfigCheck = PROVIDERS[provider];
                    if (!providerConfigCheck) { responses.push(`[Config Error: Provider '${provider}' missing]`); errorOccurred = true; break; }
                    // Check if required key is missing (getApiResponse also checks)
                    if (providerConfigCheck.apiKeyLocation !== 'none' && providerConfigCheck.format !== 'proxy_compatible' && !currentKey) {
                        responses.push(`[Config Error: No Key for ${provider}]`); errorOccurred = true; break;
                    }

                    let currentHistory = [...baseHistory]; // Use base history for each call
                    if (containsPlaceholder && numResponses > 1) {
                        // Find the *last* user message in the prepared history to substitute
                        const userMessageIndex = currentHistory.findLastIndex(m => m.role === 'user');
                         if (userMessageIndex > -1) {
                            const substitutedContent = currentHistory[userMessageIndex].content.replace( new RegExp(iterationPlaceholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g'), iteration.toString() );
                            currentHistory[userMessageIndex] = { ...currentHistory[userMessageIndex], content: substitutedContent };
                            console.log(`Substituted placeholder for iteration ${iteration} in message index ${userMessageIndex}`);
                         } else {
                            console.warn("Could not find user message in history to substitute placeholder.");
                         }
                    }

                    try {
                        // Call the central API function (assuming getApiResponse is defined in api_providers.js or similar)
                        // Make sure getApiResponse is globally accessible or imported correctly
                        if (typeof getApiResponse !== 'function') {
                             throw new Error("getApiResponse function is not defined or accessible.");
                        }
                        const messageContent = await getApiResponse(
                            provider, model, currentHistory, currentKey,
                            { temperature: 0.7, top_p: 0.9 } // Example parameters
                        );
                        responses.push(messageContent || "[Silence]");
                    } catch (e) {
                        console.error(`API Call Error (Provider: ${provider}, Model: ${model}, Iteration: ${iteration}):`, e);
                        responses.push(`[Spirit Disturbance: ${e instanceof Error ? e.message : String(e)}]`);
                        errorOccurred = true;
                         // Optionally break the loop on error? Or continue trying? Current: Continue.
                    }
                } // end for loop

                hideTypingIndicator();

                if (responses.length > 0) {
                    const botEntry = { role: 'assistant', variants: responses, selectedIndex: 0, turnId: turnId };
                    conversationHistory.push(botEntry);
                    saveHistoryToLocalStorage();
                    displayBotMessage(botEntry, 'spirit');
                    scrollToBottom();
                }
            } else {
                console.log("Query added to history, 0 responses requested.");
            }

            isWaitingForResponse = false;
            // Re-enable button based on key availability, only if the button element exists
            if (sendButton) sendButton.disabled = !hasSelectedProviderApiKeys();
            messageInput.focus();
        }

        async function handleSendEditRequest() {
             if (!hasSelectedProviderApiKeys()) {
                 const providerName = (typeof PROVIDERS !== 'undefined' && PROVIDERS[selectedProvider]?.name) ? PROVIDERS[selectedProvider].name : (selectedProvider || "the selected provider");
                 alert(`No API Key loaded for ${providerName}. Please add one in Settings.`);
                 return;
             }
             if (isWaitingForResponse) return;

             const pastedCode = editSnippetTextarea.value;
             const startLine = parseInt(editStartLineInput.value, 10);
             const endLine = parseInt(editEndLineInput.value, 10);
             const instructions = editInstructionsInput.value.trim();
             const numVariations = parseInt(editResponseCountInput.value, 10);
             const pastedLines = pastedCode.split('\n');
             const totalLines = pastedLines.length;

             // --- Input Validation ---
             if (pastedCode.trim() === '') { alert("Please inscribe the glyphs to be altered in the text area."); editSnippetTextarea.focus(); return; }
             if (!instructions) { alert("Instructions for the spirit are required."); editInstructionsInput.focus(); return; }
             if (isNaN(startLine) || isNaN(endLine) || startLine < 1 || endLine < startLine || endLine > totalLines) {
                  alert(`Invalid line selection. Start must be >= 1, End must be >= Start, and End must be <= Total Lines (${totalLines}).`);
                  editStartLineInput.focus(); return;
             }
             const numResponses = isNaN(numVariations) || numVariations < 1 ? 1 : Math.min(numVariations, 5);
             const containsPlaceholder = instructions.includes(iterationPlaceholder);

             // --- UI Updates ---
             codeEditModal.style.display = 'none';
             isWaitingForResponse = true;
             if (sendButton) sendButton.disabled = true; // Disable main send button too

             // --- Prepare and Display User Request Stub ---
             const turnId = `turn-${turnCounter++}`;
             // Display a summary of the request, not the full code/instructions maybe?
             const userRequestSummary = `[Glyph Alteration Request: Lines ${startLine}-${endLine}, ${numResponses} variation(s)]`;
             const userEntry = { role: 'user', content: userRequestSummary, turnId: turnId };
             conversationHistory.push(userEntry);
             displayMessage(userEntry, 'user');
             saveHistoryToLocalStorage();
             scrollToBottom();
             showTypingIndicator();

             // --- Prepare API Call ---
             const startIndex = startLine - 1; // 0-based index
             const endIndex = endLine; // slice excludes end index
             const snippetToAlter = pastedLines.slice(startIndex, endIndex).join('\n');
             const historyUpToEdit = conversationHistory.slice(0, -1); // History *before* this edit request
             const baseApiHistory = prepareHistoryForApi(historyUpToEdit);
             const editResponses = []; // To store the *full* reconstructed code for each variation
             let errorOccurred = false;
             const provider = selectedProvider; // Capture current selections
             const model = selectedModel;

             console.log(`Sending ${numResponses} EDIT requests to ${provider} (${model}) for lines ${startLine}-${endLine}`);

             for (let i = 0; i < numResponses; i++) {
                 const iteration = i + 1;
                 const currentKey = getNextApiKey(provider); // Rotate key

                 // Basic checks
                 if (typeof PROVIDERS === 'undefined') { editResponses.push(`--- ERROR: PROVIDERS missing ---`); errorOccurred = true; break; }
                 const providerConfigCheck = PROVIDERS[provider];
                 if (!providerConfigCheck) { editResponses.push(`--- ERROR: Provider '${provider}' missing ---`); errorOccurred = true; break; }
                 if (providerConfigCheck.apiKeyLocation !== 'none' && providerConfigCheck.format !== 'proxy_compatible' && !currentKey) {
                     editResponses.push(`--- ERROR: No Key for ${provider} ---`); errorOccurred = true; break;
                 }

                 let currentInstructions = instructions;
                 if (containsPlaceholder && numResponses > 1) {
                     currentInstructions = instructions.replace( new RegExp(iterationPlaceholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g'), iteration.toString() );
                 }

                 // Construct the prompt specifically for the edit task
                 // TODO: Refine this prompt - might need more context or clearer instructions depending on the model
                 const prompt = `You are tasked with editing a code snippet.
 Context from previous conversation may be relevant.
 You MUST ONLY return the modified lines based on the instructions provided.
 Do NOT include the original line numbers.
 Do NOT add explanations or apologies unless the instructions ask for them.
 Do NOT wrap the result in markdown code blocks unless the original snippet was inside one.

 Original lines ${startLine} to ${endLine}:
 \`\`\`
 ${snippetToAlter}
 \`\`\`

 Instructions for alteration: ${currentInstructions}

 Return ONLY the altered lines corresponding to the original lines ${startLine}-${endLine}.`;


                 // Use the history *before* the edit request + the specific edit prompt
                 let apiHistoryForThisCall = [...baseApiHistory, { role: 'user', content: prompt }];

                 try {
                      if (typeof getApiResponse !== 'function') { throw new Error("getApiResponse function is not defined."); }
                      const rawResponse = await getApiResponse(
                          provider, model, apiHistoryForThisCall, currentKey,
                          { temperature: 0.5, top_p: 0.9 } // Potentially lower temp for edits
                      );

                      // Process the response: Assume it returns *only* the edited lines
                      const editedLines = (rawResponse || "").split('\n'); // Handle null/empty response

                      // Reconstruct the full code snippet
                      const reconstructedLines = [
                          ...pastedLines.slice(0, startIndex), // Lines before edit
                          ...editedLines, // The edited lines returned by the API
                          ...pastedLines.slice(endIndex) // Lines after edit
                      ];
                      editResponses.push(reconstructedLines.join('\n'));

                 } catch (e) {
                     console.error(`Edit Request API Error (Provider: ${provider}, Model: ${model}, Variation ${iteration}):`, e);
                     // Construct an error message embedded in the original snippet
                     const errorMarker = `--- ERROR Altering Variation ${iteration} ---\n${e instanceof Error ? e.message : String(e)}\n--- ORIGINAL LINES ${startLine}-${endLine} WERE ---`;
                     const reconstructedLines = [
                         ...pastedLines.slice(0, startIndex),
                         errorMarker,
                         ...pastedLines.slice(startIndex, endIndex), // Show original lines on error
                         ...pastedLines.slice(endIndex)
                     ];
                     editResponses.push(reconstructedLines.join('\n'));
                     errorOccurred = true;
                      // Continue to next variation?
                 }
             } // end for loop

             hideTypingIndicator();

             // --- Display Bot Response ---
             // Use the array of *full reconstructed code snippets* as variants
             const botEntry = {
                 role: 'assistant',
                 variants: editResponses.length > 0 ? editResponses : ["[Edit Failed: No responses generated]"],
                 selectedIndex: 0,
                 turnId: turnId,
                 isCodeEdit: true // Optional flag to indicate this was an edit result
             };
             conversationHistory.push(botEntry);
             saveHistoryToLocalStorage();
             displayBotMessage(botEntry, 'spirit');

             // --- Reset UI State ---
             isWaitingForResponse = false;
             if (sendButton) sendButton.disabled = !hasSelectedProviderApiKeys(); // Re-enable based on keys
             scrollToBottom();
             messageInput.focus(); // Focus main input after edit
        }

        // --- Provider/Model Selection Handlers ---
        function populateProviderSelect() {
            if (!providerSelect) { console.error("providerSelect element missing, cannot populate."); return; }
            providerSelect.innerHTML = '';
            if (typeof PROVIDERS === 'undefined' || Object.keys(PROVIDERS).length === 0) {
                 console.error("PROVIDERS object not found or empty. Check api_providers.js");
                 providerSelect.innerHTML = '<option value="" disabled>Error loading providers</option>';
                 // Disable model select too
                 if (modelSelect) modelSelect.innerHTML = '<option value="" disabled>N/A</option>';
                 selectedProvider = '';
                 selectedModel = '';
                 return; // Stop if providers aren't loaded
            }
            for (const providerKey in PROVIDERS) {
                const option = document.createElement('option');
                option.value = providerKey;
                option.textContent = PROVIDERS[providerKey].name || providerKey; // Use defined name or key
                providerSelect.appendChild(option);
            }
            // Ensure selectedProvider is valid, otherwise default to first
            if (!PROVIDERS[selectedProvider]) {
                 selectedProvider = Object.keys(PROVIDERS)[0] || ''; // Default to first key or empty if none
                 localStorage.setItem('selectedProvider', selectedProvider);
            }
            providerSelect.value = selectedProvider; // Set dropdown value
            populateModelSelect(selectedProvider); // Populate models for the initial/selected provider
        }

        function populateModelSelect(providerKey) {
            if (!modelSelect) { console.error("modelSelect element missing, cannot populate."); return; }
            modelSelect.innerHTML = '';
            // Handle case where PROVIDERS might be missing or the specific key
            if (typeof PROVIDERS === 'undefined' || !providerKey || !PROVIDERS[providerKey]) {
                 modelSelect.innerHTML = '<option value="" disabled>Select Provider</option>';
                 selectedModel = ''; localStorage.setItem('selectedModel', ''); // Clear model state
                 return;
            }

            const providerConf = PROVIDERS[providerKey];
            if (!providerConf.availableModels || providerConf.availableModels.length === 0) {
                 modelSelect.innerHTML = '<option value="" disabled>No models listed</option>';
                 selectedModel = ''; localStorage.setItem('selectedModel', '');
                 return;
            }

            providerConf.availableModels.forEach(modelInfo => {
                 // Handle both simple strings and potential future object format { key: "...", name: "..." }
                 const modelKey = typeof modelInfo === 'string' ? modelInfo : modelInfo.key;
                 const modelName = typeof modelInfo === 'string' ? modelInfo : modelInfo.name || modelInfo.key;
                 if (!modelKey) return; // Skip invalid entries

                const option = document.createElement('option');
                option.value = modelKey;
                option.textContent = modelName;
                modelSelect.appendChild(option);
            });

            // Load saved model for this provider, or default, or first
            const savedModel = localStorage.getItem('selectedModel'); // Generic model save
             // Check if savedModel is actually *valid* for the *current* provider
             const isValidSavedModel = savedModel && providerConf.availableModels.some(m => (typeof m === 'string' ? m === savedModel : m.key === savedModel));

            if (isValidSavedModel) {
                 modelSelect.value = savedModel;
                 selectedModel = savedModel;
            } else if (providerConf.defaultModel && providerConf.availableModels.some(m => (typeof m === 'string' ? m === providerConf.defaultModel : m.key === providerConf.defaultModel))) {
                 // Check if defaultModel exists in the list
                 modelSelect.value = providerConf.defaultModel;
                 selectedModel = providerConf.defaultModel;
            } else {
                 // Default to the first model in the list if no saved/default match
                 const firstModelKey = typeof providerConf.availableModels[0] === 'string' ? providerConf.availableModels[0] : providerConf.availableModels[0]?.key;
                 if (firstModelKey) {
                      modelSelect.value = firstModelKey;
                      selectedModel = firstModelKey;
                 } else {
                      // Edge case: availableModels exists but first entry is invalid
                      modelSelect.innerHTML = '<option value="" disabled>Error: Invalid models</option>';
                      selectedModel = '';
                 }
            }
            localStorage.setItem('selectedModel', selectedModel); // Save the determined model
            console.log(`Model set to: ${selectedModel} for provider ${selectedProvider}`);
        }

        function handleProviderChange() {
            selectedProvider = providerSelect.value;
            localStorage.setItem('selectedProvider', selectedProvider);
            populateModelSelect(selectedProvider); // This now sets and saves selectedModel
            updateApiKeyStatus(selectedProvider);
            // Re-check button state based on new provider's key status
            if (sendButton) sendButton.disabled = !hasSelectedProviderApiKeys() || isWaitingForResponse;
        }

        function handleModelChange() {
             selectedModel = modelSelect.value;
             localStorage.setItem('selectedModel', selectedModel);
             console.log(`Model set to: ${selectedModel} for provider ${selectedProvider}`);
             // Model change doesn't usually affect key status, so no need to update sendButton here usually
         }

        // --- Settings Modal & Other Handlers ---
        function openSystemPromptModal() {
            console.log("openSystemPromptModal called"); // Debug log
            if (!systemPromptModal || !systemPromptInput || !hideCodeCheckbox || !downloadCodeCheckbox || !enableRunHtmlCheckbox || !apiKeyInput) {
                console.error("One or more Settings Modal elements are missing!");
                alert("Error opening settings: UI elements missing.");
                return;
            }
            systemPromptInput.value = conversationHistory[0]?.content || localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
            populateProviderSelect(); // Populates both provider and model dropdowns correctly now
            updateApiKeyStatus(selectedProvider); // Update key count display for the currently selected provider
            apiKeyInput.value = ''; // Clear the key input field
            hideCodeCheckbox.checked=hideCodeBlocks;
            downloadCodeCheckbox.checked=downloadCodeMode;
            enableRunHtmlCheckbox.checked=enableRunHtmlMode;
            systemPromptModal.style.display='flex';
            console.log("System prompt modal displayed");
         }

        function saveSettings() {
             console.log("saveSettings called");
            const sp = systemPromptInput.value.trim() || DEFAULT_SYSTEM_PROMPT;
             // Ensure system prompt is always the first message
             if (conversationHistory.length === 0 || conversationHistory[0]?.role !== 'system') {
                 conversationHistory.unshift({ role: 'system', content: sp });
             } else {
                 conversationHistory[0].content = sp;
             }
            localStorage.setItem('systemPrompt', sp);

            // Provider and Model are saved onChange, but save again here for consistency
            localStorage.setItem('selectedProvider', selectedProvider);
            localStorage.setItem('selectedModel', selectedModel);

            // Save API Keys and Indices
            try {
                localStorage.setItem('apiKeys', JSON.stringify(apiKeys));
                localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex)); // Save index too
                console.log(`Settings saved. Provider: ${selectedProvider}, Model: ${selectedModel}, Keys/Indices saved.`);
            } catch (e) { console.error("Failed to save API keys/indices:", e); alert("Error saving API keys/indices. Check browser storage limits."); }

            saveHistoryToLocalStorage(); // Save the potentially updated history (with system prompt)
            // Update button state based on potentially changed keys for the selected provider
            if (sendButton) sendButton.disabled = !hasSelectedProviderApiKeys();

            systemPromptModal.style.display = 'none'; // Close modal
        }

        function handleHideCodeToggle() { hideCodeBlocks=hideCodeCheckbox.checked;localStorage.setItem('hideCodeBlocks',String(hideCodeBlocks));chatContainerElement.classList.toggle('code-hidden',hideCodeBlocks); }
        function handleDownloadCodeToggle() { downloadCodeMode=downloadCodeCheckbox.checked;localStorage.setItem('downloadCodeMode',String(downloadCodeMode));chatContainerElement.classList.toggle('download-code-active',downloadCodeMode); }
        function handleEnableRunHtmlToggle() { enableRunHtmlMode=enableRunHtmlCheckbox.checked; localStorage.setItem('enableRunHtmlMode',String(enableRunHtmlMode)); chatContainerElement.classList.toggle('run-html-active',enableRunHtmlMode); }

        function handleClearChat() {
            console.log("handleClearChat called"); // Debug log
            if(confirm("Disperse all echoes from this scroll? (This cannot be undone)")){
                 console.log("Clear confirmed");
                 // Preserve only the system prompt
                 const currentSystemPrompt = conversationHistory[0]?.content || localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
                 conversationHistory=[{role:'system', content:currentSystemPrompt}];
                 turnCounter=1; // Reset turn counter
                 saveHistoryToLocalStorage();
                 rebuildChatFromHistory(); // Redraw the chat (will show only system prompt, usually hidden, or initial greeting)
                 displayInitialGreeting(); // Show the greeting message again after clearing
                 console.log("Chat cleared and initial greeting displayed.");
            } else {
                 console.log("Clear cancelled");
            }
         }

        function insertIteratorPlaceholder(targetInput) {
            console.log("insertIteratorPlaceholder called for target:", targetInput?.id); // Debug log
             if (!targetInput) {
                 console.error("Target input for iterator placeholder is null!");
                 return;
             }
             const start = targetInput.selectionStart;
             const end = targetInput.selectionEnd;
             const value = targetInput.value;
             const newValue = value.substring(0, start) + iterationPlaceholder + value.substring(end);
             targetInput.value = newValue;
             // Move cursor to after the inserted placeholder
             const newPos = start + iterationPlaceholder.length;
             targetInput.selectionStart = newPos;
             targetInput.selectionEnd = newPos;
             targetInput.focus();
             // Trigger input event for frameworks or other listeners (like autoGrowTextarea)
             targetInput.dispatchEvent(new Event('input', { bubbles: true }));
             console.log(`Iterator placeholder inserted into ${targetInput.id}`);
         }

        function autoGrowTextarea() {
             const input = messageInput; // Assuming this targets the main input
             if (!input) return;
             const maxHeightStyle = window.getComputedStyle(input).maxHeight;
             const maxHeight = parseFloat(maxHeightStyle) || 150; // Fallback if style invalid

             input.style.height = 'auto'; // Temporarily shrink to calculate scrollHeight
             const scrollHeight = input.scrollHeight;

             // Set height to scrollHeight but not exceeding maxHeight
             input.style.height = Math.min(scrollHeight, maxHeight) + 'px';

             // Show scrollbar only if content exceeds maxHeight
             input.style.overflowY = scrollHeight > maxHeight ? 'auto' : 'hidden';
         }

        function updateSnippetLineCount() {
             if (!editSnippetTextarea || !editSnippetLineCount || !editEndLineInput) return;
             const lines = editSnippetTextarea.value.split('\n');
             const count = lines.length;
             editSnippetLineCount.textContent = count;
             // Optionally update the max value of start/end line inputs
             editStartLineInput.max = count > 0 ? count : 1;
             editEndLineInput.max = count > 0 ? count : 1;
             // Prevent end line from being less than start line if start line is adjusted
             if (parseInt(editEndLineInput.value) > count) {
                 editEndLineInput.value = count;
             }
        }

        function renderRunnerHTML() {
             if (!htmlRunnerInput || !htmlRunnerFrame) { console.error("HTML Runner elements missing."); return; }
             const htmlCode = htmlRunnerInput.value;

             // Basic security check (very limited)
             if (/<script.*?>.*?window\.location.*?<\/script>/i.test(htmlCode) ||
                 /<script.*?>.*?document\.cookie.*?<\/script>/i.test(htmlCode) ||
                 /<script.*?>.*?localStorage.*?<\/script>/i.test(htmlCode) || // Added localStorage check
                 /<script.*?>.*?sessionStorage.*?<\/script>/i.test(htmlCode)) { // Added sessionStorage check
                 console.warn("Potentially harmful script detected (location, cookie, storage access). Blocking render.");
                 try {
                     const iframeDoc = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow?.document;
                     if (iframeDoc) {
                         iframeDoc.open();
                         iframeDoc.write('<html><head><title>Blocked</title></head><body style="font-family: sans-serif; padding: 20px;"><h1>Content Blocked</h1><p>Execution of potentially harmful JavaScript (like redirection, cookie, or storage access) was prevented.</p></body></html>');
                         iframeDoc.close();
                     } else { console.error("Could not access iframe document to display block message."); }
                 } catch (e) {
                     console.error("Error trying to display block message in iframe:", e);
                 }
                 return;
             }

             // Render in iframe
             try {
                 const iframeDoc = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow?.document;
                 if (iframeDoc) {
                     iframeDoc.open();
                     iframeDoc.write(htmlCode);
                     iframeDoc.close();
                     console.log("HTML rendered in runner.");
                 } else {
                     console.error("Could not access iframe document to render HTML.");
                     htmlRunnerInput.value = "Error: Could not access iframe for rendering.";
                 }
             } catch (e) {
                 console.error("Error rendering HTML in iframe:", e);
                 // Display error in the input area perhaps?
                 // htmlRunnerInput.value = `Error rendering preview:\n${e.message}`;
                 // Or display in the iframe itself
                 try {
                     const iframeDoc = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow?.document;
                     if (iframeDoc) {
                         iframeDoc.open();
                         iframeDoc.write(`<html><body><h1>Render Error</h1><pre>${e.message}</pre></body></html>`);
                         iframeDoc.close();
                     }
                 } catch (e2) { /* ignore */ }
             }
         }

        function openHtmlRunner(initialCode = '') {
             if (!htmlRunnerModal || !htmlRunnerInput) { console.error("Cannot open HTML Runner: Modal or input element missing."); return; }
             htmlRunnerInput.value = initialCode;
             renderRunnerHTML(); // Initial render when opening
             htmlRunnerModal.style.display = 'flex';
         }

        function createPfpElement(sender, pfpUrl) {
             const d=document.createElement('div');
             d.className=`avatar ${sender}-avatar`;
             d.dataset.senderType=sender; // Store type for update logic
             const i=document.createElement('img');
             i.src=pfpUrl;
             i.alt=`${sender} avatar`;
             i.onerror = () => { // Basic fallback if image fails to load
                 console.warn(`Failed to load avatar for ${sender}: ${pfpUrl}. Using default.`);
                 const fallbackUrl = sender === 'user'
                     ? 'https://ui-avatars.com/api/?name=U&background=1e3a8a&color=fff&font-size=0.6&bold=true'
                     : 'https://ui-avatars.com/api/?name=S&background=6b21a8&color=fff&font-size=0.6&bold=true';
                 i.src = fallbackUrl;
                 i.onerror = null; // Prevent infinite loop if fallback also fails
             };
             d.addEventListener('click',()=>{
                 currentPfpElementToUpdate=i; // Store the specific img element
                 if (pfpUploadInput) {
                     pfpUploadInput.click(); // Trigger the hidden file input
                 } else {
                     console.error("pfpUploadInput missing, cannot change avatar.");
                 }
             });
             d.appendChild(i);
             return d;
         }

        function displayBotMessage(entry, sender = 'spirit') {
             if (!entry || !entry.variants) {
                 console.warn("displayBotMessage called with invalid entry:", entry);
                 return; // Don't display anything if entry is bad
             }
             // Ensure variants is an array, even if it was stored differently
             const variants = Array.isArray(entry.variants) ? entry.variants : [entry.variants];
             const selectedIndex = entry.selectedIndex ?? 0;

             if (variants.length > 1) {
                 // Use a structure compatible with displayMultipleMessages
                 const multiEntry = { ...entry, variants: variants, selectedIndex: selectedIndex };
                 displayMultipleMessages(multiEntry, sender);
             } else if (variants.length === 1) {
                 // Use a structure compatible with displayMessage
                 const singleEntry = { ...entry, variants: variants, selectedIndex: 0 }; // Ensure selectedIndex is 0
                 displayMessage(singleEntry, sender);
             } else {
                 // Handle case of empty variants array (display silence or error?)
                 const silenceEntry = { ...entry, variants: ["[Silence]"], selectedIndex: 0 };
                 displayMessage(silenceEntry, sender);
                 console.warn("Bot entry had empty variants array, displaying [Silence]. TurnId:", entry.turnId);
             }
         }

        function displayMessage(entry, sender) {
             // Determine content based on sender and entry structure
             const content = (sender === 'user')
                 ? (entry.content || "") // User message content
                 : (entry.variants?.[entry.selectedIndex ?? 0] || "[Error: Missing Content]"); // Bot message content

             const msgDiv = document.createElement('div');
             msgDiv.className = `message message-${sender}`;
             if (entry.turnId) msgDiv.dataset.turnId = entry.turnId;

             const pfpUrl = (sender === 'user') ? userPfp : botPfp;
             const avatarEl = createPfpElement(sender, pfpUrl);

             const wrapper = document.createElement('div');
             wrapper.classList.add('message-content-wrapper');

             const contentDiv = document.createElement('div');
             contentDiv.className = 'message-content';

             if (sender === 'spirit') {
                 try {
                     // Use marked to parse markdown content for bot messages
                     contentDiv.innerHTML = marked.parse(content);
                 } catch (e) {
                     console.error("Markdown parsing error:", e, "Original content:", content);
                     // Fallback to text content if markdown parsing fails
                     contentDiv.textContent = content;
                     contentDiv.style.whiteSpace = 'pre-wrap'; // Ensure formatting is preserved somewhat
                 }
             } else {
                 // For user messages, just display text content and preserve whitespace/newlines
                 contentDiv.textContent = content;
                 contentDiv.style.whiteSpace = 'pre-wrap';
             }

             wrapper.appendChild(contentDiv);

             // Add code action buttons *after* content is added (for spirit messages)
             if (sender === 'spirit') {
                  // Pass the correct variant index
                  addCodeActionButtons(contentDiv, wrapper, entry.turnId, entry.selectedIndex ?? 0);
             }

             // Arrange avatar and content based on sender
             if (sender === 'user') {
                 msgDiv.appendChild(wrapper);
                 msgDiv.appendChild(avatarEl);
             } else {
                 msgDiv.appendChild(avatarEl);
                 msgDiv.appendChild(wrapper);
             }

             if (pages) {
                 pages.appendChild(msgDiv);
                 // Highlight code blocks after appending and parsing
                 if (sender === 'spirit') {
                     contentDiv.querySelectorAll('pre code').forEach((block) => {
                         try { hljs.highlightElement(block); }
                         catch (e) { console.warn("Highlight.js error:", e); }
                     });
                 }
             } else {
                 console.error("Pages container not found, cannot display message.");
             }


             return msgDiv; // Return the created message element
         }

        function displayMultipleMessages(entry, sender = 'spirit') {
            if (!pages) { console.error("Pages container not found."); return null; }
            if (!entry || !Array.isArray(entry.variants) || entry.variants.length === 0) {
                console.warn("Invalid entry for displayMultipleMessages:", entry);
                // Optionally display an error message instead of returning null
                return null;
            }

             const tid = entry.turnId;
             const vars = entry.variants;
             let idx = entry.selectedIndex ?? 0;
             if (idx < 0 || idx >= vars.length) idx = 0; // Sanitize index

             const msgDiv = document.createElement('div');
             msgDiv.className = `message message-${sender}`;
             if (tid) msgDiv.dataset.turnId = tid;

             const pfpUrl = (sender === 'user') ? userPfp : botPfp;
             const avatarEl = createPfpElement(sender, pfpUrl);

             const wrapper = document.createElement('div');
             wrapper.classList.add('message-content-wrapper');

             const contentDiv = document.createElement('div');
             contentDiv.className = 'message-content';

             const nav = document.createElement('div');
             nav.classList.add('response-navigation');
             const prev = document.createElement('button'); prev.textContent = '<'; prev.title = "Previous variation";
             const span = document.createElement('span'); span.title = "Current variation / Total variations";
             const next = document.createElement('button'); next.textContent = '>'; next.title = "Next variation";
             nav.appendChild(prev); nav.appendChild(span); nav.appendChild(next);

             // Action buttons container (will be populated by addCodeActionButtons)
             let actsContainer = document.createElement('div');
             actsContainer.classList.add('message-actions');

             // Structure: Content -> Actions -> Navigation
             wrapper.appendChild(contentDiv);
             wrapper.appendChild(actsContainer); // Add actions container
             wrapper.appendChild(nav);

             function update(currentIndex) {
                  const currentContent = vars[currentIndex] || "[Error: Empty Variant]";
                  try {
                      contentDiv.innerHTML = marked.parse(currentContent);
                  } catch (e) {
                      console.error("Markdown parsing error in multi-message:", e);
                      contentDiv.textContent = currentContent;
                      contentDiv.style.whiteSpace = 'pre-wrap';
                  }
                  // Re-add/update action buttons for the new content
                  addCodeActionButtons(contentDiv, wrapper, tid, currentIndex);
                  // Update navigation text and button states
                  span.textContent = `${currentIndex + 1} / ${vars.length}`;
                  prev.disabled = currentIndex === 0;
                  next.disabled = currentIndex === vars.length - 1;
                  // Re-highlight code
                  contentDiv.querySelectorAll('pre code').forEach((block) => {
                      try { hljs.highlightElement(block); }
                      catch(e) { console.warn("Highlight.js error:", e); }
                  });
                  // Trigger subtle animation for change indication
                  contentDiv.style.animation = 'none';
                  void contentDiv.offsetWidth; // Reflow trick
                  contentDiv.style.animation = 'fadeIn 0.3s ease-in-out';
             }

             prev.addEventListener('click', () => {
                 if (idx > 0) {
                      idx--;
                      update(idx);
                      updateHistorySelection(tid, idx); // Update central history state
                 }
             });
             next.addEventListener('click', () => {
                 if (idx < vars.length - 1) {
                      idx++;
                      update(idx);
                      updateHistorySelection(tid, idx); // Update central history state
                 }
             });

             if (sender === 'user') { // Should generally not happen for multi-messages, but handle anyway
                 msgDiv.appendChild(wrapper);
                 msgDiv.appendChild(avatarEl);
             } else {
                 msgDiv.appendChild(avatarEl);
                 msgDiv.appendChild(wrapper);
             }

             pages.appendChild(msgDiv);
             update(idx); // Initial display
             return msgDiv;
         }

        function addCodeActionButtons(contentDiv, wrapper, turnId, variantIndex) {
             // Find or create the actions container within the wrapper
             let actsContainer = wrapper.querySelector('.message-actions');
             if (!actsContainer) {
                 actsContainer = document.createElement('div');
                 actsContainer.classList.add('message-actions');
                 // Insert before navigation if it exists, otherwise append
                 const nav = wrapper.querySelector('.response-navigation');
                 if (nav) {
                     wrapper.insertBefore(actsContainer, nav);
                 } else {
                     wrapper.appendChild(actsContainer);
                 }
             }
             actsContainer.innerHTML = ''; // Clear previous buttons for this variant

             // Remove any old placeholders first
             contentDiv.querySelectorAll('.cat-placeholder').forEach(c => c.remove());

             const codeBlocks = contentDiv.querySelectorAll('pre'); // Find all <pre> elements
             if (codeBlocks.length === 0 && !actsContainer.hasChildNodes()) {
                 // If no code blocks AND no other actions were added, remove the empty container
                 actsContainer.remove();
                 return; // No code blocks, no actions needed
             }

             codeBlocks.forEach((pre, preIdx) => {
                 // --- Unique ID for targeting ---
                 const uniquePreId = `pre-${turnId || 'gen'}-${variantIndex}-${preIdx}`;
                 pre.id = uniquePreId; // Assign ID to the <pre> tag

                 // --- Placeholder (Cat Emoji) ---
                 const cat = document.createElement('span');
                 cat.classList.add('cat-placeholder');
                 cat.textContent = '🐱'; // The placeholder visual
                 cat.dataset.preId = uniquePreId; // Link placeholder to the pre block
                 cat.title = "Code block marker (hidden when code is shown)";
                 // Insert placeholder *before* the <pre> block
                 pre.parentNode.insertBefore(cat, pre);

                 // --- Extract Code and Language ---
                 const codeElement = pre.querySelector('code');
                 const codeText = codeElement ? codeElement.textContent : '';
                 const langMatch = codeElement?.className.match(/language-(\w+)/);
                 const lang = langMatch ? langMatch[1].toLowerCase() : 'txt'; // Normalize to lower case
                 const filename = `scroll_${turnId || 'code'}_${variantIndex + 1}_${preIdx + 1}.${lang}`;

                 // --- Copy Button ---
                 const cpBtn = document.createElement('button');
                 cpBtn.textContent = 'Copy';
                 cpBtn.title = `Copy ${lang} code snippet`;
                 cpBtn.classList.add('copy-code-button', 'action-button');
                 cpBtn.onclick = () => copyCodeFromPre(uniquePreId, cpBtn); // Pass button for feedback
                 actsContainer.appendChild(cpBtn);

                 // --- Download Button (Conditionally added based on mode) ---
                 const dlBtn = document.createElement('button');
                 dlBtn.textContent = 'Download';
                 dlBtn.title = `Download as ${filename}`;
                 dlBtn.classList.add('download-code-button', 'action-button'); // Class controls visibility via CSS
                 dlBtn.onclick = () => downloadCode(codeText, filename);
                 actsContainer.appendChild(dlBtn);

                 // --- Run HTML Button (Conditionally added based on mode and language) ---
                 if (lang === 'html') {
                     const runBtn = document.createElement('button');
                     runBtn.textContent = 'Run HTML';
                     runBtn.classList.add('run-html-button', 'action-button'); // Class controls visibility
                     runBtn.title = "Run this HTML snippet in a sandboxed preview";
                     runBtn.onclick = () => openHtmlRunner(codeText);
                     actsContainer.appendChild(runBtn);
                 }
             });

             // If after adding buttons, the container is still empty (e.g., only hidden buttons added), remove it
             if (!actsContainer.hasChildNodes() && actsContainer.parentNode) {
                  actsContainer.remove();
             }
         }

        function copyCodeFromPre(preId, btnElement) {
            const preElement = document.getElementById(preId);
            const codeElement = preElement ? preElement.querySelector('code') : null;
            if (!codeElement) {
                console.error(`Could not find code element within pre#${preId} to copy.`);
                if (btnElement) { btnElement.textContent = 'Error!'; setTimeout(() => { btnElement.textContent = 'Copy'; }, 2000); }
                return;
            }

            const codeText = codeElement.textContent || '';
             if (!copyHelper) {
                 console.error("Copy helper textarea not found.");
                 if (btnElement) { btnElement.textContent = 'Error!'; setTimeout(() => { btnElement.textContent = 'Copy'; }, 2000); }
                 return;
             }

            copyHelper.value = codeText; // Put text into hidden textarea
            copyHelper.select(); // Select the text
            copyHelper.setSelectionRange(0, 99999); // For mobile devices

            let success = false;
            try {
                success = document.execCommand('copy'); // Attempt to copy
            } catch (err) {
                console.error('Failed to copy code using execCommand:', err);
                success = false;
            }

            window.getSelection()?.removeAllRanges(); // Deselect text

            // Provide visual feedback on the button
            if (btnElement) {
                if (success) {
                    btnElement.textContent = 'Copied!';
                    btnElement.classList.add('copied');
                    setTimeout(() => {
                        btnElement.textContent = 'Copy';
                        btnElement.classList.remove('copied');
                    }, 1500); // Revert after 1.5 seconds
                } else {
                    btnElement.textContent = 'Failed!';
                    // Maybe provide alternative instructions? (e.g., manual copy)
                    setTimeout(() => { btnElement.textContent = 'Copy'; }, 2500); // Revert after 2.5 seconds
                }
            }
        }

        function downloadCode(codeText, filename) {
             try {
                 const blob = new Blob([codeText], { type: 'text/plain;charset=utf-8' });
                 const url = URL.createObjectURL(blob);
                 const link = document.createElement('a');
                 link.href = url;
                 link.download = filename;
                 document.body.appendChild(link); // Required for Firefox
                 link.click();
                 document.body.removeChild(link); // Clean up
                 URL.revokeObjectURL(url); // Free up memory
                 console.log(`Attempted download for ${filename}`);
             } catch (e) {
                 console.error("Download failed:", e);
                 alert("Download failed. See console for details.");
             }
         }

        function showTypingIndicator() {
             if (document.getElementById('typing-indicator')) return; // Already showing
             if (!pages) { console.error("Pages container not found, cannot show typing indicator."); return; }
             const indicator = document.createElement('div');
             indicator.className = 'typing-indicator message message-spirit'; // Style like a spirit message shell
             indicator.id = 'typing-indicator';
             // Add avatar and content structure similar to a message
             const pfpUrl = botPfp;
             const avatarEl = createPfpElement('spirit', pfpUrl);
             const wrapper = document.createElement('div');
             wrapper.classList.add('message-content-wrapper');
             const contentDiv = document.createElement('div');
             contentDiv.className = 'message-content'; // Reuse style slightly
             contentDiv.style.fontStyle = 'italic';
             contentDiv.style.color = 'var(--ink-light)';
             contentDiv.textContent = 'The spirit whispers...';
             wrapper.appendChild(contentDiv);
             indicator.appendChild(avatarEl);
             indicator.appendChild(wrapper);

             pages.appendChild(indicator);
             scrollToBottom();
         }

        function hideTypingIndicator() {
             const indicator = document.getElementById('typing-indicator');
             if (indicator) {
                 indicator.remove();
             }
         }

        function scrollToBottom() {
             if (!pages) return;
             // Using setTimeout allows the DOM to update before scrolling
             setTimeout(() => {
                 pages.scrollTop = pages.scrollHeight;
             }, 50); // Small delay
         }

        function prepareHistoryForApi(hist) {
            if (!Array.isArray(hist)) return [];
             // Ensure history is clean and contains only valid roles/content needed by API
             return hist
                 .map(m => {
                     if (!m || !m.role) return null; // Skip invalid entries

                     if (m.role === 'system') {
                         return { role: 'system', content: m.content || "" };
                     }
                     if (m.role === 'user') {
                         return { role: 'user', content: m.content || "" };
                     }
                     if (m.role === 'assistant') {
                         // Use the selected variant's content
                         const selectedContent = m.variants?.[m.selectedIndex ?? 0];
                         // Return null if assistant message has no valid selected content
                         return selectedContent ? { role: 'assistant', content: selectedContent } : null;
                     }
                     // Ignore other potential roles
                     return null;
                 })
                 .filter(Boolean); // Remove any null entries
         }

        function updateHistorySelection(turnId, newIndex) {
             if (!turnId) return;
             const messageIndex = conversationHistory.findIndex(m => m.turnId === turnId && m.role === 'assistant');
             if (messageIndex > -1) {
                 const message = conversationHistory[messageIndex];
                 if (message.variants && newIndex >= 0 && newIndex < message.variants.length) {
                     message.selectedIndex = newIndex;
                     console.log(`Updated selectedIndex to ${newIndex} for turnId ${turnId}`);
                     saveHistoryToLocalStorage(); // Save change immediately
                 } else {
                     console.warn(`Invalid index ${newIndex} or missing variants for turnId ${turnId}`);
                 }
             } else {
                 console.warn(`Could not find assistant message with turnId ${turnId} to update selection.`);
             }
         }

        function saveHistoryToLocalStorage() {
             try {
                 localStorage.setItem('conversationHistory', JSON.stringify(conversationHistory));
             } catch (e) {
                 console.error("Error saving conversation history to localStorage:", e);
                 // Consider notifying user if storage is full?
                 // alert("Warning: Could not save conversation history. Browser storage might be full.");
             }
         }

        // Modified loadHistoryFromLocalStorage for provider state init
        function loadHistoryFromLocalStorage() {
             let providerLoadError = false;
             // Load Provider/Model Selections First
             try {
                 // Check if PROVIDERS is available (loaded from api_providers.js)
                 if (typeof PROVIDERS === 'undefined' || Object.keys(PROVIDERS).length === 0) {
                     throw new Error("PROVIDERS definitions not loaded.");
                 }
                 const savedProvider = localStorage.getItem('selectedProvider');
                 if (savedProvider && PROVIDERS[savedProvider]) {
                     selectedProvider = savedProvider;
                 } else if (Object.keys(PROVIDERS).length > 0) {
                     selectedProvider = Object.keys(PROVIDERS)[0]; // Default to first defined provider if saved one is invalid
                 } else {
                     selectedProvider = ''; // No providers defined
                     throw new Error("No providers defined in PROVIDERS object.");
                 }
                 // Selected model will be determined when populateModelSelect is called in initialLoad
                 selectedModel = localStorage.getItem('selectedModel') || ''; // Load saved model preference (will be validated later)
             } catch (e) {
                  console.error("Error initializing provider/model state:", e);
                  providerLoadError = true;
                  // Attempt graceful fallback (though UI might be broken)
                  selectedProvider = localStorage.getItem('selectedProvider') || '';
                  selectedModel = localStorage.getItem('selectedModel') || '';
             }

             // Load Keys & Index Object
             try {
                  const storedKeys = localStorage.getItem('apiKeys');
                  apiKeys = storedKeys ? JSON.parse(storedKeys) : {};
                  const storedIndex = localStorage.getItem('currentApiKeyIndex');
                  currentApiKeyIndex = storedIndex ? JSON.parse(storedIndex) : {};

                  // Basic validation
                  if (typeof apiKeys !== 'object' || apiKeys === null || Array.isArray(apiKeys)) {
                       console.warn("Invalid apiKeys found in localStorage, resetting."); apiKeys = {};
                  }
                  if (typeof currentApiKeyIndex !== 'object' || currentApiKeyIndex === null || Array.isArray(currentApiKeyIndex)) {
                       console.warn("Invalid currentApiKeyIndex found in localStorage, resetting."); currentApiKeyIndex = {};
                  }
                  // Further validation: Ensure keys are arrays and indices are numbers (optional but good)
                  Object.keys(apiKeys).forEach(provKey => {
                      if (!Array.isArray(apiKeys[provKey])) {
                          console.warn(`API keys for provider ${provKey} were not an array, resetting for provider.`);
                          apiKeys[provKey] = [];
                          if (currentApiKeyIndex[provKey]) delete currentApiKeyIndex[provKey];
                      }
                  });
                   Object.keys(currentApiKeyIndex).forEach(provKey => {
                       if (typeof currentApiKeyIndex[provKey] !== 'number' || !Number.isInteger(currentApiKeyIndex[provKey]) || currentApiKeyIndex[provKey] < 0) {
                           console.warn(`API key index for provider ${provKey} was not a valid number, resetting index.`);
                           currentApiKeyIndex[provKey] = 0;
                       }
                   });


             } catch (e) { console.warn("Could not parse API keys/index object from localStorage:", e); apiKeys = {}; currentApiKeyIndex = {}; }

             // Load Conversation History
            let historyLoaded = false;
            try{
                const storedHistory = localStorage.getItem('conversationHistory');
                if (!storedHistory) throw new Error('No history found in localStorage.');

                const parsedHistory = JSON.parse(storedHistory);
                if (!Array.isArray(parsedHistory)) throw new Error('Stored history is not an array.');

                // Basic validation and migration for older formats
                if (parsedHistory.length > 0 && parsedHistory[0]?.role !== 'system') {
                    console.warn("History missing system prompt at the start, prepending default.");
                    const currentSystemPrompt = localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
                    parsedHistory.unshift({ role: 'system', content: currentSystemPrompt });
                } else if (parsedHistory.length === 0) {
                     console.warn("Stored history was empty, initializing with system prompt.");
                     const currentSystemPrompt = localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
                     parsedHistory.push({ role: 'system', content: currentSystemPrompt });
                }

                // Sanitize/normalize assistant messages (ensure 'variants' array and valid 'selectedIndex')
                conversationHistory = parsedHistory.map(m => {
                    if (m && m.role === 'assistant') {
                        const variants = Array.isArray(m.variants) ? m.variants : (m.content ? [m.content] : []);
                        let selectedIndex = m.selectedIndex ?? 0;
                        if (!Number.isInteger(selectedIndex) || selectedIndex < 0 || selectedIndex >= variants.length) {
                            selectedIndex = 0; // Default to 0 if invalid or out of bounds
                        }
                        // Return a clean object, potentially removing original 'content' if 'variants' exists
                        return { ...m, variants: variants, selectedIndex: selectedIndex, content: undefined };
                    }
                    return m; // Keep user and system messages as is (assuming they are valid)
                }).filter(Boolean); // Remove any potentially null entries from mapping/filtering

                // Determine next turn counter
                const lastTurnEntry = conversationHistory.slice().reverse().find(m => m.turnId && m.turnId.startsWith('turn-'));
                 if (lastTurnEntry?.turnId) {
                     const lastTurnNum = parseInt(lastTurnEntry.turnId.split('-')[1], 10);
                     turnCounter = (!isNaN(lastTurnNum) && lastTurnNum >= 0) ? lastTurnNum + 1 : 1;
                 } else {
                     turnCounter = 1; // Start from 1 if no valid turn IDs found
                 }

                historyLoaded = true;
                console.log(`History loaded successfully. Next turn: ${turnCounter}`);

            } catch(e) {
                console.warn("Failed to load or parse conversation history:", e.message);
                // Initialize with a fresh history if loading failed
                const currentSystemPrompt = localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
                conversationHistory=[{role:'system',content:currentSystemPrompt}];
                turnCounter=1;
                historyLoaded = false;
            }
            return historyLoaded; // Indicate success/failure
        }

        function rebuildChatFromHistory() {
             if (!pages) { console.error("Pages container not found, cannot rebuild chat."); return; }
             pages.innerHTML=''; // Clear existing messages
             // Iterate through history, skipping the system prompt (index 0)
             for (let i = 1; i < conversationHistory.length; i++) {
                 const entry = conversationHistory[i];
                 if (entry.role === 'user') {
                     displayMessage(entry, 'user');
                 } else if (entry.role === 'assistant') {
                     // Use displayBotMessage which handles single/multi variants correctly
                     displayBotMessage(entry, 'spirit');
                 } else {
                     console.warn("Skipping unknown role in history:", entry.role);
                 }
             }
             console.log("Chat rebuilt from history.");
             scrollToBottom(); // Scroll after rebuilding
         }

        function displayInitialGreeting() {
             if (!pages) return;
             // Check if only the system prompt exists or if history is truly empty
             if (conversationHistory.length <= 1) {
                 console.log("Displaying initial greeting.");
                 const greetingText = "The ancient tome awaits your query...";
                 // Create a bot message entry for the greeting
                 const greetingEntry = {
                     role: 'assistant',
                     variants: [greetingText], // Use variants array even for single message
                     selectedIndex: 0,
                     turnId: 'turn-0' // Special turn ID for greeting
                 };
                 // Temporarily add to history for display, but don't save if it's just a greeting
                 displayBotMessage(greetingEntry, 'spirit');
                 // Do NOT save this greeting to localStorage history unless you want it persisted
                 // If you *do* want it persisted, uncomment the next lines:
                 // if (!conversationHistory.some(m => m.turnId === 'turn-0')) {
                 //      conversationHistory.push(greetingEntry);
                 //      saveHistoryToLocalStorage();
                 // }
                 // Reset turn counter if needed (should already be 1 from loadHistory)
                 if (turnCounter < 1) turnCounter = 1;
             }
         }

        // --- Initial Load ---
        function initialLoad() {
            console.log("InitialLoad started.");

            // --- CRITICAL: Check for API Provider definitions ---
             if (typeof PROVIDERS === 'undefined') {
                 console.error("FATAL: api_providers.js failed to load or PROVIDERS object is missing.");
                 alert("Error: API Provider definitions (api_providers.js) failed to load. The application cannot function.");
                 // Optional: Display a user-friendly message in the body
                 document.body.innerHTML = `<div style="padding: 40px; text-align: center; color: var(--crimson, #8b0000); background-color: var(--parchment, #f5e7d0); height: 100vh;">
                                                <h1 style="font-family: 'Cinzel Decorative', cursive;">Initialization Failed</h1>
                                                <p style="font-family: Georgia, serif;">The necessary API provider definitions could not be loaded. Please ensure 'api_providers.js' is present and correctly loaded before the main script.</p>
                                            </div>`;
                 return; // Stop execution
             }
             if (typeof getApiResponse !== 'function') {
                 console.error("FATAL: The required getApiResponse function is not defined. Check api_providers.js or dependencies.");
                 alert("Error: Core API communication function (getApiResponse) is missing. The application cannot function.");
                  document.body.innerHTML = `<div style="padding: 40px; text-align: center; color: var(--crimson, #8b0000); background-color: var(--parchment, #f5e7d0); height: 100vh;">
                                                <h1 style="font-family: 'Cinzel Decorative', cursive;">Initialization Failed</h1>
                                                <p style="font-family: Georgia, serif;">The core API communication function is missing. Please ensure 'api_providers.js' (or equivalent) defines 'getApiResponse'.</p>
                                            </div>`;
                 return; // Stop execution
             }


            console.log("Checking element variables before attaching listeners...");
             console.log("editCodeButton exists:", !!editCodeButton); // Use !! to force boolean T/F
             console.log("clearChatButton exists:", !!clearChatButton);
             console.log("addIteratorButton exists:", !!addIteratorButton);

            // --- Attach Event Listeners ---
            // This is now done safely after DOM elements should be available
            attachEventListeners();

            // --- Load State ---
            loadHistoryFromLocalStorage(); // Loads keys, indices, provider, model pref, history

            // --- Populate UI based on loaded state ---
            populateProviderSelect(); // Sets provider dropdown and triggers model population/selection
            updateApiKeyStatus(selectedProvider); // Sets key count display based on loaded keys and provider

            // Load UI toggles state from localStorage
            hideCodeBlocks = localStorage.getItem('hideCodeBlocks') === 'true'; // Default to false if not 'true'
            downloadCodeMode = localStorage.getItem('downloadCodeMode') === 'true';
            enableRunHtmlMode = localStorage.getItem('enableRunHtmlMode') === 'true';

            // Apply UI toggle classes
            if (chatContainerElement) {
                chatContainerElement.classList.toggle('code-hidden', hideCodeBlocks);
                chatContainerElement.classList.toggle('download-code-active', downloadCodeMode);
                chatContainerElement.classList.toggle('run-html-active', enableRunHtmlMode);
            } else {
                console.error("chatContainerElement not found, cannot apply UI toggle classes.");
            }

             // Update checkbox states in settings modal to match loaded state
             if(hideCodeCheckbox) hideCodeCheckbox.checked = hideCodeBlocks;
             if(downloadCodeCheckbox) downloadCodeCheckbox.checked = downloadCodeMode;
             if(enableRunHtmlCheckbox) enableRunHtmlCheckbox.checked = enableRunHtmlMode;


            // --- Set initial button state ---
            // Ensure send button state reflects key availability for the loaded provider
            if (sendButton) {
                sendButton.disabled = !hasSelectedProviderApiKeys();
            }

            // --- Display Chat ---
            rebuildChatFromHistory();
            displayInitialGreeting(); // Show greeting if chat is empty/new
            // scrollToBottom(); // Rebuild calls scroll, greeting calls scroll

            console.log("Arcane Tome Initialized and Ready.");
        }

        // --- Start the application ---
        // Wait for the DOM to be fully loaded and parsed before running initialLoad
        document.addEventListener('DOMContentLoaded', initialLoad);

    </script>
</body>
</html>
