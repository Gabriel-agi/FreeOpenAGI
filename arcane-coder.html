<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcane Tome (Provider Enhanced - Reliable Font + Retry)</title>
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- API Provider Definitions (MUST be before main script) -->
    <script src="api_providers.js"></script>

    <style>
        /* --- Arcane Tome Base Styles --- */
        :root {
             --parchment: #f5e7d0; --parchment-dark: #e3d5b8; --ink: #3a3129; --ink-light: #5a4e42; --gold: #c9a227; --crimson: #8b0000; --sapphire: #1e3a8a; --amethyst: #6b21a8; --emerald: #21a853; --shadow-light: 0 1px 3px rgba(0,0,0,0.15); --code-bg: #e8e0cf; --code-border: #d1c3a9;
             /* Using Georgia as primary, Times New Roman as fallback/heading */
             --font-body: Georgia, 'Times New Roman', Times, serif;
             --font-heading: 'Times New Roman', Times, serif; /* Replaced Cinzel Decorative */
        }
        html, body { height: 100%; margin: 0; padding: 0; }
        * { box-sizing: border-box; }
        /* --- Body uses Georgia --- */
        body { font-family: var(--font-body); font-size: 1.1rem; line-height: 1.6; background-color: var(--parchment); color: var(--ink); width: 100vw; overflow: hidden; }
        .tome { width: 100%; height: 100%; display: flex; flex-direction: column; position: relative; background-color: var(--parchment); }
        .pages { flex: 1; min-height: 0; padding: 20px; overflow-y: auto; scrollbar-width: none; display: flex; flex-direction: column; gap: 15px; border-bottom: 2px solid var(--ink-light); }
        .pages::-webkit-scrollbar { display: none; }
        .message { display: flex; gap: 10px; max-width: 85%; animation: fadeIn 0.5s ease-in-out;}
        .message-user { align-self: flex-end; flex-direction: row-reverse; }
        .message-spirit { align-self: flex-start; }
        .avatar { width: 45px; height: 45px; border-radius: 50%; flex-shrink: 0; border: 2px solid var(--parchment-dark); box-shadow: var(--shadow-light); display: flex; align-items: center; justify-content: center; overflow: hidden; background-color: var(--parchment-dark); cursor: pointer; }
        .avatar img { width: 100%; height: 100%; object-fit: cover; }
        .user-avatar { background-color: var(--sapphire); }
        .spirit-avatar { background-color: var(--amethyst); }
        .message-content-wrapper { display: flex; flex-direction: column; max-width: 100%; }
        .message-content { padding: 12px 18px; border-radius: 8px; line-height: 1.5; word-break: break-word; box-shadow: var(--shadow-light); max-width: fit-content; }
        .message-user .message-content { background-color: var(--sapphire); color: white; border-top-right-radius: 0; }
        .message-spirit .message-content { background-color: white; color: var(--ink); border: 1px solid var(--ink-light); border-top-left-radius: 0; }
        .message-content p { margin: 0 0 0.5em 0; } .message-content p:last-child { margin-bottom: 0; }
        .typing-indicator { align-self: flex-start; color: var(--ink-light); font-style: italic; padding: 10px 15px; background-color: rgba(227,213,184,0.5); border-radius: 8px; font-size: 1rem; }
        .writing-area { padding: 12px; background-color: var(--parchment-dark); display: flex; flex-wrap: wrap; gap: 8px; align-items: flex-end; flex-shrink: 0; }
        .message-input { flex: 1 1 250px; padding: 10px; background-color: var(--parchment); border: 2px solid var(--ink-light); border-radius: 5px; font-family: inherit; font-size: 1.1rem; resize: none; outline: none; color: var(--ink); min-height: 48px; max-height: 150px; line-height: 1.5; }
        .message-input:focus { border-color: var(--gold); }
        .writing-controls { display: flex; align-items: flex-end; gap: 8px; flex-wrap: nowrap; margin-left: auto; }
        /* --- Footer buttons use Georgia --- */
        .footer-button { background-color: var(--ink-light); color: var(--parchment); border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; padding: 8px 10px; font-size: 0.9em; flex-shrink: 0; white-space: nowrap; height: 48px; font-family: var(--font-body); display:flex; align-items:center; justify-content:center; }
        .footer-button:hover { background-color: var(--ink); }
        #settings-button { background-color: var(--gold); color: var(--ink); font-size: 1.2em; padding: 0 12px; }
        #settings-button:hover { background-color: var(--crimson); color: white; }
        #clear-chat-button { background-color: var(--crimson); color: white;}
        #clear-chat-button:hover { background-color: darkred; }
        #upload-file-button { font-size: 1.1em; padding: 0 12px; }
        .response-count-input { width: 45px; padding: 10px; border: 2px solid var(--ink-light); border-radius: 5px; text-align: center; flex-shrink: 0; height: 48px; font-size: 1rem; background-color: var(--parchment); color: var(--ink); }
        /* --- Send button uses Heading Font --- */
        .send-button { background-color: var(--gold); color: var(--ink); border: none; border-radius: 5px; padding: 0 18px; height: 48px; font-family: var(--font-heading); font-weight: bold; cursor: pointer; box-shadow: var(--shadow-light); display: flex; align-items: center; gap: 8px; font-size: 1.1rem; transition: background-color 0.2s ease; flex-shrink: 0; }
        .send-button:hover:not(:disabled) { background-color: var(--crimson); color: white; }
        .send-button:disabled { opacity: 0.7; cursor: not-allowed; background-color: var(--ink-light); color: var(--parchment); }
        .response-navigation { display: flex; align-items: center; justify-content: flex-start; margin-top: 5px; gap: 5px; width: fit-content; }
        .response-navigation button { background-color: var(--parchment-dark); border: 1px solid var(--ink-light); color: var(--ink); border-radius: 4px; padding: 2px 6px; cursor: pointer; font-size: 0.9em; line-height: 1; }
        .response-navigation button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #ccc; }
        .response-navigation span { font-size: 0.8em; color: var(--ink-light); margin: 0 5px; user-select: none; }
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(58,49,41,0.7); justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--parchment); border: 3px solid var(--gold); color: var(--ink); padding: 25px; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.4); max-height: 90vh; width: 90%; display: flex; flex-direction: column; overflow-y: auto; }
        /* --- Modal Headings use Heading Font --- */
        .modal-content h3 { font-family: var(--font-heading); margin-top: 0; text-align: center; color: var(--ink); border-bottom: 1px solid var(--gold); padding-bottom: 10px; margin-bottom: 20px; flex-shrink: 0; }
        .modal-content .form-group { margin-bottom: 15px; display: flex; flex-wrap: wrap; align-items: center; gap: 8px 15px; flex-shrink: 0; }
        .modal-content label { display: block; margin-bottom: 5px; font-weight: bold; color: var(--ink-light); flex-basis: 100%; }
        .modal-content input[type="checkbox"] { cursor: pointer; margin-right: 5px; flex-shrink: 0; }
        .modal-content label[for*="checkbox"] { flex-basis: auto; margin-bottom: 0; font-weight: normal; }
        .modal-content input[type="password"], .modal-content textarea, .modal-content input[type="number"], .modal-content select { width: 100%; padding: 10px; border: 1px solid var(--ink-light); border-radius: 4px; outline: none; box-sizing: border-box; background-color: white; color: var(--ink); font-family: var(--font-body); font-size: 1rem; }
        .modal-content select { cursor: pointer; height: 44px; padding: 0 10px;}
        .modal-content textarea { resize: vertical; min-height: 80px; }
        .modal-content .modal-buttons { margin-top: 20px; text-align: right; display: flex; justify-content: flex-end; gap: 10px; flex-shrink: 0; border-top: 1px solid var(--gold); padding-top: 15px; }
        /* --- Modal Buttons use Heading Font --- */
        .modal-content button { background-color: var(--gold); color: var(--ink); border: none; padding: 10px 18px; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; font-family: var(--font-heading); font-weight: bold; }
        .modal-content button:hover { background-color: var(--crimson); color: white; }
        /* --- Specific overrides for buttons that should use body font --- */
        .modal-content button.cancel-button { font-family: var(--font-body); background-color: var(--ink-light); color: var(--parchment); }
        .modal-content button.cancel-button:hover { background-color: var(--ink); }
        .modal-content .small-button { font-family: var(--font-body); /* Ensure small buttons also use body font */ padding: 4px 8px; font-size: 0.8em; height: auto; background-color: var(--ink-light); color: var(--parchment); border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s ease; flex-shrink: 0; }
        .modal-content .small-button:hover { background-color: var(--ink); }
        /* ... rest of styles ... */
        .provider-selector { display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; align-items: flex-end; }
        .provider-selector > div { flex: 1; min-width: 150px; }
        .api-key-manager { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-top: 5px; }
        .api-key-manager input[type="password"] { flex-grow: 1; min-width: 200px; }
        .api-key-manager button { padding: 8px 12px; font-size: 0.9em; height: 44px; flex-shrink: 0; }
        .api-key-status-container { flex-basis: 100%; display: flex; justify-content: space-between; align-items: center; gap: 10px; margin-top: 5px; }
        .api-key-status { font-size: 0.9em; color: var(--ink-light); flex-grow: 1; }
        .api-call-count-display { font-size: 0.9em; color: var(--ink-light); flex-shrink: 0; }
        #reset-call-count-button { font-family: var(--font-body); background-color: var(--ink-light); color: var(--parchment); margin-left: 5px; padding: 4px 8px; font-size: 0.8em; height: auto; flex-shrink: 0; }
        #reset-call-count-button:hover { background-color: var(--ink); }
        #clear-keys-button { background-color: var(--crimson); color: white; margin-left: auto; }
        #clear-keys-button:hover { background-color: darkred; }
        .settings-group { margin-bottom: 15px; flex-shrink: 0; } /* Added for better spacing */
        #max-variations-input { width: 60px; text-align: center; margin-left: 8px; }
        #code-edit-modal .modal-content { max-width: 650px; }
        #edit-snippet-textarea { font-family: Consolas, Monaco, monospace; min-height: 150px; max-height: 40vh; flex-grow: 1; flex-shrink: 1; overflow-y: auto; margin-bottom: 5px; background-color: white; }
        .modal-content .line-inputs { display: flex; gap: 15px; align-items: center; margin-bottom: 10px; flex-shrink: 0; flex-wrap: wrap; }
        .modal-content .line-inputs div { flex-grow: 1; min-width: 80px; }
        .modal-content .line-inputs input[type="number"] { width: 100%; padding: 8px; }
        #edit-snippet-counter { font-size: 0.9em; color: var(--ink-light); text-align: right; margin-bottom: 15px; flex-shrink: 0; flex-basis: 100%; }
        #edit-snippet-line-count { font-weight: bold; color: var(--ink); }
        .edit-context-note { font-style: italic; color: var(--ink-light); font-size: 0.85em; margin-bottom: 15px; flex-shrink: 0; border-top: 1px dashed var(--ink-light); padding-top: 10px; margin-top: 5px; }
        .edit-instructions-area { flex-shrink: 0; margin-bottom: 15px; }
        .edit-instructions-controls { display: flex; gap: 8px; align-items: center; margin-top: 5px; }
        #edit-instructions { width: 100%; min-height: 60px; max-height: 25vh; resize: vertical; background-color: white; }
        #edit-add-iterator-button { margin-right: auto; }
        #edit-response-count { width: 40px; padding: 6px; font-size: 0.9rem; height: auto; border: 1px solid var(--ink-light); margin-left: auto; background-color: white; }
        #html-runner-modal .modal-content { max-width: 90vw; width: 85%; }
        .html-runner-container { display: flex; flex-grow: 1; gap: 15px; min-height: 0; margin-bottom: 15px; }
        .runner-editor, .runner-preview { flex: 1; display: flex; flex-direction: column; border: 1px solid var(--ink-light); border-radius: 5px; background-color: var(--parchment-dark); overflow: hidden; }
        .runner-header { margin: 0; padding: 8px 12px; background-color: var(--ink-light); color: var(--parchment); border-bottom: 1px solid var(--ink); font-size: 0.9em; font-weight: bold; flex-shrink: 0; text-align: center; }
        #html-runner-input { flex: 1; border: none; padding: 10px; font-family: Consolas, Monaco, monospace; font-size: 0.9em; resize: none; outline: none; background-color: white; color: var(--ink); }
        #html-runner-frame { flex: 1; border: none; width: 100%; height: 100%; background-color: white; }
        #html-runner-modal .modal-buttons button { padding: 8px 15px; }
        .message-content pre { border: 1px solid var(--code-border); background-color: var(--code-bg); position: relative; margin-top: 10px; margin-bottom: 5px; }
        .message-content pre code.hljs { display: block; overflow-x: auto; padding: 1em; background: transparent; color: var(--ink); border-radius: 5px; }
        .hljs-comment, .hljs-quote { color: #7a7061; font-style: italic; }
        .hljs-keyword, .hljs-selector-tag, .hljs-subst { color: var(--crimson); font-weight: bold; }
        .hljs-number, .hljs-literal, .hljs-variable, .hljs-template-variable, .hljs-tag .hljs-attr { color: var(--sapphire); }
        .hljs-string, .hljs-doctag { color: #4b8350; }
        .hljs-title, .hljs-section, .hljs-selector-id { color: var(--gold); font-weight: bold; }
        .message-content code:not(.hljs) { background-color: var(--code-bg); border: 1px solid var(--code-border); padding: 0.2em 0.4em; border-radius: 3px; font-size: 85%; font-family: Consolas, Monaco, monospace; }
        .cat-placeholder { display: none; font-size: 1.2em; cursor: default; user-select: none; padding: 2px 5px; background-color: var(--parchment-dark); border-radius: 3px; border: 1px solid var(--ink-light); margin-right: 5px; margin-bottom: 3px; }
        .message-actions { margin-top: 8px; text-align: left; display: flex; gap: 5px; flex-wrap: wrap; }
        .action-button { background-color: var(--ink-light); color: var(--parchment); border: none; padding: 4px 8px; font-size: 0.8em; border-radius: 4px; cursor: pointer; opacity: 0.9; transition: opacity 0.2s ease, background-color 0.2s ease; font-family: var(--font-body); } /* Use body font for actions */
        .action-button:hover { opacity: 1; background-color: var(--ink); }
        .copy-code-button.copied { background-color: #3a9a41; color: white; }
        .download-code-button { background-color: #17a2b8; }
        .download-code-button:hover { background-color: #138496; }
        .run-html-button { background-color: var(--emerald); }
        .run-html-button:hover { background-color: darkgreen; }
        .tome.code-hidden .message pre { display: none; }
        .tome.code-hidden .message .cat-placeholder { display: inline-block; }
        .download-code-button { display: none; }
        .tome.download-code-active .download-code-button { display: inline-block; }
        .run-html-button { display: none; }
        .tome.run-html-active .run-html-button { display: inline-block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @media (max-width: 768px) { /* ... (responsive styles unchanged) ... */ }
        .visually-hidden { position: absolute !important; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px); white-space: nowrap; }
    </style>
</head>
<body>
    <!-- HTML Structure -->
    <div class="tome" id="chat-container">
        <div class="pages" id="pages"></div>
        <div class="writing-area">
            <textarea class="message-input" id="message-input" placeholder="Inscribe thy query..." rows="1"></textarea>
            <div class="writing-controls">
                 <button id="settings-button" class="footer-button" title="Settings"> <i class="fas fa-cog"></i> </button>
                 <button id="upload-file-button" class="footer-button" title="Attach Parchment (No logic yet)"> <i class="fas fa-paperclip"></i> </button>
                 <button id="add-iterator-button" class="footer-button" title="Insert {i}">Add {i}</button>
                 <button id="clear-chat-button" class="footer-button" title="Clear Scroll">Clear</button>
                 <button id="edit-code-button" class="footer-button" title="Edit Snippet">Edit</button>
                 <input type="number" class="response-count-input" id="main-response-count" value="1" min="0" max="5" title="Responses (0 to send no query)">
                 <button class="send-button" id="send-button" title="Send Query"> <span>Send</span> <span>✒</span> </button>
            </div>
        </div>
    </div>
    <!-- Settings Modal -->
    <div class="modal-overlay" id="system-prompt-modal">
         <div class="modal-content">
             <h3>Tome Settings</h3>
             <div class="provider-selector form-group">
                 <div> <label for="provider-select">Spirit Provider:</label> <select id="provider-select"></select> </div>
                 <div> <label for="model-select">Spirit Model:</label> <select id="model-select"></select> </div>
             </div>
             <div class="form-group">
                 <label for="api-key-input">Add Spirit Essence (API Key) for <span id="selected-provider-label">Provider</span>:</label>
                 <div class="api-key-manager">
                      <input type="password" id="api-key-input" placeholder="Paste new key...">
                      <button id="add-key-button" title="Add this key to the list for the selected provider">Add Key</button>
                      <button id="clear-keys-button" title="Remove all stored keys for the selected provider">Clear Keys for Provider</button>
                 </div>
                 <div class="api-key-status-container">
                     <span id="api-key-status" class="api-key-status">Keys Loaded: 0</span>
                     <span id="api-call-count-display" class="api-call-count-display">Calls: 0</span>
                     <button id="reset-call-count-button" class="small-button" title="Reset call count for this provider">Reset Count</button>
                 </div>
             </div>
             <div class="form-group settings-group">
                 <label for="system-prompt-input">Spirit's Nature (System Prompt):</label>
                 <textarea id="system-prompt-input" placeholder="Define the spirit's core nature..."></textarea>
             </div>
             <div class="form-group settings-group">
                 <label for="max-variations-input" style="flex-basis: auto; margin-bottom: 0;">Max Response Variations:</label>
                 <input type="number" id="max-variations-input" min="1" max="10" value="5" class="response-count-input" style="width: 60px; height: 40px;">
             </div>
             <div class="form-group">
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="hide-code-checkbox"> <label for="hide-code-checkbox">Veil Glyphs</label> </div>
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="download-code-checkbox"> <label for="download-code-checkbox">Enable Download</label> </div>
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="enable-run-html-checkbox"> <label for="enable-run-html-checkbox">Enable Run HTML</label> </div>
             </div>
             <div class="modal-buttons">
                <button id="cancel-settings" class="cancel-button">Cancel</button>
                <button id="save-settings-button">Seal Settings</button>
             </div>
         </div>
    </div>
    <!-- Code Edit Modal -->
    <div class="modal-overlay" id="code-edit-modal">
        <div class="modal-content">
            <h3>Transcribe & Alter Glyphs</h3>
            <p style="font-size: 0.9em; color: var(--ink-light); margin-bottom: 10px; flex-shrink: 0;">Inscribe the glyphs below. Select lines for alteration.</p>
            <textarea id="edit-snippet-textarea" placeholder="Place glyphs here..."></textarea>
            <p class="edit-context-note"> Only the selected lines are sent. Context should be included in previous messages. </p>
            <div class="line-inputs">
                 <div> <label for="edit-start-line">Start Line:</label> <input type="number" id="edit-start-line" min="1" value="1"> </div>
                 <div> <label for="edit-end-line">End Line:</label> <input type="number" id="edit-end-line" min="1" value="1"> </div>
                 <div id="edit-snippet-counter" style="margin-left: auto;"> Lines: <span id="edit-snippet-line-count">0</span> </div>
            </div>
            <div class="edit-instructions-area">
                <label for="edit-instructions">Instructions for Spirit (applies to selected lines):</label>
                <textarea id="edit-instructions" rows="3" placeholder="e.g., Reforge these lines, mend the flaw..."></textarea>
                <div class="edit-instructions-controls">
                    <button id="edit-add-iterator-button" class="small-button" title="Insert {i}">Add {i}</button>
                    <label for="edit-response-count" style="margin-left: auto; flex-basis: auto; margin-bottom: 0; font-weight: normal; color: var(--ink-light); font-size: 0.9em;">Variations:</label>
                    <input type="number" class="response-count-input" id="edit-response-count" value="1" min="1" max="5"> <!-- Max updated dynamically -->
                </div>
            </div>
            <div class="modal-buttons">
                <button id="cancel-edit-request" class="cancel-button">Cancel</button>
                <button id="send-edit-request">Request Alteration</button>
            </div>
        </div>
    </div>
    <!-- HTML Runner Modal -->
    <div class="modal-overlay" id="html-runner-modal">
        <div class="modal-content">
            <h3>HTML Runner</h3>
            <div class="html-runner-container">
                 <div class="runner-editor"> <div class="runner-header">HTML Input</div> <textarea id="html-runner-input" placeholder="Paste HTML code here..."></textarea> </div>
                 <div class="runner-preview"> <div class="runner-header">Preview</div> <iframe id="html-runner-frame" title="HTML Output Preview" sandbox="allow-scripts allow-same-origin"></iframe> </div>
            </div>
             <div class="modal-buttons">
                 <button id="html-runner-render-button">Render</button>
                 <button id="html-runner-close-button" class="cancel-button">Close</button>
             </div>
        </div>
    </div>
    <!-- Hidden Helpers -->
    <textarea class="visually-hidden" id="copy-helper" aria-hidden="true"></textarea>
    <input type="file" id="file-upload-input" accept="*/*" style="display:none;">
    <input type="file" class="pfp-upload" accept="image/*" style="display:none;">

    <script>
        // --- Global State & Constants ---
        let conversationHistory = [];
        let userPfp = localStorage.getItem('userPfp') || 'https://ui-avatars.com/api/?name=U&background=1e3a8a&color=fff&font-size=0.6&bold=true';
        let botPfp = localStorage.getItem('botPfp') || 'https://ui-avatars.com/api/?name=S&background=6b21a8&color=fff&font-size=0.6&bold=true';
        let currentPfpElementToUpdate = null;
        let turnCounter = 0;
        const iterationPlaceholder = '{i}';
        const DEFAULT_SYSTEM_PROMPT = 'You are a mystical spirit from another realm...';

        // --- Provider/Key State ---
        let selectedProvider = '';
        let selectedModel = '';
        let apiKeys = {}; // Structure: { providerKey: ["key1", "key2"], ... }
        let currentApiKeyIndex = {}; // Structure: { providerKey: 0, ... }
        let apiCallCounts = {}; // Structure: { providerKey: 123, ... }

        // --- Settings State ---
        let maxResponseVariations = 5; // Default, loaded from storage
        let hideCodeBlocks = true;
        let downloadCodeMode = false;
        let enableRunHtmlMode = false;
        let isWaitingForResponse = false;

        // --- DOM Elements ---
        const chatContainerElement = document.getElementById('chat-container');
        const pages = document.getElementById('pages');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const mainResponseCountInput = document.getElementById('main-response-count');
        const pfpUploadInput = document.querySelector('.pfp-upload');
        const settingsButton = document.getElementById('settings-button');
        const systemPromptModal = document.getElementById('system-prompt-modal');
        const providerSelect = document.getElementById('provider-select');
        const modelSelect = document.getElementById('model-select');
        const selectedProviderLabel = document.getElementById('selected-provider-label');
        const systemPromptInput = document.getElementById('system-prompt-input');
        const apiKeyInput = document.getElementById('api-key-input');
        const addKeyButton = document.getElementById('add-key-button');
        const clearKeysButton = document.getElementById('clear-keys-button');
        const apiKeyStatus = document.getElementById('api-key-status');
        const apiCallCountDisplay = document.getElementById('api-call-count-display'); // New element
        const resetCallCountButton = document.getElementById('reset-call-count-button'); // New element
        const maxVariationsInput = document.getElementById('max-variations-input'); // New element
        const saveSettingsButton = document.getElementById('save-settings-button');
        const hideCodeCheckbox = document.getElementById('hide-code-checkbox');
        const downloadCodeCheckbox = document.getElementById('download-code-checkbox');
        const enableRunHtmlCheckbox = document.getElementById('enable-run-html-checkbox');
        const cancelSettingsButton = document.getElementById('cancel-settings');
        const editCodeButton = document.getElementById('edit-code-button');
        const codeEditModal = document.getElementById('code-edit-modal');
        const editSnippetTextarea = document.getElementById('edit-snippet-textarea');
        const editStartLineInput = document.getElementById('edit-start-line');
        const editEndLineInput = document.getElementById('edit-end-line');
        const editSnippetLineCount = document.getElementById('edit-snippet-line-count');
        const editInstructionsInput = document.getElementById('edit-instructions');
        const editAddIteratorButton = document.getElementById('edit-add-iterator-button');
        const editResponseCountInput = document.getElementById('edit-response-count');
        const sendEditRequestButton = document.getElementById('send-edit-request');
        const cancelEditRequestButton = document.getElementById('cancel-edit-request');
        const htmlRunnerModal = document.getElementById('html-runner-modal');
        const htmlRunnerInput = document.getElementById('html-runner-input');
        const htmlRunnerFrame = document.getElementById('html-runner-frame');
        const htmlRunnerRenderButton = document.getElementById('html-runner-render-button');
        const htmlRunnerCloseButton = document.getElementById('html-runner-close-button');
        const clearChatButton = document.getElementById('clear-chat-button');
        const addIteratorButton = document.getElementById('add-iterator-button');
        const uploadFileButton = document.getElementById('upload-file-button');
        const fileUploadInput = document.getElementById('file-upload-input');
        const copyHelper = document.getElementById('copy-helper');

        // --- Configure Markdown & Highlighting ---
        marked.setOptions({
            highlight: function(code, lang) {
                const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                try { return hljs.highlight(code, { language: language, ignoreIllegals: true }).value; }
                catch (e) { return hljs.highlight(code, { language: 'plaintext', ignoreIllegals: true }).value; }
            },
            langPrefix: 'hljs language-', gfm: true, breaks: true
        });

        // --- All Function Definitions ---

        function updateApiKeyStatus(provider = selectedProvider) {
            const keysForProvider = apiKeys[provider] || []; const keyCount = keysForProvider.length;
            const callCount = apiCallCounts[provider] || 0;
            const providerName = (typeof PROVIDERS !== 'undefined' && PROVIDERS[provider]?.name) ? PROVIDERS[provider].name : (provider || 'Unknown Provider');

            if (apiKeyStatus) { apiKeyStatus.textContent = `Keys Loaded: ${keyCount}`; }
            if (apiCallCountDisplay) { apiCallCountDisplay.textContent = `Calls: ${callCount}`; }
            if (selectedProviderLabel) { selectedProviderLabel.textContent = providerName; }

            const providerNeedsKey = doesProviderNeedApiKey(provider);
            if (sendButton) {
                 sendButton.disabled = (providerNeedsKey && keyCount === 0) || isWaitingForResponse;
            }
            if (apiKeyInput) {
                apiKeyInput.disabled = !providerNeedsKey;
                apiKeyInput.placeholder = providerNeedsKey ? "Paste new key..." : "Not Required";
            }
            if (addKeyButton) { addKeyButton.disabled = !providerNeedsKey; }
            if (clearKeysButton) { clearKeysButton.disabled = !providerNeedsKey; }
            if (resetCallCountButton) { resetCallCountButton.style.display = provider ? 'inline-block' : 'none'; }
        }

        function doesProviderNeedApiKey(provider) {
            if (!provider || typeof PROVIDERS === 'undefined' || !PROVIDERS[provider]) {
                return true; // Assume key needed if config is missing
            }
            const providerConfig = PROVIDERS[provider];
            // Needs key if location is NOT 'none', OR if it's a proxy_compatible format (which might still use keys server-side)
            return providerConfig.apiKeyLocation !== 'none' || providerConfig.format === 'proxy_compatible';
        }

        function addApiKey() {
             const provider = selectedProvider; const newKey = apiKeyInput.value.trim();
             if (!provider) { alert("Please select a provider first."); return; }
             if (typeof PROVIDERS === 'undefined' || !PROVIDERS[provider]) { alert(`Invalid provider selected or PROVIDERS missing: ${provider}`); return; }
             const providerConfig = PROVIDERS[provider];

             // Only proceed if the provider actually requires a client-side key
             if (!doesProviderNeedApiKey(provider)) {
                 alert(`${providerConfig.name} does not require client-side API keys.`);
                 apiKeyInput.value = '';
                 return;
             }

             if (newKey) {
                 if (!apiKeys[provider]) apiKeys[provider] = [];
                 if (!apiKeys[provider].includes(newKey)) {
                     apiKeys[provider].push(newKey);
                     apiKeyInput.value = '';
                     updateApiKeyStatus(provider);
                     console.log(`Added key for ${provider}. Total keys: ${apiKeys[provider].length}`);
                     try { localStorage.setItem('apiKeys', JSON.stringify(apiKeys)); }
                     catch (e) { console.error("Failed to save API keys after adding:", e); }
                 } else {
                     alert(`This API key is already in the list for ${providerConfig.name}.`);
                 }
             } else {
                 alert("Please paste an API key before adding.");
             }
        }

        function clearApiKeysForProvider() {
             const provider = selectedProvider;
             if (!provider) { alert("Please select a provider first."); return; }
             if (typeof PROVIDERS === 'undefined' || !PROVIDERS[provider]) { alert(`Please select a valid provider first or PROVIDERS missing.`); return; }
             const providerName = PROVIDERS[provider]?.name || provider;

             if (confirm(`Are you sure you want to remove ALL keys for ${providerName}?`)) {
                 apiKeys[provider] = [];
                 currentApiKeyIndex[provider] = 0; // Reset index as well
                 updateApiKeyStatus(provider);
                 console.log(`Cleared all API keys for ${provider}.`);
                 try {
                     localStorage.setItem('apiKeys', JSON.stringify(apiKeys));
                     localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex));
                 } catch (e) {
                     console.error("Failed to save cleared API keys/indices:", e);
                 }
             }
        }

        function resetApiCallCountForProvider() {
            const provider = selectedProvider;
            if (!provider) { alert("Please select a provider first."); return; }
            const providerName = (typeof PROVIDERS !== 'undefined' && PROVIDERS[provider]?.name) ? PROVIDERS[provider].name : provider;
            if (confirm(`Reset the successful API call count for ${providerName} to zero?`)) {
                apiCallCounts[provider] = 0;
                updateApiKeyStatus(provider);
                console.log(`Reset API call count for ${provider}.`);
                try {
                    localStorage.setItem('apiCallCounts', JSON.stringify(apiCallCounts));
                } catch (e) {
                    console.error("Failed to save reset API call counts:", e);
                }
            }
        }

        // THIS FUNCTION IS NO LONGER USED DIRECTLY FOR GETTING KEYS FOR API CALLS
        // It's kept for potential other uses or reference, but attemptApiCallWithRetry handles key selection now.
        /*
        function getNextApiKey(provider) {
            if (typeof PROVIDERS === 'undefined' || !PROVIDERS[provider]) { console.error(`Provider config missing for ${provider} in getNextApiKey`); return null; }
            const providerConfig = PROVIDERS[provider];
            if (!doesProviderNeedApiKey(provider)) { return null; } // No key needed

            const keysForProvider = apiKeys[provider] || [];
            if (keysForProvider.length === 0) {
                 console.error(`No API keys available for provider: ${provider}`);
                 return null;
            }

            let index = currentApiKeyIndex[provider] || 0;
            if (index >= keysForProvider.length) index = 0; // Wrap around

            const keyToUse = keysForProvider[index];
            currentApiKeyIndex[provider] = (index + 1) % keysForProvider.length; // Move to next index for the *next* logical call sequence

            try { localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex)); }
            catch (e) { console.warn("Could not save API key index object:", e); }

            return keyToUse;
        }
        */

        // NEW FUNCTION: Attempts API call, retrying with next available key on failure.
        async function attemptApiCallWithRetry(provider, model, history, options) {
            console.log(`Attempting API call to ${provider}/${model}.`);
            if (typeof PROVIDERS === 'undefined' || !PROVIDERS[provider]) {
                throw new Error(`Config Error: Provider '${provider}' missing`);
            }
            const providerConfig = PROVIDERS[provider];
            const needsKey = doesProviderNeedApiKey(provider);
            const keys = apiKeys[provider] || [];
            const numKeys = keys.length;
            let startIndex = currentApiKeyIndex[provider] || 0;
            let triedKeyIndices = new Set(); // Track indices tried *within this specific attempt sequence*

            if (needsKey && numKeys === 0) {
                throw new Error(`[Config Error: No API Key available for ${providerConfig.name}]`);
            }

            // Determine the maximum number of attempts (either 1 if no key needed, or the number of keys)
            const maxAttempts = needsKey ? numKeys : 1;

            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                let currentKey = null;
                let keyIndexToTry = -1; // -1 indicates no key is being used (e.g., provider doesn't need one)

                if (needsKey) {
                    // Calculate the index to try for this attempt, wrapping around from startIndex
                    keyIndexToTry = (startIndex + attempt) % numKeys;

                    // This check prevents infinite loops if somehow all keys were tried without success
                    // (though the loop structure `attempt < maxAttempts` should handle this)
                    if (triedKeyIndices.has(keyIndexToTry) && triedKeyIndices.size === numKeys) {
                         console.warn(`Already tried all keys for ${provider}. Aborting further retries for this call.`);
                         break; // Exit the retry loop for this specific API call
                    }

                    currentKey = keys[keyIndexToTry];
                    triedKeyIndices.add(keyIndexToTry); // Mark this index as tried *for this sequence*
                     console.log(`API Call Attempt ${attempt + 1}/${maxAttempts}. Trying key index: ${keyIndexToTry} for ${provider}`);
                } else {
                    // Provider doesn't need a client-side key
                     console.log(`API Call Attempt ${attempt + 1}/${maxAttempts} to ${provider} (no client key needed)`);
                }

                try {
                    if (typeof getApiResponse !== 'function') {
                        throw new Error("getApiResponse function is not defined.");
                    }
                    // Make the actual API call
                    const result = await getApiResponse(provider, model, history, currentKey, options);

                    // --- SUCCESS ---
                    console.log(`API Call Success on attempt ${attempt + 1} for ${provider}`);

                    // Update the *global* starting index for the *next* sequence of calls
                    if (needsKey && keyIndexToTry !== -1) {
                       currentApiKeyIndex[provider] = (keyIndexToTry + 1) % numKeys;
                       try { localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex)); } catch(e) {console.warn("Failed to save current API key index:", e);}
                    }

                    // Increment successful call counter for the provider
                    apiCallCounts[provider] = (apiCallCounts[provider] || 0) + 1;
                    try { localStorage.setItem('apiCallCounts', JSON.stringify(apiCallCounts)); } catch(e) {console.warn("Failed to save API call counts:", e);}
                    updateApiKeyStatus(provider); // Update UI counter immediately

                    return result || "[Silence]"; // Return the successful result

                } catch (error) {
                    console.warn(`API Call Error (Provider: ${provider}, Model: ${model}, Attempt: ${attempt + 1}, KeyIndex: ${keyIndexToTry}):`, error);
                    // If this was the last attempt, the error will propagate after the loop finishes
                    if (attempt === maxAttempts - 1) {
                        console.error(`All ${maxAttempts} attempts failed for ${provider}. Last error:`, error);
                        // Re-throw the last encountered error to be caught by the calling function
                        throw new Error(`[Spirit Disturbance after ${maxAttempts} attempts: ${error instanceof Error ? error.message : String(error)}]`);
                    }
                    // Otherwise, the loop will continue to the next key/attempt
                    console.log(`Retrying with next key...`);
                }
            }

            // This point should only be reached if all attempts failed.
            throw new Error(`[Spirit Communication Failed after ${maxAttempts} attempts for ${provider}]`);
        }


        function hasSufficientApiResources() {
             // Checks if the selected provider needs a key and if at least one exists.
             if (!selectedProvider || typeof PROVIDERS === 'undefined' || !PROVIDERS[selectedProvider]) return false;
             const needsKey = doesProviderNeedApiKey(selectedProvider);
             if (!needsKey) return true; // No key needed, resources are sufficient.
             const keysForCurrent = apiKeys[selectedProvider] || [];
             return keysForCurrent.length > 0;
        }

        async function handleSendMessage() {
             if (!hasSufficientApiResources()) {
                 const providerName = (typeof PROVIDERS !== 'undefined' && PROVIDERS[selectedProvider]?.name) ? PROVIDERS[selectedProvider].name : selectedProvider || "the selected provider";
                 if (doesProviderNeedApiKey(selectedProvider)) {
                     alert(`No API Key loaded for ${providerName}, which requires one. Please add a key in Settings.`);
                 } else {
                     alert(`Cannot send message. Please select a valid provider in Settings.`); // Should ideally not happen if validation is good
                 }
                 return;
             }
             if (isWaitingForResponse) return;

             const userInput = messageInput.value.trim();
             const responseCount = parseInt(mainResponseCountInput.value, 10);

             if (userInput === '') return;

             // Use the configured max variations limit
             const numResponses = isNaN(responseCount) || responseCount < 0 ? 0 : Math.min(responseCount, maxResponseVariations);

             const turnId = `turn-${turnCounter++}`;
             const containsPlaceholder = userInput.includes(iterationPlaceholder);

             isWaitingForResponse = true;
             if (sendButton) sendButton.disabled = true;
             messageInput.value = '';
             autoGrowTextarea();

             const userEntry = { role: 'user', content: userInput, turnId: turnId };
             conversationHistory.push(userEntry);
             displayMessage(userEntry, 'user');
             saveHistoryToLocalStorage();
             scrollToBottom();

             if (numResponses > 0) {
                 showTypingIndicator();
                 const baseHistory = prepareHistoryForApi(conversationHistory);
                 const responses = [];
                 let overallError = null; // Track if any variation failed definitively
                 const provider = selectedProvider; // Capture at start
                 const model = selectedModel; // Capture at start

                 console.log(`Sending ${numResponses} requests to ${provider} (${model})`);

                 for (let i = 0; i < numResponses; i++) {
                     const iteration = i + 1;
                     let currentHistory = [...baseHistory];

                     // Substitute placeholder if needed
                     if (containsPlaceholder && numResponses > 1) {
                         const userMessageIndex = currentHistory.findLastIndex(m => m.role === 'user');
                         if (userMessageIndex > -1) {
                             const substitutedContent = currentHistory[userMessageIndex].content.replace(new RegExp(iterationPlaceholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g'), iteration.toString());
                             currentHistory[userMessageIndex] = { ...currentHistory[userMessageIndex], content: substitutedContent };
                             console.log(`Substituted placeholder for iteration ${iteration}`);
                         } else {
                             console.warn("Could not find user message to substitute placeholder.");
                         }
                     }

                     try {
                         // Use the new retry function
                         const messageContent = await attemptApiCallWithRetry(provider, model, currentHistory, { temperature: 0.7, top_p: 0.9 });
                         responses.push(messageContent);
                     }
                     catch (e) {
                         console.error(`API Call Failed (Provider: ${provider}, Model: ${model}, Iteration: ${iteration}) after retries:`, e);
                         // Push the final error message from the retry function
                         responses.push(e.message || "[Spirit Communication Failed]");
                         overallError = e; // Record that at least one failed
                     }
                 } // End loop through variations

                 hideTypingIndicator();

                 if (responses.length > 0) {
                     const botEntry = { role: 'assistant', variants: responses, selectedIndex: 0, turnId: turnId };
                     conversationHistory.push(botEntry);
                     saveHistoryToLocalStorage();
                     displayBotMessage(botEntry, 'spirit');
                     scrollToBottom();
                 }
             } else {
                 console.log("Query added to history, 0 responses requested.");
             }

             isWaitingForResponse = false;
             // Re-enable send button based on whether resources are available
             if (sendButton) sendButton.disabled = !hasSufficientApiResources();
             messageInput.focus();
        }

        async function handleSendEditRequest() {
             if (!hasSufficientApiResources()) {
                 const providerName = (typeof PROVIDERS !== 'undefined' && PROVIDERS[selectedProvider]?.name) ? PROVIDERS[selectedProvider].name : (selectedProvider || "the selected provider");
                 if (doesProviderNeedApiKey(selectedProvider)) {
                    alert(`No API Key loaded for ${providerName}, which requires one. Please add a key in Settings.`);
                 } else {
                    alert(`Cannot send edit request. Please select a valid provider in Settings.`);
                 }
                 return;
             }
             if (isWaitingForResponse) return;

             const pastedCode = editSnippetTextarea.value;
             const startLine = parseInt(editStartLineInput.value, 10);
             const endLine = parseInt(editEndLineInput.value, 10);
             const instructions = editInstructionsInput.value.trim();
             const numVariations = parseInt(editResponseCountInput.value, 10);
             const pastedLines = pastedCode.split('\n');
             const totalLines = pastedLines.length;

             if (pastedCode.trim() === '') { alert("Please inscribe the glyphs to be altered."); editSnippetTextarea.focus(); return; }
             if (!instructions) { alert("Instructions are required."); editInstructionsInput.focus(); return; }
             if (isNaN(startLine) || isNaN(endLine) || startLine < 1 || endLine < startLine || endLine > totalLines) { alert(`Invalid line selection (1-${totalLines}).`); editStartLineInput.focus(); return; }

             // Use the configured max variations limit
             const numResponses = isNaN(numVariations) || numVariations < 1 ? 1 : Math.min(numVariations, maxResponseVariations);
             const containsPlaceholder = instructions.includes(iterationPlaceholder);

             codeEditModal.style.display = 'none';
             isWaitingForResponse = true;
             if (sendButton) sendButton.disabled = true;

             const turnId = `turn-${turnCounter++}`;
             const userRequestSummary = `[Glyph Alteration Request: Lines ${startLine}-${endLine}, ${numResponses} variation(s)]`;
             const userEntry = { role: 'user', content: userRequestSummary, turnId: turnId };
             conversationHistory.push(userEntry);
             displayMessage(userEntry, 'user');
             saveHistoryToLocalStorage();
             scrollToBottom();
             showTypingIndicator();

             const startIndex = startLine - 1;
             const endIndex = endLine; // slice is exclusive of end index
             const snippetToAlter = pastedLines.slice(startIndex, endIndex).join('\n');
             const historyUpToEdit = conversationHistory.slice(0, -1); // Exclude the "[Glyph Alteration Request...]" message itself
             const baseApiHistory = prepareHistoryForApi(historyUpToEdit);

             const editResponses = [];
             let overallError = null;
             const provider = selectedProvider; // Capture at start
             const model = selectedModel; // Capture at start

             console.log(`Sending ${numResponses} EDIT requests to ${provider} (${model})`);

             for (let i = 0; i < numResponses; i++) {
                 const iteration = i + 1;
                 let currentInstructions = instructions;
                 if (containsPlaceholder && numResponses > 1) {
                     currentInstructions = instructions.replace(new RegExp(iterationPlaceholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g'), iteration.toString());
                 }

                 // Construct the prompt for the edit request
                 const prompt = `You are tasked with editing a code snippet based ONLY on the provided lines and instructions.
Context from the previous conversation IS relevant for understanding the goal, but you MUST operate *only* on the snippet provided below.
You MUST return *only* the modified lines based on the instructions.
Do NOT include the original line numbers.
Do NOT include markdown code block fences (like \`\`\`) unless the *content* being returned *is* markdown itself.
Do NOT add explanatory text before or after the code unless explicitly asked.

Original lines ${startLine} to ${endLine}:
\`\`\`
${snippetToAlter}
\`\`\`

Instructions: ${currentInstructions}

Return ONLY the altered lines.`;

                 // Combine base history with the specific edit prompt
                 let apiHistoryForThisCall = [...baseApiHistory, { role: 'user', content: prompt }];

                 try {
                     // Use the new retry function
                     const rawResponse = await attemptApiCallWithRetry(provider, model, apiHistoryForThisCall, { temperature: 0.5, top_p: 0.9 });

                     // Process the response: split into lines and reconstruct the full code
                     const editedLines = (rawResponse || "").split('\n'); // Ensure rawResponse is treated as string
                     // Handle potential extra newlines from the model sometimes adding fences
                     const cleanedEditedLines = editedLines.map(l => l.replace(/^```(?:\w+\n)?/, '').replace(/```$/, '')).filter((l, idx, arr) => idx !== 0 || l !== '' || arr.length === 1); // Basic cleaning

                     const reconstructedLines = [
                         ...pastedLines.slice(0, startIndex),
                         ...cleanedEditedLines,
                         ...pastedLines.slice(endIndex)
                     ];
                     editResponses.push(reconstructedLines.join('\n'));
                 } catch (e) {
                     console.error(`Edit Request API Error (Provider: ${provider}, Model: ${model}, Variation ${iteration}) after retries:`, e);
                     overallError = e;
                     // Construct an error message embedded in the original code context
                     const errorMarker = `--- ERROR Altering Variation ${iteration} ---\n${e.message || String(e)}\n--- ORIGINAL LINES ${startLine}-${endLine} WERE HERE ---`;
                     const reconstructedLines = [
                         ...pastedLines.slice(0, startIndex),
                         errorMarker,
                         // ...pastedLines.slice(startIndex, endIndex), // Don't include original on error, marker replaces it
                         ...pastedLines.slice(endIndex)
                     ];
                     editResponses.push(reconstructedLines.join('\n'));
                 }
             } // End loop through variations

             hideTypingIndicator();

             // Create and display the bot response containing the edited code variations
             const botEntry = {
                 role: 'assistant',
                 variants: editResponses.length > 0 ? editResponses : ["[Edit Failed]"],
                 selectedIndex: 0,
                 turnId: turnId,
                 isCodeEdit: true // Keep this flag if it's used elsewhere
             };
             conversationHistory.push(botEntry);
             saveHistoryToLocalStorage();
             displayBotMessage(botEntry, 'spirit');

             isWaitingForResponse = false;
             // Re-enable send button based on whether resources are available
             if (sendButton) sendButton.disabled = !hasSufficientApiResources();
             scrollToBottom();
             messageInput.focus();
        }

        function populateProviderSelect() {
            if (!providerSelect) { console.error("providerSelect missing."); return; }
            providerSelect.innerHTML = '';
            if (typeof PROVIDERS === 'undefined' || Object.keys(PROVIDERS).length === 0) { console.error("PROVIDERS missing or empty."); providerSelect.innerHTML = '<option value="" disabled>Error</option>'; return; }
            for (const providerKey in PROVIDERS) { const option = document.createElement('option'); option.value = providerKey; option.textContent = PROVIDERS[providerKey].name || providerKey; providerSelect.appendChild(option); }

            // Ensure selectedProvider is valid, default to first if not
            if (!PROVIDERS[selectedProvider]) {
                selectedProvider = Object.keys(PROVIDERS)[0] || '';
                localStorage.setItem('selectedProvider', selectedProvider);
            }
            providerSelect.value = selectedProvider;
            populateModelSelect(selectedProvider); // This also updates API key status
        }

        function populateModelSelect(providerKey) {
            if (!modelSelect) { console.error("modelSelect missing."); return; }
            modelSelect.innerHTML = '';

            // Fallback if providerKey is somehow invalid
            if (typeof PROVIDERS === 'undefined' || !providerKey || !PROVIDERS[providerKey]) {
                modelSelect.innerHTML = '<option value="" disabled>Select Provider</option>';
                selectedModel = '';
                localStorage.setItem('selectedModel', '');
                updateApiKeyStatus(providerKey); // Update status even if provider is invalid
                return;
            }

            const providerConf = PROVIDERS[providerKey];
            // Check if models are defined
            if (!providerConf.availableModels || providerConf.availableModels.length === 0) {
                modelSelect.innerHTML = '<option value="" disabled>No models defined</option>';
                selectedModel = '';
                localStorage.setItem('selectedModel', '');
                updateApiKeyStatus(providerKey); // Update status
                return;
            }

            // Populate models
            providerConf.availableModels.forEach(modelInfo => {
                 const modelKey = typeof modelInfo === 'string' ? modelInfo : modelInfo.key;
                 const modelName = typeof modelInfo === 'string' ? modelInfo : modelInfo.name || modelInfo.key;
                 if (!modelKey) return; // Skip invalid model entries
                 const option = document.createElement('option');
                 option.value = modelKey;
                 option.textContent = modelName;
                 modelSelect.appendChild(option);
            });

            // Select the appropriate model (saved, default, or first)
            const savedModel = localStorage.getItem('selectedModel');
            const isValidSavedModel = savedModel && providerConf.availableModels.some(m => (typeof m === 'string' ? m === savedModel : m.key === savedModel));

            if (isValidSavedModel) {
                modelSelect.value = savedModel;
                selectedModel = savedModel;
            } else if (providerConf.defaultModel && providerConf.availableModels.some(m => (typeof m === 'string' ? m === providerConf.defaultModel : m.key === providerConf.defaultModel))) {
                modelSelect.value = providerConf.defaultModel;
                selectedModel = providerConf.defaultModel;
            } else {
                // Select the first available model as a fallback
                const firstModelKey = typeof providerConf.availableModels[0] === 'string' ? providerConf.availableModels[0] : providerConf.availableModels[0]?.key;
                if (firstModelKey) {
                    modelSelect.value = firstModelKey;
                    selectedModel = firstModelKey;
                } else {
                    // Should not happen if validation above is correct, but safeguard
                    modelSelect.innerHTML = '<option value="" disabled>Error loading models</option>';
                    selectedModel = '';
                }
            }
            localStorage.setItem('selectedModel', selectedModel);
            console.log(`Model set: ${selectedModel} for ${selectedProvider}`);
            updateApiKeyStatus(providerKey); // Crucial: Update status after model selection potentially changes provider needs
        }


        function handleProviderChange() {
            selectedProvider = providerSelect.value;
            localStorage.setItem('selectedProvider', selectedProvider);
            populateModelSelect(selectedProvider); // This triggers model population and updates API key status
            // Send button state is handled within updateApiKeyStatus called by populateModelSelect
        }

        function handleModelChange() {
            selectedModel = modelSelect.value;
            localStorage.setItem('selectedModel', selectedModel);
            console.log(`Model changed to: ${selectedModel} for ${selectedProvider}`);
            // No need to update API status here, as it depends on the provider, not the model
        }

        function openSystemPromptModal() {
             console.log("openSystemPromptModal called");
             if (!systemPromptModal) { console.error("Settings modal element missing!"); return; }

             // Populate fields from current state/storage
             if (systemPromptInput) systemPromptInput.value = conversationHistory[0]?.content || localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
             if (maxVariationsInput) maxVariationsInput.value = maxResponseVariations;
             if (hideCodeCheckbox) hideCodeCheckbox.checked = hideCodeBlocks;
             if (downloadCodeCheckbox) downloadCodeCheckbox.checked = downloadCodeMode;
             if (enableRunHtmlCheckbox) enableRunHtmlCheckbox.checked = enableRunHtmlMode;
             if (apiKeyInput) apiKeyInput.value = ''; // Clear key input field

             // Populate provider/model selects (this also updates API key status display)
             populateProviderSelect();

             systemPromptModal.style.display = 'flex';
             console.log("System prompt modal display attempt finished.");
         }

        function saveSettings() {
             console.log("saveSettings called");
             // System Prompt
             const sp = systemPromptInput.value.trim() || DEFAULT_SYSTEM_PROMPT;
             if (conversationHistory.length === 0 || conversationHistory[0]?.role !== 'system') {
                 conversationHistory.unshift({ role: 'system', content: sp });
             } else {
                 conversationHistory[0].content = sp;
             }
             localStorage.setItem('systemPrompt', sp);

             // Provider & Model (already updated by change handlers, but save again)
             localStorage.setItem('selectedProvider', selectedProvider);
             localStorage.setItem('selectedModel', selectedModel);

             // Max Variations
             const newMaxVar = parseInt(maxVariationsInput.value, 10);
             if (!isNaN(newMaxVar) && newMaxVar >= 1 && newMaxVar <= parseInt(maxVariationsInput.max, 10)) {
                maxResponseVariations = newMaxVar;
                localStorage.setItem('maxResponseVariations', String(maxResponseVariations));
                // Update the actual input fields' max attributes
                updateResponseCountInputMax();
             } else {
                 alert(`Invalid Max Variations value. Please enter a number between 1 and ${maxVariationsInput.max}.`);
                 maxVariationsInput.value = maxResponseVariations; // Reset to previous valid value
                 return; // Don't close modal if validation fails
             }


             // API Keys & Indices (already saved on add/clear/retry, but save here for completeness)
             try {
                 localStorage.setItem('apiKeys', JSON.stringify(apiKeys));
                 localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex));
                 localStorage.setItem('apiCallCounts', JSON.stringify(apiCallCounts)); // Save counts
                 console.log(`Settings saved. Provider: ${selectedProvider}, Model: ${selectedModel}, Max Variations: ${maxResponseVariations}`);
             }
             catch (e) { console.error("Failed to save API keys/indices/counts:", e); alert("Error saving API data."); }

             saveHistoryToLocalStorage(); // Save potentially modified system prompt in history
             updateApiKeyStatus(); // Update main UI button state
             systemPromptModal.style.display = 'none';
        }

        function updateResponseCountInputMax() {
            // Update the max value for the response count inputs based on the setting
            if (mainResponseCountInput) mainResponseCountInput.max = maxResponseVariations;
            if (editResponseCountInput) editResponseCountInput.max = maxResponseVariations;
        }


        function handleHideCodeToggle() { if (!hideCodeCheckbox || !chatContainerElement) return; hideCodeBlocks = hideCodeCheckbox.checked; localStorage.setItem('hideCodeBlocks', String(hideCodeBlocks)); chatContainerElement.classList.toggle('code-hidden', hideCodeBlocks); }
        function handleDownloadCodeToggle() { if (!downloadCodeCheckbox || !chatContainerElement) return; downloadCodeMode = downloadCodeCheckbox.checked; localStorage.setItem('downloadCodeMode', String(downloadCodeMode)); chatContainerElement.classList.toggle('download-code-active', downloadCodeMode); }
        function handleEnableRunHtmlToggle() { if (!enableRunHtmlCheckbox || !chatContainerElement) return; enableRunHtmlMode = enableRunHtmlCheckbox.checked; localStorage.setItem('enableRunHtmlMode', String(enableRunHtmlMode)); chatContainerElement.classList.toggle('run-html-active', enableRunHtmlMode); }

        function handleClearChat() {
             console.log("handleClearChat called");
             if (confirm("Disperse all echoes? (Cannot be undone)")) {
                 console.log("Clear confirmed");
                 const sp = conversationHistory[0]?.content || localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
                 conversationHistory = [{ role: 'system', content: sp }]; // Keep only system prompt
                 turnCounter = 1; // Reset turn counter
                 saveHistoryToLocalStorage();
                 rebuildChatFromHistory(); // Clear UI
                 displayInitialGreeting(); // Show greeting again
                 console.log("Chat cleared.");
             }
             else { console.log("Clear cancelled"); }
        }

        function insertIteratorPlaceholder(targetInput) {
             console.log("insertIteratorPlaceholder called for target:", targetInput?.id); if (!targetInput) { console.error("Target input is null!"); return; }
             const start = targetInput.selectionStart; const end = targetInput.selectionEnd; const value = targetInput.value;
             const newValue = value.substring(0, start) + iterationPlaceholder + value.substring(end); targetInput.value = newValue;
             const newPos = start + iterationPlaceholder.length; targetInput.selectionStart = newPos; targetInput.selectionEnd = newPos; targetInput.focus(); targetInput.dispatchEvent(new Event('input', { bubbles: true })); console.log(`Iterator inserted into ${targetInput.id}`);
        }

        function autoGrowTextarea() {
            if (!messageInput) return; const input = messageInput; const maxHeightStyle = window.getComputedStyle(input).maxHeight; const maxHeight = parseFloat(maxHeightStyle) || 150; input.style.height = 'auto'; const scrollHeight = input.scrollHeight; input.style.height = Math.min(scrollHeight, maxHeight) + 'px'; input.style.overflowY = scrollHeight > maxHeight ? 'auto' : 'hidden';
        }

        function openEditCodeModal() {
             console.log("openEditCodeModal called"); if (!codeEditModal) { console.error("Code edit modal missing!"); return; }
             if (editSnippetTextarea) editSnippetTextarea.value = ''; if (editStartLineInput) editStartLineInput.value = 1; if (editEndLineInput) editEndLineInput.value = 1; if (editInstructionsInput) editInstructionsInput.value = '';
             if (editResponseCountInput) {
                editResponseCountInput.value = 1;
                editResponseCountInput.max = maxResponseVariations; // Ensure max is set correctly
             }
             updateSnippetLineCount(); codeEditModal.style.display = 'flex'; if (editSnippetTextarea) editSnippetTextarea.focus();
             console.log("Code edit modal display attempt finished.");
        }

        function updateSnippetLineCount() {
             if (!editSnippetTextarea || !editSnippetLineCount || !editStartLineInput || !editEndLineInput) return;
             const lines = editSnippetTextarea.value.split('\n'); const count = editSnippetTextarea.value === '' ? 0 : lines.length; if (editSnippetLineCount) editSnippetLineCount.textContent = count;
             const maxVal = count > 0 ? count : 1; editStartLineInput.max = maxVal; editEndLineInput.max = maxVal;
             if (parseInt(editEndLineInput.value) > maxVal) editEndLineInput.value = maxVal; if (parseInt(editStartLineInput.value) > maxVal) editStartLineInput.value = maxVal; if (parseInt(editEndLineInput.value) < parseInt(editStartLineInput.value)) editEndLineInput.value = editStartLineInput.value;
        }

        function renderRunnerHTML() {
             if (!htmlRunnerInput || !htmlRunnerFrame) { console.error("HTML Runner elements missing."); return; } const htmlCode = htmlRunnerInput.value;
             // Basic check for obviously malicious patterns - could be expanded
             if (/<script.*?>.*?window\.location.*?<\/script>/i.test(htmlCode) || /<script.*?>.*?document\.cookie.*?<\/script>/i.test(htmlCode) || /<script.*?>.*?localStorage.*?<\/script>/i.test(htmlCode) || /<script.*?>.*?sessionStorage.*?<\/script>/i.test(htmlCode)) { console.warn("Potentially harmful script detected. Blocking render."); try { const d = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow?.document; if (d) { d.open(); d.write('<html><head><title>Blocked</title></head><body><p style="color:red; font-weight:bold;">Execution blocked due to potentially harmful script content (e.g., manipulating location, cookies, or storage).</p></body></html>'); d.close(); } } catch (e) { /* ignore sandbox errors */ } return; }
             try { const d = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow?.document; if (d) { d.open(); d.write(htmlCode); d.close(); } else { console.error("Cannot access iframe document."); } } catch (e) { console.error("Error rendering HTML:", e); try { const d = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow?.document; if (d) { d.open(); d.write(`<html><body><h1>Render Error</h1><pre>${e.message}</pre></body></html>`); d.close(); } } catch (e2) { /* ignore sandbox errors */ } }
        }

        function openHtmlRunner(initialCode = '') { if (!htmlRunnerModal || !htmlRunnerInput) { console.error("HTML Runner modal/input missing."); return; } htmlRunnerInput.value = initialCode; renderRunnerHTML(); htmlRunnerModal.style.display = 'flex'; }

        function createPfpElement(sender, pfpUrl) {
             const d=document.createElement('div'); d.className=`avatar ${sender}-avatar`; d.dataset.senderType=sender; const i=document.createElement('img'); i.src=pfpUrl; i.alt=`${sender} avatar`;
             i.onerror = () => { console.warn(`Failed avatar load: ${pfpUrl}`); const fb='https://ui-avatars.com/api/?name='+(sender==='user'?'U&background=1e3a8a':'S&background=6b21a8')+'&color=fff&font-size=0.6&bold=true'; i.src=fb; i.onerror=null; };
             d.addEventListener('click', () => { currentPfpElementToUpdate=i; if (pfpUploadInput) pfpUploadInput.click(); else console.error("pfpUploadInput missing."); }); d.appendChild(i); return d;
        }

        function displayBotMessage(entry, sender = 'spirit') {
            if (!entry || !entry.variants) { console.warn("Invalid bot entry:", entry); return; } const variants = Array.isArray(entry.variants) ? entry.variants : [entry.variants]; const selectedIndex = entry.selectedIndex ?? 0;
            if (variants.length > 1) displayMultipleMessages({ ...entry, variants: variants, selectedIndex: selectedIndex }, sender);
            else if (variants.length === 1) displayMessage({ ...entry, variants: variants, selectedIndex: 0 }, sender);
            else displayMessage({ ...entry, variants: ["[Silence]"], selectedIndex: 0 }, sender); // Handle empty variants case
        }

        function displayMessage(entry, sender) {
            const content = (sender === 'user') ? (entry.content || "") : (entry.variants?.[entry.selectedIndex ?? 0] || "[Error - No variant selected or available]");
            const msgDiv = document.createElement('div'); msgDiv.className = `message message-${sender}`; if (entry.turnId) msgDiv.dataset.turnId = entry.turnId;
            const pfpUrl = (sender === 'user') ? userPfp : botPfp; const avatarEl = createPfpElement(sender, pfpUrl); const wrapper = document.createElement('div'); wrapper.classList.add('message-content-wrapper');
            const contentDiv = document.createElement('div'); contentDiv.className = 'message-content';
            if (sender === 'spirit') { try { contentDiv.innerHTML = marked.parse(content); } catch (e) { console.error("Markdown error:", e); contentDiv.textContent = content; contentDiv.style.whiteSpace = 'pre-wrap'; } }
            else { contentDiv.textContent = content; contentDiv.style.whiteSpace = 'pre-wrap'; }
            wrapper.appendChild(contentDiv); if (sender === 'spirit') addCodeActionButtons(contentDiv, wrapper, entry.turnId, entry.selectedIndex ?? 0);
            if (sender === 'user') { msgDiv.appendChild(wrapper); msgDiv.appendChild(avatarEl); } else { msgDiv.appendChild(avatarEl); msgDiv.appendChild(wrapper); }
            if (pages) { pages.appendChild(msgDiv); if (sender === 'spirit') contentDiv.querySelectorAll('pre code').forEach((block) => { try { hljs.highlightElement(block); } catch (e) { console.warn("Highlight error:", e); } }); }
            else console.error("Pages container missing."); return msgDiv;
        }

        function displayMultipleMessages(entry, sender = 'spirit') {
            if (!pages) { console.error("Pages container missing."); return null; } if (!entry || !Array.isArray(entry.variants) || entry.variants.length === 0) { console.warn("Invalid multi-entry:", entry); return null; }
            const tid = entry.turnId; const vars = entry.variants; let idx = entry.selectedIndex ?? 0; if (idx < 0 || idx >= vars.length) idx = 0; // Validate index
            const msgDiv = document.createElement('div'); msgDiv.className = `message message-${sender}`; if (tid) msgDiv.dataset.turnId = tid; const pfpUrl = (sender === 'user') ? userPfp : botPfp; const avatarEl = createPfpElement(sender, pfpUrl);
            const wrapper = document.createElement('div'); wrapper.classList.add('message-content-wrapper'); const contentDiv = document.createElement('div'); contentDiv.className = 'message-content'; const nav = document.createElement('div'); nav.classList.add('response-navigation');
            const prev = document.createElement('button'); prev.textContent = '<'; prev.title = "Previous Variation"; const span = document.createElement('span'); span.title = "Current Variation"; const next = document.createElement('button'); next.textContent = '>'; next.title = "Next Variation";
            nav.appendChild(prev); nav.appendChild(span); nav.appendChild(next); let actsContainer = document.createElement('div'); actsContainer.classList.add('message-actions'); wrapper.appendChild(contentDiv); wrapper.appendChild(actsContainer); wrapper.appendChild(nav); // Nav below actions

            function update(currentIndex) {
                const c = vars[currentIndex] || "[Error - Variant unavailable]";
                try { contentDiv.innerHTML = marked.parse(c); }
                catch (e) { console.error("Markdown error:", e); contentDiv.textContent = c; contentDiv.style.whiteSpace = 'pre-wrap'; }
                addCodeActionButtons(contentDiv, wrapper, tid, currentIndex); // Pass current index
                span.textContent = `${currentIndex + 1} / ${vars.length}`;
                prev.disabled = currentIndex === 0;
                next.disabled = currentIndex === vars.length - 1;
                // Highlight code blocks within the newly rendered content
                contentDiv.querySelectorAll('pre code').forEach((block) => { try { hljs.highlightElement(block); } catch (e) { console.warn("Highlight error:", e); } });
                // Trigger reflow for animation restart
                contentDiv.style.animation = 'none';
                void contentDiv.offsetWidth; // Reflow
                contentDiv.style.animation = 'fadeIn 0.3s ease-in-out';
            }

            prev.addEventListener('click', () => { if (idx > 0) { idx--; update(idx); updateHistorySelection(tid, idx); } });
            next.addEventListener('click', () => { if (idx < vars.length - 1) { idx++; update(idx); updateHistorySelection(tid, idx); } });

            if (sender === 'user') { msgDiv.appendChild(wrapper); msgDiv.appendChild(avatarEl); } else { msgDiv.appendChild(avatarEl); msgDiv.appendChild(wrapper); }
            pages.appendChild(msgDiv);
            update(idx); // Initial display
            return msgDiv;
        }

        function addCodeActionButtons(contentDiv, wrapper, turnId, variantIndex) {
             let acts = wrapper.querySelector('.message-actions');
             // Ensure actions container exists if needed
             if (!acts) {
                 acts = document.createElement('div');
                 acts.classList.add('message-actions');
                 const nav = wrapper.querySelector('.response-navigation');
                 if (nav) {
                     wrapper.insertBefore(acts, nav); // Insert actions before navigation
                 } else {
                     wrapper.appendChild(acts); // Append if no nav exists
                 }
             }
             acts.innerHTML = ''; // Clear previous buttons for this variant

             // Remove old placeholders first
             contentDiv.querySelectorAll('.cat-placeholder').forEach(c => c.remove());

             const codeBlocks = contentDiv.querySelectorAll('pre');
             if (codeBlocks.length === 0) {
                 // If no code blocks AND no other actions are planned, remove the container
                 if (!acts.hasChildNodes() && acts.parentNode) {
                     acts.remove();
                 }
                 return;
             }

             codeBlocks.forEach((pre, preIdx) => {
                 // Unique ID considering turn, variant, and block index
                 const uid = `pre-${turnId || 'g'}-${variantIndex}-${preIdx}`;
                 pre.id = uid; // Assign ID for later retrieval

                 // Add cat placeholder for hidden code view
                 const cat = document.createElement('span');
                 cat.className = 'cat-placeholder'; cat.textContent = '🐱'; cat.dataset.preId = uid;
                 pre.parentNode.insertBefore(cat, pre);

                 const code = pre.querySelector('code');
                 const txt = code ? code.textContent : ''; // Get raw code text
                 const langMatch = code?.className.match(/language-(\w+)/);
                 const lang = langMatch ? langMatch[1].toLowerCase() : 'txt'; // Detect language
                 const fn = `tome_${turnId || 'c'}_var${variantIndex + 1}_block${preIdx + 1}.${lang}`; // Generate filename

                 // Copy Button
                 const cp = document.createElement('button'); cp.textContent='Copy'; cp.title=`Copy ${lang} Code Block ${preIdx + 1}`; cp.className='copy-code-button action-button';
                 cp.onclick = () => copyCodeFromPre(uid, cp);
                 acts.appendChild(cp);

                 // Download Button (conditionally displayed via CSS)
                 const dl = document.createElement('button'); dl.textContent='Download'; dl.title=`Download ${fn}`; dl.className='download-code-button action-button';
                 dl.onclick = () => downloadCode(txt, fn);
                 acts.appendChild(dl);

                 // Run HTML Button (conditionally displayed via CSS, only for HTML blocks)
                 if (lang === 'html') {
                     const rn = document.createElement('button'); rn.textContent='Run HTML'; rn.className='run-html-button action-button'; rn.title=`Run HTML Block ${preIdx + 1}`;
                     rn.onclick = () => openHtmlRunner(txt);
                     acts.appendChild(rn);
                 }
             });

             // Clean up actions container if it ended up empty (e.g., only non-HTML code and download disabled)
             if (!acts.hasChildNodes() && acts.parentNode) {
                  acts.remove();
             }
        }

        function copyCodeFromPre(preId, btn) {
             const pre = document.getElementById(preId); const code = pre ? pre.querySelector('code') : null; if (!code) { console.error(`Code element missing for ${preId}`); if (btn) btn.textContent='Err'; return; }
             const txt = code.textContent || ''; if (!copyHelper) { console.error("Copy helper missing."); if (btn) btn.textContent='Err'; return; } copyHelper.value = txt; copyHelper.select(); copyHelper.setSelectionRange(0, 99999); let ok = false; try { ok = document.execCommand('copy'); } catch (e) { ok = false; console.warn("document.execCommand('copy') failed:", e); }
             // Deselect text
             window.getSelection()?.removeAllRanges();
             // Provide feedback on the button
             if (btn) { if (ok) { btn.textContent = 'Copied!'; btn.classList.add('copied'); setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 1500); } else { btn.textContent = 'Failed!'; setTimeout(() => { btn.textContent = 'Copy'; }, 2500); } }
        }

        function downloadCode(codeText, filename) { try { const b = new Blob([codeText], { type: 'text/plain;charset=utf-8' }); const u = URL.createObjectURL(b); const a = document.createElement('a'); a.href = u; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(u); } catch (e) { console.error("Download err:", e); alert("Download failed."); } }
        function showTypingIndicator() { if (document.getElementById('typing-indicator')) return; if (!pages) { console.error("Pages missing for typing indicator."); return; } const ind = document.createElement('div'); ind.className = 'typing-indicator message message-spirit'; ind.id = 'typing-indicator'; const av = createPfpElement('spirit', botPfp); const wr = document.createElement('div'); wr.className = 'message-content-wrapper'; const cd = document.createElement('div'); cd.className = 'message-content'; cd.style.cssText = 'font-style: italic; color: var(--ink-light);'; cd.textContent = 'The spirit whispers...'; wr.appendChild(cd); ind.appendChild(av); ind.appendChild(wr); pages.appendChild(ind); scrollToBottom(); }
        function hideTypingIndicator() { const ind = document.getElementById('typing-indicator'); if (ind) ind.remove(); }
        function scrollToBottom() { if (!pages) return; setTimeout(() => { pages.scrollTop = pages.scrollHeight; }, 50); } // Small delay helps ensure rendering is complete

        function prepareHistoryForApi(hist) {
            if (!Array.isArray(hist)) return [];
            return hist
                // Filter out any potentially null/undefined entries just in case
                .filter(m => m && m.role)
                .map(m => {
                    if (m.role === 'system') {
                        return { role: 'system', content: m.content || "" };
                    }
                    if (m.role === 'user') {
                        // Make sure content exists, default to empty string if not
                        return { role: 'user', content: m.content || "" };
                    }
                    if (m.role === 'assistant') {
                        // Get content from the currently selected variant
                        const content = m.variants?.[m.selectedIndex ?? 0];
                        // Only include assistant message if content is valid (not null/undefined)
                        return content != null ? { role: 'assistant', content: content } : null;
                    }
                    // Ignore unknown roles
                    return null;
                })
                // Filter out any nulls potentially returned (e.g., assistant message with no valid content)
                .filter(Boolean);
        }


        function updateHistorySelection(turnId, newIndex) {
            if (!turnId) return;
            const historyIndex = conversationHistory.findIndex(m => m.turnId === turnId && m.role === 'assistant');
            if (historyIndex > -1) {
                const msg = conversationHistory[historyIndex];
                if (msg.variants && newIndex >= 0 && newIndex < msg.variants.length) {
                    if (msg.selectedIndex !== newIndex) { // Only update if changed
                        msg.selectedIndex = newIndex;
                        saveHistoryToLocalStorage(); // Save the change
                        console.log(`Updated selected index for turn ${turnId} to ${newIndex}`);
                    }
                } else {
                    console.warn(`Invalid index ${newIndex} provided for turn ${turnId}`);
                }
            } else {
                console.warn(`Could not find assistant message for turn ${turnId} to update selection.`);
            }
        }

        function saveHistoryToLocalStorage() { try { localStorage.setItem('conversationHistory', JSON.stringify(conversationHistory)); } catch (e) { console.error("Save history error:", e); } }

        function loadHistoryFromLocalStorage() {
             let providerOk = false;
             try {
                 if (typeof PROVIDERS === 'undefined' || Object.keys(PROVIDERS).length === 0) throw new Error("PROVIDERS definitions missing.");
                 const sp = localStorage.getItem('selectedProvider');
                 // Ensure the saved provider still exists in the definitions
                 selectedProvider = (sp && PROVIDERS[sp]) ? sp : (Object.keys(PROVIDERS)[0] || '');
                 selectedModel = localStorage.getItem('selectedModel') || ''; // Model validity checked in populateModelSelect
                 providerOk = true;
             } catch (e) {
                 console.error("Provider configuration or loading error:", e);
                 // Fallback to potentially stored values even if PROVIDERS is broken
                 selectedProvider = localStorage.getItem('selectedProvider') || '';
                 selectedModel = localStorage.getItem('selectedModel') || '';
             }

             // Load API Keys, Indices, and Counts
             try {
                 const sk = localStorage.getItem('apiKeys');
                 apiKeys = sk ? JSON.parse(sk) : {};
                 const si = localStorage.getItem('currentApiKeyIndex');
                 currentApiKeyIndex = si ? JSON.parse(si) : {};
                 const sc = localStorage.getItem('apiCallCounts'); // Load counts
                 apiCallCounts = sc ? JSON.parse(sc) : {};

                 // Basic validation
                 if (typeof apiKeys !== 'object' || apiKeys === null) apiKeys = {};
                 if (typeof currentApiKeyIndex !== 'object' || currentApiKeyIndex === null) currentApiKeyIndex = {};
                 if (typeof apiCallCounts !== 'object' || apiCallCounts === null) apiCallCounts = {}; // Validate counts object
             } catch (e) {
                 console.warn("API Key/Index/Count loading error:", e);
                 apiKeys = {}; currentApiKeyIndex = {}; apiCallCounts = {}; // Reset on error
             }

             // Load Max Variations setting
             try {
                 const savedMaxVar = localStorage.getItem('maxResponseVariations');
                 const parsedMaxVar = parseInt(savedMaxVar || '5', 10); // Default to 5
                 maxResponseVariations = (!isNaN(parsedMaxVar) && parsedMaxVar >= 1) ? parsedMaxVar : 5;
             } catch (e) {
                 console.warn("Max Variations loading error:", e);
                 maxResponseVariations = 5; // Default on error
             }


             // Load Conversation History
             let historyOk = false;
             try {
                 const sh = localStorage.getItem('conversationHistory');
                 if (!sh) throw new Error('No history found in localStorage');
                 const ph = JSON.parse(sh);
                 if (!Array.isArray(ph)) throw new Error('Stored history is not an array');

                 // Ensure System Prompt exists
                 if (ph.length === 0 || ph[0]?.role !== 'system') {
                     const sys = localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
                     ph.unshift({ role: 'system', content: sys });
                 } else {
                     // Ensure existing system prompt content is not null/undefined
                     ph[0].content = ph[0].content || localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
                 }

                 // Sanitize loaded history
                 conversationHistory = ph.map(m => {
                     if (!m || !m.role) return null; // Skip invalid messages
                     if (m.role === 'assistant') {
                         // Ensure variants is an array, handle old 'content' field
                         const variants = Array.isArray(m.variants) ? m.variants : (m.content != null ? [m.content] : []);
                         let selectedIndex = m.selectedIndex ?? 0;
                         // Validate selectedIndex
                         if (!Number.isInteger(selectedIndex) || selectedIndex < 0 || selectedIndex >= variants.length) {
                             selectedIndex = 0; // Default to 0 if invalid
                         }
                         return {
                             role: 'assistant',
                             variants: variants,
                             selectedIndex: selectedIndex,
                             turnId: m.turnId, // Preserve turnId
                             isCodeEdit: m.isCodeEdit // Preserve flag
                             // content: undefined // Remove legacy content field
                         };
                     }
                      // Ensure user messages have content
                     if (m.role === 'user') {
                         return { ...m, content: m.content || "" };
                     }
                     // Keep system prompt as is (already validated)
                     if (m.role === 'system') {
                        return m;
                     }
                     return null; // Skip unknown roles
                 }).filter(Boolean); // Remove null entries

                 // Determine the next turn counter
                 const lastTurn = conversationHistory.slice().reverse().find(m => m.turnId?.startsWith('turn-'));
                 turnCounter = lastTurn?.turnId ? (parseInt(lastTurn.turnId.split('-')[1], 10) || 0) + 1 : 1;

                 historyOk = true;
                 console.log(`History loaded. ${conversationHistory.length - 1} messages. Next turn ID: ${turnCounter}`);
             }
             catch (e) {
                 console.warn("Conversation history loading error:", e);
                 // Initialize with default system prompt if history loading fails
                 const sys = localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
                 conversationHistory = [{ role: 'system', content: sys }];
                 turnCounter = 1;
             }
             return providerOk && historyOk; // Indicate if core parts loaded okay
        }

        function rebuildChatFromHistory() {
            if (!pages) return;
            pages.innerHTML = ''; // Clear existing messages
            // Start from index 1 to skip the system prompt
            for (let i = 1; i < conversationHistory.length; i++) {
                 const entry = conversationHistory[i];
                 if (entry.role === 'user') {
                     displayMessage(entry, 'user');
                 } else if (entry.role === 'assistant') {
                     // Use displayBotMessage to handle single/multiple variants correctly
                     displayBotMessage(entry, 'spirit');
                 }
            }
            scrollToBottom();
        }

        function displayInitialGreeting() {
             if (!pages) return;
             // Only display if there are no messages other than the system prompt
             if (conversationHistory.length <= 1) {
                 const greetingMessage = "The ancient tome awaits your query...";
                 // Create a temporary entry structure for display
                 const greetingEntry = {
                     role: 'assistant',
                     variants: [greetingMessage],
                     selectedIndex: 0,
                     turnId: 'turn-0' // Assign a non-conflicting ID
                 };
                 displayBotMessage(greetingEntry, 'spirit');
                 // Do not add this temporary greeting to the actual conversationHistory
                 turnCounter = Math.max(turnCounter, 1); // Ensure counter is at least 1
             }
        }

        // --- Initial Load Function ---
        function initialLoad() {
            console.log("InitialLoad started.");
            // Critical dependency checks
            if (typeof PROVIDERS === 'undefined') { console.error("FATAL: PROVIDERS definitions missing (api_providers.js)."); alert("Error: PROVIDERS definitions missing. Please ensure api_providers.js is loaded correctly."); return; }
            if (typeof getApiResponse !== 'function') { console.error("FATAL: getApiResponse function missing (api_providers.js)."); alert("Error: API call function (getApiResponse) missing. Please ensure api_providers.js defines it."); return; }

            // Load all data from localStorage
            loadHistoryFromLocalStorage();

            // Populate UI elements based on loaded state
            populateProviderSelect(); // Sets provider/model selects and updates API status
            updateApiKeyStatus(selectedProvider); // Explicitly update status after load

            // Load UI state settings
            hideCodeBlocks = localStorage.getItem('hideCodeBlocks') === 'true';
            downloadCodeMode = localStorage.getItem('downloadCodeMode') === 'true';
            enableRunHtmlMode = localStorage.getItem('enableRunHtmlMode') === 'true';

            // Apply UI state classes
            if (chatContainerElement) {
                chatContainerElement.classList.toggle('code-hidden', hideCodeBlocks);
                chatContainerElement.classList.toggle('download-code-active', downloadCodeMode);
                chatContainerElement.classList.toggle('run-html-active', enableRunHtmlMode);
            }
            // Set checkbox states
            if (hideCodeCheckbox) hideCodeCheckbox.checked = hideCodeBlocks;
            if (downloadCodeCheckbox) downloadCodeCheckbox.checked = downloadCodeMode;
            if (enableRunHtmlCheckbox) enableRunHtmlCheckbox.checked = enableRunHtmlMode;

            // Set initial state of Send button
            if (sendButton) sendButton.disabled = !hasSufficientApiResources();

            // Set max values for response count inputs
            updateResponseCountInputMax();


            // Render the chat history
            rebuildChatFromHistory();

            // Display greeting if chat is empty
            displayInitialGreeting();

            // Set initial textarea height
            autoGrowTextarea();

            console.log("Arcane Tome Initialized.");
        }

        // --- Event Listeners (Attached Globally AFTER functions defined) ---
        function attachEventListeners() {
            console.log("Attaching event listeners...");
            if (sendButton) sendButton.addEventListener('click', handleSendMessage); else console.error("sendButton missing");
            if (messageInput) { messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } }); messageInput.addEventListener('input', autoGrowTextarea); } else console.error("messageInput missing");
            if (settingsButton) settingsButton.addEventListener('click', openSystemPromptModal); else console.error("settingsButton missing");
            if (providerSelect) providerSelect.addEventListener('change', handleProviderChange); else console.error("providerSelect missing");
            if (modelSelect) modelSelect.addEventListener('change', handleModelChange); else console.error("modelSelect missing");
            if (addKeyButton) addKeyButton.addEventListener('click', addApiKey); else console.error("addKeyButton missing");
            if (clearKeysButton) clearKeysButton.addEventListener('click', clearApiKeysForProvider); else console.error("clearKeysButton missing");
            if (resetCallCountButton) resetCallCountButton.addEventListener('click', resetApiCallCountForProvider); else console.error("resetCallCountButton missing"); // Listener for new button
            if (saveSettingsButton) saveSettingsButton.addEventListener('click', saveSettings); else console.error("saveSettingsButton missing");
            if (cancelSettingsButton) cancelSettingsButton.addEventListener('click', () => { if (systemPromptModal) systemPromptModal.style.display = 'none'; }); else console.error("cancelSettingsButton missing");
            if (systemPromptModal) systemPromptModal.addEventListener('click', (e) => { if (e.target === systemPromptModal) systemPromptModal.style.display = 'none'; }); else console.error("systemPromptModal missing");
            if (hideCodeCheckbox) hideCodeCheckbox.addEventListener('change', handleHideCodeToggle); else console.error("hideCodeCheckbox missing");
            if (downloadCodeCheckbox) downloadCodeCheckbox.addEventListener('change', handleDownloadCodeToggle); else console.error("downloadCodeCheckbox missing");
            if (enableRunHtmlCheckbox) enableRunHtmlCheckbox.addEventListener('change', handleEnableRunHtmlToggle); else console.error("enableRunHtmlCheckbox missing");
            if (editCodeButton) editCodeButton.addEventListener('click', openEditCodeModal); else console.error("editCodeButton missing");
            if (sendEditRequestButton) sendEditRequestButton.addEventListener('click', handleSendEditRequest); else console.error("sendEditRequestButton missing");
            if (cancelEditRequestButton) cancelEditRequestButton.addEventListener('click', () => { if (codeEditModal) codeEditModal.style.display = 'none'; }); else console.error("cancelEditRequestButton missing");
            if (codeEditModal) codeEditModal.addEventListener('click', (e) => { if (e.target === codeEditModal) codeEditModal.style.display = 'none'; }); else console.error("codeEditModal missing");
            if (editSnippetTextarea) editSnippetTextarea.addEventListener('input', updateSnippetLineCount); else console.error("editSnippetTextarea missing");
            if (editAddIteratorButton) editAddIteratorButton.addEventListener('click', () => insertIteratorPlaceholder(editInstructionsInput)); else console.error("editAddIteratorButton missing");
            if (htmlRunnerRenderButton) htmlRunnerRenderButton.addEventListener('click', renderRunnerHTML); else console.error("htmlRunnerRenderButton missing");
            if (htmlRunnerCloseButton) htmlRunnerCloseButton.addEventListener('click', () => { if (htmlRunnerModal) htmlRunnerModal.style.display = 'none'; }); else console.error("htmlRunnerCloseButton missing");
            if (htmlRunnerModal) htmlRunnerModal.addEventListener('click', (e) => { if (e.target === htmlRunnerModal) htmlRunnerModal.style.display = 'none'; }); else console.error("htmlRunnerModal missing");
            if (clearChatButton) clearChatButton.addEventListener('click', handleClearChat); else console.error("clearChatButton missing");
            if (addIteratorButton) addIteratorButton.addEventListener('click', () => insertIteratorPlaceholder(messageInput)); else console.error("addIteratorButton missing");
            if (uploadFileButton) uploadFileButton.addEventListener('click', () => { if (fileUploadInput) fileUploadInput.click(); }); else console.error("uploadFileButton missing"); // Basic file input trigger
            if (pfpUploadInput) pfpUploadInput.addEventListener('change', function(event) { const f=event.target.files[0];if(!f||!currentPfpElementToUpdate)return;const r=new FileReader();r.onload=function(e){const u=e.target.result;currentPfpElementToUpdate.src=u;const t=currentPfpElementToUpdate.closest('.avatar').dataset.senderType; if(t==='user'){userPfp=u;localStorage.setItem('userPfp',u);document.querySelectorAll('.avatar.user-avatar img').forEach(i=>i.src=u);}else if(t==='spirit'){botPfp=u;localStorage.setItem('botPfp',u);document.querySelectorAll('.avatar.spirit-avatar img').forEach(i=>i.src=u);}currentPfpElementToUpdate=null;};r.readAsDataURL(f); }); else console.error("pfpUploadInput missing");
            console.log("Event listeners attached.");
        }


        // --- Start the application ---
        // Use DOMContentLoaded to ensure HTML is parsed, then run initial setup and attach listeners.
        document.addEventListener('DOMContentLoaded', () => {
            initialLoad();
            attachEventListeners(); // Attach listeners after initial load is complete
        });

    </script>
</body>
</html>
