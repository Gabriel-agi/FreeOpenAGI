<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcane Tome (Provider Enhanced - Fixed)</title>
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=Georgia&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- API Provider Definitions (MUST be before main script) -->
    <script src="api_providers.js"></script>

    <style>
        /* --- Arcane Tome Base Styles (Mostly Unchanged) --- */
        :root { /* ... same color variables ... */
             --parchment: #f5e7d0; --parchment-dark: #e3d5b8; --ink: #3a3129; --ink-light: #5a4e42; --gold: #c9a227; --crimson: #8b0000; --sapphire: #1e3a8a; --amethyst: #6b21a8; --emerald: #21a853; --shadow-light: 0 1px 3px rgba(0,0,0,0.15); --code-bg: #e8e0cf; --code-border: #d1c3a9;
        }
        html, body { height: 100%; margin: 0; padding: 0; }
        * { box-sizing: border-box; }
        body { font-family: Georgia,'Times New Roman',Times,serif; font-size: 1.1rem; line-height: 1.6; background-color: var(--parchment); color: var(--ink); width: 100vw; overflow: hidden; }
        .tome { width: 100%; height: 100%; display: flex; flex-direction: column; position: relative; background-color: var(--parchment); }
        .pages { flex: 1; min-height: 0; padding: 20px; overflow-y: auto; scrollbar-width: none; display: flex; flex-direction: column; gap: 15px; border-bottom: 2px solid var(--ink-light); }
        .pages::-webkit-scrollbar { display: none; }
        .message { display: flex; gap: 10px; max-width: 85%; animation: fadeIn 0.5s ease-in-out;}
        .message-user { align-self: flex-end; flex-direction: row-reverse; }
        .message-spirit { align-self: flex-start; }
        .avatar { width: 45px; height: 45px; border-radius: 50%; flex-shrink: 0; border: 2px solid var(--parchment-dark); box-shadow: var(--shadow-light); display: flex; align-items: center; justify-content: center; overflow: hidden; background-color: var(--parchment-dark); cursor: pointer; }
        .avatar img { width: 100%; height: 100%; object-fit: cover; }
        .user-avatar { background-color: var(--sapphire); }
        .spirit-avatar { background-color: var(--amethyst); }
        .message-content-wrapper { display: flex; flex-direction: column; max-width: 100%; }
        .message-content { padding: 12px 18px; border-radius: 8px; line-height: 1.5; word-break: break-word; box-shadow: var(--shadow-light); max-width: fit-content; }
        .message-user .message-content { background-color: var(--sapphire); color: white; border-top-right-radius: 0; }
        .message-spirit .message-content { background-color: white; color: var(--ink); border: 1px solid var(--ink-light); border-top-left-radius: 0; }
        .message-content p { margin: 0 0 0.5em 0; } .message-content p:last-child { margin-bottom: 0; }
        .typing-indicator { align-self: flex-start; color: var(--ink-light); font-style: italic; padding: 10px 15px; background-color: rgba(227,213,184,0.5); border-radius: 8px; font-size: 1rem; }
        .writing-area { padding: 12px; background-color: var(--parchment-dark); display: flex; flex-wrap: wrap; gap: 8px; align-items: flex-end; flex-shrink: 0; }
        .message-input { flex: 1 1 250px; padding: 10px; background-color: var(--parchment); border: 2px solid var(--ink-light); border-radius: 5px; font-family: inherit; font-size: 1.1rem; resize: none; outline: none; color: var(--ink); min-height: 48px; max-height: 150px; line-height: 1.5; }
        .message-input:focus { border-color: var(--gold); }
        .writing-controls { display: flex; align-items: flex-end; gap: 8px; flex-wrap: nowrap; margin-left: auto; }
        .footer-button { background-color: var(--ink-light); color: var(--parchment); border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; padding: 8px 10px; font-size: 0.9em; flex-shrink: 0; white-space: nowrap; height: 48px; font-family: Georgia,serif; display:flex; align-items:center; justify-content:center; }
        .footer-button:hover { background-color: var(--ink); }
        #settings-button { background-color: var(--gold); color: var(--ink); font-size: 1.2em; padding: 0 12px; }
        #settings-button:hover { background-color: var(--crimson); color: white; }
        #clear-chat-button { background-color: var(--crimson); color: white;}
        #clear-chat-button:hover { background-color: darkred; }
        #upload-file-button { font-size: 1.1em; padding: 0 12px; }
        .response-count-input { width: 45px; padding: 10px; border: 2px solid var(--ink-light); border-radius: 5px; text-align: center; flex-shrink: 0; height: 48px; font-size: 1rem; background-color: var(--parchment); color: var(--ink); }
        .send-button { background-color: var(--gold); color: var(--ink); border: none; border-radius: 5px; padding: 0 18px; height: 48px; font-family: 'Cinzel Decorative',cursive; font-weight: bold; cursor: pointer; box-shadow: var(--shadow-light); display: flex; align-items: center; gap: 8px; font-size: 1.1rem; transition: background-color 0.2s ease; flex-shrink: 0; }
        .send-button:hover:not(:disabled) { background-color: var(--crimson); color: white; }
        .send-button:disabled { opacity: 0.7; cursor: not-allowed; background-color: var(--ink-light); color: var(--parchment); }
        .response-navigation { display: flex; align-items: center; justify-content: flex-start; margin-top: 5px; gap: 5px; width: fit-content; }
        .response-navigation button { background-color: var(--parchment-dark); border: 1px solid var(--ink-light); color: var(--ink); border-radius: 4px; padding: 2px 6px; cursor: pointer; font-size: 0.9em; line-height: 1; }
        .response-navigation button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #ccc; }
        .response-navigation span { font-size: 0.8em; color: var(--ink-light); margin: 0 5px; user-select: none; }
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(58,49,41,0.7); justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--parchment); border: 3px solid var(--gold); color: var(--ink); padding: 25px; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.4); max-height: 90vh; width: 90%; display: flex; flex-direction: column; overflow-y: auto; }
        .modal-content h3 { font-family: 'Cinzel Decorative',cursive; margin-top: 0; text-align: center; color: var(--ink); border-bottom: 1px solid var(--gold); padding-bottom: 10px; margin-bottom: 20px; flex-shrink: 0; }
        .modal-content .form-group { margin-bottom: 15px; display: flex; flex-wrap: wrap; align-items: center; gap: 8px 15px; flex-shrink: 0; }
        .modal-content label { display: block; margin-bottom: 5px; font-weight: bold; color: var(--ink-light); flex-basis: 100%; }
        .modal-content input[type="checkbox"] { cursor: pointer; margin-right: 5px; flex-shrink: 0; }
        .modal-content label[for*="checkbox"] { flex-basis: auto; margin-bottom: 0; font-weight: normal; }
        .modal-content input[type="password"], .modal-content textarea, .modal-content input[type="number"], .modal-content select { width: 100%; padding: 10px; border: 1px solid var(--ink-light); border-radius: 4px; outline: none; box-sizing: border-box; background-color: white; color: var(--ink); font-family: Georgia,serif; font-size: 1rem; }
        .modal-content select { cursor: pointer; height: 44px; padding: 0 10px;}
        .modal-content textarea { resize: vertical; min-height: 80px; }
        .modal-content .modal-buttons { margin-top: 20px; text-align: right; display: flex; justify-content: flex-end; gap: 10px; flex-shrink: 0; border-top: 1px solid var(--gold); padding-top: 15px; }
        .modal-content button { background-color: var(--gold); color: var(--ink); border: none; padding: 10px 18px; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; font-family: 'Cinzel Decorative',cursive; font-weight: bold; }
        .modal-content button:hover { background-color: var(--crimson); color: white; }
        .modal-content button.cancel-button { background-color: var(--ink-light); color: var(--parchment); }
        .modal-content button.cancel-button:hover { background-color: var(--ink); }
        .provider-selector { display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; align-items: flex-end; }
        .provider-selector > div { flex: 1; min-width: 150px; }
        .api-key-manager { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-top: 5px; }
        .api-key-manager input[type="password"] { flex-grow: 1; min-width: 200px; }
        .api-key-manager button { padding: 8px 12px; font-size: 0.9em; height: 44px; flex-shrink: 0; }
        .api-key-status { font-size: 0.9em; color: var(--ink-light); margin-top: 5px; flex-basis: 100%; }
        #clear-keys-button { background-color: var(--crimson); color: white; margin-left: auto; }
        #clear-keys-button:hover { background-color: darkred; }
        #code-edit-modal .modal-content { max-width: 650px; }
        #edit-snippet-textarea { font-family: Consolas, Monaco, monospace; min-height: 150px; max-height: 40vh; flex-grow: 1; flex-shrink: 1; overflow-y: auto; margin-bottom: 5px; background-color: white; }
        .modal-content .line-inputs { display: flex; gap: 15px; align-items: center; margin-bottom: 10px; flex-shrink: 0; flex-wrap: wrap; }
        .modal-content .line-inputs div { flex-grow: 1; min-width: 80px; }
        .modal-content .line-inputs input[type="number"] { width: 100%; padding: 8px; }
        #edit-snippet-counter { font-size: 0.9em; color: var(--ink-light); text-align: right; margin-bottom: 15px; flex-shrink: 0; flex-basis: 100%; }
        #edit-snippet-line-count { font-weight: bold; color: var(--ink); }
        .edit-context-note { font-style: italic; color: var(--ink-light); font-size: 0.85em; margin-bottom: 15px; flex-shrink: 0; border-top: 1px dashed var(--ink-light); padding-top: 10px; margin-top: 5px; }
        .edit-instructions-area { flex-shrink: 0; margin-bottom: 15px; }
        .edit-instructions-controls { display: flex; gap: 8px; align-items: center; margin-top: 5px; }
        #edit-instructions { width: 100%; min-height: 60px; max-height: 25vh; resize: vertical; background-color: white; }
        .modal-content .small-button { padding: 4px 8px; font-size: 0.8em; height: auto; background-color: var(--ink-light); color: var(--parchment); border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s ease; font-family: Georgia,serif; flex-shrink: 0; }
        .modal-content .small-button:hover { background-color: var(--ink); }
        #edit-response-count { width: 40px; padding: 6px; font-size: 0.9rem; height: auto; border: 1px solid var(--ink-light); margin-left: auto; background-color: white; }
        #html-runner-modal .modal-content { max-width: 90vw; width: 85%; }
        .html-runner-container { display: flex; flex-grow: 1; gap: 15px; min-height: 0; margin-bottom: 15px; }
        .runner-editor, .runner-preview { flex: 1; display: flex; flex-direction: column; border: 1px solid var(--ink-light); border-radius: 5px; background-color: var(--parchment-dark); overflow: hidden; }
        .runner-header { margin: 0; padding: 8px 12px; background-color: var(--ink-light); color: var(--parchment); border-bottom: 1px solid var(--ink); font-size: 0.9em; font-weight: bold; flex-shrink: 0; text-align: center; }
        #html-runner-input { flex: 1; border: none; padding: 10px; font-family: Consolas, Monaco, monospace; font-size: 0.9em; resize: none; outline: none; background-color: white; color: var(--ink); }
        #html-runner-frame { flex: 1; border: none; width: 100%; height: 100%; background-color: white; }
        #html-runner-modal .modal-buttons button { padding: 8px 15px; }
        .message-content pre { border: 1px solid var(--code-border); background-color: var(--code-bg); position: relative; margin-top: 10px; margin-bottom: 5px; }
        .message-content pre code.hljs { display: block; overflow-x: auto; padding: 1em; background: transparent; color: var(--ink); border-radius: 5px; }
        .hljs-comment, .hljs-quote { color: #7a7061; font-style: italic; }
        .hljs-keyword, .hljs-selector-tag, .hljs-subst { color: var(--crimson); font-weight: bold; }
        .hljs-number, .hljs-literal, .hljs-variable, .hljs-template-variable, .hljs-tag .hljs-attr { color: var(--sapphire); }
        .hljs-string, .hljs-doctag { color: #4b8350; }
        .hljs-title, .hljs-section, .hljs-selector-id { color: var(--gold); font-weight: bold; }
        .message-content code:not(.hljs) { background-color: var(--code-bg); border: 1px solid var(--code-border); padding: 0.2em 0.4em; border-radius: 3px; font-size: 85%; font-family: Consolas, Monaco, monospace; }
        .cat-placeholder { display: none; font-size: 1.2em; cursor: default; user-select: none; padding: 2px 5px; background-color: var(--parchment-dark); border-radius: 3px; border: 1px solid var(--ink-light); margin-right: 5px; margin-bottom: 3px; }
        .message-actions { margin-top: 8px; text-align: left; display: flex; gap: 5px; flex-wrap: wrap; }
        .action-button { background-color: var(--ink-light); color: var(--parchment); border: none; padding: 4px 8px; font-size: 0.8em; border-radius: 4px; cursor: pointer; opacity: 0.9; transition: opacity 0.2s ease, background-color 0.2s ease; font-family: Georgia,serif; }
        .action-button:hover { opacity: 1; background-color: var(--ink); }
        .copy-code-button.copied { background-color: #3a9a41; color: white; }
        .download-code-button { background-color: #17a2b8; }
        .download-code-button:hover { background-color: #138496; }
        .run-html-button { background-color: var(--emerald); }
        .run-html-button:hover { background-color: darkgreen; }
        .tome.code-hidden .message pre { display: none; }
        .tome.code-hidden .message .cat-placeholder { display: inline-block; }
        .download-code-button { display: none; }
        .tome.download-code-active .download-code-button { display: inline-block; }
        .run-html-button { display: none; }
        .tome.run-html-active .run-html-button { display: inline-block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @media (max-width: 768px) { /* ... (responsive styles mostly unchanged) ... */
            body { font-size: 1rem; } .pages { padding: 15px; } .message { max-width: 95%; } .message-content { padding: 10px 15px; } .writing-area { padding: 10px; flex-direction: column; align-items: stretch; } .message-input { flex-basis: 100%; margin-right: 0; } .writing-controls { width: 100%; justify-content: space-between; margin-left: 0; margin-top: 8px; flex-wrap: wrap; } .footer-button { font-size: 0.8em; padding: 6px 8px; height: 40px; margin-bottom: 5px; } .response-count-input { height: 40px; margin-bottom: 5px; } .send-button { height: 45px; padding: 0 15px; font-size: 1rem; flex-grow: 1; margin-top: 5px;} .avatar { width: 40px; height: 40px; } .modal-content { padding: 15px; width: 95%; } .modal-content .form-group { flex-direction: column; align-items: flex-start; } .modal-content .form-group > div { width: auto; margin-bottom: 5px; } .provider-selector { flex-direction: column; align-items: stretch; gap: 10px; } .api-key-manager { gap: 5px; } .api-key-manager button { font-size: 0.85em; padding: 6px 10px; height: 40px;} .api-key-manager input[type="password"] { height: 40px; } #clear-keys-button { margin-left: 0; width: 100%; margin-top: 5px; } .modal-content .line-inputs { flex-direction: column; align-items: stretch; gap: 10px; } .modal-content .line-inputs input[type="number"] { width: 100%; } .edit-instructions-controls { flex-wrap: wrap; } #edit-response-count { margin-left: 0; margin-top: 5px;} .html-runner-container { flex-direction: column; } .runner-editor, .runner-preview { min-height: 35vh; } #html-runner-modal .modal-content { max-width: 95vw; }
         }
        .visually-hidden { position: absolute !important; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px); white-space: nowrap; }
    </style>
</head>
<body>
    <!-- Arcane Tome Structure -->
    <div class="tome" id="chat-container">
        <div class="pages" id="pages"></div>
        <div class="writing-area">
            <textarea class="message-input" id="message-input" placeholder="Inscribe thy query..." rows="1"></textarea>
            <div class="writing-controls">
                 <button id="settings-button" class="footer-button" title="Settings"> <i class="fas fa-cog"></i> </button>
                 <button id="upload-file-button" class="footer-button" title="Attach Parchment (No logic yet)"> <i class="fas fa-paperclip"></i> </button>
                 <button id="add-iterator-button" class="footer-button" title="Insert {i}">Add {i}</button>
                 <button id="clear-chat-button" class="footer-button" title="Clear Scroll">Clear</button>
                 <button id="edit-code-button" class="footer-button" title="Edit Snippet">Edit</button>
                 <input type="number" class="response-count-input" id="main-response-count" value="1" min="0" max="5" title="Responses (0 to send no query)">
                 <button class="send-button" id="send-button" title="Send Query"> <span>Send</span> <span>âœ’</span> </button>
            </div>
        </div>
    </div>

     <!-- Settings Modal -->
    <div class="modal-overlay" id="system-prompt-modal">
         <div class="modal-content">
             <h3>Tome Settings</h3>
             <div class="provider-selector form-group">
                 <div> <label for="provider-select">Spirit Provider:</label> <select id="provider-select"></select> </div>
                 <div> <label for="model-select">Spirit Model:</label> <select id="model-select"></select> </div>
             </div>
             <div class="form-group">
                 <label for="api-key-input">Add Spirit Essence (API Key) for <span id="selected-provider-label">Provider</span>:</label>
                 <div class="api-key-manager">
                      <input type="password" id="api-key-input" placeholder="Paste new key...">
                      <button id="add-key-button" title="Add this key to the list for the selected provider">Add Key</button>
                      <button id="clear-keys-button" title="Remove all stored keys for the selected provider">Clear Keys for Provider</button>
                 </div>
                 <span id="api-key-status" class="api-key-status">Keys Loaded: 0</span>
             </div>
             <div class="form-group">
                 <label for="system-prompt-input">Spirit's Nature (System Prompt):</label>
                 <textarea id="system-prompt-input" placeholder="Define the spirit's core nature..."></textarea>
             </div>
             <div class="form-group">
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="hide-code-checkbox"> <label for="hide-code-checkbox">Veil Glyphs</label> </div>
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="download-code-checkbox"> <label for="download-code-checkbox">Enable Download</label> </div>
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="enable-run-html-checkbox"> <label for="enable-run-html-checkbox">Enable Run HTML</label> </div>
             </div>
             <div class="modal-buttons">
                <button id="cancel-settings" class="cancel-button">Cancel</button>
                <button id="save-settings-button">Seal Settings</button>
             </div>
         </div>
    </div>

    <!-- Code Edit Modal -->
    <div class="modal-overlay" id="code-edit-modal">
        <div class="modal-content">
            <h3>Transcribe & Alter Glyphs</h3>
            <p style="font-size: 0.9em; color: var(--ink-light); margin-bottom: 10px; flex-shrink: 0;">Inscribe the glyphs below. Select lines for alteration.</p>
            <textarea id="edit-snippet-textarea" placeholder="Place glyphs here..."></textarea>
            <p class="edit-context-note"> Only the selected lines are sent. Context should be included in previous messages. </p>
            <div class="line-inputs">
                 <div> <label for="edit-start-line">Start Line:</label> <input type="number" id="edit-start-line" min="1" value="1"> </div>
                 <div> <label for="edit-end-line">End Line:</label> <input type="number" id="edit-end-line" min="1" value="1"> </div>
                 <div id="edit-snippet-counter" style="margin-left: auto;"> Lines: <span id="edit-snippet-line-count">0</span> </div>
            </div>
            <div class="edit-instructions-area">
                <label for="edit-instructions">Instructions for Spirit (applies to selected lines):</label>
                <textarea id="edit-instructions" rows="3" placeholder="e.g., Reforge these lines, mend the flaw..."></textarea>
                <div class="edit-instructions-controls">
                    <button id="edit-add-iterator-button" class="small-button" title="Insert {i}">Add {i}</button>
                    <label for="edit-response-count" style="margin-left: auto; flex-basis: auto; margin-bottom: 0; font-weight: normal; color: var(--ink-light); font-size: 0.9em;">Variations:</label>
                    <input type="number" class="response-count-input" id="edit-response-count" value="1" min="1" max="5" title="Number of edit variations">
                </div>
            </div>
            <div class="modal-buttons">
                <button id="cancel-edit-request" class="cancel-button">Cancel</button>
                <button id="send-edit-request">Request Alteration</button>
            </div>
        </div>
    </div>

    <!-- HTML Runner Modal -->
    <div class="modal-overlay" id="html-runner-modal">
        <div class="modal-content">
            <h3>HTML Runner</h3>
            <div class="html-runner-container">
                 <div class="runner-editor"> <div class="runner-header">HTML Input</div> <textarea id="html-runner-input" placeholder="Paste HTML code here..."></textarea> </div>
                 <div class="runner-preview"> <div class="runner-header">Preview</div> <iframe id="html-runner-frame" title="HTML Output Preview" sandbox="allow-scripts allow-same-origin"></iframe> </div>
            </div>
             <div class="modal-buttons">
                 <button id="html-runner-render-button">Render</button>
                 <button id="html-runner-close-button" class="cancel-button">Close</button>
             </div>
        </div>
    </div>

    <!-- Hidden Helpers -->
    <textarea class="visually-hidden" id="copy-helper" aria-hidden="true"></textarea>
    <input type="file" id="file-upload-input" accept="*/*" style="display:none;">
    <input type="file" class="pfp-upload" accept="image/*" style="display:none;">


    <script>
        // --- Global State & Constants ---
        let conversationHistory = [];
        let userPfp = localStorage.getItem('userPfp') || 'https://ui-avatars.com/api/?name=U&background=1e3a8a&color=fff&font-size=0.6&bold=true';
        let botPfp = localStorage.getItem('botPfp') || 'https://ui-avatars.com/api/?name=S&background=6b21a8&color=fff&font-size=0.6&bold=true';
        let currentPfpElementToUpdate = null;
        let turnCounter = 0;
        const iterationPlaceholder = '{i}';
        const DEFAULT_SYSTEM_PROMPT = 'You are a mystical spirit from another realm...'; // Shortened for brevity

        // --- Provider/Key State (Initialized in initialLoad) ---
        let selectedProvider = '';
        let selectedModel = '';
        let apiKeys = {}; // { providerName: ['key1', 'key2'], ... }
        let currentApiKeyIndex = {}; // { providerName: index, ... }

        // --- Other State ---
        let hideCodeBlocks = true; // Default values set in initialLoad from localStorage
        let downloadCodeMode = false;
        let enableRunHtmlMode = false;
        let isWaitingForResponse = false;

        // --- DOM Elements ---
        const chatContainerElement = document.getElementById('chat-container');
        const pages = document.getElementById('pages');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const mainResponseCountInput = document.getElementById('main-response-count');
        const pfpUploadInput = document.querySelector('.pfp-upload');
        // Settings Modal
        const settingsButton = document.getElementById('settings-button');
        const systemPromptModal = document.getElementById('system-prompt-modal');
        const providerSelect = document.getElementById('provider-select');
        const modelSelect = document.getElementById('model-select');
        const selectedProviderLabel = document.getElementById('selected-provider-label');
        const systemPromptInput = document.getElementById('system-prompt-input');
        const apiKeyInput = document.getElementById('api-key-input');
        const addKeyButton = document.getElementById('add-key-button');
        const clearKeysButton = document.getElementById('clear-keys-button');
        const apiKeyStatus = document.getElementById('api-key-status');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const hideCodeCheckbox = document.getElementById('hide-code-checkbox');
        const downloadCodeCheckbox = document.getElementById('download-code-checkbox');
        const enableRunHtmlCheckbox = document.getElementById('enable-run-html-checkbox');
        const cancelSettingsButton = document.getElementById('cancel-settings');
        // Code Edit Modal
        const editCodeButton = document.getElementById('edit-code-button');
        const codeEditModal = document.getElementById('code-edit-modal');
        const editSnippetTextarea = document.getElementById('edit-snippet-textarea');
        const editStartLineInput = document.getElementById('edit-start-line');
        const editEndLineInput = document.getElementById('edit-end-line');
        const editSnippetLineCount = document.getElementById('edit-snippet-line-count');
        const editInstructionsInput = document.getElementById('edit-instructions');
        const editAddIteratorButton = document.getElementById('edit-add-iterator-button');
        const editResponseCountInput = document.getElementById('edit-response-count');
        const sendEditRequestButton = document.getElementById('send-edit-request');
        const cancelEditRequestButton = document.getElementById('cancel-edit-request');
        // HTML Runner Modal
        const htmlRunnerModal = document.getElementById('html-runner-modal');
        const htmlRunnerInput = document.getElementById('html-runner-input');
        const htmlRunnerFrame = document.getElementById('html-runner-frame');
        const htmlRunnerRenderButton = document.getElementById('html-runner-render-button');
        const htmlRunnerCloseButton = document.getElementById('html-runner-close-button');
        // Other Controls
        const clearChatButton = document.getElementById('clear-chat-button');
        const addIteratorButton = document.getElementById('add-iterator-button');
        const uploadFileButton = document.getElementById('upload-file-button');
        const fileUploadInput = document.getElementById('file-upload-input');
        // Helpers
        const copyHelper = document.getElementById('copy-helper');


        // --- Configure Markdown & Highlighting ---
        marked.setOptions({ highlight:function(c,l){const lang=hljs.getLanguage(l)?l:'plaintext';try{return hljs.highlight(c,{language:lang,ignoreIllegals:true}).value;}catch(e){return hljs.highlight(c,{language:'plaintext',ignoreIllegals:true}).value;}},langPrefix:'hljs language-',gfm:true,breaks:true });

        // --- PFP Handling ---
        pfpUploadInput.addEventListener('change', function(event) { const f=event.target.files[0];if(!f||!currentPfpElementToUpdate)return;const r=new FileReader();r.onload=function(e){const u=e.target.result;currentPfpElementToUpdate.src=u;const t=currentPfpElementToUpdate.closest('.avatar').dataset.senderType; if(t==='user'){userPfp=u;localStorage.setItem('userPfp',u);document.querySelectorAll('.avatar.user-avatar img').forEach(i=>i.src=u);}else if(t==='spirit'){botPfp=u;localStorage.setItem('botPfp',u);document.querySelectorAll('.avatar.spirit-avatar img').forEach(i=>i.src=u);}currentPfpElementToUpdate=null;};r.readAsDataURL(f); });

        // --- Event Listeners ---
        // NOTE: Listeners are attached AFTER DOM elements are defined.
        // Make sure the DOM is ready or wrap listener attachments in DOMContentLoaded if needed,
        // but standard script placement at the end usually suffices.
        sendButton.addEventListener('click', handleSendMessage);
        messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } });
        messageInput.addEventListener('input', autoGrowTextarea);
        settingsButton.addEventListener('click', openSystemPromptModal);
        providerSelect.addEventListener('change', handleProviderChange);
        modelSelect.addEventListener('change', handleModelChange);
        addKeyButton.addEventListener('click', addApiKey);
        clearKeysButton.addEventListener('click', clearApiKeysForProvider);
        saveSettingsButton.addEventListener('click', saveSettings);
        if (cancelSettingsButton) cancelSettingsButton.addEventListener('click', () => systemPromptModal.style.display = 'none');
        systemPromptModal.addEventListener('click', (e) => { if (e.target === systemPromptModal) { systemPromptModal.style.display = 'none'; } });
        hideCodeCheckbox.addEventListener('change', handleHideCodeToggle);
        downloadCodeCheckbox.addEventListener('change', handleDownloadCodeToggle);
        enableRunHtmlCheckbox.addEventListener('change', handleEnableRunHtmlToggle);
        editCodeButton.addEventListener('click', openEditCodeModal);
        sendEditRequestButton.addEventListener('click', handleSendEditRequest);
        cancelEditRequestButton.addEventListener('click', () => codeEditModal.style.display = 'none');
        codeEditModal.addEventListener('click', (e) => { if (e.target === codeEditModal) { codeEditModal.style.display = 'none'; } });
        editSnippetTextarea.addEventListener('input', updateSnippetLineCount);
        editAddIteratorButton.addEventListener('click', () => insertIteratorPlaceholder(editInstructionsInput));
        htmlRunnerRenderButton.addEventListener('click', renderRunnerHTML);
        htmlRunnerCloseButton.addEventListener('click', () => htmlRunnerModal.style.display = 'none');
        htmlRunnerModal.addEventListener('click', (e) => { if (e.target === htmlRunnerModal) { htmlRunnerModal.style.display = 'none'; } });
        clearChatButton.addEventListener('click', handleClearChat);
        addIteratorButton.addEventListener('click', () => insertIteratorPlaceholder(messageInput));
        uploadFileButton.addEventListener('click', () => fileUploadInput.click());


        // --- API Key Management Functions (Provider Specific) ---
        function updateApiKeyStatus(provider = selectedProvider) {
            // Ensure provider key exists in apiKeys before accessing length
            const keysForProvider = apiKeys[provider] || [];
            const count = keysForProvider.length;
            if (apiKeyStatus) { // Check if element exists
                 apiKeyStatus.textContent = `Keys Loaded: ${count}`;
            }
             if(selectedProviderLabel) { // Check if element exists
                 selectedProviderLabel.textContent = (PROVIDERS[provider]?.name || provider) ?? 'Unknown Provider';
             }
            // Disable send button if selected provider has no keys (and button exists)
            if (sendButton) {
                 sendButton.disabled = count === 0 || isWaitingForResponse;
            }
        }

        function addApiKey() {
             const provider = selectedProvider;
            const newKey = apiKeyInput.value.trim();
            if (!provider) { alert("Please select a provider first."); return; }
            if (!PROVIDERS[provider]) { alert(`Invalid provider selected: ${provider}`); return; } // Check provider validity

            // Check if the provider requires API keys from the client
             const providerConfig = PROVIDERS[provider];
            if (providerConfig.apiKeyLocation === 'none' && providerConfig.format !== 'proxy_compatible') {
                 alert(`${providerConfig.name} does not require client-side API keys.`);
                 apiKeyInput.value = '';
                 return;
            }

            if (newKey) {
                 if (!apiKeys[provider]) { apiKeys[provider] = []; }
                if (!apiKeys[provider].includes(newKey)) {
                    apiKeys[provider].push(newKey);
                    apiKeyInput.value = '';
                    updateApiKeyStatus(provider);
                    console.log(`Added key for ${provider}. Total keys for provider: ${apiKeys[provider].length}`);
                } else {
                     alert(`This API key is already in the list for ${providerConfig.name}.`);
                }
            } else {
                 alert("Please paste an API key before adding.");
            }
        }

        function clearApiKeysForProvider() {
             const provider = selectedProvider;
            if (!provider || !PROVIDERS[provider]) { alert("Please select a valid provider first."); return; }
            const providerName = PROVIDERS[provider]?.name || provider;

            if (confirm(`Are you sure you want to remove ALL keys for ${providerName}?`)) {
                apiKeys[provider] = [];
                currentApiKeyIndex[provider] = 0;
                updateApiKeyStatus(provider);
                console.log(`Cleared all API keys for ${provider}.`);
            }
        }

        function getNextApiKey(provider) {
             const keysForProvider = apiKeys[provider] || [];
             const providerConfig = PROVIDERS[provider];

             // Return null immediately if the provider doesn't need a key sent from here
             if (providerConfig && providerConfig.apiKeyLocation === 'none' && providerConfig.format !== 'proxy_compatible') {
                  console.log(`Provider ${provider} does not use client-side keys.`);
                  return null;
             }
             // If it's proxy_compatible, it *might* still use keys internally, but we don't send one.
             // The original `getApiResponse` handles not sending the key for proxy.

            if (keysForProvider.length === 0) {
                console.error(`No API keys available for provider: ${provider}`);
                return null; // Explicitly return null if no keys for this provider
            }

            let index = currentApiKeyIndex[provider] || 0;
            if (index >= keysForProvider.length) { index = 0; }
            const keyToUse = keysForProvider[index];
            currentApiKeyIndex[provider] = (index + 1) % keysForProvider.length;

            try { localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex)); }
            catch (e) { console.warn("Could not save API key index object:", e); }
            return keyToUse;
        }

        function hasSelectedProviderApiKeys() {
             // Check if the provider *requires* keys first
            const providerConfig = PROVIDERS[selectedProvider];
            if (!providerConfig) return false; // Invalid provider selected
            if (providerConfig.apiKeyLocation === 'none' && providerConfig.format !== 'proxy_compatible') {
                 return true; // No keys needed, so effectively "has keys"
            }
             // Otherwise, check if keys actually exist for this provider
             const keysForCurrent = apiKeys[selectedProvider] || [];
             return keysForCurrent.length > 0;
        }


        // --- Core Functions (Modified for Provider/Model Selection & API Call) ---
        async function handleSendMessage() {
            if (!hasSelectedProviderApiKeys()) {
                 alert(`No API Key loaded for ${PROVIDERS[selectedProvider]?.name || selectedProvider}. Please add one in Settings (or provider doesn't require one).`);
                 return;
            }
            if (isWaitingForResponse) return;

            const userInput = messageInput.value.trim();
            const responseCount = parseInt(mainResponseCountInput.value, 10);
            if (userInput === '') return;
            const numResponses = isNaN(responseCount) || responseCount < 0 ? 0 : Math.min(responseCount, 5);
            const turnId = `turn-${turnCounter++}`;
            const containsPlaceholder = userInput.includes(iterationPlaceholder);

            isWaitingForResponse = true;
            sendButton.disabled = true;
            messageInput.value = '';
            autoGrowTextarea();

            const userEntry = { role: 'user', content: userInput, turnId: turnId };
            conversationHistory.push(userEntry);
            displayMessage(userEntry, 'user');
            saveHistoryToLocalStorage();
            scrollToBottom();

            if (numResponses > 0) {
                showTypingIndicator();
                // Prepare history *once* - note: system prompt handling might differ per provider
                // getApiResponse might filter system prompt if needed by the provider
                const baseHistory = prepareHistoryForApi(conversationHistory);
                const responses = [];
                let errorOccurred = false;
                const provider = selectedProvider; // Capture current selections
                const model = selectedModel;

                console.log(`Sending ${numResponses} requests to ${provider} (${model})`);

                for (let i = 0; i < numResponses; i++) {
                    const iteration = i + 1;
                    const currentKey = getNextApiKey(provider); // Rotate key for this provider

                    // Basic check before calling getApiResponse
                    const providerConfigCheck = PROVIDERS[provider];
                     if (!providerConfigCheck) { responses.push(`[Config Error: Provider '${provider}' missing]`); errorOccurred = true; break; }
                     // Check if required key is missing (getApiResponse also checks)
                     if (providerConfigCheck.apiKeyLocation !== 'none' && providerConfigCheck.format !== 'proxy_compatible' && !currentKey) {
                         responses.push(`[Config Error: No Key for ${provider}]`); errorOccurred = true; break;
                     }

                    let currentHistory = [...baseHistory]; // Use base history for each call
                    if (containsPlaceholder && numResponses > 1) {
                        const userMessageIndex = currentHistory.length - 1;
                        if (currentHistory[userMessageIndex]?.role === 'user') {
                            const substitutedContent = currentHistory[userMessageIndex].content.replace( new RegExp(iterationPlaceholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g'), iteration.toString() );
                            currentHistory[userMessageIndex] = { ...currentHistory[userMessageIndex], content: substitutedContent };
                        }
                    }

                    try {
                        // Call the central API function
                        const messageContent = await getApiResponse(
                            provider, model, currentHistory, currentKey,
                            { temperature: 0.7, top_p: 0.9 }
                        );
                        responses.push(messageContent || "[Silence]");
                    } catch (e) {
                        console.error(`API Call Error (Provider: ${provider}, Model: ${model}, Key Index Approx: [...], Response ${iteration}):`, e);
                        responses.push(`[Spirit Disturbance: ${e instanceof Error ? e.message : String(e)}]`);
                        errorOccurred = true;
                    }
                } // end for loop

                hideTypingIndicator();

                if (responses.length > 0) {
                    const botEntry = { role: 'assistant', variants: responses, selectedIndex: 0, turnId: turnId };
                    conversationHistory.push(botEntry);
                    saveHistoryToLocalStorage();
                    displayBotMessage(botEntry, 'spirit');
                    scrollToBottom();
                }
            } else {
                console.log("Query added to history, 0 responses requested.");
            }

            isWaitingForResponse = false;
            sendButton.disabled = !hasSelectedProviderApiKeys();
            messageInput.focus();
        }

        async function handleSendEditRequest() {
             if (!hasSelectedProviderApiKeys()) { alert(`No API Key loaded for ${PROVIDERS[selectedProvider]?.name || selectedProvider}...`); return; }
             if (isWaitingForResponse) return;

            const pastedCode = editSnippetTextarea.value; /* ... validation ... */
             const startLine = parseInt(editStartLineInput.value, 10);
            const endLine = parseInt(editEndLineInput.value, 10);
            const instructions = editInstructionsInput.value.trim();
            const numVariations = parseInt(editResponseCountInput.value, 10);

            if (pastedCode.trim() === '') { alert("Please inscribe the glyphs..."); return; }
            if (!instructions) { alert("Instructions are required."); return; }
            const pastedLines = pastedCode.split('\n'); const totalLines = pastedLines.length;
            if (isNaN(startLine) || isNaN(endLine) || startLine < 1 || endLine < startLine || endLine > totalLines) { alert(`Invalid line selection...`); return; }
            const numResponses = isNaN(numVariations) || numVariations < 1 ? 1 : Math.min(numVariations, 5);
            const containsPlaceholder = instructions.includes(iterationPlaceholder);

            codeEditModal.style.display = 'none';
            isWaitingForResponse = true;
            sendButton.disabled = true; // Disable send button too during edit

            const turnId = `turn-${turnCounter++}`; /* ... display user request ... */
            const userRequestSummary = `[Glyph Alteration Request]...`;
            const userEntry = { role: 'user', content: userRequestSummary, turnId: turnId };
            conversationHistory.push(userEntry); displayMessage(userEntry, 'user'); saveHistoryToLocalStorage(); scrollToBottom(); showTypingIndicator();


            const startIndex = startLine - 1; const endIndex = endLine;
            const snippetToAlter = pastedLines.slice(startIndex, endIndex).join('\n');
            const historyUpToEdit = conversationHistory.slice(0, -1);
            const baseApiHistory = prepareHistoryForApi(historyUpToEdit);
            const editResponses = [];
            let errorOccurred = false;
            const provider = selectedProvider; // Capture current selections
            const model = selectedModel;

            console.log(`Sending ${numResponses} EDIT requests to ${provider} (${model})`);

            for (let i = 0; i < numResponses; i++) {
                const iteration = i + 1;
                const currentKey = getNextApiKey(provider); // Rotate key
                const providerConfigCheck = PROVIDERS[provider];
                 if (!providerConfigCheck) { /* ... error handling ... */ responses.push(`[Config Error: Provider '${provider}' missing]`); errorOccurred = true; break; }
                 if (providerConfigCheck.apiKeyLocation !== 'none' && providerConfigCheck.format !== 'proxy_compatible' && !currentKey) { /* ... error handling ... */ responses.push(`[Config Error: No Key for ${provider}]`); errorOccurred = true; break; }

                let currentInstructions = instructions;
                if (containsPlaceholder && numResponses > 1) { currentInstructions = instructions.replace( new RegExp(iterationPlaceholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g'), iteration.toString() ); }
                const prompt = `Alter lines ${startLine}-${endLine}...\n\`\`\`\n${snippetToAlter}\n\`\`\`\nInstructions: ${currentInstructions}\nReturn ONLY altered lines.`;
                let apiHistoryForThisCall = [...baseApiHistory, { role: 'user', content: prompt }];

                try {
                    const rawResponse = await getApiResponse( provider, model, apiHistoryForThisCall, currentKey, { temperature: 0.5, top_p: 0.9 });
                    const editedLines = rawResponse.split('\n');
                    const reconstructedLines = [ ...pastedLines.slice(0, startIndex), ...editedLines, ...pastedLines.slice(endIndex) ];
                    editResponses.push(reconstructedLines.join('\n'));
                } catch (e) {
                    console.error(`Edit Request API Error (Provider: ${provider}, Model: ${model}, Key Index Approx: [...], Variation ${iteration}):`, e);
                    const errorMarker = `--- ERROR Altering Variation ${iteration} ---\n${e instanceof Error ? e.message : String(e)}\n--- ORIGINAL LINES ${startLine}-${endLine} ---`;
                    const reconstructedLines = [ ...pastedLines.slice(0, startIndex), errorMarker, ...pastedLines.slice(startIndex, endIndex), ...pastedLines.slice(endIndex) ];
                    editResponses.push(reconstructedLines.join('\n'));
                    errorOccurred = true;
                }
            } // end for loop

            hideTypingIndicator();
            const botEntry = { role: 'assistant', variants: editResponses, selectedIndex: 0, turnId: turnId, isCodeEdit: true };
            conversationHistory.push(botEntry);
            saveHistoryToLocalStorage();
            displayBotMessage(botEntry, 'spirit');

            isWaitingForResponse = false;
            sendButton.disabled = !hasSelectedProviderApiKeys(); // Re-enable based on keys
            scrollToBottom();
        }

        // --- Provider/Model Selection Handlers ---
        function populateProviderSelect() {
            providerSelect.innerHTML = '';
            if (typeof PROVIDERS === 'undefined' || Object.keys(PROVIDERS).length === 0) {
                 console.error("PROVIDERS object not found or empty. Check api_providers.js");
                 providerSelect.innerHTML = '<option value="" disabled>Error loading providers</option>';
                 return; // Stop if providers aren't loaded
            }
            for (const providerKey in PROVIDERS) {
                const option = document.createElement('option');
                option.value = providerKey;
                option.textContent = PROVIDERS[providerKey].name || providerKey;
                providerSelect.appendChild(option);
            }
            // Ensure selectedProvider is valid, otherwise default
            if (!PROVIDERS[selectedProvider]) {
                 selectedProvider = Object.keys(PROVIDERS)[0];
                 localStorage.setItem('selectedProvider', selectedProvider);
            }
            providerSelect.value = selectedProvider;
            populateModelSelect(selectedProvider); // Populate models for the initial/selected provider
        }

        function populateModelSelect(providerKey) {
            modelSelect.innerHTML = '';
            const providerConf = PROVIDERS[providerKey];
            if (!providerConf || !providerConf.availableModels || providerConf.availableModels.length === 0) {
                 modelSelect.innerHTML = '<option value="" disabled>No models listed</option>';
                 selectedModel = ''; localStorage.setItem('selectedModel', ''); return;
            }
            providerConf.availableModels.forEach(modelKey => {
                const option = document.createElement('option');
                option.value = modelKey; option.textContent = modelKey; modelSelect.appendChild(option);
            });
            // Load saved model for this provider, or default, or first
            const savedModel = localStorage.getItem('selectedModel'); // Generic model save
            if (savedModel && providerConf.availableModels.includes(savedModel)) {
                 modelSelect.value = savedModel; selectedModel = savedModel;
            } else if (providerConf.defaultModel && providerConf.availableModels.includes(providerConf.defaultModel)) {
                 modelSelect.value = providerConf.defaultModel; selectedModel = providerConf.defaultModel;
            } else { modelSelect.selectedIndex = 0; selectedModel = providerConf.availableModels[0]; }
            localStorage.setItem('selectedModel', selectedModel); // Save the determined model
        }

        function handleProviderChange() {
            selectedProvider = providerSelect.value;
            localStorage.setItem('selectedProvider', selectedProvider);
            populateModelSelect(selectedProvider); // This now sets and saves selectedModel
            updateApiKeyStatus(selectedProvider);
            sendButton.disabled = !hasSelectedProviderApiKeys() || isWaitingForResponse;
        }

        function handleModelChange() {
             selectedModel = modelSelect.value;
             localStorage.setItem('selectedModel', selectedModel);
             console.log(`Model set to: ${selectedModel} for provider ${selectedProvider}`);
         }

        // --- Settings Modal & Other Handlers ---
        function openSystemPromptModal() {
            systemPromptInput.value=conversationHistory[0]?.content || localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
            populateProviderSelect(); // Populates both provider and model dropdowns
            updateApiKeyStatus(selectedProvider); // Update key count for the selected provider
            apiKeyInput.value = ''; // Clear the input field
            hideCodeCheckbox.checked=hideCodeBlocks;
            downloadCodeCheckbox.checked=downloadCodeMode;
            enableRunHtmlCheckbox.checked=enableRunHtmlMode;
            systemPromptModal.style.display='flex';
         }

        function saveSettings() { /* ... (unchanged from previous multi-key version) ... */
            const sp = systemPromptInput.value.trim() || DEFAULT_SYSTEM_PROMPT;
            if(conversationHistory.length === 0 || conversationHistory[0]?.role !== 'system'){ conversationHistory.unshift({role:'system', content:sp}); }
            else { conversationHistory[0].content = sp; }
            localStorage.setItem('systemPrompt', sp);
            localStorage.setItem('selectedProvider', selectedProvider);
            localStorage.setItem('selectedModel', selectedModel);
            try {
                localStorage.setItem('apiKeys', JSON.stringify(apiKeys));
                localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex));
                console.log(`Settings saved. Provider: ${selectedProvider}, Model: ${selectedModel}`);
            } catch (e) { console.error("Failed to save API keys/indices:", e); alert("Error saving API keys/indices."); }
            saveHistoryToLocalStorage();
            sendButton.disabled = !hasSelectedProviderApiKeys();
            systemPromptModal.style.display = 'none';
        }

        function handleHideCodeToggle() { /* ... (unchanged) ... */ hideCodeBlocks=hideCodeCheckbox.checked;localStorage.setItem('hideCodeBlocks',hideCodeBlocks);chatContainerElement.classList.toggle('code-hidden',hideCodeBlocks); }
        function handleDownloadCodeToggle() { /* ... (unchanged) ... */ downloadCodeMode=downloadCodeCheckbox.checked;localStorage.setItem('downloadCodeMode',downloadCodeMode);chatContainerElement.classList.toggle('download-code-active',downloadCodeMode); }
        function handleEnableRunHtmlToggle() { /* ... (unchanged) ... */ enableRunHtmlMode=enableRunHtmlCheckbox.checked; localStorage.setItem('enableRunHtmlMode',enableRunHtmlMode); chatContainerElement.classList.toggle('run-html-active',enableRunHtmlMode); }
        function handleClearChat() { /* ... (unchanged) ... */ if(confirm("Disperse echoes?")){const sp=conversationHistory[0]?.content||localStorage.getItem('systemPrompt')||DEFAULT_SYSTEM_PROMPT;conversationHistory=[{role:'system',content:sp}];turnCounter=1;saveHistoryToLocalStorage();rebuildChatFromHistory();} }
        function insertIteratorPlaceholder(targetInput) { /* ... (unchanged) ... */ if (!targetInput) return; const start = targetInput.selectionStart; const end = targetInput.selectionEnd; const value = targetInput.value; const newValue = value.substring(0, start) + iterationPlaceholder + value.substring(end); targetInput.value = newValue; const newPos = start + iterationPlaceholder.length; targetInput.selectionStart = newPos; targetInput.selectionEnd = newPos; targetInput.focus(); targetInput.dispatchEvent(new Event('input', { bubbles: true })); }
        function autoGrowTextarea() { /* ... (unchanged) ... */ const i=messageInput;const mH=i.style.maxHeight||'150px';i.style.maxHeight='none';i.style.height='auto';const sH=i.scrollHeight;i.style.height=sH+'px';i.style.maxHeight=mH;i.style.overflowY=parseFloat(i.style.height)>parseFloat(mH)?'auto':'hidden'; }
        function renderRunnerHTML() { /* ... (unchanged) ... */ const htmlCode = htmlRunnerInput.value; if (/<script.*?>.*?window\.location.*?<\/script>/i.test(htmlCode) || /<script.*?>.*?document\.cookie.*?<\/script>/i.test(htmlCode)) { console.warn("Potentially harmful script..."); const iframeDoc = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow.document; iframeDoc.open(); iframeDoc.write('<html>Blocked</html>'); iframeDoc.close(); return; } const iframeDoc = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow.document; iframeDoc.open(); iframeDoc.write(htmlCode); iframeDoc.close(); }
        function openHtmlRunner(initialCode) { /* ... (unchanged) ... */ htmlRunnerInput.value = initialCode || ''; renderRunnerHTML(); htmlRunnerModal.style.display = 'flex'; }
        function createPfpElement(sender, pfpUrl) { /* ... (unchanged) ... */ const d=document.createElement('div');d.className=`avatar ${sender}-avatar`;d.dataset.senderType=sender;const i=document.createElement('img');i.src=pfpUrl;i.alt=`${sender} avatar`;d.addEventListener('click',()=>{currentPfpElementToUpdate=i;pfpUploadInput.click();});d.appendChild(i);return d; }
        function displayBotMessage(entry, sender='spirit') { /* ... (unchanged) ... */ if(entry.variants?.length>1)displayMultipleMessages(entry,sender);else if(entry.variants?.length>=1)displayMessage(entry,sender);else console.warn("Bad bot struct:",entry); }
        function displayMessage(entry, sender) { /* ... (unchanged) ... */ const c = sender === 'user' ? entry.content : (entry.variants?.[entry.selectedIndex ?? 0] || '[Silence]'); const msgDiv = document.createElement('div'); msgDiv.className = `message message-${sender}`; if (entry.turnId) msgDiv.dataset.turnId = entry.turnId; const p = sender === 'user' ? userPfp : botPfp; const avatarEl = createPfpElement(sender, p); const wrapper = document.createElement('div'); wrapper.classList.add('message-content-wrapper'); const contentDiv = document.createElement('div'); contentDiv.className = 'message-content'; if (sender === 'spirit') { try { contentDiv.innerHTML = marked.parse(c); } catch (e) { contentDiv.textContent = c; } } else { contentDiv.textContent = c; contentDiv.style.whiteSpace = 'pre-wrap'; } wrapper.appendChild(contentDiv); if (sender === 'spirit') { addCodeActionButtons(contentDiv, wrapper, entry.turnId, entry.selectedIndex ?? 0); } if (sender === 'user') { msgDiv.appendChild(wrapper); msgDiv.appendChild(avatarEl); } else { msgDiv.appendChild(avatarEl); msgDiv.appendChild(wrapper); } pages.appendChild(msgDiv); return msgDiv; }
        function displayMultipleMessages(entry, sender = 'spirit') { /* ... (unchanged) ... */ const tid = entry.turnId; const vars = entry.variants; let idx = entry.selectedIndex; const msgDiv = document.createElement('div'); msgDiv.className = `message message-${sender}`; if (tid) msgDiv.dataset.turnId = tid; const p = sender === 'user' ? userPfp : botPfp; const avatarEl = createPfpElement(sender, p); const wrapper = document.createElement('div'); wrapper.classList.add('message-content-wrapper'); const contentDiv = document.createElement('div'); contentDiv.className = 'message-content'; const nav = document.createElement('div'); nav.classList.add('response-navigation'); const prev = document.createElement('button'); prev.textContent = '<'; const span = document.createElement('span'); const next = document.createElement('button'); next.textContent = '>'; nav.appendChild(prev); nav.appendChild(span); nav.appendChild(next); wrapper.appendChild(contentDiv); let acts = document.createElement('div'); acts.classList.add('message-actions'); wrapper.appendChild(acts); wrapper.appendChild(nav); function update(currentIndex) { try { contentDiv.innerHTML = marked.parse(vars[currentIndex]); } catch (e) { contentDiv.textContent = vars[currentIndex]; } addCodeActionButtons(contentDiv, wrapper, tid, currentIndex); span.textContent = `${currentIndex + 1} / ${vars.length}`; prev.disabled = currentIndex === 0; next.disabled = currentIndex === vars.length - 1; contentDiv.style.animation = 'none'; void contentDiv.offsetWidth; contentDiv.style.animation = 'fadeIn 0.3s ease-in-out'; } prev.addEventListener('click', () => { if (idx > 0) { idx--; update(idx); updateHistorySelection(tid, idx); } }); next.addEventListener('click', () => { if (idx < vars.length - 1) { idx++; update(idx); updateHistorySelection(tid, idx); } }); if (sender === 'user') { msgDiv.appendChild(wrapper); msgDiv.appendChild(avatarEl); } else { msgDiv.appendChild(avatarEl); msgDiv.appendChild(wrapper); } pages.appendChild(msgDiv); update(idx); return msgDiv; }
        function addCodeActionButtons(contentDiv, wrapper, turnId, variantIndex) { /* ... (unchanged) ... */ let acts = wrapper.querySelector('.message-actions'); if (!acts) { acts = document.createElement('div'); acts.classList.add('message-actions'); const nav = wrapper.querySelector('.response-navigation'); if (nav) { wrapper.insertBefore(acts, nav); } else { wrapper.appendChild(acts); } } acts.innerHTML = ''; contentDiv.querySelectorAll('.cat-placeholder').forEach(c => c.remove()); const codeBlocks = contentDiv.querySelectorAll('pre'); if (codeBlocks.length > 0) { codeBlocks.forEach((pre, preIdx) => { const uniquePreId = `pre-${turnId || 'gen'}-${variantIndex}-${preIdx}`; pre.id = uniquePreId; const cat = document.createElement('span'); cat.classList.add('cat-placeholder'); cat.textContent = 'ðŸ±'; cat.dataset.preId = uniquePreId; pre.parentNode.insertBefore(cat, pre); const codeElement = pre.querySelector('code'); const codeText = codeElement ? codeElement.textContent : ''; const langMatch = codeElement?.className.match(/language-(\w+)/); const lang = langMatch ? langMatch[1] : 'txt'; const filename = `scroll_${Date.now()}_${variantIndex + 1}.${lang}`; const cpBtn = document.createElement('button'); cpBtn.textContent = 'Copy'; cpBtn.classList.add('copy-code-button', 'action-button'); cpBtn.onclick = () => copyCodeFromPre(uniquePreId, cpBtn); acts.appendChild(cpBtn); const dlBtn = document.createElement('button'); dlBtn.textContent = 'Download'; dlBtn.classList.add('download-code-button', 'action-button'); dlBtn.onclick = () => downloadCode(codeText, filename); acts.appendChild(dlBtn); if (lang === 'html') { const runBtn = document.createElement('button'); runBtn.textContent = 'Run HTML'; runBtn.classList.add('run-html-button', 'action-button'); runBtn.title = "Run this HTML snippet"; runBtn.onclick = () => openHtmlRunner(codeText); acts.appendChild(runBtn); } }); } }
        function copyCodeFromPre(preId, btn) { /* ... (unchanged) ... */ const p=document.getElementById(preId);const c=p?p.querySelector('code'):null;if(!c){if(btn)btn.textContent='Err!';return;}const t=c.textContent||'';copyHelper.value=t;copyHelper.select();copyHelper.setSelectionRange(0,99999);let ok=false;try{ok=document.execCommand('copy');}catch(e){ok=false;}window.getSelection().removeAllRanges();if(btn){if(ok){btn.textContent='Copied!';btn.classList.add('copied');setTimeout(()=>{btn.textContent='Copy';btn.classList.remove('copied');},1500);}else{btn.textContent='Failed!';setTimeout(()=>{btn.textContent='Copy';},2000);}}}
        function downloadCode(codeText, filename) { /* ... (unchanged) ... */ try{const b=new Blob([codeText],{type:'text/plain;charset=utf-8'});const u=URL.createObjectURL(b);const l=document.createElement('a');l.href=u;l.download=filename;document.body.appendChild(l);l.click();document.body.removeChild(l);URL.revokeObjectURL(u);}catch(e){console.error("DL Err:",e);alert("Download failed.");} }
        function showTypingIndicator() { /* ... (unchanged) ... */ if(document.getElementById('typing-indicator'))return;const i=document.createElement('div');i.className='typing-indicator';i.id='typing-indicator';i.textContent='The spirit whispers...';pages.appendChild(i);scrollToBottom(); }
        function hideTypingIndicator() { /* ... (unchanged) ... */ const i=document.getElementById('typing-indicator');if(i)i.remove(); }
        function scrollToBottom() { /* ... (unchanged) ... */ setTimeout(()=>{pages.scrollTop=pages.scrollHeight;},50); }
        function prepareHistoryForApi(hist) { /* ... (unchanged) ... */ return hist.map(m=>{if(m.role==='system')return{role:'system',content:m.content};if(m.role==='user')return{role:'user',content:m.content};if(m.role==='assistant'&&m.variants?.length>0)return{role:'assistant',content:m.variants[m.selectedIndex??0]};return null;}).filter(Boolean); }
        function updateHistorySelection(turnId, idx) { /* ... (unchanged) ... */ const i=conversationHistory.findIndex(m=>m.turnId===turnId&&m.role==='assistant');if(i>-1){conversationHistory[i].selectedIndex=idx;saveHistoryToLocalStorage();} }
        function saveHistoryToLocalStorage() { /* ... (unchanged) ... */ try{localStorage.setItem('conversationHistory',JSON.stringify(conversationHistory));}catch(e){console.error("Save Err:",e);} }

        // Modified loadHistoryFromLocalStorage for provider state init
        function loadHistoryFromLocalStorage() {
             // Load Provider/Model Selections First
             try {
                 // Check if PROVIDERS is available (loaded from api_providers.js)
                 if (typeof PROVIDERS === 'undefined' || Object.keys(PROVIDERS).length === 0) {
                     throw new Error("PROVIDERS definitions not loaded.");
                 }
                 const savedProvider = localStorage.getItem('selectedProvider');
                 if (savedProvider && PROVIDERS[savedProvider]) {
                     selectedProvider = savedProvider;
                 } else {
                     selectedProvider = Object.keys(PROVIDERS)[0]; // Default to first defined provider
                 }
                 // Selected model will be determined when populateModelSelect is called in initialLoad
                 selectedModel = localStorage.getItem('selectedModel') || ''; // Load saved model preference
             } catch (e) {
                  console.error("Error initializing provider/model state:", e);
                  // Attempt graceful fallback if PROVIDERS is somehow missing later
                  selectedProvider = localStorage.getItem('selectedProvider') || 'UNKNOWN';
                  selectedModel = localStorage.getItem('selectedModel') || '';
             }

             // Load Keys & Index Object
             try {
                  const storedKeys = localStorage.getItem('apiKeys'); apiKeys = storedKeys ? JSON.parse(storedKeys) : {};
                  const storedIndex = localStorage.getItem('currentApiKeyIndex'); currentApiKeyIndex = storedIndex ? JSON.parse(storedIndex) : {};
                  if (typeof apiKeys !== 'object' || apiKeys === null) apiKeys = {};
                  if (typeof currentApiKeyIndex !== 'object' || currentApiKeyIndex === null) currentApiKeyIndex = {};
             } catch (e) { console.warn("Could not load API keys/index object:", e); apiKeys = {}; currentApiKeyIndex = {}; }

             // Load Conversation History
            try{
                const s=localStorage.getItem('conversationHistory'); if(!s)throw new Error('No hist');
                const p=JSON.parse(s); if(!Array.isArray(p)||p.length===0||p[0]?.role!=='system')throw new Error('Bad fmt');
                conversationHistory=p.map(m=>{if(m.role==='assistant'&&!Array.isArray(m.variants))return{...m,variants:[m.content||""],selectedIndex:0};if(m.role==='assistant'&&m.variants){if(!m.hasOwnProperty('selectedIndex')||m.selectedIndex<0||m.selectedIndex>=m.variants.length)m.selectedIndex=0;}return m;});
                const l=conversationHistory.filter(m=>m.turnId).pop(); if(l?.turnId?.startsWith('turn-')){const n=parseInt(l.turnId.split('-')[1],10);turnCounter=isNaN(n)?1:n+1;}else{turnCounter=1;}
                return true;
            } catch(e) {
                console.warn("Load Err (History):",e);
                // Ensure system prompt exists
                const currentSystemPrompt = localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
                conversationHistory=[{role:'system',content:currentSystemPrompt}];
                turnCounter=1; return false;
            }
        }
        function rebuildChatFromHistory() { /* ... (unchanged) ... */ pages.innerHTML='';for(let i=1;i<conversationHistory.length;i++){const e=conversationHistory[i];if(e.role==='user')displayMessage(e,'user');else if(e.role==='assistant')displayBotMessage(e,'spirit');} }
        function displayInitialGreeting() { /* ... (unchanged) ... */ const g="The ancient tome awaits...";const e={role:'assistant',variants:[g],selectedIndex:0,turnId:'turn-0'};if(conversationHistory.length <= 1) { conversationHistory.push(e); displayBotMessage(e,'spirit'); saveHistoryToLocalStorage(); turnCounter = 1; } }

        // --- Initial Load ---
        function initialLoad() {
            // Check if PROVIDERS is loaded
             if (typeof PROVIDERS === 'undefined') {
                 alert("Error: API Provider definitions (api_providers.js) failed to load. Cannot initialize application.");
                 // Optionally disable the entire interface here
                 document.body.innerHTML = "<h1 style='color:red; text-align: center; margin-top: 50px;'>Initialization Failed: Missing api_providers.js</h1>";
                 return;
             }

            loadHistoryFromLocalStorage(); // Loads keys, indices, provider, model pref, history

            // Populate UI based on loaded state
            populateProviderSelect(); // Sets provider dropdown and triggers model population
            updateApiKeyStatus(selectedProvider); // Sets key count display

            hideCodeBlocks=localStorage.getItem('hideCodeBlocks')==='true';
            downloadCodeMode=localStorage.getItem('downloadCodeMode')==='true';
            enableRunHtmlMode=localStorage.getItem('enableRunHtmlMode')==='true';
            chatContainerElement.classList.toggle('code-hidden',hideCodeBlocks);
            chatContainerElement.classList.toggle('download-code-active',downloadCodeMode);
            chatContainerElement.classList.toggle('run-html-active',enableRunHtmlMode);

            // Set initial button state after everything is loaded and populated
            sendButton.disabled = !hasSelectedProviderApiKeys();

            rebuildChatFromHistory();
            if(conversationHistory.length <= 1){ displayInitialGreeting(); }
            scrollToBottom();

            console.log("Arcane Tome Initialized.");
        }

        // --- Start the application ---
        // It's generally safer to wait for DOMContentLoaded, especially when relying on external scripts
        document.addEventListener('DOMContentLoaded', initialLoad);

    </script>
</body>
</html>
