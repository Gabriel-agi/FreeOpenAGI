<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcane Tome (Vision Enabled)</title> <!-- Updated Title -->
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- API Provider Definitions (MUST be before main script) -->
    <script src="api_providers.js"></script> <!-- Make sure this path is correct -->

    <style>
        /* --- Arcane Tome Base Styles --- */
        :root {
             --parchment: #f5e7d0; --parchment-dark: #e3d5b8; --ink: #3a3129; --ink-light: #5a4e42; --gold: #c9a227; --crimson: #8b0000; --sapphire: #1e3a8a; --amethyst: #6b21a8; --emerald: #21a853; --shadow-light: 0 1px 3px rgba(0,0,0,0.15); --code-bg: #e8e0cf; --code-border: #d1c3a9;
             /* Using Georgia as primary, Times New Roman as fallback/heading */
             --font-body: Georgia, 'Times New Roman', Times, serif;
             --font-heading: 'Times New Roman', Times, serif; /* Replaced Cinzel Decorative */
        }
        html, body { height: 100%; margin: 0; padding: 0; }
        * { box-sizing: border-box; }
        /* --- Body uses Georgia --- */
        body { font-family: var(--font-body); font-size: 1.1rem; line-height: 1.6; background-color: var(--parchment); color: var(--ink); width: 100vw; overflow: hidden; }
        .tome { width: 100%; height: 100%; display: flex; flex-direction: column; position: relative; background-color: var(--parchment); }
        .pages { flex: 1; min-height: 0; padding: 20px; overflow-y: auto; scrollbar-width: none; /* Firefox */ display: flex; flex-direction: column; gap: 15px; border-bottom: 2px solid var(--ink-light); }
        .pages::-webkit-scrollbar { display: none; /* Safari and Chrome */ }
        .message { display: flex; gap: 10px; max-width: 85%; animation: fadeIn 0.5s ease-in-out;}
        .message-user { align-self: flex-end; flex-direction: row-reverse; }
        .message-spirit { align-self: flex-start; }
        .avatar { width: 45px; height: 45px; border-radius: 50%; flex-shrink: 0; border: 2px solid var(--parchment-dark); box-shadow: var(--shadow-light); display: flex; align-items: center; justify-content: center; overflow: hidden; background-color: var(--parchment-dark); cursor: pointer; }
        .avatar img { width: 100%; height: 100%; object-fit: cover; }
        .user-avatar { background-color: var(--sapphire); }
        .spirit-avatar { background-color: var(--amethyst); }
        .message-content-wrapper { display: flex; flex-direction: column; max-width: 100%; }
        .message-content { padding: 12px 18px; border-radius: 8px; line-height: 1.5; word-break: break-word; box-shadow: var(--shadow-light); max-width: fit-content; }
        .message-user .message-content { background-color: var(--sapphire); color: white; border-top-right-radius: 0; }
        .message-spirit .message-content { background-color: white; color: var(--ink); border: 1px solid var(--ink-light); border-top-left-radius: 0; }
        .message-content p { margin: 0 0 0.5em 0; } .message-content p:last-child { margin-bottom: 0; }

        /* --- Style for attached image previews in user message --- */
        .message-content .attached-image-preview {
            display: block; /* Display below text */
            max-width: 200px; /* Slightly larger preview */
            max-height: 150px;
            margin-top: 10px;
            border-radius: 4px;
            border: 1px solid var(--ink-light);
            cursor: pointer; /* Optional: Could add lightbox later */
            background-color: var(--parchment-dark); /* Placeholder bg */
        }

        .typing-indicator { align-self: flex-start; color: var(--ink-light); font-style: italic; padding: 10px 15px; background-color: rgba(227,213,184,0.5); border-radius: 8px; font-size: 1rem; }
        .writing-area { padding: 12px; background-color: var(--parchment-dark); display: flex; flex-wrap: wrap; gap: 8px; align-items: flex-end; flex-shrink: 0; }
        .message-input { flex: 1 1 250px; padding: 10px; background-color: var(--parchment); border: 2px solid var(--ink-light); border-radius: 5px; font-family: inherit; font-size: 1.1rem; resize: none; outline: none; color: var(--ink); min-height: 48px; max-height: 150px; line-height: 1.5; }
        .message-input:focus { border-color: var(--gold); }

        /* --- Area to show attached file names --- */
        .attachments-preview {
            flex-basis: 100%; /* Take full width below input */
            font-size: 0.85em;
            color: var(--ink-light);
            margin-top: 5px; /* Space above controls */
            padding-left: 5px; /* Align with input padding */
            min-height: 1.2em; /* Reserve some space even when empty */
            display: flex; /* Allow wrapping */
            flex-wrap: wrap;
            gap: 5px; /* Spacing between items */
        }
        .attachment-item {
            display: inline-flex; /* Align text and button nicely */
            align-items: center;
            background-color: var(--parchment);
            border: 1px solid var(--ink-light);
            padding: 2px 6px;
            border-radius: 10px; /* More rounded */
            white-space: nowrap; /* Prevent filename breaking */
            overflow: hidden;
            text-overflow: ellipsis; /* Add ellipsis if too long */
            max-width: 150px; /* Limit width */
        }
        .remove-attachment {
            color: var(--crimson);
            margin-left: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1em;
            line-height: 1;
            padding: 0 2px;
        }
        .remove-attachment:hover {
            color: darkred;
        }


        .writing-controls { display: flex; align-items: flex-end; gap: 8px; flex-wrap: nowrap; margin-left: auto; width: 100%; /* Ensure controls take width if needed */ justify-content: flex-end; }
        /* --- Footer buttons use Georgia --- */
        .footer-button { background-color: var(--ink-light); color: var(--parchment); border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; padding: 8px 10px; font-size: 0.9em; flex-shrink: 0; white-space: nowrap; height: 48px; font-family: var(--font-body); display:flex; align-items:center; justify-content:center; }
        .footer-button:hover:not(:disabled) { background-color: var(--ink); }
        .footer-button:disabled { opacity: 0.6; cursor: not-allowed; background-color: #aaa; /* More obvious disabled state */ }

        /* --- Style for upload button when files are attached --- */
        #upload-file-button.has-files {
            background-color: var(--emerald);
            color: white;
            border: 1px solid darkgreen; /* Add border for emphasis */
        }
        #upload-file-button.has-files:hover:not(:disabled) {
            background-color: darkgreen;
        }

        #settings-button { background-color: var(--gold); color: var(--ink); font-size: 1.2em; padding: 0 12px; }
        #settings-button:hover { background-color: var(--crimson); color: white; }
        #clear-chat-button { background-color: var(--crimson); color: white;}
        #clear-chat-button:hover { background-color: darkred; }
        #upload-file-button { font-size: 1.1em; padding: 0 12px; } /* Base style */
        .response-count-input { width: 45px; padding: 10px; border: 2px solid var(--ink-light); border-radius: 5px; text-align: center; flex-shrink: 0; height: 48px; font-size: 1rem; background-color: var(--parchment); color: var(--ink); }
        /* --- Send button uses Heading Font --- */
        .send-button { background-color: var(--gold); color: var(--ink); border: none; border-radius: 5px; padding: 0 18px; height: 48px; font-family: var(--font-heading); font-weight: bold; cursor: pointer; box-shadow: var(--shadow-light); display: flex; align-items: center; gap: 8px; font-size: 1.1rem; transition: background-color 0.2s ease; flex-shrink: 0; }
        .send-button:hover:not(:disabled) { background-color: var(--crimson); color: white; }
        .send-button:disabled { opacity: 0.7; cursor: not-allowed; background-color: var(--ink-light); color: var(--parchment); }
        .response-navigation { display: flex; align-items: center; justify-content: flex-start; margin-top: 5px; gap: 5px; width: fit-content; }
        .response-navigation button { background-color: var(--parchment-dark); border: 1px solid var(--ink-light); color: var(--ink); border-radius: 4px; padding: 2px 6px; cursor: pointer; font-size: 0.9em; line-height: 1; }
        .response-navigation button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #ccc; }
        .response-navigation span { font-size: 0.8em; color: var(--ink-light); margin: 0 5px; user-select: none; }
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(58,49,41,0.7); justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--parchment); border: 3px solid var(--gold); color: var(--ink); padding: 25px; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.4); max-height: 90vh; width: 90%; max-width: 650px; /* Limit settings modal width */ display: flex; flex-direction: column; overflow-y: auto; }
        /* --- Modal Headings use Heading Font --- */
        .modal-content h3 { font-family: var(--font-heading); margin-top: 0; text-align: center; color: var(--ink); border-bottom: 1px solid var(--gold); padding-bottom: 10px; margin-bottom: 20px; flex-shrink: 0; }
        .modal-content .form-group { margin-bottom: 15px; display: flex; flex-wrap: wrap; align-items: center; gap: 8px 15px; flex-shrink: 0; }
        .modal-content label { display: block; margin-bottom: 5px; font-weight: bold; color: var(--ink-light); flex-basis: 100%; }
        .modal-content input[type="checkbox"] { cursor: pointer; margin-right: 5px; flex-shrink: 0; }
        .modal-content label[for*="checkbox"] { flex-basis: auto; margin-bottom: 0; font-weight: normal; }
        .modal-content input[type="password"], .modal-content textarea, .modal-content input[type="number"], .modal-content select { width: 100%; padding: 10px; border: 1px solid var(--ink-light); border-radius: 4px; outline: none; box-sizing: border-box; background-color: white; color: var(--ink); font-family: var(--font-body); font-size: 1rem; }
        .modal-content select { cursor: pointer; height: 44px; padding: 0 10px;}
        .modal-content textarea { resize: vertical; min-height: 80px; }
        .modal-content .modal-buttons { margin-top: 20px; text-align: right; display: flex; justify-content: flex-end; gap: 10px; flex-shrink: 0; border-top: 1px solid var(--gold); padding-top: 15px; }
        /* --- Modal Buttons use Heading Font --- */
        .modal-content button { background-color: var(--gold); color: var(--ink); border: none; padding: 10px 18px; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; font-family: var(--font-heading); font-weight: bold; }
        .modal-content button:hover { background-color: var(--crimson); color: white; }
        /* --- Specific overrides for buttons that should use body font --- */
        .modal-content button.cancel-button { font-family: var(--font-body); background-color: var(--ink-light); color: var(--parchment); }
        .modal-content button.cancel-button:hover { background-color: var(--ink); }
        .modal-content .small-button { font-family: var(--font-body); /* Ensure small buttons also use body font */ padding: 4px 8px; font-size: 0.8em; height: auto; background-color: var(--ink-light); color: var(--parchment); border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s ease; flex-shrink: 0; }
        .modal-content .small-button:hover { background-color: var(--ink); }
        /* ... rest of styles ... */
        .provider-selector { display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; align-items: flex-end; }
        .provider-selector > div { flex: 1; min-width: 150px; }
        .api-key-manager { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-top: 5px; }
        .api-key-manager input[type="password"] { flex-grow: 1; min-width: 200px; }
        .api-key-manager button { padding: 8px 12px; font-size: 0.9em; height: 44px; flex-shrink: 0; }
        .api-key-status-container { flex-basis: 100%; display: flex; justify-content: space-between; align-items: center; gap: 10px; margin-top: 5px; }
        .api-key-status { font-size: 0.9em; color: var(--ink-light); flex-grow: 1; }
        .api-call-count-display { font-size: 0.9em; color: var(--ink-light); flex-shrink: 0; }
        #reset-call-count-button { font-family: var(--font-body); background-color: var(--ink-light); color: var(--parchment); margin-left: 5px; padding: 4px 8px; font-size: 0.8em; height: auto; flex-shrink: 0; }
        #reset-call-count-button:hover { background-color: var(--ink); }
        #clear-keys-button { background-color: var(--crimson); color: white; margin-left: auto; }
        #clear-keys-button:hover { background-color: darkred; }
        .settings-group { margin-bottom: 15px; flex-shrink: 0; } /* Added for better spacing */
        #max-variations-input { width: 60px; text-align: center; margin-left: 8px; }

        /* --- Styles for HTML Runner Modal --- */
        #html-runner-modal .modal-content { max-width: 90vw; width: 85%; }
        .html-runner-container { display: flex; flex-grow: 1; gap: 15px; min-height: 0; margin-bottom: 15px; }
        .runner-editor, .runner-preview { flex: 1; display: flex; flex-direction: column; border: 1px solid var(--ink-light); border-radius: 5px; background-color: var(--parchment-dark); overflow: hidden; }
        .runner-header { margin: 0; padding: 8px 12px; background-color: var(--ink-light); color: var(--parchment); border-bottom: 1px solid var(--ink); font-size: 0.9em; font-weight: bold; flex-shrink: 0; text-align: center; }
        #html-runner-input { flex: 1; border: none; padding: 10px; font-family: Consolas, Monaco, monospace; font-size: 0.9em; resize: none; outline: none; background-color: white; color: var(--ink); }
        #html-runner-frame { flex: 1; border: none; width: 100%; height: 100%; background-color: white; }
        #html-runner-modal .modal-buttons button { padding: 8px 15px; }

        /* --- Code Block Styling --- */
        .message-content pre { border: 1px solid var(--code-border); background-color: var(--code-bg); position: relative; margin-top: 10px; margin-bottom: 5px; }
        .message-content pre code.hljs { display: block; overflow-x: auto; padding: 1em; background: transparent; color: var(--ink); border-radius: 5px; }
        .hljs-comment, .hljs-quote { color: #7a7061; font-style: italic; }
        .hljs-keyword, .hljs-selector-tag, .hljs-subst { color: var(--crimson); font-weight: bold; }
        .hljs-number, .hljs-literal, .hljs-variable, .hljs-template-variable, .hljs-tag .hljs-attr { color: var(--sapphire); }
        .hljs-string, .hljs-doctag { color: #4b8350; }
        .hljs-title, .hljs-section, .hljs-selector-id { color: var(--gold); font-weight: bold; }
        .message-content code:not(.hljs) { background-color: var(--code-bg); border: 1px solid var(--code-border); padding: 0.2em 0.4em; border-radius: 3px; font-size: 85%; font-family: Consolas, Monaco, monospace; }
        .cat-placeholder { display: none; font-size: 1.2em; cursor: default; user-select: none; padding: 2px 5px; background-color: var(--parchment-dark); border-radius: 3px; border: 1px solid var(--ink-light); margin-right: 5px; margin-bottom: 3px; }

        /* --- Message Action Button Styling --- */
        .message-actions { margin-top: 8px; text-align: left; display: flex; gap: 5px; flex-wrap: wrap; }
        .action-button { background-color: var(--ink-light); color: var(--parchment); border: none; padding: 4px 8px; font-size: 0.8em; border-radius: 4px; cursor: pointer; opacity: 0.9; transition: opacity 0.2s ease, background-color 0.2s ease; font-family: var(--font-body); } /* Use body font for actions */
        .action-button:hover { opacity: 1; background-color: var(--ink); }
        .copy-code-button.copied { background-color: #3a9a41; color: white; }
        .download-code-button { background-color: #17a2b8; }
        .download-code-button:hover { background-color: #138496; }
        .run-html-button { background-color: var(--emerald); }
        .run-html-button:hover { background-color: darkgreen; }

        /* --- Conditional Visibility --- */
        .tome.code-hidden .message pre { display: none; }
        .tome.code-hidden .message .cat-placeholder { display: inline-block; }
        .download-code-button { display: none; }
        .tome.download-code-active .download-code-button { display: inline-block; }
        .run-html-button { display: none; }
        .tome.run-html-active .run-html-button { display: inline-block; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @media (max-width: 768px) { /* ... (responsive styles unchanged) ... */ }
        .visually-hidden { position: absolute !important; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px); white-space: nowrap; }
    </style>
</head>
<body>
    <!-- HTML Structure -->
    <div class="tome" id="chat-container">
        <div class="pages" id="pages"></div>
        <div class="writing-area">
            <textarea class="message-input" id="message-input" placeholder="Inscribe thy query..." rows="1"></textarea>
            <!-- Div to show names of attached files -->
            <div class="attachments-preview" id="attachments-preview"></div>
            <div class="writing-controls">
                 <button id="settings-button" class="footer-button" title="Settings"> <i class="fas fa-cog"></i> </button>
                 <!-- Upload button - title will be updated -->
                 <button id="upload-file-button" class="footer-button" title="Attach Parchment (Images)"> <i class="fas fa-paperclip"></i> </button>
                 <button id="add-iterator-button" class="footer-button" title="Insert {i}">Add {i}</button>
                 <button id="clear-chat-button" class="footer-button" title="Clear Scroll">Clear</button>
                 <!-- Removed Edit Button -->
                 <input type="number" class="response-count-input" id="main-response-count" value="1" min="0" max="5" title="Responses (0 to send no query)">
                 <button class="send-button" id="send-button" title="Send Query"> <span>Send</span> <span>✒</span> </button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="system-prompt-modal">
         <div class="modal-content">
             <h3>Tome Settings</h3>
             <div class="provider-selector form-group">
                 <div> <label for="provider-select">Spirit Provider:</label> <select id="provider-select"></select> </div>
                 <div> <label for="model-select">Spirit Model:</label> <select id="model-select"></select> </div>
             </div>
             <div class="form-group">
                 <label for="api-key-input">Add Spirit Essence (API Key) for <span id="selected-provider-label">Provider</span>:</label>
                 <div class="api-key-manager">
                      <input type="password" id="api-key-input" placeholder="Paste new key...">
                      <button id="add-key-button" title="Add this key to the list for the selected provider">Add Key</button>
                      <button id="clear-keys-button" title="Remove all stored keys for the selected provider">Clear Keys for Provider</button>
                 </div>
                 <div class="api-key-status-container">
                     <span id="api-key-status" class="api-key-status">Keys Loaded: 0</span>
                     <span id="api-call-count-display" class="api-call-count-display">Calls: 0</span>
                     <button id="reset-call-count-button" class="small-button" title="Reset call count for this provider">Reset Count</button>
                 </div>
             </div>
             <div class="form-group settings-group">
                 <label for="system-prompt-input">Spirit's Nature (System Prompt):</label>
                 <textarea id="system-prompt-input" placeholder="Define the spirit's core nature..."></textarea>
             </div>
             <div class="form-group settings-group">
                 <label for="max-variations-input" style="flex-basis: auto; margin-bottom: 0;">Max Response Variations:</label>
                 <input type="number" id="max-variations-input" min="1" max="10" value="5" class="response-count-input" style="width: 60px; height: 40px;">
             </div>
             <div class="form-group">
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="hide-code-checkbox"> <label for="hide-code-checkbox">Veil Glyphs</label> </div>
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="download-code-checkbox"> <label for="download-code-checkbox">Enable Download</label> </div>
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="enable-run-html-checkbox"> <label for="enable-run-html-checkbox">Enable Run HTML</label> </div>
             </div>
             <div class="modal-buttons">
                <button id="cancel-settings" class="cancel-button">Cancel</button>
                <button id="save-settings-button">Seal Settings</button>
             </div>
         </div>
    </div>

    <!-- Removed Code Edit Modal -->

    <!-- HTML Runner Modal -->
    <div class="modal-overlay" id="html-runner-modal">
        <div class="modal-content">
            <h3>HTML Runner</h3>
            <div class="html-runner-container">
                 <div class="runner-editor"> <div class="runner-header">HTML Input</div> <textarea id="html-runner-input" placeholder="Paste HTML code here..."></textarea> </div>
                 <div class="runner-preview"> <div class="runner-header">Preview</div> <iframe id="html-runner-frame" title="HTML Output Preview" sandbox="allow-scripts allow-same-origin"></iframe> </div>
            </div>
             <div class="modal-buttons">
                 <button id="html-runner-render-button">Render</button>
                 <button id="html-runner-close-button" class="cancel-button">Close</button>
             </div>
        </div>
    </div>

    <!-- Hidden Helpers -->
    <textarea class="visually-hidden" id="copy-helper" aria-hidden="true"></textarea>
    <!-- Update file input to accept common image types and allow multiple selections -->
    <input type="file" id="file-upload-input" accept="image/jpeg, image/png, image/webp, image/gif" style="display:none;" multiple>
    <input type="file" class="pfp-upload" accept="image/*" style="display:none;">


    <script>
        // --- Global State & Constants ---
        let conversationHistory = [];
        let userPfp = localStorage.getItem('userPfp') || 'https://ui-avatars.com/api/?name=U&background=1e3a8a&color=fff&font-size=0.6&bold=true';
        let botPfp = localStorage.getItem('botPfp') || 'https://ui-avatars.com/api/?name=S&background=6b21a8&color=fff&font-size=0.6&bold=true';
        let currentPfpElementToUpdate = null;
        let turnCounter = 0;
        const iterationPlaceholder = '{i}';
        const DEFAULT_SYSTEM_PROMPT = 'You are a mystical spirit from another realm...';
        const MAX_ATTACHMENTS = 5; // Max number of images to attach
        const MAX_FILE_SIZE = 4 * 1024 * 1024; // 4MB limit per image
        const ALLOWED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];

        // --- Provider/Key State ---
        let selectedProvider = '';
        let selectedModel = '';
        let apiKeys = {};
        let currentApiKeyIndex = {};
        let apiCallCounts = {};

        // --- State for attached files ---
        let attachedFilesData = []; // Stores { fileId: "...", name: "...", mimeType: "...", data: "base64..." }

        // --- Settings State ---
        let maxResponseVariations = 5;
        let hideCodeBlocks = true;
        let downloadCodeMode = false;
        let enableRunHtmlMode = false;
        let isWaitingForResponse = false;

        // --- DOM Elements ---
        const chatContainerElement = document.getElementById('chat-container');
        const pages = document.getElementById('pages');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const mainResponseCountInput = document.getElementById('main-response-count');
        const pfpUploadInput = document.querySelector('.pfp-upload');
        const settingsButton = document.getElementById('settings-button');
        const systemPromptModal = document.getElementById('system-prompt-modal');
        const providerSelect = document.getElementById('provider-select');
        const modelSelect = document.getElementById('model-select');
        const selectedProviderLabel = document.getElementById('selected-provider-label');
        const systemPromptInput = document.getElementById('system-prompt-input');
        const apiKeyInput = document.getElementById('api-key-input');
        const addKeyButton = document.getElementById('add-key-button');
        const clearKeysButton = document.getElementById('clear-keys-button');
        const apiKeyStatus = document.getElementById('api-key-status');
        const apiCallCountDisplay = document.getElementById('api-call-count-display');
        const resetCallCountButton = document.getElementById('reset-call-count-button');
        const maxVariationsInput = document.getElementById('max-variations-input');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const hideCodeCheckbox = document.getElementById('hide-code-checkbox');
        const downloadCodeCheckbox = document.getElementById('download-code-checkbox');
        const enableRunHtmlCheckbox = document.getElementById('enable-run-html-checkbox');
        const cancelSettingsButton = document.getElementById('cancel-settings');
        // Removed Edit Modal Elements
        const htmlRunnerModal = document.getElementById('html-runner-modal');
        const htmlRunnerInput = document.getElementById('html-runner-input');
        const htmlRunnerFrame = document.getElementById('html-runner-frame');
        const htmlRunnerRenderButton = document.getElementById('html-runner-render-button');
        const htmlRunnerCloseButton = document.getElementById('html-runner-close-button');
        const clearChatButton = document.getElementById('clear-chat-button');
        const addIteratorButton = document.getElementById('add-iterator-button');
        const uploadFileButton = document.getElementById('upload-file-button'); // Button to trigger input
        const fileUploadInput = document.getElementById('file-upload-input'); // The hidden input itself
        const copyHelper = document.getElementById('copy-helper');
        const attachmentsPreview = document.getElementById('attachments-preview'); // Div for preview

        // --- Configure Markdown & Highlighting ---
        marked.setOptions({
            highlight: function(code, lang) {
                const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                try { return hljs.highlight(code, { language: language, ignoreIllegals: true }).value; }
                catch (e) { return hljs.highlight(code, { language: 'plaintext', ignoreIllegals: true }).value; }
            },
            langPrefix: 'hljs language-', gfm: true, breaks: true
        });

        // --- Function Definitions ---

        // --- Function to update UI based on attached files ---
        function updateAttachmentUI() {
            if (!uploadFileButton || !attachmentsPreview) return;

            attachmentsPreview.innerHTML = ''; // Clear preview area

            const providerSupportsImages = (typeof PROVIDERS !== 'undefined' && selectedProvider && PROVIDERS[selectedProvider]?.supportsImages) ?? false;

            if (attachedFilesData.length > 0) {
                uploadFileButton.classList.add('has-files');
                const fileCount = attachedFilesData.length;
                uploadFileButton.title = `Attach Parchment (${fileCount} image${fileCount > 1 ? 's' : ''} attached)`;

                // Display file names with remove buttons
                attachedFilesData.forEach(file => {
                    const item = document.createElement('span');
                    item.className = 'attachment-item';

                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = file.name;
                    item.appendChild(nameSpan);

                    const removeBtn = document.createElement('span');
                    removeBtn.className = 'remove-attachment';
                    removeBtn.textContent = '×'; // Times symbol
                    removeBtn.title = `Remove ${file.name}`;
                    removeBtn.dataset.fileId = file.fileId; // Store ID to identify which file to remove
                    removeBtn.onclick = (e) => {
                        e.stopPropagation(); // Prevent triggering file input again if nested weirdly
                        removeAttachment(file.fileId);
                    };

                    item.appendChild(removeBtn);
                    attachmentsPreview.appendChild(item);
                });

            } else {
                uploadFileButton.classList.remove('has-files');
                // Set title based on provider support
                uploadFileButton.title = providerSupportsImages
                    ? 'Attach Parchment (Images)'
                    : 'Attachment disabled (Provider does not support images)';
            }

             // Disable upload button if provider doesn't support images
            uploadFileButton.disabled = !providerSupportsImages;
            // Ensure file input is also disabled visually if needed (though clicking button is main interaction)
            if (fileUploadInput) fileUploadInput.disabled = !providerSupportsImages;

            console.log(`Attachment UI Updated. Provider Supports Images: ${providerSupportsImages}, Attached Count: ${attachedFilesData.length}, Button Disabled: ${!providerSupportsImages}`);
        }

        // --- Function to remove an attachment ---
        function removeAttachment(fileIdToRemove) {
            attachedFilesData = attachedFilesData.filter(file => file.fileId !== fileIdToRemove);
            updateAttachmentUI(); // Refresh the display
            console.log(`Removed attachment with ID: ${fileIdToRemove}`);
        }

        // --- Handler for file input selection ---
        function handleFileSelection(event) {
            const files = event.target.files;
            if (!files || files.length === 0) {
                return; // No files selected
            }

            // Check if provider supports images *before* processing
            const providerSupportsImages = (typeof PROVIDERS !== 'undefined' && selectedProvider && PROVIDERS[selectedProvider]?.supportsImages) ?? false;
            if (!providerSupportsImages) {
                alert("The current provider does not support image attachments.");
                event.target.value = null; // Clear the selection
                return;
            }


            const currentCount = attachedFilesData.length;
            let addedCount = 0;

            for (const file of files) {
                if (currentCount + addedCount >= MAX_ATTACHMENTS) {
                    alert(`You can attach a maximum of ${MAX_ATTACHMENTS} images.`);
                    break; // Stop processing further files in this selection
                }

                const fileId = `file-${Date.now()}-${Math.random().toString(16).substring(2)}`;
                console.log(`Processing file: ${file.name}, Type: ${file.type}, Size: ${file.size}`);

                // --- Validation ---
                if (!ALLOWED_IMAGE_TYPES.includes(file.type)) {
                    console.warn(`Skipping invalid file type: ${file.name} (${file.type})`);
                    alert(`Invalid file type: ${file.name}. Only JPEG, PNG, WEBP, GIF allowed.`);
                    continue; // Skip this file
                }
                if (file.size > MAX_FILE_SIZE) {
                     console.warn(`Skipping oversized file: ${file.name} (${file.size} bytes)`);
                     alert(`File too large: ${file.name} (${(file.size / 1024 / 1024).toFixed(1)}MB). Max size is 4MB.`);
                    continue; // Skip this file
                }
                // Check if file with same name is already attached (simple check)
                if (attachedFilesData.some(f => f.name === file.name)) {
                     console.warn(`Skipping duplicate filename: ${file.name}`);
                     alert(`File "${file.name}" is already attached.`);
                    continue; // Skip this file
                }
                // --- End Validation ---


                const reader = new FileReader();

                // Use a Promise to handle async reading cleanly within the loop
                const readFilePromise = new Promise((resolve, reject) => {
                    reader.onload = (e) => {
                        const dataUrl = e.target.result;
                        const parts = dataUrl.split(',');
                        if (parts.length === 2) {
                            const metaPart = parts[0];
                            const base64Data = parts[1];
                            const mimeType = metaPart.split(':')[1].split(';')[0];
                            resolve({ fileId, name: file.name, mimeType, data: base64Data });
                        } else {
                            console.error("Failed to parse data URL:", dataUrl.substring(0,50) + "...");
                            reject(new Error(`Could not process file: ${file.name}`));
                        }
                    };
                    reader.onerror = (e) => {
                        console.error("FileReader error:", e);
                        reject(new Error(`Error reading file: ${file.name}`));
                    };
                    reader.readAsDataURL(file);
                });

                // Process the result of reading the file
                readFilePromise.then(fileData => {
                    attachedFilesData.push(fileData);
                    addedCount++;
                    console.log(`Successfully added ${fileData.name} to attachments.`);
                }).catch(error => {
                     alert(error.message); // Show error to user
                }).finally(() => {
                    // Update UI after each file is processed (success or failure)
                    // This ensures the UI updates progressively if multiple files are selected
                    updateAttachmentUI();
                });
            }

            // Clear the file input value AFTER the loop finishes
            // allowing the 'change' event to fire again for the same file selection.
            event.target.value = null;
        }

        // --- handleSendMessage ---
        async function handleSendMessage() {
            // Check provider image support FIRST if files are attached
            const providerConfig = (typeof PROVIDERS !== 'undefined' && selectedProvider) ? PROVIDERS[selectedProvider] : null;
            const providerSupportsImages = providerConfig?.supportsImages ?? false;
            if (attachedFilesData.length > 0 && !providerSupportsImages) {
                 alert(`The selected provider (${providerConfig?.name || selectedProvider}) does not support image input. Please remove attachments or switch provider.`);
                 return;
            }

            if (!hasSufficientApiResources()) {
                 const providerName = providerConfig?.name || selectedProvider || "the selected provider";
                 if (doesProviderNeedApiKey(selectedProvider)) {
                     alert(`No API Key loaded for ${providerName}, which requires one. Please add a key in Settings.`);
                 } else {
                     alert(`Cannot send message. Please select a valid provider in Settings.`);
                 }
                 return;
            }
            if (isWaitingForResponse) return;

            const userInput = messageInput.value.trim();
            const responseCount = parseInt(mainResponseCountInput.value, 10);

            // Require text OR an image to send
            if (userInput === '' && attachedFilesData.length === 0) {
                console.log("Send cancelled: No text or attachments.");
                return;
            }

            const numResponses = isNaN(responseCount) || responseCount < 0 ? 0 : Math.min(responseCount, maxResponseVariations);
            const turnId = `turn-${turnCounter++}`;
            const containsPlaceholder = userInput.includes(iterationPlaceholder);

            isWaitingForResponse = true;
            if (sendButton) sendButton.disabled = true;
            if (uploadFileButton) uploadFileButton.disabled = true; // Disable upload while waiting
            messageInput.value = ''; // Clear text input
            autoGrowTextarea();

            // --- Create user entry with potential images ---
            const userEntry = {
                role: 'user',
                content: userInput, // Text content
                turnId: turnId
            };
            // If images are attached, add them to the entry (only mimeType and data needed for history/API)
            if (attachedFilesData.length > 0) {
                userEntry.images = attachedFilesData.map(f => ({ mimeType: f.mimeType, data: f.data }));
                console.log(`Attaching ${userEntry.images.length} images to user message entry.`);
            }
            // ---

            conversationHistory.push(userEntry);
            displayMessage(userEntry, 'user'); // Display will handle showing images
            saveHistoryToLocalStorage();
            scrollToBottom();

            // --- Clear attachments AFTER adding to history and displaying ---
            const attachmentsSent = [...attachedFilesData]; // Keep a copy if needed later, otherwise just clear
            attachedFilesData = [];
            updateAttachmentUI(); // Update UI to show no files attached
            // ---

            // --- API Call Logic ---
            if (numResponses > 0) {
                showTypingIndicator();
                const baseHistory = prepareHistoryForApi(conversationHistory); // Prepare full history
                const responses = [];
                let overallError = null;
                const provider = selectedProvider;
                const model = selectedModel;

                console.log(`Sending ${numResponses} requests to ${provider} (${model})`);

                for (let i = 0; i < numResponses; i++) {
                    const iteration = i + 1;
                    let currentHistory = [...baseHistory]; // Use the prepared history for each iteration

                    // --- Placeholder substitution ---
                    if (containsPlaceholder && numResponses > 1) {
                        const userMessageIndex = currentHistory.findLastIndex(m => m.role === 'user');
                        // Ensure the message and its content exist before replacing
                        if (userMessageIndex > -1 && typeof currentHistory[userMessageIndex].content === 'string') {
                            const originalMessage = currentHistory[userMessageIndex];
                            const substitutedContent = originalMessage.content.replace(
                                new RegExp(iterationPlaceholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g'),
                                iteration.toString()
                            );
                            // Create a new object to prevent modifying the base history object directly
                            currentHistory[userMessageIndex] = {
                                ...originalMessage, // Copy other properties (like images, role, turnId)
                                content: substitutedContent // Update the content
                            };
                            console.log(`Substituted placeholder in user message content for iteration ${iteration}`);
                        } else {
                            console.warn("Could not find user message with text content to substitute placeholder.");
                        }
                    }
                    // --- End Placeholder ---

                    try {
                        const messageContent = await attemptApiCallWithRetry(provider, model, currentHistory, { temperature: 0.7, top_p: 0.9 });
                        responses.push(messageContent);
                    } catch (e) {
                        console.error(`API Call Failed (Provider: ${provider}, Model: ${model}, Iteration: ${iteration}) after retries:`, e);
                        responses.push(e.message || "[Spirit Communication Failed]");
                        overallError = e;
                    }
                } // End loop through variations

                hideTypingIndicator();

                if (responses.length > 0) {
                    const botEntry = { role: 'assistant', variants: responses, selectedIndex: 0, turnId: turnId };
                    conversationHistory.push(botEntry);
                    saveHistoryToLocalStorage();
                    displayBotMessage(botEntry, 'spirit');
                    scrollToBottom();
                }
            } else {
                console.log("Query added to history, 0 responses requested.");
            }
            // --- End API Call Logic ---

            isWaitingForResponse = false;
            if (sendButton) sendButton.disabled = !hasSufficientApiResources();
             // Re-enable upload button based on provider support
            updateAttachmentUI();
            messageInput.focus();
        }


        // --- displayMessage to show image previews ---
        function displayMessage(entry, sender) {
            let contentText = "";
            if (sender === 'user') {
                contentText = entry.content || "";
            } else {
                contentText = entry.variants?.[entry.selectedIndex ?? 0] || "[Error - Variant unavailable]";
            }

            const msgDiv = document.createElement('div');
            msgDiv.className = `message message-${sender}`;
            if (entry.turnId) msgDiv.dataset.turnId = entry.turnId;

            const pfpUrl = (sender === 'user') ? userPfp : botPfp;
            const avatarEl = createPfpElement(sender, pfpUrl);
            const wrapper = document.createElement('div');
            wrapper.classList.add('message-content-wrapper');
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';

            // Render text content (Markdown for bot, plain for user)
            if (sender === 'spirit') {
                try { contentDiv.innerHTML = marked.parse(contentText); }
                catch (e) { console.error("Markdown error:", e); contentDiv.textContent = contentText; contentDiv.style.whiteSpace = 'pre-wrap'; }
            } else { // User message
                // Add text only if it exists
                if (contentText) {
                     const textSpan = document.createElement('span'); // Use span for potential inline display with images if needed later
                     textSpan.textContent = contentText;
                     textSpan.style.whiteSpace = 'pre-wrap'; // Ensure user text wraps
                     contentDiv.appendChild(textSpan);
                }
            }

             // --- Append image previews for user messages ---
             if (sender === 'user' && Array.isArray(entry.images) && entry.images.length > 0) {
                 const imageContainer = document.createElement('div'); // Optional container for images
                 imageContainer.style.marginTop = contentText ? '10px' : '0'; // Add margin only if text exists above
                 imageContainer.style.display = 'flex'; // Arrange images
                 imageContainer.style.flexWrap = 'wrap';
                 imageContainer.style.gap = '5px';

                 entry.images.forEach(imgData => {
                     if (imgData && imgData.mimeType && imgData.data) {
                         const imgPreview = document.createElement('img');
                         imgPreview.className = 'attached-image-preview';
                         // Construct the full data URL for the src attribute
                         imgPreview.src = `data:${imgData.mimeType};base64,${imgData.data}`;
                         imgPreview.alt = 'Attached image'; // More descriptive alt
                         imgPreview.title = 'Attached image'; // Tooltip
                         // Add click handler to open full image? (Future enhancement)
                         // imgPreview.onclick = () => { window.open(imgPreview.src, '_blank'); };
                         imageContainer.appendChild(imgPreview);
                     }
                 });
                 contentDiv.appendChild(imageContainer); // Append container to content
             }
             // --- END ---

            wrapper.appendChild(contentDiv);
            if (sender === 'spirit') {
                 addCodeActionButtons(contentDiv, wrapper, entry.turnId, entry.selectedIndex ?? 0);
            }

            if (sender === 'user') { msgDiv.appendChild(wrapper); msgDiv.appendChild(avatarEl); }
            else { msgDiv.appendChild(avatarEl); msgDiv.appendChild(wrapper); }

            if (pages) {
                pages.appendChild(msgDiv);
                if (sender === 'spirit') {
                    contentDiv.querySelectorAll('pre code').forEach((block) => {
                        try { hljs.highlightElement(block); } catch (e) { console.warn("Highlight error:", e); }
                    });
                }
            } else { console.error("Pages container missing."); }
            return msgDiv;
        }

        // --- prepareHistoryForApi ---
        // Passes 'images' field along if present on user messages.
        // API-specific transformation (e.g., for Gemini) happens later.
        function prepareHistoryForApi(hist) {
            if (!Array.isArray(hist)) return [];
            return hist
                .filter(m => m && m.role) // Basic validation
                .map(m => {
                    if (m.role === 'system') {
                        return { role: 'system', content: m.content || "" };
                    }
                    if (m.role === 'user') {
                        const userMsg = { role: 'user', content: m.content || "", turnId: m.turnId }; // Include turnId if needed by API? (Usually not)
                        if (Array.isArray(m.images) && m.images.length > 0) {
                            // Ensure we only pass valid image objects needed by API transform
                            userMsg.images = m.images.filter(img => img && img.mimeType && img.data)
                                                    .map(img => ({ mimeType: img.mimeType, data: img.data }));
                            if(userMsg.images.length === 0) delete userMsg.images; // Don't send empty array
                        }
                        return userMsg;
                    }
                    if (m.role === 'assistant') {
                        const content = m.variants?.[m.selectedIndex ?? 0];
                        return (content != null) ? { role: 'assistant', content: content, turnId: m.turnId } : null;
                    }
                    return null;
                })
                .filter(Boolean); // Filter out any nulls
        }

        // --- loadHistoryFromLocalStorage ---
        // Ensures 'images' field is handled if present in stored history
        function loadHistoryFromLocalStorage() {
            let providerOk = false;
            try {
                if (typeof PROVIDERS === 'undefined' || Object.keys(PROVIDERS).length === 0) throw new Error("PROVIDERS definitions missing.");
                const sp = localStorage.getItem('selectedProvider');
                selectedProvider = (sp && PROVIDERS[sp]) ? sp : (Object.keys(PROVIDERS)[0] || '');
                selectedModel = localStorage.getItem('selectedModel') || '';
                providerOk = true;
            } catch (e) {
                console.error("Provider configuration or loading error:", e);
                selectedProvider = localStorage.getItem('selectedProvider') || '';
                selectedModel = localStorage.getItem('selectedModel') || '';
            }

             try {
                 const sk = localStorage.getItem('apiKeys'); apiKeys = sk ? JSON.parse(sk) : {};
                 const si = localStorage.getItem('currentApiKeyIndex'); currentApiKeyIndex = si ? JSON.parse(si) : {};
                 const sc = localStorage.getItem('apiCallCounts'); apiCallCounts = sc ? JSON.parse(sc) : {};
                 if (typeof apiKeys !== 'object' || apiKeys === null) apiKeys = {};
                 if (typeof currentApiKeyIndex !== 'object' || currentApiKeyIndex === null) currentApiKeyIndex = {};
                 if (typeof apiCallCounts !== 'object' || apiCallCounts === null) apiCallCounts = {};
                 const savedMaxVar = localStorage.getItem('maxResponseVariations');
                 const parsedMaxVar = parseInt(savedMaxVar || '5', 10);
                 maxResponseVariations = (!isNaN(parsedMaxVar) && parsedMaxVar >= 1) ? parsedMaxVar : 5;
             } catch (e) { console.warn("API Key/Index/Count/Settings loading error:", e); apiKeys = {}; currentApiKeyIndex = {}; apiCallCounts = {}; maxResponseVariations = 5;}

            let historyOk = false;
            try {
                const sh = localStorage.getItem('conversationHistory');
                if (!sh) throw new Error('No history found in localStorage');
                let ph = JSON.parse(sh);
                if (!Array.isArray(ph)) throw new Error('Stored history is not an array');
                if (ph.length === 0 || ph[0]?.role !== 'system') {
                    const sys = localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
                    ph.unshift({ role: 'system', content: sys });
                } else { ph[0].content = ph[0].content || localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT; }

                // --- Sanitize loaded history, preserving VALID images field ---
                conversationHistory = ph.map(m => {
                    if (!m || !m.role) return null;
                    if (m.role === 'system') { return m; }
                    if (m.role === 'user') {
                         const userMsg = {
                              role: 'user', content: m.content || "", turnId: m.turnId
                         };
                         // --- Load and validate images array ---
                         if (Array.isArray(m.images)) {
                              userMsg.images = m.images.filter(img => img && typeof img.mimeType === 'string' && typeof img.data === 'string');
                              if (userMsg.images.length === 0) { delete userMsg.images; } // Remove empty array
                         }
                         return userMsg;
                    }
                    if (m.role === 'assistant') {
                        const variants = Array.isArray(m.variants) ? m.variants : (m.content != null ? [m.content] : []);
                        let selectedIndex = m.selectedIndex ?? 0;
                        if (!Number.isInteger(selectedIndex) || selectedIndex < 0 || selectedIndex >= variants.length) { selectedIndex = 0; }
                        // Removed isCodeEdit property check
                        return { role: 'assistant', variants: variants, selectedIndex: selectedIndex, turnId: m.turnId };
                    }
                    return null;
                }).filter(Boolean);
                // --- End Sanitization ---

                const lastTurn = conversationHistory.slice().reverse().find(m => m.turnId?.startsWith('turn-'));
                turnCounter = lastTurn?.turnId ? (parseInt(lastTurn.turnId.split('-')[1], 10) || 0) + 1 : 1;
                historyOk = true;
                console.log(`History loaded. ${conversationHistory.length - 1} messages. Next turn ID: ${turnCounter}`);
            } catch (e) {
                console.warn("Conversation history loading error:", e);
                const sys = localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
                conversationHistory = [{ role: 'system', content: sys }]; turnCounter = 1;
            }
            // --- Clear any stray attachments on load ---
            attachedFilesData = [];
            updateAttachmentUI(); // Ensure UI reflects empty state initially

            return providerOk && historyOk;
        }

        // --- initialLoad ---
        // Calls updateAttachmentUI after loading state
        function initialLoad() {
            console.log("InitialLoad started.");
            if (typeof PROVIDERS === 'undefined') { console.error("FATAL: PROVIDERS definitions missing."); alert("Error: PROVIDERS definitions missing."); return; }
            if (typeof getApiResponse !== 'function') { console.error("FATAL: getApiResponse missing."); alert("Error: API function missing."); return; }

            loadHistoryFromLocalStorage(); // Loads history, keys, settings etc.
            populateProviderSelect(); // Populates selects based on loaded state
            updateApiKeyStatus(selectedProvider); // Updates key status display
            updateAttachmentUI(); // <--- Update attachment button state based on loaded provider

            hideCodeBlocks = localStorage.getItem('hideCodeBlocks') === 'true';
            downloadCodeMode = localStorage.getItem('downloadCodeMode') === 'true';
            enableRunHtmlMode = localStorage.getItem('enableRunHtmlMode') === 'true';
            if (chatContainerElement) { chatContainerElement.classList.toggle('code-hidden', hideCodeBlocks); chatContainerElement.classList.toggle('download-code-active', downloadCodeMode); chatContainerElement.classList.toggle('run-html-active', enableRunHtmlMode); }
            if (hideCodeCheckbox) hideCodeCheckbox.checked = hideCodeBlocks; if (downloadCodeCheckbox) downloadCodeCheckbox.checked = downloadCodeMode; if (enableRunHtmlCheckbox) enableRunHtmlCheckbox.checked = enableRunHtmlMode;

            if (sendButton) sendButton.disabled = !hasSufficientApiResources();
            updateResponseCountInputMax();
            rebuildChatFromHistory();
            displayInitialGreeting();
            autoGrowTextarea();
            console.log("Arcane Tome Initialized.");
        }

        // --- attachEventListeners ---
        // Add listener for file input and provider change
        function attachEventListeners() {
            console.log("Attaching event listeners...");
            if (sendButton) sendButton.addEventListener('click', handleSendMessage); else console.error("sendButton missing");
            if (messageInput) { messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } }); messageInput.addEventListener('input', autoGrowTextarea); } else console.error("messageInput missing");
            if (settingsButton) settingsButton.addEventListener('click', openSystemPromptModal); else console.error("settingsButton missing");

            // --- Add updateAttachmentUI call on provider change ---
            if (providerSelect) {
                 providerSelect.addEventListener('change', () => {
                     handleProviderChange(); // Existing handler
                     // If provider changes, clear pending attachments and update UI
                     if (attachedFilesData.length > 0) {
                        console.log("Provider changed, clearing existing attachments.");
                        attachedFilesData = [];
                     }
                     updateAttachmentUI();
                 });
            } else console.error("providerSelect missing");
            // ---

            if (modelSelect) modelSelect.addEventListener('change', handleModelChange); else console.error("modelSelect missing");
            if (addKeyButton) addKeyButton.addEventListener('click', addApiKey); else console.error("addKeyButton missing");
            if (clearKeysButton) clearKeysButton.addEventListener('click', clearApiKeysForProvider); else console.error("clearKeysButton missing");
            if (resetCallCountButton) resetCallCountButton.addEventListener('click', resetApiCallCountForProvider); else console.error("resetCallCountButton missing");
            if (saveSettingsButton) saveSettingsButton.addEventListener('click', saveSettings); else console.error("saveSettingsButton missing");
            if (cancelSettingsButton) cancelSettingsButton.addEventListener('click', () => { if (systemPromptModal) systemPromptModal.style.display = 'none'; }); else console.error("cancelSettingsButton missing");
            if (systemPromptModal) systemPromptModal.addEventListener('click', (e) => { if (e.target === systemPromptModal) systemPromptModal.style.display = 'none'; }); else console.error("systemPromptModal missing");
            if (hideCodeCheckbox) hideCodeCheckbox.addEventListener('change', handleHideCodeToggle); else console.error("hideCodeCheckbox missing");
            if (downloadCodeCheckbox) downloadCodeCheckbox.addEventListener('change', handleDownloadCodeToggle); else console.error("downloadCodeCheckbox missing");
            if (enableRunHtmlCheckbox) enableRunHtmlCheckbox.addEventListener('change', handleEnableRunHtmlToggle); else console.error("enableRunHtmlCheckbox missing");

            // Removed event listeners for Edit Modal elements

            if (htmlRunnerRenderButton) htmlRunnerRenderButton.addEventListener('click', renderRunnerHTML); else console.error("htmlRunnerRenderButton missing");
            if (htmlRunnerCloseButton) htmlRunnerCloseButton.addEventListener('click', () => { if (htmlRunnerModal) htmlRunnerModal.style.display = 'none'; }); else console.error("htmlRunnerCloseButton missing");
            if (htmlRunnerModal) htmlRunnerModal.addEventListener('click', (e) => { if (e.target === htmlRunnerModal) htmlRunnerModal.style.display = 'none'; }); else console.error("htmlRunnerModal missing");
            if (clearChatButton) clearChatButton.addEventListener('click', handleClearChat); else console.error("clearChatButton missing");
            if (addIteratorButton) addIteratorButton.addEventListener('click', () => insertIteratorPlaceholder(messageInput)); else console.error("addIteratorButton missing");

            // --- Listener for the upload button to trigger the hidden input ---
            if (uploadFileButton) {
                 uploadFileButton.addEventListener('click', () => {
                     if (fileUploadInput && !uploadFileButton.disabled) {
                          fileUploadInput.click();
                     } else if (uploadFileButton.disabled) {
                         console.log("Upload button clicked but disabled.");
                         // Optionally show a tooltip or message why it's disabled
                     }
                 });
            } else console.error("uploadFileButton missing");

            // --- Listener for the actual file input change event ---
            if (fileUploadInput) {
                fileUploadInput.addEventListener('change', handleFileSelection);
            } else {
                console.error("fileUploadInput missing");
            }

            if (pfpUploadInput) pfpUploadInput.addEventListener('change', handlePfpUpload); else console.error("pfpUploadInput missing");
            console.log("Event listeners attached.");
        }

        // --- Handler for PFP Upload (extracted) ---
        function handlePfpUpload(event) {
             const f = event.target.files[0]; if (!f || !currentPfpElementToUpdate) return; const r = new FileReader();
             r.onload = function(e) {
                 const u = e.target.result; currentPfpElementToUpdate.src = u;
                 const t = currentPfpElementToUpdate.closest('.avatar').dataset.senderType;
                 if (t === 'user') { userPfp = u; localStorage.setItem('userPfp', u); document.querySelectorAll('.avatar.user-avatar img').forEach(i=>i.src=u); }
                 else if (t === 'spirit') { botPfp = u; localStorage.setItem('botPfp', u); document.querySelectorAll('.avatar.spirit-avatar img').forEach(i=>i.src=u); }
                 currentPfpElementToUpdate = null;
             }; r.readAsDataURL(f); event.target.value = null;
        }


        // --- Other functions (updateApiKeyStatus, addApiKey, clearApiKeysForProvider, resetApiCallCountForProvider, attemptApiCallWithRetry, hasSufficientApiResources, populateProviderSelect, populateModelSelect, handleProviderChange, handleModelChange, openSystemPromptModal, saveSettings, updateResponseCountInputMax, handleHideCodeToggle, handleDownloadCodeToggle, handleEnableRunHtmlToggle, handleClearChat, insertIteratorPlaceholder, autoGrowTextarea, renderRunnerHTML, openHtmlRunner, createPfpElement, displayBotMessage, displayMultipleMessages, addCodeActionButtons, copyCodeFromPre, downloadCode, showTypingIndicator, hideTypingIndicator, scrollToBottom, updateHistorySelection, saveHistoryToLocalStorage, rebuildChatFromHistory, displayInitialGreeting, doesProviderNeedApiKey) ---
        // ... These functions remain largely the same as in the previous version ...

        function updateApiKeyStatus(provider = selectedProvider) {
            const keysForProvider = apiKeys[provider] || []; const keyCount = keysForProvider.length;
            const callCount = apiCallCounts[provider] || 0;
            const providerConfig = (typeof PROVIDERS !== 'undefined' && provider) ? PROVIDERS[provider] : null;
            const providerName = providerConfig?.name || provider || 'Unknown Provider';
            const needsKey = doesProviderNeedApiKey(provider);

            if (apiKeyStatus) { apiKeyStatus.textContent = `Keys Loaded: ${keyCount}`; }
            if (apiCallCountDisplay) { apiCallCountDisplay.textContent = `Calls: ${callCount}`; }
            if (selectedProviderLabel) { selectedProviderLabel.textContent = providerName; }
            if (sendButton) { sendButton.disabled = (needsKey && keyCount === 0) || isWaitingForResponse; }
            if (apiKeyInput) { apiKeyInput.disabled = !needsKey; apiKeyInput.placeholder = needsKey ? "Paste new key..." : "Not Required"; }
            if (addKeyButton) { addKeyButton.disabled = !needsKey; }
            if (clearKeysButton) { clearKeysButton.disabled = !needsKey; }
            if (resetCallCountButton) { resetCallCountButton.style.display = provider ? 'inline-block' : 'none'; }
        }
        function doesProviderNeedApiKey(provider) {
            if (!provider || typeof PROVIDERS === 'undefined' || !PROVIDERS[provider]) { return true; } // Assume needed if config missing
            const providerConfig = PROVIDERS[provider];
            return providerConfig.apiKeyLocation !== 'none' || providerConfig.format === 'proxy_compatible';
        }
        function addApiKey() {
             const provider = selectedProvider; const newKey = apiKeyInput.value.trim(); if (!provider) { alert("Select provider."); return; }
             const providerConfig = PROVIDERS[provider]; if (!providerConfig) { alert("Invalid provider."); return; }
             if (!doesProviderNeedApiKey(provider)) { alert(`${providerConfig.name} does not require client-side keys.`); apiKeyInput.value = ''; return; }
             if (newKey) { if (!apiKeys[provider]) apiKeys[provider] = []; if (!apiKeys[provider].includes(newKey)) { apiKeys[provider].push(newKey); apiKeyInput.value = ''; updateApiKeyStatus(provider); console.log(`Added key for ${provider}. Total: ${apiKeys[provider].length}`); try { localStorage.setItem('apiKeys', JSON.stringify(apiKeys)); } catch (e) { console.error("Failed to save API keys:", e); }} else { alert(`Key already exists for ${providerConfig.name}.`); }} else { alert("Paste key."); }
        }
        function clearApiKeysForProvider() {
             const provider = selectedProvider; if (!provider) { alert("Select provider."); return; }
             const providerConfig = PROVIDERS[provider]; if (!providerConfig) { alert(`Invalid provider.`); return; }
             const providerName = providerConfig.name || provider;
             if (confirm(`Remove ALL keys for ${providerName}?`)) { apiKeys[provider] = []; currentApiKeyIndex[provider] = 0; updateApiKeyStatus(provider); console.log(`Cleared keys for ${provider}.`); try { localStorage.setItem('apiKeys', JSON.stringify(apiKeys)); localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex)); } catch (e) { console.error("Failed to save cleared keys/indices:", e); }}
        }
        function resetApiCallCountForProvider() {
            const provider = selectedProvider; if (!provider) { alert("Select provider."); return; }
            const providerName = (typeof PROVIDERS !== 'undefined' && PROVIDERS[provider]?.name) ? PROVIDERS[provider].name : provider;
            if (confirm(`Reset call count for ${providerName} to zero?`)) { apiCallCounts[provider] = 0; updateApiKeyStatus(provider); console.log(`Reset API call count for ${provider}.`); try { localStorage.setItem('apiCallCounts', JSON.stringify(apiCallCounts)); } catch (e) { console.error("Failed to save reset count:", e); } }
        }
        async function attemptApiCallWithRetry(provider, model, history, options) {
            console.log(`Attempting API call to ${provider}/${model}.`);
            if (typeof PROVIDERS === 'undefined' || !PROVIDERS[provider]) { throw new Error(`Config Error: Provider '${provider}' missing`); }
            const providerConfig = PROVIDERS[provider]; const needsKey = doesProviderNeedApiKey(provider);
            const keys = apiKeys[provider] || []; const numKeys = keys.length; let startIndex = currentApiKeyIndex[provider] || 0; let triedKeyIndices = new Set();
            if (needsKey && numKeys === 0) { throw new Error(`[Config Error: No API Key available for ${providerConfig.name}]`); }
            const maxAttempts = needsKey ? numKeys : 1;
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                let currentKey = null; let keyIndexToTry = -1;
                if (needsKey) { keyIndexToTry = (startIndex + attempt) % numKeys; if (triedKeyIndices.has(keyIndexToTry) && triedKeyIndices.size === numKeys) { console.warn(`Tried all keys for ${provider}. Aborting retries.`); break; } currentKey = keys[keyIndexToTry]; triedKeyIndices.add(keyIndexToTry); console.log(`API Call Attempt ${attempt + 1}/${maxAttempts}. Key index: ${keyIndexToTry} for ${provider}`); }
                else { console.log(`API Call Attempt ${attempt + 1}/${maxAttempts} to ${provider} (no client key needed)`); }
                try {
                    if (typeof getApiResponse !== 'function') { throw new Error("getApiResponse function is not defined."); }
                    const result = await getApiResponse(provider, model, history, currentKey, options);
                    console.log(`API Call Success on attempt ${attempt + 1} for ${provider}`);
                    if (needsKey && keyIndexToTry !== -1) { currentApiKeyIndex[provider] = (keyIndexToTry + 1) % numKeys; try { localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex)); } catch(e) {console.warn("Failed to save API key index:", e);} }
                    apiCallCounts[provider] = (apiCallCounts[provider] || 0) + 1; try { localStorage.setItem('apiCallCounts', JSON.stringify(apiCallCounts)); } catch(e) {console.warn("Failed to save API call counts:", e);} updateApiKeyStatus(provider);
                    return result ?? "[Silence]"; // Use nullish coalescing
                } catch (error) {
                    console.warn(`API Call Error (Provider: ${provider}, Model: ${model}, Attempt: ${attempt + 1}, KeyIndex: ${keyIndexToTry}):`, error);
                    if (attempt === maxAttempts - 1) { console.error(`All ${maxAttempts} attempts failed for ${provider}. Last error:`, error); throw new Error(`[Spirit Disturbance after ${maxAttempts} attempts: ${error instanceof Error ? error.message : String(error)}]`); }
                    console.log(`Retrying with next key...`);
                }
            } throw new Error(`[Spirit Communication Failed after ${maxAttempts} attempts for ${provider}]`);
        }
        function hasSufficientApiResources() {
             if (!selectedProvider || typeof PROVIDERS === 'undefined' || !PROVIDERS[selectedProvider]) return false; const needsKey = doesProviderNeedApiKey(selectedProvider); if (!needsKey) return true; const keysForCurrent = apiKeys[selectedProvider] || []; return keysForCurrent.length > 0;
        }
        // Removed handleSendEditRequest function
        function populateProviderSelect() { if (!providerSelect) { console.error("providerSelect missing."); return; } providerSelect.innerHTML = ''; if (typeof PROVIDERS === 'undefined' || Object.keys(PROVIDERS).length === 0) { console.error("PROVIDERS missing."); providerSelect.innerHTML = '<option value="" disabled>Error</option>'; return; } for (const providerKey in PROVIDERS) { const option = document.createElement('option'); option.value = providerKey; option.textContent = PROVIDERS[providerKey].name || providerKey; providerSelect.appendChild(option); } if (!PROVIDERS[selectedProvider]) { selectedProvider = Object.keys(PROVIDERS)[0] || ''; localStorage.setItem('selectedProvider', selectedProvider); } providerSelect.value = selectedProvider; populateModelSelect(selectedProvider);}
        function populateModelSelect(providerKey) { if (!modelSelect) { console.error("modelSelect missing."); return; } modelSelect.innerHTML = ''; if (typeof PROVIDERS === 'undefined' || !providerKey || !PROVIDERS[providerKey]) { modelSelect.innerHTML = '<option value="" disabled>Select Provider</option>'; selectedModel = ''; localStorage.setItem('selectedModel', ''); updateApiKeyStatus(providerKey); return; } const providerConf = PROVIDERS[providerKey]; if (!providerConf.availableModels || providerConf.availableModels.length === 0) { modelSelect.innerHTML = '<option value="" disabled>No models</option>'; selectedModel = ''; localStorage.setItem('selectedModel', ''); updateApiKeyStatus(providerKey); return; } providerConf.availableModels.forEach(modelInfo => { const modelKey = typeof modelInfo === 'string' ? modelInfo : modelInfo.key; const modelName = typeof modelInfo === 'string' ? modelInfo : modelInfo.name || modelInfo.key; if (!modelKey) return; const option = document.createElement('option'); option.value = modelKey; option.textContent = modelName; modelSelect.appendChild(option); }); const savedModel = localStorage.getItem('selectedModel'); const isValidSavedModel = savedModel && providerConf.availableModels.some(m => (typeof m === 'string' ? m === savedModel : m.key === savedModel)); if (isValidSavedModel) { modelSelect.value = savedModel; selectedModel = savedModel; } else if (providerConf.defaultModel && providerConf.availableModels.some(m => (typeof m === 'string' ? m === providerConf.defaultModel : m.key === providerConf.defaultModel))) { modelSelect.value = providerConf.defaultModel; selectedModel = providerConf.defaultModel; } else { const firstModelKey = typeof providerConf.availableModels[0] === 'string' ? providerConf.availableModels[0] : providerConf.availableModels[0]?.key; if (firstModelKey) { modelSelect.value = firstModelKey; selectedModel = firstModelKey; } else { modelSelect.innerHTML = '<option value="" disabled>Error</option>'; selectedModel = ''; } } localStorage.setItem('selectedModel', selectedModel); console.log(`Model set: ${selectedModel} for ${selectedProvider}`); updateApiKeyStatus(providerKey); }
        function handleProviderChange() { selectedProvider = providerSelect.value; localStorage.setItem('selectedProvider', selectedProvider); populateModelSelect(selectedProvider); /* updateAttachmentUI handled by listener */; }
        function handleModelChange() { selectedModel = modelSelect.value; localStorage.setItem('selectedModel', selectedModel); console.log(`Model set: ${selectedModel} for ${selectedProvider}`); }
        function openSystemPromptModal() { console.log("openSystemPromptModal called"); if (!systemPromptModal) { console.error("Settings modal missing!"); return; } if (systemPromptInput) systemPromptInput.value = conversationHistory[0]?.content || localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT; if (maxVariationsInput) maxVariationsInput.value = maxResponseVariations; if (hideCodeCheckbox) hideCodeCheckbox.checked = hideCodeBlocks; if (downloadCodeCheckbox) downloadCodeCheckbox.checked = downloadCodeMode; if (enableRunHtmlCheckbox) enableRunHtmlCheckbox.checked = enableRunHtmlMode; if (apiKeyInput) apiKeyInput.value = ''; populateProviderSelect(); systemPromptModal.style.display = 'flex'; console.log("System prompt modal display attempt finished.");}
        function saveSettings() { console.log("saveSettings called"); const sp = systemPromptInput.value.trim() || DEFAULT_SYSTEM_PROMPT; if (conversationHistory.length === 0 || conversationHistory[0]?.role !== 'system') { conversationHistory.unshift({ role: 'system', content: sp }); } else { conversationHistory[0].content = sp; } localStorage.setItem('systemPrompt', sp); localStorage.setItem('selectedProvider', selectedProvider); localStorage.setItem('selectedModel', selectedModel); const newMaxVar = parseInt(maxVariationsInput.value, 10); if (!isNaN(newMaxVar) && newMaxVar >= 1 && newMaxVar <= parseInt(maxVariationsInput.max, 10)) { maxResponseVariations = newMaxVar; localStorage.setItem('maxResponseVariations', String(maxResponseVariations)); updateResponseCountInputMax(); } else { alert(`Invalid Max Variations value. Must be between 1 and ${maxVariationsInput.max}.`); maxVariationsInput.value = maxResponseVariations; return; } try { localStorage.setItem('apiKeys', JSON.stringify(apiKeys)); localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex)); localStorage.setItem('apiCallCounts', JSON.stringify(apiCallCounts)); console.log(`Settings saved. Provider: ${selectedProvider}, Model: ${selectedModel}, Max Variations: ${maxResponseVariations}`); } catch (e) { console.error("Failed to save API keys/indices/counts:", e); alert("Error saving API data."); } saveHistoryToLocalStorage(); updateApiKeyStatus(); systemPromptModal.style.display = 'none';}
        function updateResponseCountInputMax() { if (mainResponseCountInput) mainResponseCountInput.max = maxResponseVariations; /* Removed reference to editResponseCountInput */; }
        function handleHideCodeToggle() { if (!hideCodeCheckbox || !chatContainerElement) return; hideCodeBlocks = hideCodeCheckbox.checked; localStorage.setItem('hideCodeBlocks', String(hideCodeBlocks)); chatContainerElement.classList.toggle('code-hidden', hideCodeBlocks); }
        function handleDownloadCodeToggle() { if (!downloadCodeCheckbox || !chatContainerElement) return; downloadCodeMode = downloadCodeCheckbox.checked; localStorage.setItem('downloadCodeMode', String(downloadCodeMode)); chatContainerElement.classList.toggle('download-code-active', downloadCodeMode); }
        function handleEnableRunHtmlToggle() { if (!enableRunHtmlCheckbox || !chatContainerElement) return; enableRunHtmlMode = enableRunHtmlCheckbox.checked; localStorage.setItem('enableRunHtmlMode', String(enableRunHtmlMode)); chatContainerElement.classList.toggle('run-html-active', enableRunHtmlMode); }
        function handleClearChat() { console.log("handleClearChat called"); if (confirm("Disperse all echoes? (Cannot be undone)")) { console.log("Clear confirmed"); const sp = conversationHistory[0]?.content || localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT; conversationHistory = [{ role: 'system', content: sp }]; turnCounter = 1; attachedFilesData = []; updateAttachmentUI(); saveHistoryToLocalStorage(); rebuildChatFromHistory(); displayInitialGreeting(); console.log("Chat cleared."); } else { console.log("Clear cancelled"); } }
        function insertIteratorPlaceholder(targetInput) { console.log("insertIteratorPlaceholder called for target:", targetInput?.id); if (!targetInput) { console.error("Target input is null!"); return; } const start = targetInput.selectionStart; const end = targetInput.selectionEnd; const value = targetInput.value; const newValue = value.substring(0, start) + iterationPlaceholder + value.substring(end); targetInput.value = newValue; const newPos = start + iterationPlaceholder.length; targetInput.selectionStart = newPos; targetInput.selectionEnd = newPos; targetInput.focus(); targetInput.dispatchEvent(new Event('input', { bubbles: true })); console.log(`Iterator inserted into ${targetInput.id}`);}
        function autoGrowTextarea() { if (!messageInput) return; const input = messageInput; const maxHeightStyle = window.getComputedStyle(input).maxHeight; const maxHeight = parseFloat(maxHeightStyle) || 150; input.style.height = 'auto'; const scrollHeight = input.scrollHeight; input.style.height = Math.min(scrollHeight, maxHeight) + 'px'; input.style.overflowY = scrollHeight > maxHeight ? 'auto' : 'hidden'; }
        // Removed openEditCodeModal function
        // Removed updateSnippetLineCount function
        function renderRunnerHTML() { if (!htmlRunnerInput || !htmlRunnerFrame) { console.error("HTML Runner elements missing."); return; } const htmlCode = htmlRunnerInput.value; if (/<script.*?>.*?window\.location.*?<\/script>/i.test(htmlCode) || /<script.*?>.*?document\.cookie.*?<\/script>/i.test(htmlCode) || /<script.*?>.*?localStorage.*?<\/script>/i.test(htmlCode) || /<script.*?>.*?sessionStorage.*?<\/script>/i.test(htmlCode)) { console.warn("Harmful script detected. Blocking render."); try { const d = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow?.document; if (d) { d.open(); d.write('<html><body>Blocked</body></html>'); d.close(); } } catch (e) { /* ignore */ } return; } try { const d = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow?.document; if (d) { d.open(); d.write(htmlCode); d.close(); } else { console.error("Cannot access iframe document."); } } catch (e) { console.error("Error rendering HTML:", e); try { const d = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow?.document; if (d) { d.open(); d.write(`<html><body>Error:<pre>${e.message}</pre></body></html>`); d.close(); } } catch (e2) { /* ignore */ } } }
        function openHtmlRunner(initialCode = '') { if (!htmlRunnerModal || !htmlRunnerInput) { console.error("HTML Runner modal/input missing."); return; } htmlRunnerInput.value = initialCode; renderRunnerHTML(); htmlRunnerModal.style.display = 'flex'; }
        function createPfpElement(sender, pfpUrl) { const d=document.createElement('div'); d.className=`avatar ${sender}-avatar`; d.dataset.senderType=sender; const i=document.createElement('img'); i.src=pfpUrl; i.alt=`${sender} avatar`; i.onerror = () => { console.warn(`Failed avatar load: ${pfpUrl}`); const fb='https://ui-avatars.com/api/?name='+(sender==='user'?'U&background=1e3a8a':'S&background=6b21a8')+'&color=fff&font-size=0.6&bold=true'; i.src=fb; i.onerror=null; }; d.addEventListener('click', () => { currentPfpElementToUpdate=i; if (pfpUploadInput) pfpUploadInput.click(); else console.error("pfpUploadInput missing."); }); d.appendChild(i); return d; }
        function displayBotMessage(entry, sender = 'spirit') { if (!entry || !entry.variants) { console.warn("Invalid bot entry:", entry); return; } const variants = Array.isArray(entry.variants) ? entry.variants : [entry.variants]; const selectedIndex = entry.selectedIndex ?? 0; if (variants.length > 1) displayMultipleMessages({ ...entry, variants: variants, selectedIndex: selectedIndex }, sender); else if (variants.length === 1) displayMessage({ ...entry, variants: variants, selectedIndex: 0 }, sender); else displayMessage({ ...entry, variants: ["[Silence]"], selectedIndex: 0 }, sender); }
        function displayMultipleMessages(entry, sender = 'spirit') { if (!pages) { console.error("Pages container missing."); return null; } if (!entry || !Array.isArray(entry.variants) || entry.variants.length === 0) { console.warn("Invalid multi-entry:", entry); return null; } const tid = entry.turnId; const vars = entry.variants; let idx = entry.selectedIndex ?? 0; if (idx < 0 || idx >= vars.length) idx = 0; const msgDiv = document.createElement('div'); msgDiv.className = `message message-${sender}`; if (tid) msgDiv.dataset.turnId = tid; const pfpUrl = (sender === 'user') ? userPfp : botPfp; const avatarEl = createPfpElement(sender, pfpUrl); const wrapper = document.createElement('div'); wrapper.classList.add('message-content-wrapper'); const contentDiv = document.createElement('div'); contentDiv.className = 'message-content'; const nav = document.createElement('div'); nav.classList.add('response-navigation'); const prev = document.createElement('button'); prev.textContent = '<'; prev.title = "Previous"; const span = document.createElement('span'); span.title = "Variant"; const next = document.createElement('button'); next.textContent = '>'; next.title = "Next"; nav.appendChild(prev); nav.appendChild(span); nav.appendChild(next); let actsContainer = document.createElement('div'); actsContainer.classList.add('message-actions'); wrapper.appendChild(contentDiv); wrapper.appendChild(actsContainer); wrapper.appendChild(nav); function update(currentIndex) { const c = vars[currentIndex] || "[Error]"; try { contentDiv.innerHTML = marked.parse(c); } catch (e) { console.error("Markdown error:", e); contentDiv.textContent = c; contentDiv.style.whiteSpace = 'pre-wrap'; } addCodeActionButtons(contentDiv, wrapper, tid, currentIndex); span.textContent = `${currentIndex + 1} / ${vars.length}`; prev.disabled = currentIndex === 0; next.disabled = currentIndex === vars.length - 1; contentDiv.querySelectorAll('pre code').forEach((block) => { try { hljs.highlightElement(block); } catch (e) { console.warn("Highlight error:", e); } }); contentDiv.style.animation = 'none'; void contentDiv.offsetWidth; contentDiv.style.animation = 'fadeIn 0.3s ease-in-out'; } prev.addEventListener('click', () => { if (idx > 0) { idx--; update(idx); updateHistorySelection(tid, idx); } }); next.addEventListener('click', () => { if (idx < vars.length - 1) { idx++; update(idx); updateHistorySelection(tid, idx); } }); if (sender === 'user') { msgDiv.appendChild(wrapper); msgDiv.appendChild(avatarEl); } else { msgDiv.appendChild(avatarEl); msgDiv.appendChild(wrapper); } pages.appendChild(msgDiv); update(idx); return msgDiv; }
        function addCodeActionButtons(contentDiv, wrapper, turnId, variantIndex) { let acts = wrapper.querySelector('.message-actions'); if (!acts) { acts = document.createElement('div'); acts.classList.add('message-actions'); const nav = wrapper.querySelector('.response-navigation'); if (nav) wrapper.insertBefore(acts, nav); else wrapper.appendChild(acts); } acts.innerHTML = ''; contentDiv.querySelectorAll('.cat-placeholder').forEach(c => c.remove()); const codeBlocks = contentDiv.querySelectorAll('pre'); if (codeBlocks.length === 0 && !acts.hasChildNodes()) { if(acts.parentNode) acts.remove(); return; } codeBlocks.forEach((pre, preIdx) => { const uid = `pre-${turnId || 'g'}-${variantIndex}-${preIdx}`; pre.id = uid; const cat = document.createElement('span'); cat.className = 'cat-placeholder'; cat.textContent = '🐱'; cat.dataset.preId = uid; pre.parentNode.insertBefore(cat, pre); const code = pre.querySelector('code'); const txt = code ? code.textContent : ''; const lang = code?.className.match(/language-(\w+)/)?.[1]?.toLowerCase() || 'txt'; const fn = `tome_${turnId || 'c'}_${variantIndex + 1}_${preIdx + 1}.${lang}`; const cp = document.createElement('button'); cp.textContent='Copy'; cp.title=`Copy ${lang}`; cp.className='copy-code-button action-button'; cp.onclick=()=>copyCodeFromPre(uid, cp); acts.appendChild(cp); const dl = document.createElement('button'); dl.textContent='Download'; dl.title=`Download ${fn}`; dl.className='download-code-button action-button'; dl.onclick=()=>downloadCode(txt, fn); acts.appendChild(dl); if (lang==='html') { const rn = document.createElement('button'); rn.textContent='Run HTML'; rn.className='run-html-button action-button'; rn.title="Run HTML"; rn.onclick=()=>openHtmlRunner(txt); acts.appendChild(rn); } }); if (!acts.hasChildNodes() && acts.parentNode) acts.remove(); }
        function copyCodeFromPre(preId, btn) { const pre = document.getElementById(preId); const code = pre ? pre.querySelector('code') : null; if (!code) { console.error(`Code element missing for ${preId}`); if (btn) btn.textContent='Err'; return; } const txt = code.textContent || ''; if (!copyHelper) { console.error("Copy helper missing."); if (btn) btn.textContent='Err'; return; } copyHelper.value = txt; copyHelper.select(); copyHelper.setSelectionRange(0, 99999); let ok = false; try { ok = document.execCommand('copy'); } catch (e) { ok = false; } window.getSelection()?.removeAllRanges(); if (btn) { if (ok) { btn.textContent = 'Copied!'; btn.classList.add('copied'); setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 1500); } else { btn.textContent = 'Failed!'; setTimeout(() => { btn.textContent = 'Copy'; }, 2500); } } }
        function downloadCode(codeText, filename) { try { const b = new Blob([codeText], { type: 'text/plain;charset=utf-8' }); const u = URL.createObjectURL(b); const a = document.createElement('a'); a.href = u; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(u); } catch (e) { console.error("Download err:", e); alert("Download failed."); } }
        function showTypingIndicator() { if (document.getElementById('typing-indicator')) return; if (!pages) { console.error("Pages missing for typing indicator."); return; } const ind = document.createElement('div'); ind.className = 'typing-indicator message message-spirit'; ind.id = 'typing-indicator'; const av = createPfpElement('spirit', botPfp); const wr = document.createElement('div'); wr.className = 'message-content-wrapper'; const cd = document.createElement('div'); cd.className = 'message-content'; cd.style.cssText = 'font-style: italic; color: var(--ink-light);'; cd.textContent = 'The spirit whispers...'; wr.appendChild(cd); ind.appendChild(av); ind.appendChild(wr); pages.appendChild(ind); scrollToBottom(); }
        function hideTypingIndicator() { const ind = document.getElementById('typing-indicator'); if (ind) ind.remove(); }
        function scrollToBottom() { if (!pages) return; setTimeout(() => { pages.scrollTop = pages.scrollHeight; }, 50); }
        function updateHistorySelection(turnId, newIndex) { if (!turnId) return; const idx = conversationHistory.findIndex(m => m.turnId === turnId && m.role === 'assistant'); if (idx > -1) { const msg = conversationHistory[idx]; if (msg.variants && newIndex >= 0 && newIndex < msg.variants.length) { if (msg.selectedIndex !== newIndex) { msg.selectedIndex = newIndex; saveHistoryToLocalStorage(); } } else { console.warn(`Invalid index ${newIndex} for turn ${turnId}`); } } }
        function saveHistoryToLocalStorage() { try { localStorage.setItem('conversationHistory', JSON.stringify(conversationHistory)); } catch (e) { console.error("Save history error:", e); } }
        function rebuildChatFromHistory() { if (!pages) return; pages.innerHTML = ''; for (let i = 1; i < conversationHistory.length; i++) { const e = conversationHistory[i]; if (e.role === 'user') displayMessage(e, 'user'); else if (e.role === 'assistant') displayBotMessage(e, 'spirit'); } scrollToBottom(); }
        function displayInitialGreeting() { if (!pages) return; if (conversationHistory.length <= 1) { const g = "The ancient tome awaits..."; const e = { role: 'assistant', variants: [g], selectedIndex: 0, turnId: 'turn-0' }; displayBotMessage(e, 'spirit'); turnCounter = Math.max(turnCounter, 1); } }

        // --- Start the application ---
        document.addEventListener('DOMContentLoaded', () => {
            initialLoad();
            attachEventListeners();
        });

    </script>
</body>
</html>
