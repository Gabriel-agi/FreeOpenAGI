<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcane Tome (Vision Enabled)</title> <!-- Updated Title -->
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- API Provider Definitions (MUST be before main script) -->
    <script src="api_providers.js"></script> <!-- Make sure this path is correct -->

    <style>
        /* --- Arcane Tome Base Styles --- */
        :root {
             --parchment: #f5e7d0; --parchment-dark: #e3d5b8; --ink: #3a3129; --ink-light: #5a4e42; --gold: #c9a227; --crimson: #8b0000; --sapphire: #1e3a8a; --amethyst: #6b21a8; --emerald: #21a853; --shadow-light: 0 1px 3px rgba(0,0,0,0.15); --code-bg: #e8e0cf; --code-border: #d1c3a9;
             /* Using Georgia as primary, Times New Roman as fallback/heading */
             --font-body: Georgia, 'Times New Roman', Times, serif;
             --font-heading: 'Times New Roman', Times, serif; /* Replaced Cinzel Decorative */
        }
        html, body { height: 100%; margin: 0; padding: 0; }
        * { box-sizing: border-box; }
        /* --- Body uses Georgia --- */
        body { font-family: var(--font-body); font-size: 1.1rem; line-height: 1.6; background-color: var(--parchment); color: var(--ink); width: 100vw; overflow: hidden; }
        .tome { width: 100%; height: 100%; display: flex; flex-direction: column; position: relative; background-color: var(--parchment); }
        .pages { flex: 1; min-height: 0; padding: 20px; overflow-y: auto; scrollbar-width: none; /* Firefox */ display: flex; flex-direction: column; gap: 15px; border-bottom: 2px solid var(--ink-light); }
        .pages::-webkit-scrollbar { display: none; /* Safari and Chrome */ }
        .message { display: flex; gap: 10px; max-width: 85%; animation: fadeIn 0.5s ease-in-out;}
        .message-user { align-self: flex-end; flex-direction: row-reverse; }
        .message-spirit { align-self: flex-start; }
        .avatar { width: 45px; height: 45px; border-radius: 50%; flex-shrink: 0; border: 2px solid var(--parchment-dark); box-shadow: var(--shadow-light); display: flex; align-items: center; justify-content: center; overflow: hidden; background-color: var(--parchment-dark); cursor: pointer; }
        .avatar img { width: 100%; height: 100%; object-fit: cover; }
        .user-avatar { background-color: var(--sapphire); }
        .spirit-avatar { background-color: var(--amethyst); }
        .message-content-wrapper { display: flex; flex-direction: column; max-width: 100%; }
        .message-content { padding: 12px 18px; border-radius: 8px; line-height: 1.5; word-break: break-word; box-shadow: var(--shadow-light); max-width: fit-content; }
        .message-user .message-content { background-color: var(--sapphire); color: white; border-top-right-radius: 0; }
        .message-spirit .message-content { background-color: white; color: var(--ink); border: 1px solid var(--ink-light); border-top-left-radius: 0; }
        .message-content p { margin: 0 0 0.5em 0; } .message-content p:last-child { margin-bottom: 0; }

        /* --- NEW: Style for attached image previews in user message --- */
        .message-content .attached-image-preview {
            display: block; /* Display below text or inline-block if preferred */
            max-width: 150px; /* Slightly smaller than before */
            max-height: 100px; /* Adjusted height */
            margin-top: 10px;
            border-radius: 4px;
            border: 1px solid var(--ink-light);
            cursor: pointer; /* Optional: Could add lightbox later */
            background-color: var(--parchment-dark); /* Placeholder bg */
            object-fit: cover; /* Ensure image covers the area well */
        }
        /* Container for multiple images */
        .image-attachment-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px; /* Add space if there's text above */
        }

        .typing-indicator { align-self: flex-start; color: var(--ink-light); font-style: italic; padding: 10px 15px; background-color: rgba(227,213,184,0.5); border-radius: 8px; font-size: 1rem; }
        .writing-area { padding: 12px; background-color: var(--parchment-dark); grid-template-rows: auto auto; align-items: center; display: grid; grid-template-columns: 1fr auto; gap: 8px; flex-shrink: 0; }
        .message-input { flex: 1 1 250px; padding: 10px; background-color: var(--parchment); grid-column: 1 / 2; grid-row: 1 / 2;  border: 2px solid var(--ink-light); border-radius: 5px; font-family: inherit; font-size: 1.1rem; resize: none; outline: none; color: var(--ink); min-height: 36px; max-height: 150px; line-height: 1.5; }
        .message-input:focus { border-color: var(--gold); }

        /* --- NEW: Area to show attached file names --- */
        .attachments-preview {
            grid-column: 1 / 3; /* Take full width below input */
            grid-row: 2 / 3;
            margin-top: 5px;
            font-size: 0.85em;
            color: var(--ink-light);
            margin-top: 5px; /* Space above controls */
            padding-left: 5px; /* Align with input padding */
            min-height: 1.2em; /* Reserve some space even when empty */
            display: flex; /* Allow wrapping */
            flex-wrap: wrap;
            gap: 5px; /* Spacing between items */
        }
        .attachment-item {
            display: inline-flex; /* Align text and button nicely */
            align-items: center;
            background-color: var(--parchment);
            border: 1px solid var(--ink-light);
            padding: 2px 6px;
            border-radius: 10px; /* More rounded */
            white-space: nowrap; /* Prevent filename breaking */
            overflow: hidden;
            text-overflow: ellipsis; /* Add ellipsis if too long */
            max-width: 150px; /* Limit width */
        }
        .remove-attachment {
            color: var(--crimson);
            margin-left: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1em;
            line-height: 1;
            padding: 0 2px;
        }
        .remove-attachment:hover {
            color: darkred;
        }


        .writing-controls { display: flex; align-items: flex-end; gap: 8px; flex-wrap: nowrap; grid-column: 2 / 3; grid-row: 1 / 2; align-self: center;  /* Ensure controls take width if needed */ }
        /* --- Footer buttons use Georgia --- */
        .footer-button { background-color: var(--ink-light); color: var(--parchment); border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; padding: 8px 10px; font-size: 0.9em; flex-shrink: 0; white-space: nowrap; height: 36px; font-family: var(--font-body); display:flex; align-items:center; justify-content:center; }
        .footer-button:hover:not(:disabled) { background-color: var(--ink); }
        .footer-button:disabled { opacity: 0.6; cursor: not-allowed; background-color: #aaa; /* More obvious disabled state */ }

        /* --- NEW: Style for upload button when files are attached --- */
        #upload-file-button.has-files {
            background-color: var(--emerald);
            color: white;
            border: 1px solid darkgreen; /* Add border for emphasis */
        }
        #upload-file-button.has-files:hover:not(:disabled) {
            background-color: darkgreen;
        }

        #settings-button { background-color: var(--gold); color: var(--ink); font-size: 1.2em; padding: 0 12px; }
        #settings-button:hover { background-color: var(--crimson); color: white; }
        #clear-chat-button { background-color: var(--crimson); color: white;}
        #clear-chat-button:hover { background-color: darkred; }
        #upload-file-button { font-size: 1.1em; padding: 0 12px; } /* Base style */
        .response-count-input { width: 45px; padding: 10px; border: 2px solid var(--ink-light); border-radius: 5px; text-align: center; flex-shrink: 0; height: 36px; font-size: 1rem; background-color: var(--parchment); color: var(--ink); }
        /* --- Send button uses Heading Font --- */
        .send-button { background-color: var(--gold); color: var(--ink); border: none; border-radius: 5px; padding: 0 18px; height: 36px; font-family: var(--font-heading); font-weight: bold; cursor: pointer; box-shadow: var(--shadow-light); display: flex; align-items: center; gap: 8px; font-size: 1.1rem; transition: background-color 0.2s ease; flex-shrink: 0; }
        .send-button:hover:not(:disabled) { background-color: var(--crimson); color: white; }
        .send-button:disabled { opacity: 0.7; cursor: not-allowed; background-color: var(--ink-light); color: var(--parchment); }
        .response-navigation { display: flex; align-items: center; justify-content: flex-start; margin-top: 5px; gap: 5px; width: fit-content; }
        .response-navigation button { background-color: var(--parchment-dark); border: 1px solid var(--ink-light); color: var(--ink); border-radius: 4px; padding: 2px 6px; cursor: pointer; font-size: 0.9em; line-height: 1; }
        .response-navigation button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #ccc; }
        .response-navigation span { font-size: 0.8em; color: var(--ink-light); margin: 0 5px; user-select: none; }
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(58,49,41,0.7); justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--parchment); border: 3px solid var(--gold); color: var(--ink); padding: 25px; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.4); max-height: 90vh; width: 90%; max-width: 650px; /* Limit settings modal width */ display: flex; flex-direction: column; overflow-y: auto; }
        /* --- Modal Headings use Heading Font --- */
        .modal-content h3 { font-family: var(--font-heading); margin-top: 0; text-align: center; color: var(--ink); border-bottom: 1px solid var(--gold); padding-bottom: 10px; margin-bottom: 20px; flex-shrink: 0; }
        .modal-content .form-group { margin-bottom: 15px; display: flex; flex-wrap: wrap; align-items: center; gap: 8px 15px; flex-shrink: 0; }
        .modal-content label { display: block; margin-bottom: 5px; font-weight: bold; color: var(--ink-light); flex-basis: 100%; }
        .modal-content input[type="checkbox"] { cursor: pointer; margin-right: 5px; flex-shrink: 0; }
        .modal-content label[for*="checkbox"] { flex-basis: auto; margin-bottom: 0; font-weight: normal; }
        .modal-content input[type="password"], .modal-content textarea, .modal-content input[type="number"], .modal-content select { width: 100%; padding: 10px; border: 1px solid var(--ink-light); border-radius: 4px; outline: none; box-sizing: border-box; background-color: white; color: var(--ink); font-family: var(--font-body); font-size: 1rem; }
        .modal-content select { cursor: pointer; height: 44px; padding: 0 10px;}
        .modal-content textarea { resize: vertical; min-height: 80px; }
        .modal-content .modal-buttons { margin-top: 20px; text-align: right; display: flex; justify-content: flex-end; gap: 10px; flex-shrink: 0; border-top: 1px solid var(--gold); padding-top: 15px; }
        /* --- Modal Buttons use Heading Font --- */
        .modal-content button { background-color: var(--gold); color: var(--ink); border: none; padding: 10px 18px; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; font-family: var(--font-heading); font-weight: bold; }
        .modal-content button:hover { background-color: var(--crimson); color: white; }
        /* --- Specific overrides for buttons that should use body font --- */
        .modal-content button.cancel-button { font-family: var(--font-body); background-color: var(--ink-light); color: var(--parchment); }
        .modal-content button.cancel-button:hover { background-color: var(--ink); }
        .modal-content .small-button { font-family: var(--font-body); /* Ensure small buttons also use body font */ padding: 4px 8px; font-size: 0.8em; height: auto; background-color: var(--ink-light); color: var(--parchment); border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s ease; flex-shrink: 0; }
        .modal-content .small-button:hover { background-color: var(--ink); }
        /* ... rest of styles ... */
        .provider-selector { display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; align-items: flex-end; }
        .provider-selector > div { flex: 1; min-width: 150px; }
        .api-key-manager { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-top: 5px; }
        .api-key-manager input[type="password"] { flex-grow: 1; min-width: 200px; }
        .api-key-manager button { padding: 8px 12px; font-size: 0.9em; height: 44px; flex-shrink: 0; }
        .api-key-status-container { flex-basis: 100%; display: flex; justify-content: space-between; align-items: center; gap: 10px; margin-top: 5px; }
        .api-key-status { font-size: 0.9em; color: var(--ink-light); flex-grow: 1; }
        .api-call-count-display { font-size: 0.9em; color: var(--ink-light); flex-shrink: 0; }
        #reset-call-count-button { font-family: var(--font-body); background-color: var(--ink-light); color: var(--parchment); margin-left: 5px; padding: 4px 8px; font-size: 0.8em; height: auto; flex-shrink: 0; }
        #reset-call-count-button:hover { background-color: var(--ink); }
        #clear-keys-button { background-color: var(--crimson); color: white; margin-left: auto; }
        #clear-keys-button:hover { background-color: darkred; }
        .settings-group { margin-bottom: 15px; flex-shrink: 0; } /* Added for better spacing */
        #max-variations-input { width: 60px; text-align: center; margin-left: 8px; }
        #code-edit-modal .modal-content { max-width: 650px; }
        #edit-snippet-textarea { font-family: Consolas, Monaco, monospace; min-height: 150px; max-height: 40vh; flex-grow: 1; flex-shrink: 1; overflow-y: auto; margin-bottom: 5px; background-color: white; }
        .modal-content .line-inputs { display: flex; gap: 15px; align-items: center; margin-bottom: 10px; flex-shrink: 0; flex-wrap: wrap; }
        .modal-content .line-inputs div { flex-grow: 1; min-width: 80px; }
        .modal-content .line-inputs input[type="number"] { width: 100%; padding: 8px; }
        #edit-snippet-counter { font-size: 0.9em; color: var(--ink-light); text-align: right; margin-bottom: 15px; flex-shrink: 0; flex-basis: 100%; }
        #edit-snippet-line-count { font-weight: bold; color: var(--ink); }
        .edit-context-note { font-style: italic; color: var(--ink-light); font-size: 0.85em; margin-bottom: 15px; flex-shrink: 0; border-top: 1px dashed var(--ink-light); padding-top: 10px; margin-top: 5px; }
        .edit-instructions-area { flex-shrink: 0; margin-bottom: 15px; }
        .edit-instructions-controls { display: flex; gap: 8px; align-items: center; margin-top: 5px; }
        #edit-instructions { width: 100%; min-height: 60px; max-height: 25vh; resize: vertical; background-color: white; }
        #edit-add-iterator-button { margin-right: auto; }
        #edit-response-count { width: 40px; padding: 6px; font-size: 0.9rem; height: auto; border: 1px solid var(--ink-light); margin-left: auto; background-color: white; }
        #html-runner-modal .modal-content { max-width: 90vw; width: 85%; }
        .html-runner-container { display: flex; flex-grow: 1; gap: 15px; min-height: 0; margin-bottom: 15px; }
        .runner-editor, .runner-preview { flex: 1; display: flex; flex-direction: column; border: 1px solid var(--ink-light); border-radius: 5px; background-color: var(--parchment-dark); overflow: hidden; }
        .runner-header { margin: 0; padding: 8px 12px; background-color: var(--ink-light); color: var(--parchment); border-bottom: 1px solid var(--ink); font-size: 0.9em; font-weight: bold; flex-shrink: 0; text-align: center; }
        #html-runner-input { flex: 1; border: none; padding: 10px; font-family: Consolas, Monaco, monospace; font-size: 0.9em; resize: none; outline: none; background-color: white; color: var(--ink); }
        #html-runner-frame { flex: 1; border: none; width: 100%; height: 100%; background-color: white; }
        #html-runner-modal .modal-buttons button { padding: 8px 15px; }
        .message-content pre { border: 1px solid var(--code-border); background-color: var(--code-bg); position: relative; margin-top: 10px; margin-bottom: 5px; }
        .message-content pre code.hljs { display: block; overflow-x: auto; padding: 1em; background: transparent; color: var(--ink); border-radius: 5px; }
        .hljs-comment, .hljs-quote { color: #7a7061; font-style: italic; }
        .hljs-keyword, .hljs-selector-tag, .hljs-subst { color: var(--crimson); font-weight: bold; }
        .hljs-number, .hljs-literal, .hljs-variable, .hljs-template-variable, .hljs-tag .hljs-attr { color: var(--sapphire); }
        .hljs-string, .hljs-doctag { color: #4b8350; }
        .hljs-title, .hljs-section, .hljs-selector-id { color: var(--gold); font-weight: bold; }
        .message-content code:not(.hljs) { background-color: var(--code-bg); border: 1px solid var(--code-border); padding: 0.2em 0.4em; border-radius: 3px; font-size: 85%; font-family: Consolas, Monaco, monospace; }
        .cat-placeholder { display: none; font-size: 1.2em; cursor: default; user-select: none; padding: 2px 5px; background-color: var(--parchment-dark); border-radius: 3px; border: 1px solid var(--ink-light); margin-right: 5px; margin-bottom: 3px; }
        .message-actions { margin-top: 8px; text-align: left; display: flex; gap: 5px; flex-wrap: wrap; }
        .action-button { background-color: var(--ink-light); color: var(--parchment); border: none; padding: 4px 8px; font-size: 0.8em; border-radius: 4px; cursor: pointer; opacity: 0.9; transition: opacity 0.2s ease, background-color 0.2s ease; font-family: var(--font-body); } /* Use body font for actions */
        .action-button:hover { opacity: 1; background-color: var(--ink); }
        .copy-code-button.copied { background-color: #3a9a41; color: white; }
        .download-code-button { background-color: #17a2b8; }
        .download-code-button:hover { background-color: #138496; }
        .run-html-button { background-color: var(--emerald); }
        .run-html-button:hover { background-color: darkgreen; }
        .tome.code-hidden .message pre { display: none; }
        .tome.code-hidden .message .cat-placeholder { display: inline-block; }
        .download-code-button { display: none; }
        .tome.download-code-active .download-code-button { display: inline-block; }
        .run-html-button { display: none; }
        .tome.run-html-active .run-html-button { display: inline-block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @media (max-width: 768px) {
            .message { max-width: 95%; }
            .writing-area { padding: 10px; gap: 6px; }
            .writing-controls { flex-wrap: wrap; justify-content: flex-start; width: 100%; gap: 6px; }
            .footer-button { padding: 8px; font-size: 0.85em; height: 44px;}
            .response-count-input { width: 40px; height: 44px; padding: 8px; }
            .send-button { padding: 0 15px; height: 44px; font-size: 1rem; }
            #settings-button, #upload-file-button { padding: 0 10px; }
            .modal-content { width: 95%; padding: 20px; max-height: 85vh;}
            .provider-selector { flex-direction: column; gap: 10px; align-items: stretch;}
            .api-key-manager { flex-direction: column; align-items: stretch; gap: 5px; }
            .api-key-manager input { width: 100%; }
            .api-key-manager button { width: 100%; height: 40px; font-size: 0.85em;}
            #clear-keys-button { margin-left: 0; }
            .modal-content .modal-buttons { flex-direction: column-reverse; gap: 8px; align-items: stretch; }
            .modal-content button { width: 100%; }
            .html-runner-container { flex-direction: column; height: 70vh; }
        }
        .visually-hidden { position: absolute !important; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px); white-space: nowrap; }
    </style>
</head>
<body>
    <!-- HTML Structure -->
    <div class="tome" id="chat-container">
        <div class="pages" id="pages"></div>
        <div class="writing-area">
            <textarea class="message-input" id="message-input" placeholder="Inscribe thy query..." rows="1"></textarea>
            <!-- NEW: Div to show names of attached files -->
            <div class="attachments-preview" id="attachments-preview"></div>
            <div class="writing-controls">
                 <button id="settings-button" class="footer-button" title="Settings"> <i class="fas fa-cog"></i> </button>
                 <!-- Upload button - title will be updated -->
                 <button id="upload-file-button" class="footer-button" title="Attach Parchment (Images)"> <i class="fas fa-paperclip"></i> </button>
                 <button id="add-iterator-button" class="footer-button" title="Insert {i}">Add {i}</button>
                 <button id="clear-chat-button" class="footer-button" title="Clear Scroll">Clear</button>
                 <button id="edit-code-button" class="footer-button" title="Edit Snippet">Edit</button>
                 <input type="number" class="response-count-input" id="main-response-count" value="1" min="0" max="5" title="Responses (0 to send no query)">
                 <button class="send-button" id="send-button" title="Send Query"> <span>Send</span> <span>✒</span> </button>
            </div>
        </div>
    </div>
    <!-- Settings Modal -->
    <div class="modal-overlay" id="system-prompt-modal">
         <div class="modal-content">
             <h3>Tome Settings</h3>
             <div class="provider-selector form-group">
                 <div> <label for="provider-select">Spirit Provider:</label> <select id="provider-select"></select> </div>
                 <div> <label for="model-select">Spirit Model:</label> <select id="model-select"></select> </div>
             </div>
             <div class="form-group">
                 <label for="api-key-input">Add Spirit Essence (API Key) for <span id="selected-provider-label">Provider</span>:</label>
                 <div class="api-key-manager">
                      <input type="password" id="api-key-input" placeholder="Paste new key...">
                      <button id="add-key-button" title="Add this key to the list for the selected provider">Add Key</button>
                      <button id="clear-keys-button" title="Remove all stored keys for the selected provider">Clear Keys for Provider</button>
                 </div>
                 <div class="api-key-status-container">
                     <span id="api-key-status" class="api-key-status">Keys Loaded: 0</span>
                     <span id="api-call-count-display" class="api-call-count-display">Calls: 0</span>
                     <button id="reset-call-count-button" class="small-button" title="Reset call count for this provider">Reset Count</button>
                 </div>
             </div>
             <div class="form-group settings-group">
                 <label for="system-prompt-input">Spirit's Nature (System Prompt):</label>
                 <textarea id="system-prompt-input" placeholder="Define the spirit's core nature..."></textarea>
             </div>
             <div class="form-group settings-group">
                 <label for="max-variations-input" style="flex-basis: auto; margin-bottom: 0;">Max Response Variations:</label>
                 <input type="number" id="max-variations-input" min="1" max="99" value="5" class="response-count-input" style="width: 60px; height: 40px;">
             </div>
             <div class="form-group">
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="hide-code-checkbox"> <label for="hide-code-checkbox">Veil Glyphs</label> </div>
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="download-code-checkbox"> <label for="download-code-checkbox">Enable Download</label> </div>
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="enable-run-html-checkbox"> <label for="enable-run-html-checkbox">Enable Run HTML</label> </div>
             </div>
             <div class="modal-buttons">
                <button id="cancel-settings" class="cancel-button">Cancel</button>
                <button id="save-settings-button">Seal Settings</button>
             </div>
         </div>
    </div>
    <!-- Code Edit Modal -->
    <div class="modal-overlay" id="code-edit-modal">
        <div class="modal-content">
            <h3>Transcribe & Alter Glyphs</h3>
            <p style="font-size: 0.9em; color: var(--ink-light); margin-bottom: 10px; flex-shrink: 0;">Inscribe the glyphs below. Select lines for alteration.</p>
            <textarea id="edit-snippet-textarea" placeholder="Place glyphs here..."></textarea>
            <p class="edit-context-note"> Only the selected lines are sent. Context should be included in previous messages. </p>
            <div class="line-inputs">
                 <div> <label for="edit-start-line">Start Line:</label> <input type="number" id="edit-start-line" min="1" value="1"> </div>
                 <div> <label for="edit-end-line">End Line:</label> <input type="number" id="edit-end-line" min="1" value="1"> </div>
                 <div id="edit-snippet-counter" style="margin-left: auto;"> Lines: <span id="edit-snippet-line-count">0</span> </div>
            </div>
            <div class="edit-instructions-area">
                <label for="edit-instructions">Instructions for Spirit (applies to selected lines):</label>
                <textarea id="edit-instructions" rows="3" placeholder="e.g., Reforge these lines, mend the flaw..."></textarea>
                <div class="edit-instructions-controls">
                    <button id="edit-add-iterator-button" class="small-button" title="Insert {i}">Add {i}</button>
                    <label for="edit-response-count" style="margin-left: auto; flex-basis: auto; margin-bottom: 0; font-weight: normal; color: var(--ink-light); font-size: 0.9em;">Variations:</label>
                    <input type="number" class="response-count-input" id="edit-response-count" value="1" min="1" max="5"> <!-- Max updated dynamically -->
                </div>
            </div>
            <div class="modal-buttons">
                <button id="cancel-edit-request" class="cancel-button">Cancel</button>
                <button id="send-edit-request">Request Alteration</button>
            </div>
        </div>
    </div>
    <!-- HTML Runner Modal -->
    <div class="modal-overlay" id="html-runner-modal">
        <div class="modal-content">
            <h3>HTML Runner</h3>
            <div class="html-runner-container">
                 <div class="runner-editor"> <div class="runner-header">HTML Input</div> <textarea id="html-runner-input" placeholder="Paste HTML code here..."></textarea> </div>
                 <div class="runner-preview"> <div class="runner-header">Preview</div> <iframe id="html-runner-frame" title="HTML Output Preview" sandbox="allow-scripts allow-same-origin"></iframe> </div>
            </div>
             <div class="modal-buttons">
                 <button id="html-runner-render-button">Render</button>
                 <button id="html-runner-close-button" class="cancel-button">Close</button>
             </div>
        </div>
    </div>

    <!-- Hidden Helpers -->
    <textarea class="visually-hidden" id="copy-helper" aria-hidden="true"></textarea>
    <!-- Update file input to accept common image types and allow multiple selections -->
    <input type="file" id="file-upload-input" accept="image/jpeg, image/png, image/webp, image/gif" style="display:none;" multiple>
    <input type="file" class="pfp-upload" accept="image/*" style="display:none;">


    <script>
        // --- Global State & Constants ---
        let conversationHistory = [];
        let userPfp = localStorage.getItem('userPfp') || 'https://ui-avatars.com/api/?name=U&background=1e3a8a&color=fff&font-size=0.6&bold=true';
        let botPfp = localStorage.getItem('botPfp') || 'https://ui-avatars.com/api/?name=S&background=6b21a8&color=fff&font-size=0.6&bold=true';
        let currentPfpElementToUpdate = null;
        let turnCounter = 0;
        const iterationPlaceholder = '{i}';
        const DEFAULT_SYSTEM_PROMPT = 'You are a mystical spirit from another realm, speaking through this ancient tome. Answer queries concisely and with a touch of arcane wisdom. Format code clearly.';
        const MAX_ATTACHMENTS = 5; // Max number of images to attach
        const MAX_FILE_SIZE = 4 * 1024 * 1024; // 4MB limit per image
        const ALLOWED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];

        // --- Provider/Key State ---
        let selectedProvider = '';
        let selectedModel = '';
        let apiKeys = {};
        let currentApiKeyIndex = {};
        let apiCallCounts = {};

        // --- NEW: State for attached files ---
        let attachedFilesData = []; // Stores { fileId: "...", name: "...", mimeType: "...", data: "base64..." }

        // --- Settings State ---
        let maxResponseVariations = 5;
        let hideCodeBlocks = true;
        let downloadCodeMode = false;
        let enableRunHtmlMode = false;
        let isWaitingForResponse = false;

        // --- DOM Elements ---
        const chatContainerElement = document.getElementById('chat-container');
        const pages = document.getElementById('pages');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const mainResponseCountInput = document.getElementById('main-response-count');
        const pfpUploadInput = document.querySelector('.pfp-upload');
        const settingsButton = document.getElementById('settings-button');
        const systemPromptModal = document.getElementById('system-prompt-modal');
        const providerSelect = document.getElementById('provider-select');
        const modelSelect = document.getElementById('model-select');
        const selectedProviderLabel = document.getElementById('selected-provider-label');
        const systemPromptInput = document.getElementById('system-prompt-input');
        const apiKeyInput = document.getElementById('api-key-input');
        const addKeyButton = document.getElementById('add-key-button');
        const clearKeysButton = document.getElementById('clear-keys-button');
        const apiKeyStatus = document.getElementById('api-key-status');
        const apiCallCountDisplay = document.getElementById('api-call-count-display');
        const resetCallCountButton = document.getElementById('reset-call-count-button');
        const maxVariationsInput = document.getElementById('max-variations-input');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const hideCodeCheckbox = document.getElementById('hide-code-checkbox');
        const downloadCodeCheckbox = document.getElementById('download-code-checkbox');
        const enableRunHtmlCheckbox = document.getElementById('enable-run-html-checkbox');
        const cancelSettingsButton = document.getElementById('cancel-settings');
        const editCodeButton = document.getElementById('edit-code-button');
        const codeEditModal = document.getElementById('code-edit-modal');
        const editSnippetTextarea = document.getElementById('edit-snippet-textarea');
        const editStartLineInput = document.getElementById('edit-start-line');
        const editEndLineInput = document.getElementById('edit-end-line');
        const editSnippetLineCount = document.getElementById('edit-snippet-line-count');
        const editInstructionsInput = document.getElementById('edit-instructions');
        const editAddIteratorButton = document.getElementById('edit-add-iterator-button');
        const editResponseCountInput = document.getElementById('edit-response-count');
        const sendEditRequestButton = document.getElementById('send-edit-request');
        const cancelEditRequestButton = document.getElementById('cancel-edit-request');
        const htmlRunnerModal = document.getElementById('html-runner-modal');
        const htmlRunnerInput = document.getElementById('html-runner-input');
        const htmlRunnerFrame = document.getElementById('html-runner-frame');
        const htmlRunnerRenderButton = document.getElementById('html-runner-render-button');
        const htmlRunnerCloseButton = document.getElementById('html-runner-close-button');
        const clearChatButton = document.getElementById('clear-chat-button');
        const addIteratorButton = document.getElementById('add-iterator-button');
        const uploadFileButton = document.getElementById('upload-file-button'); // Button to trigger input
        const fileUploadInput = document.getElementById('file-upload-input'); // The hidden input itself
        const copyHelper = document.getElementById('copy-helper');
        const attachmentsPreview = document.getElementById('attachments-preview'); // NEW Div for preview

        // --- Configure Markdown & Highlighting ---
        marked.setOptions({
            highlight: function(code, lang) {
                const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                try { return hljs.highlight(code, { language: language, ignoreIllegals: true }).value; }
                catch (e) { return hljs.highlight(code, { language: 'plaintext', ignoreIllegals: true }).value; }
            },
            langPrefix: 'hljs language-', gfm: true, breaks: true
        });

        // --- Function Definitions ---

        // --- NEW: Function to update UI based on attached files ---
        function updateAttachmentUI() {
            if (!uploadFileButton || !attachmentsPreview) return;

            attachmentsPreview.innerHTML = ''; // Clear preview area

            const providerSupportsImages = (typeof PROVIDERS !== 'undefined' && selectedProvider && PROVIDERS[selectedProvider]?.supportsImages) ?? false;

            if (attachedFilesData.length > 0) {
                uploadFileButton.classList.add('has-files');
                const fileCount = attachedFilesData.length;
                uploadFileButton.title = `Attach Parchment (${fileCount} image${fileCount > 1 ? 's' : ''} attached)`;

                // Display file names with remove buttons
                attachedFilesData.forEach(file => {
                    const item = document.createElement('span');
                    item.className = 'attachment-item';

                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = file.name;
                    item.appendChild(nameSpan);

                    const removeBtn = document.createElement('span');
                    removeBtn.className = 'remove-attachment';
                    removeBtn.textContent = '×'; // Times symbol
                    removeBtn.title = `Remove ${file.name}`;
                    removeBtn.dataset.fileId = file.fileId; // Store ID to identify which file to remove
                    removeBtn.onclick = (e) => {
                        e.stopPropagation(); // Prevent triggering file input again if nested weirdly
                        removeAttachment(file.fileId);
                    };

                    item.appendChild(removeBtn);
                    attachmentsPreview.appendChild(item);
                });

            } else {
                uploadFileButton.classList.remove('has-files');
                // Set title based on provider support
                uploadFileButton.title = providerSupportsImages
                    ? 'Attach Parchment (Images)'
                    : 'Attachment disabled (Provider does not support images)';
            }

             // Disable upload button if provider doesn't support images OR if waiting for response
            uploadFileButton.disabled = !providerSupportsImages || isWaitingForResponse;
            // Ensure file input is also disabled visually if needed (though clicking button is main interaction)
            if (fileUploadInput) fileUploadInput.disabled = !providerSupportsImages || isWaitingForResponse;

            // console.log(`Attachment UI Updated. Provider Supports Images: ${providerSupportsImages}, Attached Count: ${attachedFilesData.length}, Button Disabled: ${uploadFileButton.disabled}`);
        }

        // --- NEW: Function to remove an attachment ---
        function removeAttachment(fileIdToRemove) {
            attachedFilesData = attachedFilesData.filter(file => file.fileId !== fileIdToRemove);
            updateAttachmentUI(); // Refresh the display
            console.log(`Removed attachment with ID: ${fileIdToRemove}`);
        }

        // --- NEW: Handler for file input selection ---
        function handleFileSelection(event) {
            const files = event.target.files;
            if (!files || files.length === 0) {
                return; // No files selected
            }

            // Check if provider supports images *before* processing
            const providerSupportsImages = (typeof PROVIDERS !== 'undefined' && selectedProvider && PROVIDERS[selectedProvider]?.supportsImages) ?? false;
            if (!providerSupportsImages) {
                alert("The current provider does not support image attachments.");
                event.target.value = null; // Clear the selection
                return;
            }

            const currentCount = attachedFilesData.length;
            let addedCount = 0;
            let promises = []; // Array to hold file reading promises

            for (const file of files) {
                if (currentCount + addedCount >= MAX_ATTACHMENTS) {
                    alert(`You can attach a maximum of ${MAX_ATTACHMENTS} images.`);
                    break; // Stop processing further files in this selection
                }

                const fileId = `file-${Date.now()}-${Math.random().toString(16).substring(2)}`;
                console.log(`Processing file: ${file.name}, Type: ${file.type}, Size: ${file.size}`);

                // --- Validation ---
                if (!ALLOWED_IMAGE_TYPES.includes(file.type)) {
                    console.warn(`Skipping invalid file type: ${file.name} (${file.type})`);
                    alert(`Invalid file type: ${file.name}. Only JPEG, PNG, WEBP, GIF allowed.`);
                    continue; // Skip this file
                }
                if (file.size > MAX_FILE_SIZE) {
                     console.warn(`Skipping oversized file: ${file.name} (${file.size} bytes)`);
                     alert(`File too large: ${file.name} (${(file.size / 1024 / 1024).toFixed(1)}MB). Max size is 4MB.`);
                    continue; // Skip this file
                }
                // Check if file with same name is already attached (simple check)
                if (attachedFilesData.some(f => f.name === file.name)) {
                     console.warn(`Skipping duplicate filename: ${file.name}`);
                     alert(`File "${file.name}" is already attached.`);
                    continue; // Skip this file
                }
                // --- End Validation ---

                // Create a promise for each file reader
                const readFilePromise = new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const dataUrl = e.target.result;
                        const parts = dataUrl.split(',');
                        if (parts.length === 2) {
                            const metaPart = parts[0];
                            const base64Data = parts[1];
                            const mimeType = metaPart.split(':')[1].split(';')[0];
                            resolve({ fileId, name: file.name, mimeType, data: base64Data });
                        } else {
                            console.error("Failed to parse data URL:", dataUrl.substring(0,50) + "...");
                            reject(new Error(`Could not process file: ${file.name}`));
                        }
                    };
                    reader.onerror = (e) => {
                        console.error("FileReader error:", e);
                        reject(new Error(`Error reading file: ${file.name}`));
                    };
                    reader.readAsDataURL(file);
                });

                promises.push(readFilePromise);
                addedCount++; // Increment added count optimistically
            }

            // Process all promises
            Promise.allSettled(promises).then(results => {
                results.forEach(result => {
                    if (result.status === 'fulfilled') {
                        attachedFilesData.push(result.value);
                        console.log(`Successfully added ${result.value.name} to attachments.`);
                    } else {
                        // Handle rejected promises (errors during file reading)
                        alert(result.reason.message);
                        console.error("File reading failed:", result.reason);
                    }
                });
            }).finally(() => {
                // Update UI after all files have been processed (or failed)
                updateAttachmentUI();
                // Clear the file input value AFTER processing is done
                // allowing the 'change' event to fire again for the same file selection.
                event.target.value = null;
            });
        }

        // --- MODIFIED: handleSendMessage ---
        async function handleSendMessage() {
            // Check provider image support FIRST if files are attached
            const providerConfig = (typeof PROVIDERS !== 'undefined' && selectedProvider) ? PROVIDERS[selectedProvider] : null;
            const providerSupportsImages = providerConfig?.supportsImages ?? false;
            if (attachedFilesData.length > 0 && !providerSupportsImages) {
                 alert(`The selected provider (${providerConfig?.name || selectedProvider}) does not support image input. Please remove attachments or switch provider.`);
                 return;
            }

            if (!hasSufficientApiResources()) {
                 const providerName = providerConfig?.name || selectedProvider || "the selected provider";
                 if (doesProviderNeedApiKey(selectedProvider)) {
                     alert(`No API Key loaded for ${providerName}, which requires one. Please add a key in Settings.`);
                 } else {
                     alert(`Cannot send message. Please select a valid provider in Settings.`);
                 }
                 return;
            }
            if (isWaitingForResponse) return;

            const userInput = messageInput.value.trim();
            const responseCount = parseInt(mainResponseCountInput.value, 10);

            // Require text OR an image to send
            if (userInput === '' && attachedFilesData.length === 0) {
                console.log("Send cancelled: No text or attachments.");
                return;
            }

            const numResponses = isNaN(responseCount) || responseCount < 0 ? 0 : Math.min(responseCount, maxResponseVariations);
            const turnId = `turn-${turnCounter++}`;
            const containsPlaceholder = userInput.includes(iterationPlaceholder);

            isWaitingForResponse = true;
            if (sendButton) sendButton.disabled = true;
            updateAttachmentUI(); // Disables upload button via state check
            messageInput.value = ''; // Clear text input
            autoGrowTextarea();

            // --- Create user entry with potential images ---
            const userEntry = {
                role: 'user',
                content: userInput, // Text content
                turnId: turnId
            };
            // If images are attached, add them to the entry (only mimeType and data needed for history/API)
            if (attachedFilesData.length > 0) {
                userEntry.images = attachedFilesData.map(f => ({ mimeType: f.mimeType, data: f.data }));
                console.log(`Attaching ${userEntry.images.length} images to user message entry.`);
            }
            // ---

            conversationHistory.push(userEntry);
            displayMessage(userEntry, 'user'); // Display will handle showing images
            saveHistoryToLocalStorage();
            scrollToBottom();

            // --- Clear attachments AFTER adding to history and displaying ---
            attachedFilesData = []; // Clear the global state
            // Note: UI update will happen again when response finishes or if user interacts
            // ---

            // --- API Call Logic ---
            if (numResponses > 0) {
                showTypingIndicator();
                const baseHistory = prepareHistoryForApi(conversationHistory); // Prepare full history
                const responses = [];
                let overallError = null;
                const provider = selectedProvider;
                const model = selectedModel;

                console.log(`Sending ${numResponses} requests to ${provider} (${model})`);

                for (let i = 0; i < numResponses; i++) {
                    const iteration = i + 1;
                    let currentHistory = [...baseHistory]; // Use the prepared history for each iteration

                    // --- Placeholder substitution ---
                    if (containsPlaceholder && numResponses > 1) {
                        const userMessageIndex = currentHistory.findLastIndex(m => m.role === 'user');
                        // Ensure the message and its content exist before replacing
                        if (userMessageIndex > -1 && typeof currentHistory[userMessageIndex].content === 'string') {
                            const originalMessage = currentHistory[userMessageIndex];
                            const substitutedContent = originalMessage.content.replace(
                                new RegExp(iterationPlaceholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g'),
                                iteration.toString()
                            );
                            // Create a new object to prevent modifying the base history object directly
                            currentHistory[userMessageIndex] = {
                                ...originalMessage, // Copy other properties (like images, role, turnId)
                                content: substitutedContent // Update the content
                            };
                            console.log(`Substituted placeholder in user message content for iteration ${iteration}`);
                        } else {
                            console.warn("Could not find user message with text content to substitute placeholder.");
                        }
                    }
                    // --- End Placeholder ---

                    try {
                        const messageContent = await attemptApiCallWithRetry(provider, model, currentHistory, { temperature: 0.7, top_p: 0.9 });
                        responses.push(messageContent);
                    } catch (e) {
                        console.error(`API Call Failed (Provider: ${provider}, Model: ${model}, Iteration: ${iteration}) after retries:`, e);
                        responses.push(e.message || "[Spirit Communication Failed]");
                        overallError = e;
                    }
                } // End loop through variations

                hideTypingIndicator();

                if (responses.length > 0) {
                    const botEntry = { role: 'assistant', variants: responses, selectedIndex: 0, turnId: turnId };
                    conversationHistory.push(botEntry);
                    saveHistoryToLocalStorage();
                    displayBotMessage(botEntry, 'spirit');
                    scrollToBottom();
                }
            } else {
                console.log("Query added to history, 0 responses requested.");
            }
            // --- End API Call Logic ---

            isWaitingForResponse = false;
            if (sendButton) sendButton.disabled = !hasSufficientApiResources();
            updateAttachmentUI(); // Re-enable upload button based on provider support & state
            messageInput.focus();
        }


        // --- MODIFIED: displayMessage to show image previews ---
        function displayMessage(entry, sender) {
            let contentText = "";
            if (sender === 'user') {
                contentText = entry.content || "";
            } else { // assistant
                contentText = entry.variants?.[entry.selectedIndex ?? 0] || "[Error - Variant unavailable]";
            }

            const msgDiv = document.createElement('div');
            msgDiv.className = `message message-${sender}`;
            if (entry.turnId) msgDiv.dataset.turnId = entry.turnId;

            const pfpUrl = (sender === 'user') ? userPfp : botPfp;
            const avatarEl = createPfpElement(sender, pfpUrl);
            const wrapper = document.createElement('div');
            wrapper.classList.add('message-content-wrapper');
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';

            // Render text content (Markdown for bot, plain for user)
            if (contentText) { // Only add text node if text exists
                if (sender === 'spirit') {
                    try {
                        const parsedHTML = marked.parse(contentText);
                        // Basic sanitization: Remove script tags (more robust needed for production)
                        const sanitizedHTML = parsedHTML.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
                        contentDiv.innerHTML = sanitizedHTML;
                    } catch (e) {
                         console.error("Markdown error:", e);
                         contentDiv.textContent = contentText;
                         contentDiv.style.whiteSpace = 'pre-wrap';
                    }
                } else { // User message text
                     const textNode = document.createTextNode(contentText);
                     const p = document.createElement('p'); // Wrap text in paragraph for consistent spacing
                     p.appendChild(textNode);
                     p.style.whiteSpace = 'pre-wrap'; // Ensure user text wraps
                     contentDiv.appendChild(p);
                }
            }


             // --- Append image previews for user messages ---
             if (sender === 'user' && Array.isArray(entry.images) && entry.images.length > 0) {
                 const imageContainer = document.createElement('div');
                 imageContainer.className = 'image-attachment-container'; // Use class for styling

                 entry.images.forEach(imgData => {
                     if (imgData && imgData.mimeType && imgData.data) {
                         const imgPreview = document.createElement('img');
                         imgPreview.className = 'attached-image-preview';
                         imgPreview.src = `data:${imgData.mimeType};base64,${imgData.data}`;
                         imgPreview.alt = 'Attached image';
                         imgPreview.title = 'Attached image';
                         // Optional: Add click handler for lightbox/full view
                         // imgPreview.onclick = () => { window.open(imgPreview.src, '_blank'); };
                         imageContainer.appendChild(imgPreview);
                     }
                 });
                 // Append image container only if it has images
                 if (imageContainer.hasChildNodes()) {
                    contentDiv.appendChild(imageContainer);
                 }
             }
             // --- END NEW ---

            wrapper.appendChild(contentDiv);
            if (sender === 'spirit') {
                 addCodeActionButtons(contentDiv, wrapper, entry.turnId, entry.selectedIndex ?? 0);
                 // Add navigation controls only if needed (moved here from displayMultipleMessages)
                 if (Array.isArray(entry.variants) && entry.variants.length > 1) {
                    addNavigationControls(wrapper, entry);
                 }
            }

            if (sender === 'user') { msgDiv.appendChild(wrapper); msgDiv.appendChild(avatarEl); }
            else { msgDiv.appendChild(avatarEl); msgDiv.appendChild(wrapper); }

            if (pages) {
                pages.appendChild(msgDiv);
                if (sender === 'spirit') {
                    contentDiv.querySelectorAll('pre code').forEach((block) => {
                        try { hljs.highlightElement(block); } catch (e) { console.warn("Highlight error:", e); }
                    });
                }
            } else { console.error("Pages container missing."); }
            return msgDiv;
        }

        // --- Helper to add navigation controls (extracted from displayMultipleMessages) ---
        function addNavigationControls(wrapper, entry) {
            const nav = document.createElement('div');
            nav.classList.add('response-navigation');
            const prev = document.createElement('button'); prev.textContent = '<'; prev.title = "Previous";
            const span = document.createElement('span'); span.title = "Variant";
            const next = document.createElement('button'); next.textContent = '>'; next.title = "Next";

            let currentIndex = entry.selectedIndex ?? 0;
            const variants = entry.variants;
            const turnId = entry.turnId;

            function updateNavState() {
                span.textContent = `${currentIndex + 1} / ${variants.length}`;
                prev.disabled = currentIndex === 0;
                next.disabled = currentIndex === variants.length - 1;
            }

            prev.addEventListener('click', () => {
                if (currentIndex > 0) {
                    currentIndex--;
                    updateHistorySelection(turnId, currentIndex);
                    // Find the message div and re-render its content
                    const msgDiv = wrapper.closest('.message');
                    if (msgDiv) {
                       const contentDiv = msgDiv.querySelector('.message-content');
                       const currentEntry = conversationHistory.find(m => m.turnId === turnId && m.role === 'assistant');
                       if(contentDiv && currentEntry) {
                           const newText = currentEntry.variants[currentIndex] || "[Error]";
                           try { contentDiv.innerHTML = marked.parse(newText); }
                           catch(e){ contentDiv.textContent = newText; contentDiv.style.whiteSpace = 'pre-wrap'; }
                           contentDiv.querySelectorAll('pre code').forEach(hljs.highlightElement);
                           addCodeActionButtons(contentDiv, wrapper, turnId, currentIndex); // Re-add actions for new code
                           contentDiv.style.animation = 'none'; void contentDiv.offsetWidth; contentDiv.style.animation = 'fadeIn 0.3s ease-in-out';
                       }
                    }
                    updateNavState();
                }
            });
            next.addEventListener('click', () => {
                if (currentIndex < variants.length - 1) {
                    currentIndex++;
                    updateHistorySelection(turnId, currentIndex);
                     // Find the message div and re-render its content
                    const msgDiv = wrapper.closest('.message');
                    if (msgDiv) {
                       const contentDiv = msgDiv.querySelector('.message-content');
                       const currentEntry = conversationHistory.find(m => m.turnId === turnId && m.role === 'assistant');
                       if(contentDiv && currentEntry) {
                           const newText = currentEntry.variants[currentIndex] || "[Error]";
                           try { contentDiv.innerHTML = marked.parse(newText); }
                           catch(e){ contentDiv.textContent = newText; contentDiv.style.whiteSpace = 'pre-wrap'; }
                           contentDiv.querySelectorAll('pre code').forEach(hljs.highlightElement);
                           addCodeActionButtons(contentDiv, wrapper, turnId, currentIndex); // Re-add actions for new code
                           contentDiv.style.animation = 'none'; void contentDiv.offsetWidth; contentDiv.style.animation = 'fadeIn 0.3s ease-in-out';
                       }
                    }
                    updateNavState();
                }
            });

            nav.appendChild(prev);
            nav.appendChild(span);
            nav.appendChild(next);
            wrapper.appendChild(nav);
            updateNavState(); // Initial state
        }


        // --- prepareHistoryForApi ---
        // Passes 'images' field along if present on user messages.
        // API-specific transformation (e.g., for Gemini) happens later.
        function prepareHistoryForApi(hist) {
            if (!Array.isArray(hist)) return [];
            // Filter out system prompt if it's empty or default AND not the only message
            const filteredHist = hist.filter((m, index, arr) => {
                if (m.role === 'system') {
                    const isEmptyOrDefault = !m.content || m.content === DEFAULT_SYSTEM_PROMPT;
                    // Keep if it's the ONLY message or if it has actual content
                    return arr.length === 1 || (m.content && m.content !== DEFAULT_SYSTEM_PROMPT);
                }
                return true; // Keep non-system messages
            });

            return filteredHist
                .filter(m => m && m.role) // Basic validation
                .map(m => {
                    if (m.role === 'system') {
                        return { role: 'system', content: m.content || "" };
                    }
                    if (m.role === 'user') {
                        const userMsg = { role: 'user', content: m.content || "" }; // Don't pass turnId to API
                        if (Array.isArray(m.images) && m.images.length > 0) {
                            // Ensure we only pass valid image objects needed by API transform
                            userMsg.images = m.images.filter(img => img && img.mimeType && img.data)
                                                    .map(img => ({ mimeType: img.mimeType, data: img.data }));
                            if(userMsg.images.length === 0) delete userMsg.images; // Don't send empty array
                        }
                        return userMsg;
                    }
                    if (m.role === 'assistant') {
                        const content = m.variants?.[m.selectedIndex ?? 0];
                        // Ensure content is a string, even if empty. Exclude if null/undefined.
                        return (content != null) ? { role: 'assistant', content: String(content) } : null;
                    }
                    return null;
                })
                .filter(Boolean); // Filter out any nulls (like assistant messages with no valid variant)
        }

        // --- MODIFIED: loadHistoryFromLocalStorage ---
        // Ensures 'images' field is handled if present in stored history
        function loadHistoryFromLocalStorage() {
            let providerOk = false;
            try {
                if (typeof PROVIDERS === 'undefined' || Object.keys(PROVIDERS).length === 0) throw new Error("PROVIDERS definitions missing.");
                const sp = localStorage.getItem('selectedProvider');
                selectedProvider = (sp && PROVIDERS[sp]) ? sp : (Object.keys(PROVIDERS)[0] || '');
                selectedModel = localStorage.getItem('selectedModel') || '';
                providerOk = true;
            } catch (e) {
                console.error("Provider configuration or loading error:", e);
                selectedProvider = localStorage.getItem('selectedProvider') || '';
                selectedModel = localStorage.getItem('selectedModel') || '';
            }

             try {
                 const sk = localStorage.getItem('apiKeys'); apiKeys = sk ? JSON.parse(sk) : {};
                 const si = localStorage.getItem('currentApiKeyIndex'); currentApiKeyIndex = si ? JSON.parse(si) : {};
                 const sc = localStorage.getItem('apiCallCounts'); apiCallCounts = sc ? JSON.parse(sc) : {};
                 if (typeof apiKeys !== 'object' || apiKeys === null) apiKeys = {};
                 if (typeof currentApiKeyIndex !== 'object' || currentApiKeyIndex === null) currentApiKeyIndex = {};
                 if (typeof apiCallCounts !== 'object' || apiCallCounts === null) apiCallCounts = {};
                 const savedMaxVar = localStorage.getItem('maxResponseVariations');
                 const parsedMaxVar = parseInt(savedMaxVar || '5', 10);
                 maxResponseVariations = (!isNaN(parsedMaxVar) && parsedMaxVar >= 1) ? parsedMaxVar : 5;
             } catch (e) { console.warn("API Key/Index/Count/Settings loading error:", e); apiKeys = {}; currentApiKeyIndex = {}; apiCallCounts = {}; maxResponseVariations = 5;}

            let historyOk = false;
            try {
                const sh = localStorage.getItem('conversationHistory');
                const defaultSys = localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
                let ph = sh ? JSON.parse(sh) : [];

                if (!Array.isArray(ph)) throw new Error('Stored history is not an array');

                // Ensure system prompt exists at the start
                if (ph.length === 0 || ph[0]?.role !== 'system') {
                    ph.unshift({ role: 'system', content: defaultSys });
                } else {
                    // Update existing system prompt if it was default but a custom one is now saved
                    ph[0].content = defaultSys;
                }


                // --- Sanitize loaded history, preserving VALID images field ---
                conversationHistory = ph.map(m => {
                    if (!m || !m.role) return null;
                    if (m.role === 'system') {
                        return { role: 'system', content: m.content || defaultSys }; // Ensure content exists
                    }
                    if (m.role === 'user') {
                         const userMsg = {
                              role: 'user', content: m.content || "", turnId: m.turnId
                         };
                         // --- Load and validate images array ---
                         if (Array.isArray(m.images)) {
                              userMsg.images = m.images.filter(img => img && typeof img.mimeType === 'string' && typeof img.data === 'string');
                              if (userMsg.images.length === 0) { delete userMsg.images; } // Remove empty array
                         }
                         return userMsg;
                    }
                    if (m.role === 'assistant') {
                        const variants = Array.isArray(m.variants) ? m.variants.map(v => v ?? "[Content Error]") : (m.content != null ? [m.content] : ["[Content Error]"]);
                        if (variants.length === 0) variants.push("[Content Error]"); // Ensure at least one variant
                        let selectedIndex = m.selectedIndex ?? 0;
                        if (!Number.isInteger(selectedIndex) || selectedIndex < 0 || selectedIndex >= variants.length) { selectedIndex = 0; }
                        return {
                            role: 'assistant',
                            variants: variants,
                            selectedIndex: selectedIndex,
                            turnId: m.turnId,
                            isCodeEdit: m.isCodeEdit // Preserve edit flag if present
                        };
                    }
                    return null;
                }).filter(Boolean);
                // --- End Sanitization ---

                const lastTurn = conversationHistory.slice().reverse().find(m => m.turnId?.startsWith('turn-'));
                turnCounter = lastTurn?.turnId ? (parseInt(lastTurn.turnId.split('-')[1], 10) || 0) + 1 : 1;
                historyOk = true;
                console.log(`History loaded. ${conversationHistory.length - 1} messages. Next turn ID: ${turnCounter}`);
            } catch (e) {
                console.warn("Conversation history loading error:", e);
                const sys = localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
                conversationHistory = [{ role: 'system', content: sys }]; turnCounter = 1;
            }
            // --- Clear any stray attachments on load ---
            attachedFilesData = [];
            updateAttachmentUI(); // Ensure UI reflects empty state initially

            return providerOk && historyOk;
        }

        // --- MODIFIED: initialLoad ---
        // Calls updateAttachmentUI after loading state
        function initialLoad() {
            console.log("InitialLoad started.");
            if (typeof PROVIDERS === 'undefined') { console.error("FATAL: PROVIDERS definitions missing."); alert("Error: PROVIDERS definitions missing."); return; }
            if (typeof getApiResponse !== 'function') { console.error("FATAL: getApiResponse missing."); alert("Error: API function missing."); return; }

            loadHistoryFromLocalStorage(); // Loads history, keys, settings etc.
            populateProviderSelect(); // Populates selects based on loaded state
            updateApiKeyStatus(selectedProvider); // Updates key status display
            updateAttachmentUI(); // <--- NEW: Update attachment button state based on loaded provider

            hideCodeBlocks = localStorage.getItem('hideCodeBlocks') === 'true';
            downloadCodeMode = localStorage.getItem('downloadCodeMode') === 'true';
            enableRunHtmlMode = localStorage.getItem('enableRunHtmlMode') === 'true';
            if (chatContainerElement) { chatContainerElement.classList.toggle('code-hidden', hideCodeBlocks); chatContainerElement.classList.toggle('download-code-active', downloadCodeMode); chatContainerElement.classList.toggle('run-html-active', enableRunHtmlMode); }
            if (hideCodeCheckbox) hideCodeCheckbox.checked = hideCodeBlocks; if (downloadCodeCheckbox) downloadCodeCheckbox.checked = downloadCodeMode; if (enableRunHtmlCheckbox) enableRunHtmlCheckbox.checked = enableRunHtmlMode;

            if (sendButton) sendButton.disabled = !hasSufficientApiResources();
            updateResponseCountInputMax();
            rebuildChatFromHistory();
            displayInitialGreeting();
            autoGrowTextarea();
            console.log("Arcane Tome Initialized.");
        }

        // --- MODIFIED: attachEventListeners ---
        // Add listener for file input and provider change
        function attachEventListeners() {
            console.log("Attaching event listeners...");
            if (sendButton) sendButton.addEventListener('click', handleSendMessage); else console.error("sendButton missing");
            if (messageInput) { messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } }); messageInput.addEventListener('input', autoGrowTextarea); } else console.error("messageInput missing");
            if (settingsButton) settingsButton.addEventListener('click', openSystemPromptModal); else console.error("settingsButton missing");

            // --- MODIFIED: Add updateAttachmentUI call on provider change ---
            if (providerSelect) {
                 providerSelect.addEventListener('change', () => {
                     handleProviderChange(); // Existing handler
                     // If provider changes, clear pending attachments and update UI
                     if (attachedFilesData.length > 0) {
                        console.log("Provider changed, clearing existing attachments.");
                        attachedFilesData = [];
                     }
                     updateAttachmentUI();
                 });
            } else console.error("providerSelect missing");
            // ---

            if (modelSelect) modelSelect.addEventListener('change', handleModelChange); else console.error("modelSelect missing");
            if (addKeyButton) addKeyButton.addEventListener('click', addApiKey); else console.error("addKeyButton missing");
            if (clearKeysButton) clearKeysButton.addEventListener('click', clearApiKeysForProvider); else console.error("clearKeysButton missing");
            if (resetCallCountButton) resetCallCountButton.addEventListener('click', resetApiCallCountForProvider); else console.error("resetCallCountButton missing");
            if (saveSettingsButton) saveSettingsButton.addEventListener('click', saveSettings); else console.error("saveSettingsButton missing");
            if (cancelSettingsButton) cancelSettingsButton.addEventListener('click', () => { if (systemPromptModal) systemPromptModal.style.display = 'none'; }); else console.error("cancelSettingsButton missing");
            if (systemPromptModal) systemPromptModal.addEventListener('click', (e) => { if (e.target === systemPromptModal) systemPromptModal.style.display = 'none'; }); else console.error("systemPromptModal missing");
            if (hideCodeCheckbox) hideCodeCheckbox.addEventListener('change', handleHideCodeToggle); else console.error("hideCodeCheckbox missing");
            if (downloadCodeCheckbox) downloadCodeCheckbox.addEventListener('change', handleDownloadCodeToggle); else console.error("downloadCodeCheckbox missing");
            if (enableRunHtmlCheckbox) enableRunHtmlCheckbox.addEventListener('change', handleEnableRunHtmlToggle); else console.error("enableRunHtmlCheckbox missing");
            if (editCodeButton) editCodeButton.addEventListener('click', openEditCodeModal); else console.error("editCodeButton missing");
            if (sendEditRequestButton) sendEditRequestButton.addEventListener('click', handleSendEditRequest); else console.error("sendEditRequestButton missing"); // Listener for edit request
            if (cancelEditRequestButton) cancelEditRequestButton.addEventListener('click', () => { if (codeEditModal) codeEditModal.style.display = 'none'; }); else console.error("cancelEditRequestButton missing");
            if (codeEditModal) codeEditModal.addEventListener('click', (e) => { if (e.target === codeEditModal) codeEditModal.style.display = 'none'; }); else console.error("codeEditModal missing");
            if (editSnippetTextarea) editSnippetTextarea.addEventListener('input', updateSnippetLineCount); else console.error("editSnippetTextarea missing");
            if (editAddIteratorButton) editAddIteratorButton.addEventListener('click', () => insertIteratorPlaceholder(editInstructionsInput)); else console.error("editAddIteratorButton missing");
            if (htmlRunnerRenderButton) htmlRunnerRenderButton.addEventListener('click', renderRunnerHTML); else console.error("htmlRunnerRenderButton missing");
            if (htmlRunnerCloseButton) htmlRunnerCloseButton.addEventListener('click', () => { if (htmlRunnerModal) htmlRunnerModal.style.display = 'none'; }); else console.error("htmlRunnerCloseButton missing");
            if (htmlRunnerModal) htmlRunnerModal.addEventListener('click', (e) => { if (e.target === htmlRunnerModal) htmlRunnerModal.style.display = 'none'; }); else console.error("htmlRunnerModal missing");
            if (clearChatButton) clearChatButton.addEventListener('click', handleClearChat); else console.error("clearChatButton missing");
            if (addIteratorButton) addIteratorButton.addEventListener('click', () => insertIteratorPlaceholder(messageInput)); else console.error("addIteratorButton missing");

            // --- Listener for the upload button to trigger the hidden input ---
            if (uploadFileButton) {
                 uploadFileButton.addEventListener('click', () => {
                     if (fileUploadInput && !uploadFileButton.disabled) {
                          fileUploadInput.click();
                     } else if (uploadFileButton.disabled) {
                         console.log("Upload button clicked but disabled.");
                         // Optionally show a tooltip or message why it's disabled
                         const providerSupportsImages = (typeof PROVIDERS !== 'undefined' && selectedProvider && PROVIDERS[selectedProvider]?.supportsImages) ?? false;
                         if (isWaitingForResponse) {
                             // alert("Cannot attach files while waiting for a response.");
                         } else if (!providerSupportsImages) {
                              alert(`Attachment disabled: The current provider (${PROVIDERS[selectedProvider]?.name || selectedProvider}) does not support images.`);
                         }
                     }
                 });
            } else console.error("uploadFileButton missing");

            // --- Listener for the actual file input change event ---
            if (fileUploadInput) {
                fileUploadInput.addEventListener('change', handleFileSelection);
            } else {
                console.error("fileUploadInput missing");
            }

            if (pfpUploadInput) pfpUploadInput.addEventListener('change', handlePfpUpload); else console.error("pfpUploadInput missing");
            console.log("Event listeners attached.");
        }

        // --- Handler for PFP Upload (extracted) ---
        function handlePfpUpload(event) {
             const f = event.target.files[0]; if (!f || !currentPfpElementToUpdate) return; const r = new FileReader();
             r.onload = function(e) {
                 const u = e.target.result; currentPfpElementToUpdate.src = u;
                 const t = currentPfpElementToUpdate.closest('.avatar').dataset.senderType;
                 if (t === 'user') { userPfp = u; localStorage.setItem('userPfp', u); document.querySelectorAll('.avatar.user-avatar img').forEach(i=>i.src=u); }
                 else if (t === 'spirit') { botPfp = u; localStorage.setItem('botPfp', u); document.querySelectorAll('.avatar.spirit-avatar img').forEach(i=>i.src=u); }
                 currentPfpElementToUpdate = null;
             }; r.readAsDataURL(f); event.target.value = null;
        }

        // --- Function Implementations ---
        function updateApiKeyStatus(provider = selectedProvider) {
            const keysForProvider = apiKeys[provider] || []; const keyCount = keysForProvider.length;
            const callCount = apiCallCounts[provider] || 0;
            const providerConfig = (typeof PROVIDERS !== 'undefined' && provider) ? PROVIDERS[provider] : null;
            const providerName = providerConfig?.name || provider || 'Unknown Provider';
            const needsKey = doesProviderNeedApiKey(provider);

            if (apiKeyStatus) { apiKeyStatus.textContent = `Keys Loaded: ${keyCount}`; }
            if (apiCallCountDisplay) { apiCallCountDisplay.textContent = `Calls: ${callCount}`; }
            if (selectedProviderLabel) { selectedProviderLabel.textContent = providerName; }
            if (sendButton) { sendButton.disabled = (needsKey && keyCount === 0) || isWaitingForResponse; }
            if (apiKeyInput) { apiKeyInput.disabled = !needsKey; apiKeyInput.placeholder = needsKey ? "Paste new key..." : "Not Required"; }
            if (addKeyButton) { addKeyButton.disabled = !needsKey; }
            if (clearKeysButton) { clearKeysButton.disabled = !needsKey; }
            if (resetCallCountButton) { resetCallCountButton.style.display = provider ? 'inline-block' : 'none'; }
        }
        function doesProviderNeedApiKey(provider) {
            if (!provider || typeof PROVIDERS === 'undefined' || !PROVIDERS[provider]) { return true; } // Assume needed if config missing
            const providerConfig = PROVIDERS[provider];
            // Needs key if location is not 'none' OR if it's proxy compatible (which implies a key, maybe server-side)
            return providerConfig.apiKeyLocation !== 'none'; // Simplified - proxy compatible doesn't mean client needs key
        }
        function addApiKey() {
             const provider = selectedProvider; const newKey = apiKeyInput.value.trim(); if (!provider) { alert("Select provider."); return; }
             const providerConfig = PROVIDERS[provider]; if (!providerConfig) { alert("Invalid provider."); return; }
             if (!doesProviderNeedApiKey(provider)) { alert(`${providerConfig.name} does not require client-side keys.`); apiKeyInput.value = ''; return; }
             if (newKey) { if (!apiKeys[provider]) apiKeys[provider] = []; if (!apiKeys[provider].includes(newKey)) { apiKeys[provider].push(newKey); apiKeyInput.value = ''; updateApiKeyStatus(provider); console.log(`Added key for ${provider}. Total: ${apiKeys[provider].length}`); try { localStorage.setItem('apiKeys', JSON.stringify(apiKeys)); } catch (e) { console.error("Failed to save API keys:", e); }} else { alert(`Key already exists for ${providerConfig.name}.`); }} else { alert("Paste key."); }
        }
        function clearApiKeysForProvider() {
             const provider = selectedProvider; if (!provider) { alert("Select provider."); return; }
             const providerConfig = PROVIDERS[provider]; if (!providerConfig) { alert(`Invalid provider.`); return; }
             const providerName = providerConfig.name || provider;
             if (confirm(`Remove ALL keys for ${providerName}?`)) { apiKeys[provider] = []; currentApiKeyIndex[provider] = 0; updateApiKeyStatus(provider); console.log(`Cleared keys for ${provider}.`); try { localStorage.setItem('apiKeys', JSON.stringify(apiKeys)); localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex)); } catch (e) { console.error("Failed to save cleared keys/indices:", e); }}
        }
        function resetApiCallCountForProvider() {
            const provider = selectedProvider; if (!provider) { alert("Select provider."); return; }
            const providerName = (typeof PROVIDERS !== 'undefined' && PROVIDERS[provider]?.name) ? PROVIDERS[provider].name : provider;
            if (confirm(`Reset call count for ${providerName} to zero?`)) { apiCallCounts[provider] = 0; updateApiKeyStatus(provider); console.log(`Reset API call count for ${provider}.`); try { localStorage.setItem('apiCallCounts', JSON.stringify(apiCallCounts)); } catch (e) { console.error("Failed to save reset count:", e); } }
        }
        async function attemptApiCallWithRetry(provider, model, history, options) {
            console.log(`Attempting API call to ${provider}/${model}. History length: ${history.length}`);
            // console.log("History for API:", JSON.stringify(history.slice(-4), null, 2)); // Log last few messages
            if (typeof PROVIDERS === 'undefined' || !PROVIDERS[provider]) { throw new Error(`Config Error: Provider '${provider}' missing`); }
            const providerConfig = PROVIDERS[provider]; const needsKey = doesProviderNeedApiKey(provider);
            const keys = apiKeys[provider] || []; const numKeys = keys.length; let startIndex = currentApiKeyIndex[provider] || 0; let triedKeyIndices = new Set();
            if (needsKey && numKeys === 0) { throw new Error(`[Config Error: No API Key available for ${providerConfig.name}]`); }
            const maxAttempts = needsKey ? numKeys : 1;
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                let currentKey = null; let keyIndexToTry = -1;
                if (needsKey) { keyIndexToTry = (startIndex + attempt) % numKeys; if (triedKeyIndices.has(keyIndexToTry) && triedKeyIndices.size === numKeys) { console.warn(`Tried all keys for ${provider}. Aborting retries.`); break; } currentKey = keys[keyIndexToTry]; triedKeyIndices.add(keyIndexToTry); console.log(`API Call Attempt ${attempt + 1}/${maxAttempts}. Key index: ${keyIndexToTry} for ${provider}`); }
                else { console.log(`API Call Attempt ${attempt + 1}/${maxAttempts} to ${provider} (no client key needed)`); }
                try {
                    if (typeof getApiResponse !== 'function') { throw new Error("getApiResponse function is not defined."); }
                    // Make sure history is passed correctly
                    const result = await getApiResponse(provider, model, history, currentKey, options);
                    console.log(`API Call Success on attempt ${attempt + 1} for ${provider}`);
                    if (needsKey && keyIndexToTry !== -1) { currentApiKeyIndex[provider] = (keyIndexToTry + 1) % numKeys; try { localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex)); } catch(e) {console.warn("Failed to save API key index:", e);} }
                    apiCallCounts[provider] = (apiCallCounts[provider] || 0) + 1; try { localStorage.setItem('apiCallCounts', JSON.stringify(apiCallCounts)); } catch(e) {console.warn("Failed to save API call counts:", e);} updateApiKeyStatus(provider);
                    return result ?? "[Silence]"; // Use nullish coalescing
                } catch (error) {
                    console.warn(`API Call Error (Provider: ${provider}, Model: ${model}, Attempt: ${attempt + 1}, KeyIndex: ${keyIndexToTry}):`, error);
                    // Handle specific error types if needed (e.g., 401 Unauthorized vs. 500 Server Error)
                    if (attempt === maxAttempts - 1) { console.error(`All ${maxAttempts} attempts failed for ${provider}. Last error:`, error); throw new Error(`[Spirit Disturbance after ${maxAttempts} attempts: ${error instanceof Error ? error.message : String(error)}]`); }
                    console.log(`Retrying...`); // Simplified retry message
                }
            } throw new Error(`[Spirit Communication Failed after ${maxAttempts} attempts for ${provider}]`);
        }
        function hasSufficientApiResources() {
             if (!selectedProvider || typeof PROVIDERS === 'undefined' || !PROVIDERS[selectedProvider]) return false;
             const needsKey = doesProviderNeedApiKey(selectedProvider);
             if (!needsKey) return true; // No key needed, always sufficient
             const keysForCurrent = apiKeys[selectedProvider] || [];
             return keysForCurrent.length > 0; // Sufficient if at least one key exists
        }

        // --- **** NEW/FIXED: handleSendEditRequest Implementation **** ---
        async function handleSendEditRequest() {
            console.log("handleSendEditRequest initiated.");
            if (isWaitingForResponse) {
                console.warn("Attempted to send edit request while already waiting.");
                return;
            }
            if (!hasSufficientApiResources()) {
                 const providerName = (typeof PROVIDERS !== 'undefined' && selectedProvider && PROVIDERS[selectedProvider]?.name) ? PROVIDERS[selectedProvider].name : selectedProvider || "the selected provider";
                 if (doesProviderNeedApiKey(selectedProvider)) { alert(`No API Key loaded for ${providerName}, which requires one. Please add a key in Settings.`); }
                 else { alert(`Cannot send edit request. Please select a valid provider in Settings.`); }
                 return;
            }

            const snippet = editSnippetTextarea.value;
            const startLine = parseInt(editStartLineInput.value, 10);
            const endLine = parseInt(editEndLineInput.value, 10);
            const instructions = editInstructionsInput.value.trim();
            const responseCount = parseInt(editResponseCountInput.value, 10);

            // --- Validation ---
            if (snippet === '') { alert("Glyph area is empty."); editSnippetTextarea.focus(); return; }
            const lines = snippet.split('\n');
            const totalLines = lines.length;
            if (isNaN(startLine) || isNaN(endLine) || startLine < 1 || endLine < 1 || startLine > totalLines || endLine > totalLines || startLine > endLine) {
                alert("Invalid start or end line number."); return;
            }
            if (instructions === '') { alert("Please provide instructions for the spirit."); editInstructionsInput.focus(); return; }
            const numResponses = isNaN(responseCount) || responseCount < 0 ? 0 : Math.min(responseCount, maxResponseVariations);
            if (numResponses === 0) { alert("Set Variations to 1 or more to request an alteration."); editResponseCountInput.focus(); return; }
            // --- End Validation ---

            isWaitingForResponse = true;
            if (sendEditRequestButton) sendEditRequestButton.disabled = true;
            if (sendButton) sendButton.disabled = true; // Also disable main send
            updateAttachmentUI(); // Ensure upload button is also disabled

            const turnId = `turn-${turnCounter++}`;
            const containsPlaceholder = instructions.includes(iterationPlaceholder);
            const selectedLines = lines.slice(startLine - 1, endLine).join('\n');

            // --- Create User Entry for the Edit Request ---
            // Use Markdown for clarity in the chat history
            const userMessageContent = `*Requesting alteration for lines ${startLine} to ${endLine}*\n**Instructions:** ${instructions}\n\n---\n**Original Code (Lines ${startLine}-${endLine}):**\n\`\`\`\n${selectedLines}\n\`\`\``;
            const userEntry = {
                role: 'user',
                content: userMessageContent,
                turnId: turnId,
                isEditRequest: true // Optional flag
            };

            conversationHistory.push(userEntry);
            displayMessage(userEntry, 'user'); // Display the request itself
            saveHistoryToLocalStorage();
            scrollToBottom();

            // --- Close Modal Immediately after adding user message ---
            if (codeEditModal) codeEditModal.style.display = 'none';

            // --- API Call Logic ---
            showTypingIndicator();
            // Prepare history *including* the new edit request message
            const baseHistory = prepareHistoryForApi(conversationHistory);
            const responses = [];
            let overallError = null;
            const provider = selectedProvider;
            const model = selectedModel;

            console.log(`Sending ${numResponses} edit requests to ${provider} (${model})`);

            for (let i = 0; i < numResponses; i++) {
                const iteration = i + 1;
                let currentHistory = JSON.parse(JSON.stringify(baseHistory)); // Deep copy for modification

                // --- Placeholder substitution in the LAST user message (our edit request) ---
                if (containsPlaceholder && numResponses > 1) {
                    const lastUserMessageIndex = currentHistory.findLastIndex(m => m.role === 'user');
                    if (lastUserMessageIndex > -1 && typeof currentHistory[lastUserMessageIndex].content === 'string') {
                        const originalMessage = currentHistory[lastUserMessageIndex];
                        // Substitute placeholder ONLY within the instructions part if possible, otherwise globally in the message
                        // A safer approach: substitute globally in the last message content
                        const substitutedContent = originalMessage.content.replace(
                             new RegExp(iterationPlaceholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g'),
                             iteration.toString()
                        );
                        currentHistory[lastUserMessageIndex] = {
                            ...originalMessage,
                            content: substitutedContent
                        };
                        console.log(`Substituted placeholder in edit request message content for iteration ${iteration}`);
                    } else {
                        console.warn("Could not find user message (edit request) to substitute placeholder.");
                    }
                }
                 // --- End Placeholder ---

                try {
                    // Pass the potentially modified history for this iteration
                    const messageContent = await attemptApiCallWithRetry(provider, model, currentHistory, { temperature: 0.7, top_p: 0.9 });
                    responses.push(messageContent);
                } catch (e) {
                    console.error(`API Call Failed (Edit Request, Provider: ${provider}, Model: ${model}, Iteration: ${iteration}) after retries:`, e);
                    responses.push(e.message || "[Spirit Alteration Failed]");
                    overallError = e;
                }
            } // End loop through variations

            hideTypingIndicator();

            if (responses.length > 0) {
                const botEntry = {
                    role: 'assistant',
                    variants: responses,
                    selectedIndex: 0,
                    turnId: turnId,
                    isCodeEdit: true // Mark this response as resulting from an edit
                };
                conversationHistory.push(botEntry);
                saveHistoryToLocalStorage();
                displayBotMessage(botEntry, 'spirit'); // Display the result
                scrollToBottom();
            }
            // --- End API Call Logic ---

            isWaitingForResponse = false;
            if (sendEditRequestButton) sendEditRequestButton.disabled = false;
            if (sendButton) sendButton.disabled = !hasSufficientApiResources(); // Re-enable main send based on resources
            updateAttachmentUI(); // Re-enable upload button if applicable
            messageInput.focus(); // Focus main input after closing modal
            console.log("handleSendEditRequest completed.");
        }
        // --- **** END handleSendEditRequest **** ---


        function populateProviderSelect() {
             if (!providerSelect) { console.error("providerSelect missing."); return; }
             providerSelect.innerHTML = '';
             if (typeof PROVIDERS === 'undefined' || Object.keys(PROVIDERS).length === 0) {
                 console.error("PROVIDERS missing or empty.");
                 providerSelect.innerHTML = '<option value="" disabled>Error: No Providers</option>';
                 selectedProvider = ''; localStorage.setItem('selectedProvider', '');
                 populateModelSelect(''); // Clear models
                 return;
             }
             let foundSelected = false;
             for (const providerKey in PROVIDERS) {
                 const option = document.createElement('option');
                 option.value = providerKey;
                 option.textContent = PROVIDERS[providerKey].name || providerKey;
                 providerSelect.appendChild(option);
                 if (providerKey === selectedProvider) foundSelected = true;
             }
             // If saved provider doesn't exist anymore, select the first available one
             if (!foundSelected && Object.keys(PROVIDERS).length > 0) {
                 selectedProvider = Object.keys(PROVIDERS)[0];
                 localStorage.setItem('selectedProvider', selectedProvider);
                 console.warn(`Saved provider '${providerSelect.value}' not found. Defaulting to '${selectedProvider}'.`);
             }
             providerSelect.value = selectedProvider; // Set the select value
             populateModelSelect(selectedProvider); // Populate models for the selected (or defaulted) provider
        }
        function populateModelSelect(providerKey) {
             if (!modelSelect) { console.error("modelSelect missing."); return; }
             modelSelect.innerHTML = '';
             selectedModel = ''; // Reset selected model first

             if (typeof PROVIDERS === 'undefined' || !providerKey || !PROVIDERS[providerKey]) {
                 modelSelect.innerHTML = '<option value="" disabled>Select Provider</option>';
                 localStorage.setItem('selectedModel', '');
                 updateApiKeyStatus(providerKey); // Update status even if no models
                 return;
             }

             const providerConf = PROVIDERS[providerKey];
             if (!providerConf.availableModels || providerConf.availableModels.length === 0) {
                 modelSelect.innerHTML = '<option value="" disabled>No models listed</option>';
                 localStorage.setItem('selectedModel', '');
                 updateApiKeyStatus(providerKey);
                 return;
             }

             providerConf.availableModels.forEach(modelInfo => {
                 const modelKey = typeof modelInfo === 'string' ? modelInfo : modelInfo.key;
                 const modelName = typeof modelInfo === 'string' ? modelInfo : modelInfo.name || modelInfo.key;
                 if (!modelKey) return; // Skip if key is missing
                 const option = document.createElement('option');
                 option.value = modelKey;
                 option.textContent = modelName;
                 modelSelect.appendChild(option);
             });

             const savedModel = localStorage.getItem('selectedModel');
             // Check if the saved model is valid for the *current* provider
             const isValidSavedModel = savedModel && providerConf.availableModels.some(m => (typeof m === 'string' ? m === savedModel : m.key === savedModel));

             if (isValidSavedModel) {
                 modelSelect.value = savedModel;
                 selectedModel = savedModel;
             } else if (providerConf.defaultModel && providerConf.availableModels.some(m => (typeof m === 'string' ? m === providerConf.defaultModel : m.key === providerConf.defaultModel))) {
                 // Use provider's default if saved one is invalid or missing
                 modelSelect.value = providerConf.defaultModel;
                 selectedModel = providerConf.defaultModel;
                 console.warn(`Saved model '${savedModel}' invalid for ${providerKey}. Using default: ${selectedModel}`);
             } else if (modelSelect.options.length > 0) {
                 // Fallback to the first available model if no default or saved model works
                 modelSelect.selectedIndex = 0; // Select the first option
                 selectedModel = modelSelect.value;
                 console.warn(`No valid saved or default model for ${providerKey}. Using first available: ${selectedModel}`);
             } else {
                 // Should not happen if availableModels is not empty, but handle defensively
                 modelSelect.innerHTML = '<option value="" disabled>Error loading models</option>';
                 selectedModel = '';
                 console.error(`Error condition: No models available for ${providerKey} after population.`);
             }

             localStorage.setItem('selectedModel', selectedModel); // Save the final selected model
             console.log(`Model set: ${selectedModel} for ${selectedProvider}`);
             updateApiKeyStatus(providerKey); // Update status based on the provider
        }
        function handleProviderChange() {
            selectedProvider = providerSelect.value;
            localStorage.setItem('selectedProvider', selectedProvider);
            populateModelSelect(selectedProvider); // This will also update selectedModel and save it
            // updateAttachmentUI is handled by the listener already
        }
        function handleModelChange() {
             selectedModel = modelSelect.value;
             localStorage.setItem('selectedModel', selectedModel);
             console.log(`Model changed: ${selectedModel} for ${selectedProvider}`);
             // No need to update API status here as it depends on the provider, not the model itself
        }
        function openSystemPromptModal() {
            console.log("openSystemPromptModal called");
            if (!systemPromptModal) { console.error("Settings modal missing!"); return; }
            // Load current system prompt from history if possible, else from storage/default
            const currentSystemPrompt = conversationHistory[0]?.content || localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
            if (systemPromptInput) systemPromptInput.value = currentSystemPrompt;
            if (maxVariationsInput) maxVariationsInput.value = maxResponseVariations;
            if (hideCodeCheckbox) hideCodeCheckbox.checked = hideCodeBlocks;
            if (downloadCodeCheckbox) downloadCodeCheckbox.checked = downloadCodeMode;
            if (enableRunHtmlCheckbox) enableRunHtmlCheckbox.checked = enableRunHtmlMode;
            if (apiKeyInput) apiKeyInput.value = ''; // Clear API key input field
            populateProviderSelect(); // Ensure selects are up-to-date with current state
            // Note: populateModelSelect is called within populateProviderSelect
            updateApiKeyStatus(selectedProvider); // Ensure API key status reflects current provider
            systemPromptModal.style.display = 'flex';
            console.log("System prompt modal display attempt finished.");
        }
        function saveSettings() {
            console.log("saveSettings called");
            const spText = systemPromptInput.value.trim();
            const sp = spText || DEFAULT_SYSTEM_PROMPT; // Use default if empty

            // Update system prompt in history AND localStorage
            if (conversationHistory.length === 0 || conversationHistory[0]?.role !== 'system') {
                conversationHistory.unshift({ role: 'system', content: sp });
            } else {
                conversationHistory[0].content = sp;
            }
            localStorage.setItem('systemPrompt', sp);

            // Save provider/model (already updated via change handlers, but save again for robustness)
            localStorage.setItem('selectedProvider', selectedProvider);
            localStorage.setItem('selectedModel', selectedModel);

            // Save Max Variations
            const newMaxVar = parseInt(maxVariationsInput.value, 10);
            const maxAllowed = parseInt(maxVariationsInput.max, 10) || 10; // Read max from input attribute or default
            if (!isNaN(newMaxVar) && newMaxVar >= 1 && newMaxVar <= maxAllowed) {
                maxResponseVariations = newMaxVar;
                localStorage.setItem('maxResponseVariations', String(maxResponseVariations));
                updateResponseCountInputMax();
            } else {
                alert(`Invalid Max Variations value. Must be between 1 and ${maxAllowed}.`);
                maxVariationsInput.value = maxResponseVariations; // Reset to valid value
                return; // Don't close modal if validation failed
            }

            // Save API Keys, Index, Counts (already updated by add/clear/reset, but save again)
            try {
                localStorage.setItem('apiKeys', JSON.stringify(apiKeys));
                localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex));
                localStorage.setItem('apiCallCounts', JSON.stringify(apiCallCounts));
                console.log(`Settings saved. Provider: ${selectedProvider}, Model: ${selectedModel}, Max Variations: ${maxResponseVariations}`);
            } catch (e) {
                console.error("Failed to save API keys/indices/counts:", e);
                alert("Error saving API data.");
            }

            saveHistoryToLocalStorage(); // Save the modified history (with updated system prompt)
            updateApiKeyStatus(); // Update status display based on saved provider/keys
            systemPromptModal.style.display = 'none'; // Close modal on successful save
        }
        function updateResponseCountInputMax() {
             const maxVal = maxResponseVariations || 5; // Fallback
             if (mainResponseCountInput) mainResponseCountInput.max = maxVal;
             if (editResponseCountInput) editResponseCountInput.max = maxVal;
             // Optionally adjust current values if they exceed the new max
             if (mainResponseCountInput && parseInt(mainResponseCountInput.value) > maxVal) mainResponseCountInput.value = maxVal;
             if (editResponseCountInput && parseInt(editResponseCountInput.value) > maxVal) editResponseCountInput.value = maxVal;
        }
        function handleHideCodeToggle() {
            if (!hideCodeCheckbox || !chatContainerElement) return;
            hideCodeBlocks = hideCodeCheckbox.checked;
            localStorage.setItem('hideCodeBlocks', String(hideCodeBlocks));
            chatContainerElement.classList.toggle('code-hidden', hideCodeBlocks);
            // No need to rebuild chat, CSS handles visibility
        }
        function handleDownloadCodeToggle() {
             if (!downloadCodeCheckbox || !chatContainerElement) return;
             downloadCodeMode = downloadCodeCheckbox.checked;
             localStorage.setItem('downloadCodeMode', String(downloadCodeMode));
             chatContainerElement.classList.toggle('download-code-active', downloadCodeMode);
              // Rebuild needed if buttons are added/removed dynamically, but here CSS handles it
        }
        function handleEnableRunHtmlToggle() {
            if (!enableRunHtmlCheckbox || !chatContainerElement) return;
            enableRunHtmlMode = enableRunHtmlCheckbox.checked;
            localStorage.setItem('enableRunHtmlMode', String(enableRunHtmlMode));
            chatContainerElement.classList.toggle('run-html-active', enableRunHtmlMode);
            // Rebuild needed if buttons are added/removed dynamically, but here CSS handles it
        }
        function handleClearChat() {
            console.log("handleClearChat called");
            if (isWaitingForResponse) {
                alert("Cannot clear chat while waiting for a response.");
                return;
            }
            if (confirm("Disperse all echoes? This action cannot be undone.")) {
                console.log("Clear confirmed");
                const sp = conversationHistory[0]?.content || localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_PROMPT;
                conversationHistory = [{ role: 'system', content: sp }]; // Keep only system prompt
                turnCounter = 1; // Reset turn counter
                attachedFilesData = []; // Clear any pending attachments
                updateAttachmentUI(); // Update attachment display
                saveHistoryToLocalStorage(); // Save the cleared history
                rebuildChatFromHistory(); // Update the UI
                displayInitialGreeting(); // Show the initial message if applicable
                console.log("Chat cleared.");
            } else {
                console.log("Clear cancelled");
            }
        }
        function insertIteratorPlaceholder(targetInput) {
            console.log("insertIteratorPlaceholder called for target:", targetInput?.id);
            if (!targetInput) { console.error("Target input is null!"); return; }
            const start = targetInput.selectionStart;
            const end = targetInput.selectionEnd;
            const value = targetInput.value;
            const newValue = value.substring(0, start) + iterationPlaceholder + value.substring(end);
            targetInput.value = newValue;
            // Move cursor to after the inserted placeholder
            const newPos = start + iterationPlaceholder.length;
            targetInput.selectionStart = newPos;
            targetInput.selectionEnd = newPos;
            targetInput.focus(); // Keep focus on the input
            // Trigger input event for frameworks/libraries that might listen to it (like autoGrowTextarea)
            targetInput.dispatchEvent(new Event('input', { bubbles: true }));
            console.log(`Iterator inserted into ${targetInput.id}`);
        }
        function autoGrowTextarea() {
             if (!messageInput) return;
             const input = messageInput;
             const maxHeightStyle = window.getComputedStyle(input).maxHeight;
             // Ensure maxHeightStyle is parsed correctly, default if invalid
             const maxHeight = parseFloat(maxHeightStyle) || 150;
             // Temporarily reduce height to get accurate scrollHeight
             input.style.height = 'auto';
             const scrollHeight = input.scrollHeight;
             // Set new height, capped by max-height
             input.style.height = Math.min(scrollHeight, maxHeight) + 'px';
             // Show scrollbar only if content exceeds max-height
             input.style.overflowY = scrollHeight > maxHeight ? 'auto' : 'hidden';
        }
        function openEditCodeModal() {
             console.log("openEditCodeModal called");
             if (!codeEditModal) { console.error("Code edit modal missing!"); return; }
             if (isWaitingForResponse) { alert("Cannot edit while waiting for a response."); return; }

             // Try to find the last code block from the last assistant message
             const lastBotMessage = conversationHistory.slice().reverse().find(m => m.role === 'assistant');
             let initialCode = '';
             if(lastBotMessage && lastBotMessage.variants) {
                 const lastVariantText = lastBotMessage.variants[lastBotMessage.selectedIndex ?? 0];
                 const codeMatch = lastVariantText.match(/```(?:\w*\n)?([\s\S]*?)```/); // Simple ``` block match
                 if (codeMatch && codeMatch[1]) {
                     initialCode = codeMatch[1].trim(); // Get content inside ```
                 }
             }

             if (editSnippetTextarea) editSnippetTextarea.value = initialCode; // Pre-fill if found
             if (editStartLineInput) editStartLineInput.value = 1;
             if (editEndLineInput) editEndLineInput.value = initialCode ? initialCode.split('\n').length : 1; // Set end line based on pre-filled code
             if (editInstructionsInput) editInstructionsInput.value = ''; // Clear instructions
             if (editResponseCountInput) {
                 editResponseCountInput.value = 1; // Default to 1 variation
                 editResponseCountInput.max = maxResponseVariations; // Set max based on global setting
             }
             updateSnippetLineCount(); // Update line count display
             codeEditModal.style.display = 'flex';
             if (editSnippetTextarea) editSnippetTextarea.focus(); // Focus the textarea
             console.log("Code edit modal display attempt finished.");
        }
        function updateSnippetLineCount() {
             if (!editSnippetTextarea || !editSnippetLineCount || !editStartLineInput || !editEndLineInput) return;
             const lines = editSnippetTextarea.value.split('\n');
             const count = editSnippetTextarea.value === '' ? 0 : lines.length;
             if (editSnippetLineCount) editSnippetLineCount.textContent = count; // Update display

             const maxVal = count > 0 ? count : 1; // Max value for line inputs is total lines (or 1 if empty)
             editStartLineInput.max = maxVal;
             editEndLineInput.max = maxVal;

             // Adjust values if they exceed the new max or if end < start
             let startVal = parseInt(editStartLineInput.value);
             let endVal = parseInt(editEndLineInput.value);

             if (isNaN(startVal) || startVal < 1) startVal = 1;
             if (isNaN(endVal) || endVal < 1) endVal = 1;

             startVal = Math.min(startVal, maxVal);
             endVal = Math.min(endVal, maxVal);

             if (endVal < startVal) endVal = startVal; // Ensure end is not before start

             editStartLineInput.value = startVal;
             editEndLineInput.value = endVal;
        }
        function renderRunnerHTML() {
            if (!htmlRunnerInput || !htmlRunnerFrame) { console.error("HTML Runner elements missing."); return; }
            const htmlCode = htmlRunnerInput.value;

            // Basic check for potentially harmful patterns (highly insecure, illustrative only)
            const harmfulPatterns = /<\s*script.*?(?:src\s*=|document\.cookie|localStorage|sessionStorage|window\.location|eval\(|alert\()/i;
            if (harmfulPatterns.test(htmlCode)) {
                 console.warn("Potentially harmful script detected. Blocking render.");
                 try {
                     const doc = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow?.document;
                     if (doc) {
                         doc.open();
                         // Display a clear message within the iframe
                         doc.write('<html><head><style>body{font-family: sans-serif; color: #8b0000; padding: 15px;}</style></head><body><h2>Blocked Content</h2><p>Rendering was blocked due to potentially harmful script patterns.</p></body></html>');
                         doc.close();
                     }
                 } catch (e) { /* ignore potential security errors writing to iframe */ }
                 return; // Stop execution
            }

             try {
                 const doc = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow?.document;
                 if (doc) {
                     doc.open();
                     doc.write(htmlCode); // Write the user's HTML
                     doc.close();
                 } else {
                     console.error("Cannot access iframe document. Rendering failed.");
                 }
             } catch (e) {
                 console.error("Error rendering HTML:", e);
                 // Attempt to display error in iframe
                 try {
                     const doc = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow?.document;
                     if (doc) {
                         doc.open();
                         doc.write(`<html><head><style>body{font-family: monospace; color: red; white-space: pre-wrap;}</style></head><body>Error rendering preview:\n\n${e.message}</body></html>`);
                         doc.close();
                     }
                 } catch (e2) { /* nested catch to prevent errors here */ }
             }
        }
        function openHtmlRunner(initialCode = '') {
             if (!htmlRunnerModal || !htmlRunnerInput) { console.error("HTML Runner modal/input missing."); return; }
             htmlRunnerInput.value = initialCode; // Set the initial code
             renderRunnerHTML(); // Render it immediately
             htmlRunnerModal.style.display = 'flex'; // Show the modal
        }
        function createPfpElement(sender, pfpUrl) {
            const d=document.createElement('div');
            d.className=`avatar ${sender}-avatar`;
            d.dataset.senderType=sender; // Store type for click handler
            const i=document.createElement('img');
            i.src=pfpUrl;
            i.alt=`${sender} avatar`;
            // Fallback image on error
            i.onerror = () => {
                console.warn(`Failed avatar load: ${pfpUrl}. Using fallback.`);
                const fallbackUrl = 'https://ui-avatars.com/api/?name='+(sender==='user'?'U&background=1e3a8a':'S&background=6b21a8')+'&color=fff&font-size=0.6&bold=true';
                if (i.src !== fallbackUrl) { // Prevent infinite loop if fallback also fails
                    i.src = fallbackUrl;
                }
                i.onerror=null; // Remove error handler after fallback attempt
            };
            // Click listener to change PFP
            d.addEventListener('click', () => {
                currentPfpElementToUpdate = i; // Store the image element being clicked
                if (pfpUploadInput) pfpUploadInput.click(); // Trigger hidden file input
                else console.error("pfpUploadInput missing.");
            });
            d.appendChild(i);
            return d;
        }
        function displayBotMessage(entry, sender = 'spirit') {
             if (!entry || !entry.variants) { console.warn("Invalid bot entry:", entry); return; }
             // Always use displayMessage, but pass the full entry which includes variants and selectedIndex.
             // displayMessage will handle rendering the selected variant.
             // addNavigationControls will be added within displayMessage if variants > 1.
             displayMessage(entry, sender);
        }
        // displayMultipleMessages is now merged into displayMessage and addNavigationControls helper
        // function displayMultipleMessages(...) { /* REMOVED */ }
        function addCodeActionButtons(contentDiv, wrapper, turnId, variantIndex) {
            let actsContainer = wrapper.querySelector('.message-actions');
            // If container doesn't exist, create it and insert before navigation (if nav exists)
            if (!actsContainer) {
                actsContainer = document.createElement('div');
                actsContainer.classList.add('message-actions');
                const nav = wrapper.querySelector('.response-navigation');
                if (nav) { wrapper.insertBefore(actsContainer, nav); }
                else { wrapper.appendChild(actsContainer); }
            }
            actsContainer.innerHTML = ''; // Clear existing actions for this variant

            // Remove old placeholders, find new code blocks
            contentDiv.querySelectorAll('.cat-placeholder').forEach(c => c.remove());
            const codeBlocks = contentDiv.querySelectorAll('pre');

            if (codeBlocks.length === 0) {
                // If no code blocks AND no other actions planned, remove the container
                 if (actsContainer.parentNode && !actsContainer.hasChildNodes()) actsContainer.remove();
                 return; // No code, no actions needed
            }

            let hasActions = false; // Flag to check if any buttons were added

            codeBlocks.forEach((pre, preIdx) => {
                const uniqueId = `pre-${turnId || 'g'}-${variantIndex}-${preIdx}`; // Unique ID per variant/block
                pre.id = uniqueId;

                // Add placeholder for hidden code mode
                const placeholder = document.createElement('span');
                placeholder.className = 'cat-placeholder';
                placeholder.textContent = 'Code Block'; // More descriptive placeholder
                placeholder.dataset.preId = uniqueId;
                pre.parentNode.insertBefore(placeholder, pre); // Insert placeholder before the <pre> tag

                const codeElement = pre.querySelector('code');
                const codeText = codeElement ? codeElement.textContent : '';
                const langMatch = codeElement?.className.match(/language-(\w+)/);
                const language = langMatch ? langMatch[1].toLowerCase() : 'txt';
                const filename = `tome_${turnId || 'code'}_v${variantIndex + 1}_b${preIdx + 1}.${language}`;

                // 1. Copy Button (Always add)
                const copyBtn = document.createElement('button');
                copyBtn.textContent = 'Copy';
                copyBtn.title = `Copy ${language} code`;
                copyBtn.className = 'copy-code-button action-button';
                copyBtn.onclick = () => copyCodeFromPre(uniqueId, copyBtn);
                actsContainer.appendChild(copyBtn);
                hasActions = true;

                // 2. Download Button (Conditional)
                const downloadBtn = document.createElement('button');
                downloadBtn.textContent = 'Download';
                downloadBtn.title = `Download ${filename}`;
                downloadBtn.className = 'download-code-button action-button'; // Class controls visibility via CSS
                downloadBtn.onclick = () => downloadCode(codeText, filename);
                actsContainer.appendChild(downloadBtn);
                // Note: Visibility is controlled by .tome.download-code-active CSS rule

                // 3. Run HTML Button (Conditional)
                if (language === 'html') {
                    const runBtn = document.createElement('button');
                    runBtn.textContent = 'Run HTML';
                    runBtn.className = 'run-html-button action-button'; // Class controls visibility via CSS
                    runBtn.title = "Run HTML in previewer";
                    runBtn.onclick = () => openHtmlRunner(codeText);
                    actsContainer.appendChild(runBtn);
                     // Note: Visibility is controlled by .tome.run-html-active CSS rule
                }
            });

             // Remove actions container if it ended up empty (e.g., no code blocks found)
            if (!hasActions && actsContainer.parentNode) {
                actsContainer.remove();
            }
        }
        function copyCodeFromPre(preId, buttonElement) {
             const preElement = document.getElementById(preId);
             const codeElement = preElement ? preElement.querySelector('code') : null;
             if (!codeElement) {
                 console.error(`Code element not found for pre ID: ${preId}`);
                 if (buttonElement) { buttonElement.textContent='Error'; setTimeout(() => buttonElement.textContent='Copy', 2000); }
                 return;
             }
             const codeText = codeElement.textContent || '';
             if (!copyHelper) {
                 console.error("Copy helper textarea element missing.");
                 if (buttonElement) { buttonElement.textContent='Error'; setTimeout(() => buttonElement.textContent='Copy', 2000); }
                 return;
             }

             copyHelper.value = codeText;
             copyHelper.select();
             // For mobile devices, set selection range might be needed
             copyHelper.setSelectionRange(0, 99999);

             let success = false;
             try {
                 // Use Clipboard API if available (more modern and secure)
                 if (navigator.clipboard && window.isSecureContext) {
                      navigator.clipboard.writeText(codeText).then(() => {
                           success = true;
                           if (buttonElement) {
                               buttonElement.textContent = 'Copied!';
                               buttonElement.classList.add('copied');
                               setTimeout(() => {
                                   buttonElement.textContent = 'Copy';
                                   buttonElement.classList.remove('copied');
                               }, 1500);
                           }
                      }).catch(err => {
                           console.error('Async clipboard copy failed:', err);
                           // Fallback to execCommand if Clipboard API fails
                           success = document.execCommand('copy');
                           updateCopyButtonState(buttonElement, success);
                      });
                 } else {
                     // Fallback to execCommand for older browsers or non-secure contexts
                     success = document.execCommand('copy');
                     updateCopyButtonState(buttonElement, success);
                 }
             } catch (e) {
                 console.error("Error during copy command:", e);
                 updateCopyButtonState(buttonElement, false); // Ensure button state reflects failure
             }

             // Clean up selection
             window.getSelection()?.removeAllRanges();
        }
        // Helper function for copy button state update
        function updateCopyButtonState(buttonElement, success) {
            if (!buttonElement) return;
            if (success) {
                buttonElement.textContent = 'Copied!';
                buttonElement.classList.add('copied');
                setTimeout(() => {
                    buttonElement.textContent = 'Copy';
                    buttonElement.classList.remove('copied');
                }, 1500);
            } else {
                buttonElement.textContent = 'Failed!';
                 setTimeout(() => { buttonElement.textContent = 'Copy'; }, 2500);
            }
        }
        function downloadCode(codeText, filename) {
             try {
                 const blob = new Blob([codeText], { type: 'text/plain;charset=utf-8' });
                 const url = URL.createObjectURL(blob);
                 const link = document.createElement('a');
                 link.href = url;
                 link.download = filename;
                 document.body.appendChild(link); // Required for Firefox
                 link.click();
                 document.body.removeChild(link); // Clean up
                 URL.revokeObjectURL(url); // Free up memory
             } catch (e) {
                 console.error("Download error:", e);
                 alert("Download failed. See console for details.");
             }
        }
        function showTypingIndicator() {
            if (document.getElementById('typing-indicator')) return; // Already exists
            if (!pages) { console.error("Pages container missing for typing indicator."); return; }
            const indicatorDiv = document.createElement('div');
            indicatorDiv.className = 'message message-spirit typing-indicator'; // Use specific class
            indicatorDiv.id = 'typing-indicator';

            const avatarElement = createPfpElement('spirit', botPfp);
            const wrapperDiv = document.createElement('div');
            wrapperDiv.className = 'message-content-wrapper';
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.style.cssText = 'font-style: italic; color: var(--ink-light); background-color: rgba(227, 213, 184, 0.5); border: none;'; // Custom style
            // Simple animation or text
            contentDiv.textContent = 'The spirit whispers...';

            wrapperDiv.appendChild(contentDiv);
            indicatorDiv.appendChild(avatarElement);
            indicatorDiv.appendChild(wrapperDiv);
            pages.appendChild(indicatorDiv);
            scrollToBottom(); // Scroll to show indicator
        }
        function hideTypingIndicator() {
             const indicator = document.getElementById('typing-indicator');
             if (indicator) indicator.remove();
        }
        function scrollToBottom() {
            if (!pages) return;
            // Use timeout to allow DOM to update before scrolling
            setTimeout(() => {
                pages.scrollTop = pages.scrollHeight;
            }, 50); // Small delay
        }
        function updateHistorySelection(turnId, newIndex) {
             if (!turnId) return;
             const historyIndex = conversationHistory.findIndex(m => m.turnId === turnId && m.role === 'assistant');
             if (historyIndex > -1) {
                 const messageEntry = conversationHistory[historyIndex];
                 if (messageEntry.variants && newIndex >= 0 && newIndex < messageEntry.variants.length) {
                     if (messageEntry.selectedIndex !== newIndex) {
                         messageEntry.selectedIndex = newIndex;
                         saveHistoryToLocalStorage(); // Save change immediately
                         console.log(`Updated selected index for turn ${turnId} to ${newIndex}`);
                     }
                 } else {
                     console.warn(`Invalid index ${newIndex} requested for turn ${turnId}. Max index: ${messageEntry.variants.length - 1}`);
                 }
             } else {
                 console.warn(`Could not find assistant message with turn ID ${turnId} to update selection.`);
             }
        }
        function saveHistoryToLocalStorage() {
             try {
                 // Prune history if it gets too long? (Optional future enhancement)
                 localStorage.setItem('conversationHistory', JSON.stringify(conversationHistory));
             } catch (e) {
                 console.error("Save history error:", e);
                 // Potentially notify user or implement more robust storage
             }
        }
        function rebuildChatFromHistory() {
            if (!pages) return;
            pages.innerHTML = ''; // Clear existing messages
            // Start from index 1 to skip system prompt
            for (let i = 1; i < conversationHistory.length; i++) {
                const entry = conversationHistory[i];
                if (entry.role === 'user') {
                    displayMessage(entry, 'user');
                } else if (entry.role === 'assistant') {
                    // Use displayBotMessage which internally calls displayMessage
                    displayBotMessage(entry, 'spirit');
                }
            }
            scrollToBottom(); // Scroll to the end after rebuilding
        }
        function displayInitialGreeting() {
             // Show greeting only if it's truly the first interaction (history only has system prompt)
             if (!pages || conversationHistory.length > 1) return;

             const greetingText = "The ancient tome awaits your query...";
             // Create a temporary entry, don't save it to history unless needed
             const greetingEntry = {
                 role: 'assistant',
                 variants: [greetingText],
                 selectedIndex: 0,
                 turnId: 'greeting-0' // Special ID for greeting
             };
             displayBotMessage(greetingEntry, 'spirit');
             // Do NOT increment turnCounter here
        }

        // --- Start the application ---
        document.addEventListener('DOMContentLoaded', () => {
            // Ensure api_providers.js loaded before proceeding
             if (typeof PROVIDERS === 'undefined' || typeof getApiResponse === 'undefined') {
                 console.error("FATAL: api_providers.js script not loaded or failed.");
                 alert("Error: Critical script 'api_providers.js' failed to load. Cannot initialize.");
                 // Optionally disable UI elements here
                 if(sendButton) sendButton.disabled = true;
                 if(messageInput) messageInput.disabled = true;
                 // ... disable other controls ...
                 return; // Stop initialization
             }
            initialLoad();
            attachEventListeners();
        });

    </script>
</body>
</html>
