<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcane Tome (Provider Enhanced)</title>
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=Georgia&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- API Provider Definitions (MUST be before main script) -->
    <script src="api_providers.js"></script>

    <style>
        /* --- Arcane Tome Base Styles (Mostly Unchanged) --- */
        :root { /* ... same color variables ... */
             --parchment: #f5e7d0; --parchment-dark: #e3d5b8; --ink: #3a3129; --ink-light: #5a4e42; --gold: #c9a227; --crimson: #8b0000; --sapphire: #1e3a8a; --amethyst: #6b21a8; --emerald: #21a853; --shadow-light: 0 1px 3px rgba(0,0,0,0.15); --code-bg: #e8e0cf; --code-border: #d1c3a9;
        }
        html, body { height: 100%; margin: 0; padding: 0; }
        * { box-sizing: border-box; }
        body { font-family: Georgia,'Times New Roman',Times,serif; font-size: 1.1rem; line-height: 1.6; background-color: var(--parchment); color: var(--ink); width: 100vw; overflow: hidden; }
        .tome { width: 100%; height: 100%; display: flex; flex-direction: column; position: relative; background-color: var(--parchment); }
        .pages { flex: 1; min-height: 0; padding: 20px; overflow-y: auto; scrollbar-width: none; display: flex; flex-direction: column; gap: 15px; border-bottom: 2px solid var(--ink-light); }
        .pages::-webkit-scrollbar { display: none; }
        .message { display: flex; gap: 10px; max-width: 85%; animation: fadeIn 0.5s ease-in-out;}
        .message-user { align-self: flex-end; flex-direction: row-reverse; }
        .message-spirit { align-self: flex-start; }
        .avatar { width: 45px; height: 45px; border-radius: 50%; flex-shrink: 0; border: 2px solid var(--parchment-dark); box-shadow: var(--shadow-light); display: flex; align-items: center; justify-content: center; overflow: hidden; background-color: var(--parchment-dark); cursor: pointer; }
        .avatar img { width: 100%; height: 100%; object-fit: cover; }
        .user-avatar { background-color: var(--sapphire); }
        .spirit-avatar { background-color: var(--amethyst); }
        .message-content-wrapper { display: flex; flex-direction: column; max-width: 100%; }
        .message-content { padding: 12px 18px; border-radius: 8px; line-height: 1.5; word-break: break-word; box-shadow: var(--shadow-light); max-width: fit-content; }
        .message-user .message-content { background-color: var(--sapphire); color: white; border-top-right-radius: 0; }
        .message-spirit .message-content { background-color: white; color: var(--ink); border: 1px solid var(--ink-light); border-top-left-radius: 0; }
        .message-content p { margin: 0 0 0.5em 0; } .message-content p:last-child { margin-bottom: 0; }
        .typing-indicator { align-self: flex-start; color: var(--ink-light); font-style: italic; padding: 10px 15px; background-color: rgba(227,213,184,0.5); border-radius: 8px; font-size: 1rem; }
        .writing-area { padding: 12px; background-color: var(--parchment-dark); display: flex; flex-wrap: wrap; gap: 8px; align-items: flex-end; flex-shrink: 0; }
        .message-input { flex: 1 1 250px; padding: 10px; background-color: var(--parchment); border: 2px solid var(--ink-light); border-radius: 5px; font-family: inherit; font-size: 1.1rem; resize: none; outline: none; color: var(--ink); min-height: 48px; max-height: 150px; line-height: 1.5; }
        .message-input:focus { border-color: var(--gold); }
        .writing-controls { display: flex; align-items: flex-end; gap: 8px; flex-wrap: nowrap; margin-left: auto; }
        .footer-button { background-color: var(--ink-light); color: var(--parchment); border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; padding: 8px 10px; font-size: 0.9em; flex-shrink: 0; white-space: nowrap; height: 48px; font-family: Georgia,serif; display:flex; align-items:center; justify-content:center; }
        .footer-button:hover { background-color: var(--ink); }
        #settings-button { background-color: var(--gold); color: var(--ink); font-size: 1.2em; padding: 0 12px; }
        #settings-button:hover { background-color: var(--crimson); color: white; }
        #clear-chat-button { background-color: var(--crimson); color: white;}
        #clear-chat-button:hover { background-color: darkred; }
        #upload-file-button { font-size: 1.1em; padding: 0 12px; }
        .response-count-input { width: 45px; padding: 10px; border: 2px solid var(--ink-light); border-radius: 5px; text-align: center; flex-shrink: 0; height: 48px; font-size: 1rem; background-color: var(--parchment); color: var(--ink); }
        .send-button { background-color: var(--gold); color: var(--ink); border: none; border-radius: 5px; padding: 0 18px; height: 48px; font-family: 'Cinzel Decorative',cursive; font-weight: bold; cursor: pointer; box-shadow: var(--shadow-light); display: flex; align-items: center; gap: 8px; font-size: 1.1rem; transition: background-color 0.2s ease; flex-shrink: 0; }
        .send-button:hover:not(:disabled) { background-color: var(--crimson); color: white; }
        .send-button:disabled { opacity: 0.7; cursor: not-allowed; background-color: var(--ink-light); color: var(--parchment); }
        .response-navigation { display: flex; align-items: center; justify-content: flex-start; margin-top: 5px; gap: 5px; width: fit-content; }
        .response-navigation button { background-color: var(--parchment-dark); border: 1px solid var(--ink-light); color: var(--ink); border-radius: 4px; padding: 2px 6px; cursor: pointer; font-size: 0.9em; line-height: 1; }
        .response-navigation button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #ccc; }
        .response-navigation span { font-size: 0.8em; color: var(--ink-light); margin: 0 5px; user-select: none; }
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(58,49,41,0.7); justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--parchment); border: 3px solid var(--gold); color: var(--ink); padding: 25px; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.4); max-height: 90vh; width: 90%; display: flex; flex-direction: column; overflow-y: auto; }
        .modal-content h3 { font-family: 'Cinzel Decorative',cursive; margin-top: 0; text-align: center; color: var(--ink); border-bottom: 1px solid var(--gold); padding-bottom: 10px; margin-bottom: 20px; flex-shrink: 0; }
        .modal-content .form-group { margin-bottom: 15px; display: flex; flex-wrap: wrap; align-items: center; gap: 8px 15px; flex-shrink: 0; }
        .modal-content label { display: block; margin-bottom: 5px; font-weight: bold; color: var(--ink-light); flex-basis: 100%; }
        .modal-content input[type="checkbox"] { cursor: pointer; margin-right: 5px; flex-shrink: 0; }
        .modal-content label[for*="checkbox"] { flex-basis: auto; margin-bottom: 0; font-weight: normal; }
        .modal-content input[type="password"], .modal-content textarea, .modal-content input[type="number"], .modal-content select { width: 100%; padding: 10px; border: 1px solid var(--ink-light); border-radius: 4px; outline: none; box-sizing: border-box; background-color: white; color: var(--ink); font-family: Georgia,serif; font-size: 1rem; }
        .modal-content select { cursor: pointer; height: 44px; /* Match input height */ padding: 0 10px;} /* Adjust padding for select */
        .modal-content textarea { resize: vertical; min-height: 80px; }
        .modal-content .modal-buttons { margin-top: 20px; text-align: right; display: flex; justify-content: flex-end; gap: 10px; flex-shrink: 0; border-top: 1px solid var(--gold); padding-top: 15px; }
        .modal-content button { background-color: var(--gold); color: var(--ink); border: none; padding: 10px 18px; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; font-family: 'Cinzel Decorative',cursive; font-weight: bold; }
        .modal-content button:hover { background-color: var(--crimson); color: white; }
        .modal-content button.cancel-button { background-color: var(--ink-light); color: var(--parchment); }
        .modal-content button.cancel-button:hover { background-color: var(--ink); }

        /* --- Settings Modal Specifics (Provider/Key) --- */
        .provider-selector { display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; align-items: flex-end; }
        .provider-selector > div { flex: 1; min-width: 150px; }
        .api-key-manager { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-top: 5px; }
        .api-key-manager input[type="password"] { flex-grow: 1; min-width: 200px; }
        .api-key-manager button { padding: 8px 12px; font-size: 0.9em; height: 44px; flex-shrink: 0; /* Match input height */ }
        .api-key-status { font-size: 0.9em; color: var(--ink-light); margin-top: 5px; flex-basis: 100%; }
        #clear-keys-button { background-color: var(--crimson); color: white; margin-left: auto; }
        #clear-keys-button:hover { background-color: darkred; }

        /* ... (Other modal specifics, code formatting, buttons, modes - mostly unchanged) ... */
         #code-edit-modal .modal-content { max-width: 650px; }
        #edit-snippet-textarea { font-family: Consolas, Monaco, monospace; min-height: 150px; max-height: 40vh; flex-grow: 1; flex-shrink: 1; overflow-y: auto; margin-bottom: 5px; background-color: white; }
        .modal-content .line-inputs { display: flex; gap: 15px; align-items: center; margin-bottom: 10px; flex-shrink: 0; flex-wrap: wrap; }
        .modal-content .line-inputs div { flex-grow: 1; min-width: 80px; }
        .modal-content .line-inputs input[type="number"] { width: 100%; padding: 8px; }
        #edit-snippet-counter { font-size: 0.9em; color: var(--ink-light); text-align: right; margin-bottom: 15px; flex-shrink: 0; flex-basis: 100%; }
        #edit-snippet-line-count { font-weight: bold; color: var(--ink); }
        .edit-context-note { font-style: italic; color: var(--ink-light); font-size: 0.85em; margin-bottom: 15px; flex-shrink: 0; border-top: 1px dashed var(--ink-light); padding-top: 10px; margin-top: 5px; }
        .edit-instructions-area { flex-shrink: 0; margin-bottom: 15px; }
        .edit-instructions-controls { display: flex; gap: 8px; align-items: center; margin-top: 5px; }
        #edit-instructions { width: 100%; min-height: 60px; max-height: 25vh; resize: vertical; background-color: white; }
        .modal-content .small-button { padding: 4px 8px; font-size: 0.8em; height: auto; background-color: var(--ink-light); color: var(--parchment); border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s ease; font-family: Georgia,serif; flex-shrink: 0; }
        .modal-content .small-button:hover { background-color: var(--ink); }
        #edit-response-count { width: 40px; padding: 6px; font-size: 0.9rem; height: auto; border: 1px solid var(--ink-light); margin-left: auto; background-color: white; }
        #html-runner-modal .modal-content { max-width: 90vw; width: 85%; }
        .html-runner-container { display: flex; flex-grow: 1; gap: 15px; min-height: 0; margin-bottom: 15px; }
        .runner-editor, .runner-preview { flex: 1; display: flex; flex-direction: column; border: 1px solid var(--ink-light); border-radius: 5px; background-color: var(--parchment-dark); overflow: hidden; }
        .runner-header { margin: 0; padding: 8px 12px; background-color: var(--ink-light); color: var(--parchment); border-bottom: 1px solid var(--ink); font-size: 0.9em; font-weight: bold; flex-shrink: 0; text-align: center; }
        #html-runner-input { flex: 1; border: none; padding: 10px; font-family: Consolas, Monaco, monospace; font-size: 0.9em; resize: none; outline: none; background-color: white; color: var(--ink); }
        #html-runner-frame { flex: 1; border: none; width: 100%; height: 100%; background-color: white; }
        #html-runner-modal .modal-buttons button { padding: 8px 15px; }
        .message-content pre { border: 1px solid var(--code-border); background-color: var(--code-bg); position: relative; margin-top: 10px; margin-bottom: 5px; }
        .message-content pre code.hljs { display: block; overflow-x: auto; padding: 1em; background: transparent; color: var(--ink); border-radius: 5px; }
        .hljs-comment, .hljs-quote { color: #7a7061; font-style: italic; }
        .hljs-keyword, .hljs-selector-tag, .hljs-subst { color: var(--crimson); font-weight: bold; }
        .hljs-number, .hljs-literal, .hljs-variable, .hljs-template-variable, .hljs-tag .hljs-attr { color: var(--sapphire); }
        .hljs-string, .hljs-doctag { color: #4b8350; }
        .hljs-title, .hljs-section, .hljs-selector-id { color: var(--gold); font-weight: bold; }
        .message-content code:not(.hljs) { background-color: var(--code-bg); border: 1px solid var(--code-border); padding: 0.2em 0.4em; border-radius: 3px; font-size: 85%; font-family: Consolas, Monaco, monospace; }
        .cat-placeholder { display: none; font-size: 1.2em; cursor: default; user-select: none; padding: 2px 5px; background-color: var(--parchment-dark); border-radius: 3px; border: 1px solid var(--ink-light); margin-right: 5px; margin-bottom: 3px; }
        .message-actions { margin-top: 8px; text-align: left; display: flex; gap: 5px; flex-wrap: wrap; }
        .action-button { background-color: var(--ink-light); color: var(--parchment); border: none; padding: 4px 8px; font-size: 0.8em; border-radius: 4px; cursor: pointer; opacity: 0.9; transition: opacity 0.2s ease, background-color 0.2s ease; font-family: Georgia,serif; }
        .action-button:hover { opacity: 1; background-color: var(--ink); }
        .copy-code-button.copied { background-color: #3a9a41; color: white; }
        .download-code-button { background-color: #17a2b8; }
        .download-code-button:hover { background-color: #138496; }
        .run-html-button { background-color: var(--emerald); }
        .run-html-button:hover { background-color: darkgreen; }
        .tome.code-hidden .message pre { display: none; }
        .tome.code-hidden .message .cat-placeholder { display: inline-block; }
        .download-code-button { display: none; }
        .tome.download-code-active .download-code-button { display: inline-block; }
        .run-html-button { display: none; }
        .tome.run-html-active .run-html-button { display: inline-block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @media (max-width: 768px) { /* ... (responsive styles mostly unchanged, check stacking for new provider select) ... */
             body { font-size: 1rem; }
            .pages { padding: 15px; }
            .message { max-width: 95%; }
            .message-content { padding: 10px 15px; }
            .writing-area { padding: 10px; flex-direction: column; align-items: stretch; }
            .message-input { flex-basis: 100%; margin-right: 0; }
            .writing-controls { width: 100%; justify-content: space-between; margin-left: 0; margin-top: 8px; flex-wrap: wrap; }
            .footer-button { font-size: 0.8em; padding: 6px 8px; height: 40px; margin-bottom: 5px; }
            .response-count-input { height: 40px; margin-bottom: 5px; }
            .send-button { height: 45px; padding: 0 15px; font-size: 1rem; flex-grow: 1; margin-top: 5px;}
            .avatar { width: 40px; height: 40px; }
            .modal-content { padding: 15px; width: 95%; }
            .modal-content .form-group { flex-direction: column; align-items: flex-start; }
            .modal-content .form-group > div { width: auto; margin-bottom: 5px; }
            /* Stack provider/model selects */
            .provider-selector { flex-direction: column; align-items: stretch; gap: 10px; }
            .api-key-manager { gap: 5px; }
            .api-key-manager button { font-size: 0.85em; padding: 6px 10px; height: 40px;} /* Adjust button height */
            .api-key-manager input[type="password"] { height: 40px; } /* Match height */
            #clear-keys-button { margin-left: 0; width: 100%; margin-top: 5px; }
            .modal-content .line-inputs { flex-direction: column; align-items: stretch; gap: 10px; }
            .modal-content .line-inputs input[type="number"] { width: 100%; }
            .edit-instructions-controls { flex-wrap: wrap; }
            #edit-response-count { margin-left: 0; margin-top: 5px;}
            .html-runner-container { flex-direction: column; }
            .runner-editor, .runner-preview { min-height: 35vh; }
            #html-runner-modal .modal-content { max-width: 95vw; }
         }
        .visually-hidden { position: absolute !important; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px); white-space: nowrap; }
    </style>
</head>
<body>
    <!-- Arcane Tome Structure -->
    <div class="tome" id="chat-container">
        <div class="pages" id="pages"></div>
        <div class="writing-area">
            <textarea class="message-input" id="message-input" placeholder="Inscribe thy query..." rows="1"></textarea>
            <div class="writing-controls">
                 <button id="settings-button" class="footer-button" title="Settings"> <i class="fas fa-cog"></i> </button>
                 <button id="upload-file-button" class="footer-button" title="Attach Parchment (No logic yet)"> <i class="fas fa-paperclip"></i> </button>
                 <button id="add-iterator-button" class="footer-button" title="Insert {i}">Add {i}</button>
                 <button id="clear-chat-button" class="footer-button" title="Clear Scroll">Clear</button>
                 <button id="edit-code-button" class="footer-button" title="Edit Snippet">Edit</button>
                 <input type="number" class="response-count-input" id="main-response-count" value="1" min="0" max="5" title="Responses (0 to send no query)">
                 <button class="send-button" id="send-button" title="Send Query"> <span>Send</span> <span>✒</span> </button>
            </div>
        </div>
    </div>

     <!-- Settings Modal -->
    <div class="modal-overlay" id="system-prompt-modal">
         <div class="modal-content">
             <h3>Tome Settings</h3>

             <!-- Provider & Model Selection -->
             <div class="provider-selector form-group">
                 <div>
                     <label for="provider-select">Spirit Provider:</label>
                     <select id="provider-select"></select>
                 </div>
                  <div>
                     <label for="model-select">Spirit Model:</label>
                     <select id="model-select"></select>
                 </div>
             </div>

             <!-- API Key Management (Provider Specific) -->
              <div class="form-group">
                 <label for="api-key-input">Add Spirit Essence (API Key) for <span id="selected-provider-label">Provider</span>:</label>
                 <div class="api-key-manager">
                      <input type="password" id="api-key-input" placeholder="Paste new key...">
                      <button id="add-key-button" title="Add this key to the list for the selected provider">Add Key</button>
                      <button id="clear-keys-button" title="Remove all stored keys for the selected provider">Clear Keys for Provider</button>
                 </div>
                 <span id="api-key-status" class="api-key-status">Keys Loaded: 0</span>
             </div>

             <!-- System Prompt -->
             <div class="form-group">
                 <label for="system-prompt-input">Spirit's Nature (System Prompt):</label>
                 <textarea id="system-prompt-input" placeholder="Define the spirit's core nature..."></textarea>
             </div>

             <!-- Checkboxes -->
              <div class="form-group">
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="hide-code-checkbox"> <label for="hide-code-checkbox">Veil Glyphs</label> </div>
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="download-code-checkbox"> <label for="download-code-checkbox">Enable Download</label> </div>
                 <div style="display: flex; align-items: center;"> <input type="checkbox" id="enable-run-html-checkbox"> <label for="enable-run-html-checkbox">Enable Run HTML</label> </div>
             </div>

             <div class="modal-buttons">
                <button id="cancel-settings" class="cancel-button">Cancel</button>
                <button id="save-settings-button">Seal Settings</button>
             </div>
         </div>
    </div>

    <!-- Code Edit Modal -->
    <div class="modal-overlay" id="code-edit-modal"> /* ... (Modal content unchanged) ... */
         <div class="modal-content">
            <h3>Transcribe & Alter Glyphs</h3>
            <p style="font-size: 0.9em; color: var(--ink-light); margin-bottom: 10px; flex-shrink: 0;">Inscribe the glyphs below. Select lines for alteration.</p>
            <textarea id="edit-snippet-textarea" placeholder="Place glyphs here..."></textarea>
            <p class="edit-context-note"> Only the selected lines are sent. Context should be included in previous messages. </p>
            <div class="line-inputs">
                 <div> <label for="edit-start-line">Start Line:</label> <input type="number" id="edit-start-line" min="1" value="1"> </div>
                 <div> <label for="edit-end-line">End Line:</label> <input type="number" id="edit-end-line" min="1" value="1"> </div>
                 <div id="edit-snippet-counter" style="margin-left: auto;"> Lines: <span id="edit-snippet-line-count">0</span> </div>
            </div>
            <div class="edit-instructions-area">
                <label for="edit-instructions">Instructions for Spirit (applies to selected lines):</label>
                <textarea id="edit-instructions" rows="3" placeholder="e.g., Reforge these lines, mend the flaw..."></textarea>
                <div class="edit-instructions-controls">
                    <button id="edit-add-iterator-button" class="small-button" title="Insert {i}">Add {i}</button>
                    <label for="edit-response-count" style="margin-left: auto; flex-basis: auto; margin-bottom: 0; font-weight: normal; color: var(--ink-light); font-size: 0.9em;">Variations:</label>
                    <input type="number" class="response-count-input" id="edit-response-count" value="1" min="1" max="5" title="Number of edit variations">
                </div>
            </div>
            <div class="modal-buttons">
                <button id="cancel-edit-request" class="cancel-button">Cancel</button>
                <button id="send-edit-request">Request Alteration</button>
            </div>
        </div>
     </div>

    <!-- HTML Runner Modal -->
    <div class="modal-overlay" id="html-runner-modal"> /* ... (Modal content unchanged) ... */
         <div class="modal-content">
            <h3>HTML Runner</h3>
            <div class="html-runner-container">
                 <div class="runner-editor"> <div class="runner-header">HTML Input</div> <textarea id="html-runner-input" placeholder="Paste HTML code here..."></textarea> </div>
                 <div class="runner-preview"> <div class="runner-header">Preview</div> <iframe id="html-runner-frame" title="HTML Output Preview" sandbox="allow-scripts allow-same-origin"></iframe> </div>
            </div>
             <div class="modal-buttons">
                 <button id="html-runner-render-button">Render</button>
                 <button id="html-runner-close-button" class="cancel-button">Close</button>
             </div>
        </div>
     </div>

    <!-- Hidden Helpers -->
    <textarea class="visually-hidden" id="copy-helper" aria-hidden="true"></textarea>
    <input type="file" id="file-upload-input" accept="*/*" style="display:none;">
    <input type="file" class="pfp-upload" accept="image/*" style="display:none;">


    <script>
        // --- Global State & Constants ---
        let conversationHistory = [];
        let userPfp = localStorage.getItem('userPfp') || 'https://ui-avatars.com/api/?name=U&background=1e3a8a&color=fff&font-size=0.6&bold=true';
        let botPfp = localStorage.getItem('botPfp') || 'https://ui-avatars.com/api/?name=S&background=6b21a8&color=fff&font-size=0.6&bold=true';
        let currentPfpElementToUpdate = null;
        let turnCounter = 0;
        const iterationPlaceholder = '{i}';
        const DEFAULT_SYSTEM_PROMPT = 'You are a mystical spirit from another realm, bound within this ancient tome. Speak in an ancient, poetic manner full of mystery and wonder. Keep responses concise where possible.';
        // Removed API_URL constant, will use provider config

        // --- Provider/Key State ---
        let selectedProvider = localStorage.getItem('selectedProvider') || Object.keys(PROVIDERS)[0]; // Default to first provider
        let selectedModel = localStorage.getItem('selectedModel') || ''; // Will be set based on provider
        let apiKeys = {}; // Object: { providerName: ['key1', 'key2'], ... }
        let currentApiKeyIndex = {}; // Object: { providerName: index, ... }

        // --- Other State ---
        let hideCodeBlocks = localStorage.getItem('hideCodeBlocks') === 'true';
        let downloadCodeMode = localStorage.getItem('downloadCodeMode') === 'true';
        let enableRunHtmlMode = localStorage.getItem('enableRunHtmlMode') === 'true';
        let isWaitingForResponse = false;

        // --- DOM Elements ---
        const chatContainerElement = document.getElementById('chat-container');
        const pages = document.getElementById('pages');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const mainResponseCountInput = document.getElementById('main-response-count');
        const pfpUploadInput = document.querySelector('.pfp-upload');
        // Settings Modal
        const settingsButton = document.getElementById('settings-button');
        const systemPromptModal = document.getElementById('system-prompt-modal');
        const providerSelect = document.getElementById('provider-select'); // New
        const modelSelect = document.getElementById('model-select'); // New
        const selectedProviderLabel = document.getElementById('selected-provider-label'); // New
        const systemPromptInput = document.getElementById('system-prompt-input');
        const apiKeyInput = document.getElementById('api-key-input');
        const addKeyButton = document.getElementById('add-key-button');
        const clearKeysButton = document.getElementById('clear-keys-button');
        const apiKeyStatus = document.getElementById('api-key-status');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const hideCodeCheckbox = document.getElementById('hide-code-checkbox');
        const downloadCodeCheckbox = document.getElementById('download-code-checkbox');
        const enableRunHtmlCheckbox = document.getElementById('enable-run-html-checkbox');
        const cancelSettingsButton = document.getElementById('cancel-settings');
        // Code Edit Modal... (unchanged refs)
        const editCodeButton = document.getElementById('edit-code-button');
        const codeEditModal = document.getElementById('code-edit-modal');
        const editSnippetTextarea = document.getElementById('edit-snippet-textarea');
        const editStartLineInput = document.getElementById('edit-start-line');
        const editEndLineInput = document.getElementById('edit-end-line');
        const editSnippetLineCount = document.getElementById('edit-snippet-line-count');
        const editInstructionsInput = document.getElementById('edit-instructions');
        const editAddIteratorButton = document.getElementById('edit-add-iterator-button');
        const editResponseCountInput = document.getElementById('edit-response-count');
        const sendEditRequestButton = document.getElementById('send-edit-request');
        const cancelEditRequestButton = document.getElementById('cancel-edit-request');
        // HTML Runner Modal... (unchanged refs)
        const htmlRunnerModal = document.getElementById('html-runner-modal');
        const htmlRunnerInput = document.getElementById('html-runner-input');
        const htmlRunnerFrame = document.getElementById('html-runner-frame');
        const htmlRunnerRenderButton = document.getElementById('html-runner-render-button');
        const htmlRunnerCloseButton = document.getElementById('html-runner-close-button');
        // Other Controls... (unchanged refs)
        const clearChatButton = document.getElementById('clear-chat-button');
        const addIteratorButton = document.getElementById('add-iterator-button');
        const uploadFileButton = document.getElementById('upload-file-button');
        const fileUploadInput = document.getElementById('file-upload-input');
        const copyHelper = document.getElementById('copy-helper');


        // --- Configure Markdown & Highlighting ---
        marked.setOptions({ highlight:function(c,l){const lang=hljs.getLanguage(l)?l:'plaintext';try{return hljs.highlight(c,{language:lang,ignoreIllegals:true}).value;}catch(e){return hljs.highlight(c,{language:'plaintext',ignoreIllegals:true}).value;}},langPrefix:'hljs language-',gfm:true,breaks:true });

        // --- PFP Handling ---
        pfpUploadInput.addEventListener('change', function(event) { /* ... (unchanged) ... */
             const f=event.target.files[0];if(!f||!currentPfpElementToUpdate)return;const r=new FileReader();r.onload=function(e){const u=e.target.result;currentPfpElementToUpdate.src=u;const t=currentPfpElementToUpdate.closest('.avatar').dataset.senderType; if(t==='user'){userPfp=u;localStorage.setItem('userPfp',u);document.querySelectorAll('.avatar.user-avatar img').forEach(i=>i.src=u);}else if(t==='spirit'){botPfp=u;localStorage.setItem('botPfp',u);document.querySelectorAll('.avatar.spirit-avatar img').forEach(i=>i.src=u);}currentPfpElementToUpdate=null;};r.readAsDataURL(f);
         });

        // --- Event Listeners ---
        sendButton.addEventListener('click', handleSendMessage);
        messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } });
        messageInput.addEventListener('input', autoGrowTextarea);
        // Settings Modal
        settingsButton.addEventListener('click', openSystemPromptModal);
        providerSelect.addEventListener('change', handleProviderChange); // New
        modelSelect.addEventListener('change', handleModelChange); // New
        addKeyButton.addEventListener('click', addApiKey);
        clearKeysButton.addEventListener('click', clearApiKeysForProvider); // Changed name
        saveSettingsButton.addEventListener('click', saveSettings);
        if (cancelSettingsButton) cancelSettingsButton.addEventListener('click', () => systemPromptModal.style.display = 'none');
        systemPromptModal.addEventListener('click', (e) => { if (e.target === systemPromptModal) { systemPromptModal.style.display = 'none'; } });
        hideCodeCheckbox.addEventListener('change', handleHideCodeToggle);
        downloadCodeCheckbox.addEventListener('change', handleDownloadCodeToggle);
        enableRunHtmlCheckbox.addEventListener('change', handleEnableRunHtmlToggle);
        // Code Edit Modal... (unchanged listeners)
         editCodeButton.addEventListener('click', openEditCodeModal);
        sendEditRequestButton.addEventListener('click', handleSendEditRequest);
        cancelEditRequestButton.addEventListener('click', () => codeEditModal.style.display = 'none');
        codeEditModal.addEventListener('click', (e) => { if (e.target === codeEditModal) { codeEditModal.style.display = 'none'; } });
        editSnippetTextarea.addEventListener('input', updateSnippetLineCount);
        editAddIteratorButton.addEventListener('click', () => insertIteratorPlaceholder(editInstructionsInput));
        // HTML Runner Modal... (unchanged listeners)
        htmlRunnerRenderButton.addEventListener('click', renderRunnerHTML);
        htmlRunnerCloseButton.addEventListener('click', () => htmlRunnerModal.style.display = 'none');
        htmlRunnerModal.addEventListener('click', (e) => { if (e.target === htmlRunnerModal) { htmlRunnerModal.style.display = 'none'; } });
        // Other... (unchanged listeners)
        clearChatButton.addEventListener('click', handleClearChat);
        addIteratorButton.addEventListener('click', () => insertIteratorPlaceholder(messageInput));
        uploadFileButton.addEventListener('click', () => fileUploadInput.click());


        // --- API Key Management Functions (Provider Specific) ---
        function updateApiKeyStatus(provider = selectedProvider) {
            const keysForProvider = apiKeys[provider] || [];
            const count = keysForProvider.length;
            apiKeyStatus.textContent = `Keys Loaded: ${count}`;
            // Update label in settings modal
             if(selectedProviderLabel) selectedProviderLabel.textContent = PROVIDERS[provider]?.name || provider;
             // Disable send button if selected provider has no keys
             sendButton.disabled = count === 0 || isWaitingForResponse;
        }

        function addApiKey() {
             const provider = selectedProvider; // Use currently selected provider
            const newKey = apiKeyInput.value.trim();
            if (!provider) { alert("Please select a provider first."); return; }

            if (newKey) {
                 // Initialize array for provider if it doesn't exist
                 if (!apiKeys[provider]) {
                      apiKeys[provider] = [];
                 }
                 // Add key if not already present for this provider
                if (!apiKeys[provider].includes(newKey)) {
                    apiKeys[provider].push(newKey);
                    apiKeyInput.value = ''; // Clear input
                    updateApiKeyStatus(provider);
                    console.log(`Added key for ${provider}. Total keys for provider: ${apiKeys[provider].length}`);
                    // Note: Save happens on "Seal Settings"
                } else {
                     alert(`This API key is already in the list for ${PROVIDERS[provider]?.name || provider}.`);
                }
            } else {
                 alert("Please paste an API key before adding.");
            }
        }

        function clearApiKeysForProvider() {
             const provider = selectedProvider;
            if (!provider) { alert("Please select a provider first."); return; }

            if (confirm(`Are you sure you want to remove ALL keys for ${PROVIDERS[provider]?.name || provider}?`)) {
                apiKeys[provider] = []; // Clear keys for this provider
                currentApiKeyIndex[provider] = 0; // Reset index for this provider
                updateApiKeyStatus(provider);
                console.log(`Cleared all API keys for ${provider}.`);
                // Note: Save happens on "Seal Settings"
            }
        }

        // Gets the next API key for a SPECIFIC provider and rotates its index
        function getNextApiKey(provider) {
             const keysForProvider = apiKeys[provider] || [];
            if (keysForProvider.length === 0) {
                console.error(`No API keys available for provider: ${provider}`);
                return null;
            }

            // Get or initialize index for this provider
            let index = currentApiKeyIndex[provider] || 0;
            if (index >= keysForProvider.length) {
                 index = 0; // Reset if index is out of bounds
            }

            const keyToUse = keysForProvider[index];

            // Increment and wrap index for the *next* call for this provider
            currentApiKeyIndex[provider] = (index + 1) % keysForProvider.length;

            // --- IMPORTANT: Persist provider-specific index change immediately ---
            try {
                 localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex));
            } catch (e) {
                 console.warn("Could not immediately save API key index object to localStorage:", e);
            }
            // --- End immediate persistence ---

            // console.log(`Using key index ${index} for ${provider}. Next index: ${currentApiKeyIndex[provider]}`); // Debug
            return keyToUse;
        }

        // Check if the CURRENTLY SELECTED provider has keys
        function hasSelectedProviderApiKeys() {
             const keysForCurrent = apiKeys[selectedProvider] || [];
             return keysForCurrent.length > 0;
        }


        // --- Core Functions (Modified for Provider/Model Selection & API Call) ---
        async function handleSendMessage() {
            // Check keys for SELECTED provider
            if (!hasSelectedProviderApiKeys()) {
                alert(`No Spirit Essence (API Key) loaded for ${PROVIDERS[selectedProvider]?.name || selectedProvider}. Please add one in Settings.`);
                return;
            }
            if (isWaitingForResponse) return;

            const userInput = messageInput.value.trim();
            const responseCount = parseInt(mainResponseCountInput.value, 10);
            if (userInput === '') return;
            const numResponses = isNaN(responseCount) || responseCount < 0 ? 0 : Math.min(responseCount, 5);
            const turnId = `turn-${turnCounter++}`;
            const containsPlaceholder = userInput.includes(iterationPlaceholder);

            isWaitingForResponse = true;
            sendButton.disabled = true; // Disable regardless of keys while processing
            messageInput.value = '';
            autoGrowTextarea();

            const userEntry = { role: 'user', content: userInput, turnId: turnId };
            conversationHistory.push(userEntry);
            displayMessage(userEntry, 'user');
            saveHistoryToLocalStorage();
            scrollToBottom();

            if (numResponses > 0) {
                showTypingIndicator();
                const baseHistory = prepareHistoryForApi(conversationHistory);
                const responses = [];
                let errorOccurred = false;

                // Get current provider/model selections ONCE before the loop
                 const provider = selectedProvider;
                 const model = selectedModel;
                 console.log(`Sending ${numResponses} requests to ${provider} (${model})`);

                for (let i = 0; i < numResponses; i++) {
                    const iteration = i + 1;
                    // Get the next rotating key for the SELECTED provider
                    const currentKey = getNextApiKey(provider);
                     // Provider config check (getApiResponse will also check)
                     const providerConfig = PROVIDERS[provider];
                     if (!providerConfig) {
                          console.error(`Config not found for provider: ${provider}`);
                          responses.push(`[Configuration Error: Provider '${provider}' not found]`);
                          errorOccurred = true;
                          break;
                     }
                     // Key check (also done by getApiResponse if required by format)
                    if (providerConfig.apiKeyLocation !== 'none' && providerConfig.format !== 'proxy_compatible' && !currentKey) {
                         console.error(`No API key available for provider ${provider} for request ${iteration}`);
                         responses.push(`[Configuration Error: No API Key for ${provider} for request ${iteration}]`);
                         errorOccurred = true;
                         break;
                    }

                    let currentHistory = [...baseHistory];
                    if (containsPlaceholder && numResponses > 1) {
                        const userMessageIndex = currentHistory.length - 1;
                        if (currentHistory[userMessageIndex]?.role === 'user') {
                            const substitutedContent = currentHistory[userMessageIndex].content.replace(
                                new RegExp(iterationPlaceholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g'),
                                iteration.toString()
                            );
                            currentHistory[userMessageIndex] = { ...currentHistory[userMessageIndex], content: substitutedContent };
                        }
                    }

                    try {
                        // --- Call the API provider function ---
                        const messageContent = await getApiResponse(
                            provider,
                            model,
                            currentHistory,
                            currentKey, // Pass the potentially null key (getApiResponse handles based on config)
                            { temperature: 0.7, top_p: 0.9 } // Pass options if needed
                        );
                        responses.push(messageContent || "[Silence]");
                        // --- End API provider call ---
                    } catch (e) {
                        console.error(`API Call Error (Provider: ${provider}, Model: ${model}, Key Index Approx: ${(currentApiKeyIndex[provider] + (apiKeys[provider]?.length || 1) - 1) % (apiKeys[provider]?.length || 1)}, Response ${iteration}):`, e);
                         // Use error message directly from getApiResponse if it's an Error object
                        responses.push(`[Spirit Disturbance: ${e instanceof Error ? e.message : String(e)}]`);
                        errorOccurred = true;
                    }
                }
                hideTypingIndicator();

                if (responses.length > 0) {
                    const botEntry = { role: 'assistant', variants: responses, selectedIndex: 0, turnId: turnId };
                    conversationHistory.push(botEntry);
                    saveHistoryToLocalStorage();
                    displayBotMessage(botEntry, 'spirit');
                    scrollToBottom();
                }
            } else {
                console.log("Query added to history, 0 responses requested.");
            }

            isWaitingForResponse = false;
             sendButton.disabled = !hasSelectedProviderApiKeys(); // Re-enable based on selected provider keys
            messageInput.focus();
        }

        async function handleSendEditRequest() {
            if (!hasSelectedProviderApiKeys()) { alert(`No API Key loaded for ${PROVIDERS[selectedProvider]?.name || selectedProvider}. Please add one in Settings.`); return; }
            if (isWaitingForResponse) return;

            const pastedCode = editSnippetTextarea.value;
            const startLine = parseInt(editStartLineInput.value, 10);
            const endLine = parseInt(editEndLineInput.value, 10);
            const instructions = editInstructionsInput.value.trim();
            const numVariations = parseInt(editResponseCountInput.value, 10);

            if (pastedCode.trim() === '') { alert("Please inscribe the glyphs (code snippet) to alter."); return; }
            if (!instructions) { alert("Instructions for the spirit are required."); return; }
            const pastedLines = pastedCode.split('\n');
            const totalLines = pastedLines.length;
            if (isNaN(startLine) || isNaN(endLine) || startLine < 1 || endLine < startLine || endLine > totalLines) { alert(`Invalid line selection...`); return; }
            const numResponses = isNaN(numVariations) || numVariations < 1 ? 1 : Math.min(numVariations, 5);
            const containsPlaceholder = instructions.includes(iterationPlaceholder);

            codeEditModal.style.display = 'none';
            isWaitingForResponse = true;
            const turnId = `turn-${turnCounter++}`;
            const userRequestSummary = `[Glyph Alteration Request]...`; // Keep summary concise
            const userEntry = { role: 'user', content: userRequestSummary, turnId: turnId };
            conversationHistory.push(userEntry);
            displayMessage(userEntry, 'user');
            saveHistoryToLocalStorage();
            scrollToBottom();
            showTypingIndicator();

            const startIndex = startLine - 1;
            const endIndex = endLine;
            const snippetToAlter = pastedLines.slice(startIndex, endIndex).join('\n');
            const historyUpToEdit = conversationHistory.slice(0, -1);
            const baseApiHistory = prepareHistoryForApi(historyUpToEdit);
            const editResponses = [];
            let errorOccurred = false;

             // Get current provider/model selections ONCE before the loop
             const provider = selectedProvider;
             const model = selectedModel;
             console.log(`Sending ${numResponses} EDIT requests to ${provider} (${model})`);

            for (let i = 0; i < numResponses; i++) {
                const iteration = i + 1;
                 // Get the next rotating key for the SELECTED provider
                 const currentKey = getNextApiKey(provider);
                 const providerConfig = PROVIDERS[provider]; // For checks
                  if (!providerConfig) { /* ... error handling ... */ responses.push(`[Config Error: Provider '${provider}' not found]`); errorOccurred = true; break; }
                 if (providerConfig.apiKeyLocation !== 'none' && providerConfig.format !== 'proxy_compatible' && !currentKey) { /* ... error handling ... */ responses.push(`[Config Error: No Key for ${provider}]`); errorOccurred = true; break; }


                let currentInstructions = instructions;
                if (containsPlaceholder && numResponses > 1) {
                    currentInstructions = instructions.replace( new RegExp(iterationPlaceholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g'), iteration.toString() );
                }
                // Simplified prompt for brevity in example
                const prompt = `Alter lines ${startLine}-${endLine} of the following snippet:\n\`\`\`\n${snippetToAlter}\n\`\`\`\nInstructions: ${currentInstructions}\nReturn ONLY the altered lines.`;
                let apiHistoryForThisCall = [...baseApiHistory, { role: 'user', content: prompt }];

                try {
                     // --- Call the API provider function ---
                     const rawResponse = await getApiResponse(
                          provider,
                          model,
                          apiHistoryForThisCall,
                          currentKey,
                          { temperature: 0.5, top_p: 0.9 } // Edit-specific options?
                     );
                    const editedLines = rawResponse.split('\n'); // Assume rawResponse is the code string
                    const reconstructedLines = [ ...pastedLines.slice(0, startIndex), ...editedLines, ...pastedLines.slice(endIndex) ];
                    editResponses.push(reconstructedLines.join('\n'));
                } catch (e) {
                    console.error(`Edit Request API Error (Provider: ${provider}, Model: ${model}, Key Index Approx: [...], Variation ${iteration}):`, e);
                    const errorMarker = `--- ERROR Altering Variation ${iteration} ---\n${e instanceof Error ? e.message : String(e)}\n--- ORIGINAL LINES ${startLine}-${endLine} ---`;
                    const reconstructedLines = [ ...pastedLines.slice(0, startIndex), errorMarker, ...pastedLines.slice(startIndex, endIndex), ...pastedLines.slice(endIndex) ];
                    editResponses.push(reconstructedLines.join('\n'));
                    errorOccurred = true;
                }
            }
            hideTypingIndicator();
            const botEntry = { role: 'assistant', variants: editResponses, selectedIndex: 0, turnId: turnId, isCodeEdit: true };
            conversationHistory.push(botEntry);
            saveHistoryToLocalStorage();
            displayBotMessage(botEntry, 'spirit');
            isWaitingForResponse = false;
            sendButton.disabled = !hasSelectedProviderApiKeys(); // Re-enable based on selected provider
            scrollToBottom();
        }

        // --- Provider/Model Selection ---
        function populateProviderSelect() {
            providerSelect.innerHTML = ''; // Clear existing options
            for (const providerKey in PROVIDERS) {
                const option = document.createElement('option');
                option.value = providerKey;
                option.textContent = PROVIDERS[providerKey].name || providerKey;
                providerSelect.appendChild(option);
            }
            // Set initial value from state or default
            providerSelect.value = selectedProvider;
            // Trigger population of models for the initial provider
            populateModelSelect(selectedProvider);
        }

        function populateModelSelect(providerKey) {
            modelSelect.innerHTML = ''; // Clear existing
            const providerConf = PROVIDERS[providerKey];
            if (!providerConf || !providerConf.availableModels || providerConf.availableModels.length === 0) {
                 const option = document.createElement('option');
                 option.value = '';
                 option.textContent = 'No models available';
                 option.disabled = true;
                 modelSelect.appendChild(option);
                 selectedModel = ''; // Reset selected model
                 return;
            }

            providerConf.availableModels.forEach(modelKey => {
                const option = document.createElement('option');
                option.value = modelKey;
                option.textContent = modelKey;
                modelSelect.appendChild(option);
            });

             // Try to set the model from saved state, or use provider default, or first available
             const savedModel = localStorage.getItem('selectedModel');
             if (savedModel && providerConf.availableModels.includes(savedModel)) {
                  modelSelect.value = savedModel;
                  selectedModel = savedModel;
             } else if (providerConf.defaultModel && providerConf.availableModels.includes(providerConf.defaultModel)) {
                  modelSelect.value = providerConf.defaultModel;
                  selectedModel = providerConf.defaultModel;
             } else {
                  // Fallback to the first available model
                  modelSelect.selectedIndex = 0;
                  selectedModel = providerConf.availableModels[0];
             }
             // Save the potentially updated model selection immediately
             localStorage.setItem('selectedModel', selectedModel);
        }

        function handleProviderChange() {
            selectedProvider = providerSelect.value;
            console.log("Provider changed to:", selectedProvider);
            localStorage.setItem('selectedProvider', selectedProvider); // Save selection
            populateModelSelect(selectedProvider); // Update model list & selection
            updateApiKeyStatus(selectedProvider); // Update key count display
            // Ensure send button state reflects key availability for the new provider
            sendButton.disabled = !hasSelectedProviderApiKeys() || isWaitingForResponse;
        }

         function handleModelChange() {
             selectedModel = modelSelect.value;
             console.log("Model changed to:", selectedModel);
             localStorage.setItem('selectedModel', selectedModel); // Save selection
         }

        // --- Settings Modal & Other Handlers ---
        function openSystemPromptModal() {
            systemPromptInput.value=conversationHistory[0]?.content||DEFAULT_SYSTEM_PROMPT;
            populateProviderSelect(); // Populate providers and set current selection
            // updateApiKeyStatus will be called by populateModelSelect indirectly via handleProviderChange logic
            apiKeyInput.value = '';
            hideCodeCheckbox.checked=hideCodeBlocks;
            downloadCodeCheckbox.checked=downloadCodeMode;
            enableRunHtmlCheckbox.checked=enableRunHtmlMode;
            systemPromptModal.style.display='flex';
         }

        function saveSettings() {
            // Save System Prompt
            const sp = systemPromptInput.value.trim() || DEFAULT_SYSTEM_PROMPT;
            if(conversationHistory.length === 0 || conversationHistory[0]?.role !== 'system'){ conversationHistory.unshift({role:'system', content:sp}); }
            else { conversationHistory[0].content = sp; }
            localStorage.setItem('systemPrompt', sp);

            // Save Provider & Model Selections (already saved on change, but good to be explicit)
             localStorage.setItem('selectedProvider', selectedProvider);
             localStorage.setItem('selectedModel', selectedModel);

            // Save API Keys Object & Index Object
            try {
                localStorage.setItem('apiKeys', JSON.stringify(apiKeys));
                localStorage.setItem('currentApiKeyIndex', JSON.stringify(currentApiKeyIndex));
                console.log(`Settings saved. ${apiKeys[selectedProvider]?.length || 0} keys for ${selectedProvider}. Next index obj:`, currentApiKeyIndex);
            } catch (e) {
                 console.error("Failed to save API keys/indices to localStorage:", e);
                 alert("Error saving API keys/indices.");
            }

            // Persist full conversation history
            saveHistoryToLocalStorage();

            // Update send button state based on saved keys for selected provider
            sendButton.disabled = !hasSelectedProviderApiKeys();

            systemPromptModal.style.display = 'none';
        }

        // ... (handleHideCodeToggle, handleDownloadCodeToggle, handleEnableRunHtmlToggle, handleClearChat - unchanged) ...
        function handleHideCodeToggle() { hideCodeBlocks=hideCodeCheckbox.checked;localStorage.setItem('hideCodeBlocks',hideCodeBlocks);chatContainerElement.classList.toggle('code-hidden',hideCodeBlocks); }
        function handleDownloadCodeToggle() { downloadCodeMode=downloadCodeCheckbox.checked;localStorage.setItem('downloadCodeMode',downloadCodeMode);chatContainerElement.classList.toggle('download-code-active',downloadCodeMode); }
        function handleEnableRunHtmlToggle() { enableRunHtmlMode=enableRunHtmlCheckbox.checked; localStorage.setItem('enableRunHtmlMode',enableRunHtmlMode); chatContainerElement.classList.toggle('run-html-active',enableRunHtmlMode); }
        function handleClearChat() { if(confirm("Disperse echoes?")){const sp=conversationHistory[0]?.content||localStorage.getItem('systemPrompt')||DEFAULT_SYSTEM_PROMPT;conversationHistory=[{role:'system',content:sp}];turnCounter=1;saveHistoryToLocalStorage();rebuildChatFromHistory();} }

        function insertIteratorPlaceholder(targetInput) { /* ... (unchanged) ... */
             if (!targetInput) return; const start = targetInput.selectionStart; const end = targetInput.selectionEnd; const value = targetInput.value; const newValue = value.substring(0, start) + iterationPlaceholder + value.substring(end); targetInput.value = newValue; const newPos = start + iterationPlaceholder.length; targetInput.selectionStart = newPos; targetInput.selectionEnd = newPos; targetInput.focus(); targetInput.dispatchEvent(new Event('input', { bubbles: true }));
        }
        function autoGrowTextarea() { /* ... (unchanged) ... */
             const i=messageInput;const mH=i.style.maxHeight||'150px';i.style.maxHeight='none';i.style.height='auto';const sH=i.scrollHeight;i.style.height=sH+'px';i.style.maxHeight=mH;i.style.overflowY=parseFloat(i.style.height)>parseFloat(mH)?'auto':'hidden';
        }
        function renderRunnerHTML() { /* ... (unchanged) ... */
            const htmlCode = htmlRunnerInput.value; if (/<script.*?>.*?window\.location.*?<\/script>/i.test(htmlCode) || /<script.*?>.*?document\.cookie.*?<\/script>/i.test(htmlCode)) { console.warn("Potentially harmful script detected..."); const iframeDoc = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow.document; iframeDoc.open(); iframeDoc.write('<html>...Blocked...</html>'); iframeDoc.close(); return; } const iframeDoc = htmlRunnerFrame.contentDocument || htmlRunnerFrame.contentWindow.document; iframeDoc.open(); iframeDoc.write(htmlCode); iframeDoc.close();
         }
        function openHtmlRunner(initialCode) { /* ... (unchanged) ... */
            htmlRunnerInput.value = initialCode || ''; renderRunnerHTML(); htmlRunnerModal.style.display = 'flex';
        }
        function createPfpElement(sender, pfpUrl) { /* ... (unchanged) ... */
            const d=document.createElement('div');d.className=`avatar ${sender}-avatar`;d.dataset.senderType=sender;const i=document.createElement('img');i.src=pfpUrl;i.alt=`${sender} avatar`;d.addEventListener('click',()=>{currentPfpElementToUpdate=i;pfpUploadInput.click();});d.appendChild(i);return d;
         }
        function displayBotMessage(entry, sender='spirit') { /* ... (unchanged) ... */
            if(entry.variants?.length>1)displayMultipleMessages(entry,sender);else if(entry.variants?.length>=1)displayMessage(entry,sender);else console.warn("Bad bot struct:",entry);
         }
        function displayMessage(entry, sender) { /* ... (unchanged) ... */
             const c = sender === 'user' ? entry.content : (entry.variants?.[entry.selectedIndex ?? 0] || '[Silence]'); const msgDiv = document.createElement('div'); msgDiv.className = `message message-${sender}`; if (entry.turnId) msgDiv.dataset.turnId = entry.turnId; const p = sender === 'user' ? userPfp : botPfp; const avatarEl = createPfpElement(sender, p); const wrapper = document.createElement('div'); wrapper.classList.add('message-content-wrapper'); const contentDiv = document.createElement('div'); contentDiv.className = 'message-content'; if (sender === 'spirit') { try { contentDiv.innerHTML = marked.parse(c); } catch (e) { contentDiv.textContent = c; } } else { contentDiv.textContent = c; contentDiv.style.whiteSpace = 'pre-wrap'; } wrapper.appendChild(contentDiv); if (sender === 'spirit') { addCodeActionButtons(contentDiv, wrapper, entry.turnId, entry.selectedIndex ?? 0); } if (sender === 'user') { msgDiv.appendChild(wrapper); msgDiv.appendChild(avatarEl); } else { msgDiv.appendChild(avatarEl); msgDiv.appendChild(wrapper); } pages.appendChild(msgDiv); return msgDiv;
        }
        function displayMultipleMessages(entry, sender = 'spirit') { /* ... (unchanged) ... */
             const tid = entry.turnId; const vars = entry.variants; let idx = entry.selectedIndex; const msgDiv = document.createElement('div'); msgDiv.className = `message message-${sender}`; if (tid) msgDiv.dataset.turnId = tid; const p = sender === 'user' ? userPfp : botPfp; const avatarEl = createPfpElement(sender, p); const wrapper = document.createElement('div'); wrapper.classList.add('message-content-wrapper'); const contentDiv = document.createElement('div'); contentDiv.className = 'message-content'; const nav = document.createElement('div'); nav.classList.add('response-navigation'); const prev = document.createElement('button'); prev.textContent = '<'; const span = document.createElement('span'); const next = document.createElement('button'); next.textContent = '>'; nav.appendChild(prev); nav.appendChild(span); nav.appendChild(next); wrapper.appendChild(contentDiv); let acts = document.createElement('div'); acts.classList.add('message-actions'); wrapper.appendChild(acts); wrapper.appendChild(nav); function update(currentIndex) { try { contentDiv.innerHTML = marked.parse(vars[currentIndex]); } catch (e) { contentDiv.textContent = vars[currentIndex]; } addCodeActionButtons(contentDiv, wrapper, tid, currentIndex); span.textContent = `${currentIndex + 1} / ${vars.length}`; prev.disabled = currentIndex === 0; next.disabled = currentIndex === vars.length - 1; contentDiv.style.animation = 'none'; void contentDiv.offsetWidth; contentDiv.style.animation = 'fadeIn 0.3s ease-in-out'; } prev.addEventListener('click', () => { if (idx > 0) { idx--; update(idx); updateHistorySelection(tid, idx); } }); next.addEventListener('click', () => { if (idx < vars.length - 1) { idx++; update(idx); updateHistorySelection(tid, idx); } }); if (sender === 'user') { msgDiv.appendChild(wrapper); msgDiv.appendChild(avatarEl); } else { msgDiv.appendChild(avatarEl); msgDiv.appendChild(wrapper); } pages.appendChild(msgDiv); update(idx); return msgDiv;
        }
        function addCodeActionButtons(contentDiv, wrapper, turnId, variantIndex) { /* ... (unchanged) ... */
             let acts = wrapper.querySelector('.message-actions'); if (!acts) { acts = document.createElement('div'); acts.classList.add('message-actions'); const nav = wrapper.querySelector('.response-navigation'); if (nav) { wrapper.insertBefore(acts, nav); } else { wrapper.appendChild(acts); } } acts.innerHTML = ''; contentDiv.querySelectorAll('.cat-placeholder').forEach(c => c.remove()); const codeBlocks = contentDiv.querySelectorAll('pre'); if (codeBlocks.length > 0) { codeBlocks.forEach((pre, preIdx) => { const uniquePreId = `pre-${turnId || 'gen'}-${variantIndex}-${preIdx}`; pre.id = uniquePreId; const cat = document.createElement('span'); cat.classList.add('cat-placeholder'); cat.textContent = '🐱'; cat.dataset.preId = uniquePreId; pre.parentNode.insertBefore(cat, pre); const codeElement = pre.querySelector('code'); const codeText = codeElement ? codeElement.textContent : ''; const langMatch = codeElement?.className.match(/language-(\w+)/); const lang = langMatch ? langMatch[1] : 'txt'; const filename = `scroll_${Date.now()}_${variantIndex + 1}.${lang}`; const cpBtn = document.createElement('button'); cpBtn.textContent = 'Copy'; cpBtn.classList.add('copy-code-button', 'action-button'); cpBtn.onclick = () => copyCodeFromPre(uniquePreId, cpBtn); acts.appendChild(cpBtn); const dlBtn = document.createElement('button'); dlBtn.textContent = 'Download'; dlBtn.classList.add('download-code-button', 'action-button'); dlBtn.onclick = () => downloadCode(codeText, filename); acts.appendChild(dlBtn); if (lang === 'html') { const runBtn = document.createElement('button'); runBtn.textContent = 'Run HTML'; runBtn.classList.add('run-html-button', 'action-button'); runBtn.title = "Run this HTML snippet in a preview modal"; runBtn.onclick = () => openHtmlRunner(codeText); acts.appendChild(runBtn); } }); }
        }
        function copyCodeFromPre(preId, btn) { /* ... (unchanged) ... */
            const p=document.getElementById(preId);const c=p?p.querySelector('code'):null;if(!c){if(btn)btn.textContent='Err!';return;}const t=c.textContent||'';copyHelper.value=t;copyHelper.select();copyHelper.setSelectionRange(0,99999);let ok=false;try{ok=document.execCommand('copy');}catch(e){ok=false;}window.getSelection().removeAllRanges();if(btn){if(ok){btn.textContent='Copied!';btn.classList.add('copied');setTimeout(()=>{btn.textContent='Copy';btn.classList.remove('copied');},1500);}else{btn.textContent='Failed!';setTimeout(()=>{btn.textContent='Copy';},2000);}}
         }
        function downloadCode(codeText, filename) { /* ... (unchanged) ... */
             try{const b=new Blob([codeText],{type:'text/plain;charset=utf-8'});const u=URL.createObjectURL(b);const l=document.createElement('a');l.href=u;l.download=filename;document.body.appendChild(l);l.click();document.body.removeChild(l);URL.revokeObjectURL(u);}catch(e){console.error("DL Err:",e);alert("Download failed.");}
         }
        function showTypingIndicator() { /* ... (unchanged) ... */
             if(document.getElementById('typing-indicator'))return;const i=document.createElement('div');i.className='typing-indicator';i.id='typing-indicator';i.textContent='The spirit whispers...';pages.appendChild(i);scrollToBottom();
         }
        function hideTypingIndicator() { /* ... (unchanged) ... */
            const i=document.getElementById('typing-indicator');if(i)i.remove();
         }
        function scrollToBottom() { /* ... (unchanged) ... */
            setTimeout(()=>{pages.scrollTop=pages.scrollHeight;},50);
         }
        function prepareHistoryForApi(hist) { /* ... (unchanged) ... */
            return hist.map(m=>{if(m.role==='system')return{role:'system',content:m.content};if(m.role==='user')return{role:'user',content:m.content};if(m.role==='assistant'&&m.variants?.length>0)return{role:'assistant',content:m.variants[m.selectedIndex??0]};return null;}).filter(Boolean);
         }
        function updateHistorySelection(turnId, idx) { /* ... (unchanged) ... */
            const i=conversationHistory.findIndex(m=>m.turnId===turnId&&m.role==='assistant');if(i>-1){conversationHistory[i].selectedIndex=idx;saveHistoryToLocalStorage();}
         }
        function saveHistoryToLocalStorage() { /* ... (unchanged) ... */
             try{localStorage.setItem('conversationHistory',JSON.stringify(conversationHistory));}catch(e){console.error("Save Err:",e);}
         }

        // Modified loadHistoryFromLocalStorage for provider state
        function loadHistoryFromLocalStorage() {
             // Load Provider/Model Selections First
             const savedProvider = localStorage.getItem('selectedProvider');
             if (savedProvider && PROVIDERS[savedProvider]) {
                  selectedProvider = savedProvider;
             } else {
                  selectedProvider = Object.keys(PROVIDERS)[0]; // Fallback to first defined provider
                  localStorage.setItem('selectedProvider', selectedProvider); // Save default if missing
             }
             // selectedModel is loaded/set within populateModelSelect called during initialLoad

             // Load Keys & Index Object
             try {
                  const storedKeys = localStorage.getItem('apiKeys');
                  apiKeys = storedKeys ? JSON.parse(storedKeys) : {};
                  const storedIndex = localStorage.getItem('currentApiKeyIndex');
                  currentApiKeyIndex = storedIndex ? JSON.parse(storedIndex) : {};
                   // Basic validation (ensure loaded data is objects)
                  if (typeof apiKeys !== 'object' || apiKeys === null) apiKeys = {};
                  if (typeof currentApiKeyIndex !== 'object' || currentApiKeyIndex === null) currentApiKeyIndex = {};
                  console.log(`Loaded keys object:`, apiKeys);
                  console.log(`Loaded index object:`, currentApiKeyIndex);
             } catch (e) {
                  console.warn("Could not load API keys/index object from localStorage:", e);
                  apiKeys = {};
                  currentApiKeyIndex = {};
             }
             // Initial UI update for keys will happen in initialLoad after selects are populated

             // Load Conversation History (as before)
            try{
                const s=localStorage.getItem('conversationHistory'); if(!s)throw new Error('No hist');
                const p=JSON.parse(s); if(!Array.isArray(p)||p.length===0||p[0]?.role!=='system')throw new Error('Bad fmt');
                conversationHistory=p.map(m=>{if(m.role==='assistant'&&!Array.isArray(m.variants))return{...m,variants:[m.content||""],selectedIndex:0};if(m.role==='assistant'&&m.variants){if(!m.hasOwnProperty('selectedIndex')||m.selectedIndex<0||m.selectedIndex>=m.variants.length)m.selectedIndex=0;}return m;});
                console.log("Loaded conversation history");
                const l=conversationHistory.filter(m=>m.turnId).pop(); if(l?.turnId?.startsWith('turn-')){const n=parseInt(l.turnId.split('-')[1],10);turnCounter=isNaN(n)?1:n+1;}else{turnCounter=1;}
                return true;
            } catch(e) {
                console.warn("Load Err (Conversation History):",e); conversationHistory=[{role:'system',content:localStorage.getItem('systemPrompt')||DEFAULT_SYSTEM_PROMPT}]; turnCounter=1; return false;
            }
        }
        function rebuildChatFromHistory() { /* ... (unchanged) ... */
             pages.innerHTML='';for(let i=1;i<conversationHistory.length;i++){const e=conversationHistory[i];if(e.role==='user')displayMessage(e,'user');else if(e.role==='assistant')displayBotMessage(e,'spirit');}
         }
        function displayInitialGreeting() { /* ... (unchanged) ... */
            const g="The ancient tome awaits your words...";const e={role:'assistant',variants:[g],selectedIndex:0,turnId:'turn-0'};if(conversationHistory.length <= 1) { conversationHistory.push(e); displayBotMessage(e,'spirit'); saveHistoryToLocalStorage(); turnCounter = 1; }
        }

        // --- Initial Load ---
        function initialLoad() {
            // Load state from localStorage (keys, indices, provider, history)
            loadHistoryFromLocalStorage();

            // Populate Provider/Model dropdowns based on loaded state
            populateProviderSelect(); // This also populates models for the loaded provider

            // Load other settings
            hideCodeBlocks=localStorage.getItem('hideCodeBlocks')==='true';
            downloadCodeMode=localStorage.getItem('downloadCodeMode')==='true';
            enableRunHtmlMode=localStorage.getItem('enableRunHtmlMode')==='true';

            // Apply UI states
            chatContainerElement.classList.toggle('code-hidden',hideCodeBlocks);
            chatContainerElement.classList.toggle('download-code-active',downloadCodeMode);
            chatContainerElement.classList.toggle('run-html-active',enableRunHtmlMode);
            updateApiKeyStatus(selectedProvider); // Update key count display for loaded provider
            sendButton.disabled = !hasSelectedProviderApiKeys(); // Set initial button state

            // Rebuild chat and potentially greet
            rebuildChatFromHistory();
            if(conversationHistory.length <= 1){ displayInitialGreeting(); }
            scrollToBottom();
        }

        initialLoad(); // Start

    </script>
</body>
</html>
