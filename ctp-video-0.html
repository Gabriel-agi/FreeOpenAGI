<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 0: Interactive Lesson Player</title>
    <!-- Fonts & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&family=Roboto:wght@400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* --- Base Styles & Variables --- */
        :root {
            /* ... (Keep the color palette from the previous "beautiful" version) ... */
            --bg-base: #181a1f; --bg-panel: #21252b; --bg-editor: #282c34;
            --bg-console: #1f2328; --text-primary: #abb2bf; --text-secondary: #5c6370;
            --text-highlight: #e5c07b; --border-color: #3a3f4b; --cursor-color: #528bff;
            --scrollbar-thumb: #4b5263; --scrollbar-track: var(--bg-panel);
            --hl-keyword: #c678dd; --hl-string: #98c379; --hl-comment: var(--text-secondary);
            --hl-function: #61afef; --hl-paren: var(--text-primary); --hl-number: #d19a66;
            --hl-output: #a0e8ff; --hl-error: #e06c75;
            --sidebar-bg: var(--bg-base); --statusbar-bg: #1b1d23; --statusbar-text: var(--text-secondary);
            --titlebar-bg: var(--bg-base); --titlebar-text: var(--text-secondary);
            --control-bg: #21252b; --control-button-bg: #3a3f4b; --control-button-hover: #4b5263;
            --final-nav-bg: rgba(33, 37, 43, 0.95);

            --font-code: 'Fira Code', 'Courier New', Courier, monospace;
            --font-ui: 'Roboto', sans-serif;
            --transition-speed: 0.2s;
            --typing-cursor-height: 1.4em;
            --line-height-editor: 1.7;
        }

        /* --- Reset & Base --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; overflow: hidden; background-color: var(--bg-base); font-family: var(--font-ui); color: var(--text-primary); }

        /* --- IDE Layout --- */
        .ide-container { display: flex; flex-direction: column; width: 100vw; height: 100vh; background-color: var(--bg-base); }
        .title-bar { background-color: var(--titlebar-bg); padding: 8px 15px; color: var(--titlebar-text); font-size: 0.9em; text-align: center; border-bottom: 1px solid var(--border-color); flex-shrink: 0; position: relative; }
        .title-bar .file-name { font-weight: 500; color: var(--text-primary); }
        .title-bar-icons { position: absolute; left: 10px; top: 50%; transform: translateY(-50%); display: flex; gap: 8px; }
        .title-bar-icons i { font-size: 0.8em; color: #555; }
        .main-content { display: flex; flex-grow: 1; overflow: hidden; position: relative; } /* Added position relative for overlay */
        .sidebar-placeholder { width: 50px; background-color: var(--sidebar-bg); border-right: 1px solid var(--border-color); flex-shrink: 0; display: flex; flex-direction: column; align-items: center; padding-top: 20px; gap: 25px; }
        .sidebar-placeholder i { font-size: 1.4em; color: var(--text-secondary); opacity: 0.6; }
        .sidebar-placeholder i.active { color: var(--text-primary); opacity: 1; }
        .editor-console-split { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; }
        .editor-pane { flex-grow: 1; background-color: var(--bg-editor); display: flex; overflow: hidden; position: relative; min-height: 150px; }
        .line-numbers { font-family: var(--font-code); font-size: 1em; line-height: var(--line-height-editor); color: var(--text-secondary); text-align: right; padding: 15px 15px 15px 10px; user-select: none; background-color: var(--bg-editor); border-right: 1px solid var(--border-color); white-space: pre; overflow: hidden; flex-shrink: 0; }
        .code-area-wrapper { flex-grow: 1; overflow-y: auto; padding: 15px; position: relative; }
        .code-area { font-family: var(--font-code); font-size: 1em; line-height: var(--line-height-editor); color: var(--text-primary); white-space: pre; outline: none; min-height: 100%; position: relative; }
        .minimap-placeholder { position: absolute; top: 0; right: 0; bottom: 0; width: 80px; background-color: rgba(0, 0, 0, 0.1); border-left: 1px solid var(--border-color); flex-shrink: 0; overflow: hidden; opacity: 0.5; pointer-events: none; }
        .minimap-placeholder::before { content: ''; position: absolute; top: 10px; left: 10px; right: 10px; bottom: 10px; background: linear-gradient( rgba(255,255,255,0.08) 1px, transparent 1px ); background-size: 100% 4px; }
        .console-pane { height: 30%; max-height: 350px; min-height: 120px; background-color: var(--bg-console); border-top: 1px solid var(--border-color); color: var(--text-primary); font-family: var(--font-code); font-size: 0.95em; line-height: 1.6; padding: 10px 15px; overflow-y: auto; flex-shrink: 0; white-space: pre-wrap; word-wrap: break-word; }
        .console-pane .output-line { color: var(--hl-output); }
        .console-pane .error-line { color: var(--hl-error); font-weight: bold;}
        .console-pane .placeholder { color: var(--text-secondary); font-style: italic; }
        .console-pane .info-line { color: var(--text-secondary); font-style: italic;}
        .console-prompt { color: var(--text-secondary); margin-right: 8px; user-select: none;}
        .status-bar { background-color: var(--statusbar-bg); color: var(--statusbar-text); padding: 5px 15px; font-size: 0.85em; display: flex; justify-content: space-between; align-items: center; border-top: 1px solid var(--border-color); flex-shrink: 0; white-space: nowrap; }
        .status-bar-left, .status-bar-right { display: flex; gap: 15px; align-items: center; }
        .status-bar i { margin-right: 5px; font-size: 1.1em; vertical-align: middle;}
        .status-bar .git-branch i { color: #e8ae59; }
        .status-bar .language i { color: #61afef; }

        /* --- Cursor Styling --- */
        .code-area::after { content: ''; display: block; width: 2px; height: var(--typing-cursor-height); background-color: var(--cursor-color); position: absolute; top: 0; left: 0; opacity: 0; transition: opacity 0.1s ease-out, top 0.05s linear, left 0.05s linear; border-radius: 1px; box-shadow: 0 0 5px var(--cursor-color); }
        .code-area.typing::after { opacity: 1; animation: none; }
        .code-area.idle::after { opacity: 1; animation: blink 1.1s steps(1) infinite; }
        .code-area.no-cursor::after { opacity: 0; animation: none; }
        @keyframes blink { 50% { opacity: 0; } }

        /* --- Syntax Highlighting --- */
        .hl-keyword { color: var(--hl-keyword); font-weight: 500; } .hl-string { color: var(--hl-string); }
        .hl-comment { color: var(--hl-comment); font-style: italic; } .hl-function { color: var(--hl-function); }
        .hl-paren { color: var(--hl-paren); } .hl-number { color: var(--hl-number); }

        /* --- Player Controls --- */
        .player-controls {
            background-color: var(--control-bg);
            border-top: 1px solid var(--border-color);
            padding: 8px 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            flex-shrink: 0; /* Prevent shrinking */
            position: relative; /* For course menu button */
        }
        .player-controls button {
            background-color: var(--control-button-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 6px 12px;
            font-size: 1.2em; /* Larger icons */
            cursor: pointer;
            transition: background-color var(--transition-speed), color var(--transition-speed);
            line-height: 1; /* Prevent extra spacing */
        }
        .player-controls button:hover:not(:disabled) { background-color: var(--control-button-hover); }
        .player-controls button:disabled { opacity: 0.4; cursor: not-allowed; }
        .player-controls .play-btn, .player-controls .pause-btn { width: 45px; /* Ensure consistent width */ }
        /* Hide play when playing, hide pause when paused */
        .ide-container.is-playing .play-btn { display: none; }
        .ide-container:not(.is-playing) .pause-btn { display: none; }

        /* Small Course Menu Button */
        .course-menu-btn-container {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
        }
        .course-menu-btn {
            font-size: 0.8em !important; /* Smaller text */
            padding: 4px 8px !important; /* Smaller padding */
            background-color: var(--text-secondary) !important;
            color: var(--bg-base) !important;
            opacity: 0.7;
            transition: opacity var(--transition-speed);
        }
        .course-menu-btn:hover { opacity: 1; background-color: var(--text-primary) !important;}


        /* --- Final Navigation Overlay --- */
        .final-navigation-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: var(--final-nav-bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100; /* Above IDE content */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease-out, visibility 0.4s;
            backdrop-filter: blur(3px);
        }
        .final-navigation-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .final-navigation-overlay h3 {
            font-family: var(--font-title);
            font-size: 1.8em;
            color: var(--text-highlight);
            margin-bottom: 25px;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .final-navigation-overlay .button-group {
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            gap: 15px;
            align-items: center;
        }
        .final-navigation-overlay .button-group a {
            background-color: var(--hl-function); /* Blue */
            color: white;
            text-decoration: none;
            padding: 12px 25px;
            border-radius: 6px;
            font-weight: 500;
            min-width: 250px;
            text-align: center;
            transition: background-color var(--transition-speed), transform var(--transition-speed);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }
        .final-navigation-overlay .button-group a:hover {
             background-color: #7ac2fb; /* Lighter blue */
             transform: translateY(-2px);
         }
         .final-navigation-overlay .button-group a.secondary {
             background-color: var(--control-button-bg);
             color: var(--text-primary);
         }
         .final-navigation-overlay .button-group a.secondary:hover {
              background-color: var(--control-button-hover);
         }
         .final-navigation-overlay .button-group a i { margin-right: 8px; }

        /* --- Scrollbar Styling --- */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: var(--scrollbar-track); }
        ::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: #5a6375; }
        ::-webkit-scrollbar-corner { background: var(--scrollbar-track); }

    </style>
</head>
<body>

    <div class="ide-container" id="ide-container"> <!-- Added ID for state class -->
        <!-- Title Bar -->
        <div class="title-bar">
             <span class="file-name">module_0_review.py</span>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Sidebar Placeholder -->
            <div class="sidebar-placeholder">
                 <i class="fas fa-copy active"></i> <i class="fas fa-search"></i> <i class="fas fa-code-branch"></i>
                 <i class="fas fa-bug"></i> <i class="fas fa-puzzle-piece"></i>
            </div>

            <!-- Editor & Console -->
            <div class="editor-console-split">
                <!-- Editor Pane -->
                <div class="editor-pane">
                    <div class="line-numbers" id="line-numbers">1</div>
                     <div class="code-area-wrapper" id="code-area-wrapper">
                        <div class="code-area" id="code-area"></div>
                     </div>
                     <div class="minimap-placeholder"></div>
                </div>
                <!-- Console Pane -->
                <div class="console-pane" id="console-pane">
                    <span class="placeholder">Python Console Ready... [Click Play to Start]</span>
                </div>
            </div>

             <!-- Final Navigation (Initially Hidden) -->
             <div class="final-navigation-overlay" id="final-navigation">
                 <h3>Lesson Complete!</h3>
                 <div class="button-group">
                     <a href="ctp-knowledge-check-0.html"><i class="fas fa-question-circle"></i> Knowledge Check</a> <!-- UPDATE HREF -->
                     <a href="ctp-theory-0.html" class="secondary"><i class="fas fa-book-open"></i> Review Theory</a>
                     <a href="ctp-practice-0.html" class="secondary"><i class="fas fa-redo-alt"></i> Revisit Basic Practice</a>
                     <a href="ctp-advanced-0.html" class="secondary"><i class="fas fa-redo-alt"></i> Revisit Advanced Practice</a>
                     <a href="ctp.html" class="secondary"><i class="fas fa-list"></i> Course Menu</a> <!-- Course Menu -->
                 </div>
             </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar" id="status-bar">
             <div class="status-bar-left">
                 <span class="git-branch"><i class="fas fa-code-branch"></i> main</span>
             </div>
             <div class="status-bar-right">
                <span id="cursor-pos">Ln 1, Col 1</span>
                <span>Spaces: 4</span>
                <span>UTF-8</span>
                <span class="language"><i class="fab fa-python"></i> Python 3.1x.x</span>
             </div>
        </div>

         <!-- Player Controls -->
         <div class="player-controls">
             <button id="prev-step-btn" title="Previous Step"><i class="fas fa-backward-step"></i></button>
             <button id="play-btn" class="play-btn" title="Play"><i class="fas fa-play"></i></button>
             <button id="pause-btn" class="pause-btn" title="Pause"><i class="fas fa-pause"></i></button>
             <button id="next-step-btn" title="Next Step"><i class="fas fa-forward-step"></i></button>
             <!-- Small Course Menu Button (Visible when paused/ended) -->
             <div class="course-menu-btn-container" id="course-menu-btn-container" style="display: none;">
                 <a href="ctp.html" class="course-menu-btn"><i class="fas fa-list"></i> Menu</a>
             </div>
         </div>
    </div>

     <!-- Hidden Audio Elements -->
     <div style="display: none;">
        <audio id="audio-ctp-0-a1-eng" src="audio/ctp-0-a1-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a2-eng" src="audio/ctp-0-a2-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a3-eng" src="audio/ctp-0-a3-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a4-eng" src="audio/ctp-0-a4-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a5-eng" src="audio/ctp-0-a5-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a6-eng" src="audio/ctp-0-a6-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a7-eng" src="audio/ctp-0-a7-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a8-eng" src="audio/ctp-0-a8-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a9-eng" src="audio/ctp-0-a9-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a10-eng" src="audio/ctp-0-a10-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a11-eng" src="audio/ctp-0-a11-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a12-eng" src="audio/ctp-0-a12-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a13-eng" src="audio/ctp-0-a13-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a14-eng" src="audio/ctp-0-a14-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a15-eng" src="audio/ctp-0-a15-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a16-eng" src="audio/ctp-0-a16-eng.mp3" preload="auto"></audio>
     </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- Element References ---
        const ideContainer = document.getElementById('ide-container');
        const codeArea = document.getElementById('code-area');
        const consolePane = document.getElementById('console-pane');
        const lineNumbersEl = document.getElementById('line-numbers');
        const statusBar = document.getElementById('status-bar');
        const cursorPosEl = document.getElementById('cursor-pos');
        const codeAreaWrapper = document.getElementById('code-area-wrapper');
        const playBtn = document.getElementById('play-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const nextStepBtn = document.getElementById('next-step-btn');
        const prevStepBtn = document.getElementById('prev-step-btn');
        const finalNavOverlay = document.getElementById('final-navigation');
        const courseMenuBtnContainer = document.getElementById('course-menu-btn-container');


        // --- State Variables ---
        let currentStepIndex = 0;
        let isPlaying = false;
        let timeoutId = null; // Stores ID of the next scheduled step timer
        let currentAudioElement = null; // Stores the audio element currently playing
        let simulationStarted = false; // Has the user clicked play initially?
        let charWidthEstimate = 9;
        let lineHeightEstimate = 27; // Update based on CSS


        // --- Audio Setup ---
        const audioElements = {};
        document.querySelectorAll('audio[id^="audio-ctp-0-a"]').forEach(el => {
            audioElements[el.id] = el;
            el.onerror = () => console.error(`Error loading audio: ${el.src}`);
             // Add ended listener to automatically advance *if playing*
             el.addEventListener('ended', () => {
                 if (isPlaying && currentAudioElement === el) {
                     // console.log(`Audio ended naturally: ${el.id}, attempting next step.`);
                     // Don't auto-advance here, let the main timer handle it
                     // based on the full segment duration in lessonScript.
                     // This prevents issues if audio ends slightly before visuals.
                     currentAudioElement = null; // Clear current audio
                 }
             });
        });

        // --- Helper Functions ---

         function getTextWidth(text, font) { /* ... as before ... */
             const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
             const context = canvas.getContext("2d");
             context.font = font || getComputedStyle(codeArea).font;
             return context.measureText(text).width;
         }

        function updateStatusBarAndCursor(lineNum, colNum, contentForMeasure = null) {
            const lines = (contentForMeasure ?? codeArea.innerText).split('\n');
            const targetLine = Math.max(1, Math.min(lineNum ?? lines.length, lines.length));
            const lastLineText = lines[targetLine - 1] || '';
            const targetCol = Math.max(1, Math.min(colNum ?? lastLineText.length + 1, lastLineText.length + 1));

            cursorPosEl.textContent = `Ln ${targetLine}, Col ${targetCol}`;

            const cursorTop = (targetLine - 1) * lineHeightEstimate;
            // Recalculate left based on actual column position needed
            const textToMeasure = lastLineText.substring(0, targetCol - 1);
            const cursorLeft = getTextWidth(textToMeasure, getComputedStyle(codeArea).font);


             const cursorPseudoStyle = `
                 .code-area.idle::after,
                 .code-area.typing::after {
                     top: ${cursorTop}px;
                     left: ${cursorLeft}px;
                     height: ${getComputedStyle(codeArea).lineHeight}; /* Match line height dynamically */
                 }`;
             let styleSheet = document.getElementById('cursor-style');
             if (!styleSheet) {
                 styleSheet = document.createElement('style'); styleSheet.id = 'cursor-style';
                 document.head.appendChild(styleSheet);
             }
             styleSheet.textContent = cursorPseudoStyle;

             // --- Scrolling Logic ---
             const wrapperRect = codeAreaWrapper.getBoundingClientRect();
             const cursorAbsoluteTop = codeArea.offsetTop + cursorTop;
             const scrollTop = codeAreaWrapper.scrollTop;
             const scrollBottom = scrollTop + wrapperRect.height;
             const currentLineHeight = parseFloat(getComputedStyle(codeArea).lineHeight);

             if (cursorAbsoluteTop + currentLineHeight > scrollBottom) {
                 codeAreaWrapper.scrollTop = cursorAbsoluteTop + currentLineHeight - wrapperRect.height + 10;
             } else if (cursorAbsoluteTop < scrollTop) {
                 codeAreaWrapper.scrollTop = Math.max(0, cursorAbsoluteTop - 10);
             }
        }

        function updateLineNumbers(numLines) {
             const lines = numLines ?? codeArea.innerText.split('\n').length;
             const maxLines = Math.max(lines, 1);
             let numbersHTML = '';
             for (let i = 1; i <= maxLines; i++) { numbersHTML += i + '\n'; }
             lineNumbersEl.textContent = numbersHTML.trimEnd();
         }

        // Function to immediately set the visual state for a given step index
        function renderStepState(stepIndex) {
             if (stepIndex < 0 || stepIndex >= lessonScript.length) return;

            const step = lessonScript[stepIndex];
            const state = step.startState; // Use the precalculated start state

            if (state) {
                codeArea.innerHTML = state.editorHTML;
                consolePane.innerHTML = ''; // Start console fresh for the state
                state.consoleLines.forEach(lineInfo => {
                     const lineEl = document.createElement('div');
                      if (lineInfo.isError) { lineEl.className = 'error-line'; lineEl.textContent = `❌ ${lineInfo.text}`; }
                      else if (lineInfo.isInfo) { lineEl.className = 'info-line'; lineEl.textContent = `ℹ️ ${lineInfo.text}`; }
                      else {
                          lineEl.className = 'output-line';
                          const promptSpan = document.createElement('span'); promptSpan.className = 'console-prompt'; promptSpan.textContent = '>>>';
                          lineEl.appendChild(promptSpan); lineEl.appendChild(document.createTextNode(` ${lineInfo.text}`));
                      }
                      consolePane.appendChild(lineEl);
                 });
                consolePane.scrollTop = consolePane.scrollHeight;

                updateLineNumbers(state.numLines);
                 // Update status bar and cursor position to the END of the rendered state
                 const lines = state.editorHTML.replace(/<[^>]*>/g, '').split('\n'); // Crude text extraction
                 const lastLine = lines.length;
                 const lastCol = (lines[lastLine - 1] || '').length + 1;
                 updateStatusBarAndCursor(lastLine, lastCol, state.editorHTML.replace(/<[^>]*>/g, ''));
            } else {
                // Fallback if state isn't precalculated (e.g., for step 0)
                if (stepIndex === 0) {
                     clearEditor();
                     clearConsole();
                     consolePane.innerHTML = '<span class="placeholder">Python Console Ready... [Click Play to Start]</span>';
                } else {
                     console.warn(`No startState defined for step ${stepIndex}`);
                }
             }
             codeArea.classList.add('idle'); // Ensure cursor is visible when seeking
             codeArea.classList.remove('typing', 'no-cursor');
             updateButtonStates(); // Update prev/next button enabled state
         }


        // Typing simulation - Needs to update editor state correctly
        function simulateTyping(textToTypeHTML, typingSpeed) {
             return new Promise((resolve) => {
                 codeArea.classList.add('typing');
                 codeArea.classList.remove('idle', 'no-cursor');
                 let charIndex = 0;
                 let currentHTML = codeArea.innerHTML; // Start from current rendered HTML

                 function typeStep() {
                      const step = lessonScript[currentStepIndex]; // Get current step data
                      // Check if simulation was paused or changed step mid-typing
                      if (!isPlaying || currentStepIndex !== step.originalIndex) {
                         console.log("Typing interrupted (paused or seeked).");
                          resolve(false); // Indicate interruption
                          return;
                      }

                     if (charIndex >= textToTypeHTML.length) {
                         codeArea.classList.remove('typing');
                         codeArea.classList.add('idle');
                         updateLineNumbers();
                         updateStatusBarAndCursor(); // Final update for this typing sequence
                         resolve(true); // Indicate completion
                         return;
                     }
                     // ... (rest of the tag handling logic as before) ...
                     let nextChar = textToTypeHTML[charIndex];
                     let stepSize = 1;
                     if (nextChar === '<') {
                         const tagEndIndex = textToTypeHTML.indexOf('>', charIndex);
                         if (tagEndIndex !== -1) {
                             stepSize = tagEndIndex - charIndex + 1;
                             nextChar = textToTypeHTML.substring(charIndex, tagEndIndex + 1);
                         }
                     }
                     currentHTML += nextChar;
                     codeArea.innerHTML = currentHTML;
                     updateLineNumbers();
                     updateStatusBarAndCursor();
                     charIndex += stepSize;
                     timeoutId = setTimeout(typeStep, typingSpeed); // Use global timeoutId
                 }
                 typeStep();
             });
        }


        function showOutput(outputLines, isInfo = false, isError = false) {
             // This function should ADD lines to the console, not clear it,
             // if we want the console state to be cumulative for seeking.
             // OR, the lessonScript's consoleStateLines must be accurate.
             // Let's stick to renderStepState handling the clearing.
             return new Promise((resolve) => {
                outputLines.forEach(line => {
                     const lineEl = document.createElement('div');
                     // ... (styling logic as before) ...
                      if (isError) { lineEl.className = 'error-line'; lineEl.textContent = `❌ ${line}`; }
                      else if (isInfo) { lineEl.className = 'info-line'; lineEl.textContent = `ℹ️ ${line}`; }
                      else {
                          lineEl.className = 'output-line';
                          const promptSpan = document.createElement('span'); promptSpan.className = 'console-prompt'; promptSpan.textContent = '>>>';
                          lineEl.appendChild(promptSpan); lineEl.appendChild(document.createTextNode(` ${line}`));
                      }
                     consolePane.appendChild(lineEl);
                 });
                 consolePane.scrollTop = consolePane.scrollHeight;
                 resolve();
             });
        }

        function clearConsole() { /* ... as before ... */ }
        function clearEditor() { /* ... as before ... */ }

        async function playAudio(audioId) { /* ... as before ... */
            pauseCurrentAudio(); // Stop previous audio before starting new
            const audioElement = audioElements[audioId];
            if (!audioElement) { console.warn(`Audio ${audioId} not found.`); return null; }
            try {
                audioElement.currentTime = 0;
                await audioElement.play();
                console.log(`Playing: ${audioId}`);
                currentAudioElement = audioElement; // Track current audio
                return audioElement; // Return element if needed
            } catch (error) { console.error(`Error playing ${audioId}:`, error); currentAudioElement = null; return null;}
        }

         function pauseCurrentAudio() {
             if (currentAudioElement && !currentAudioElement.paused) {
                 currentAudioElement.pause();
                 console.log(`Paused audio: ${currentAudioElement.id}`);
             }
         }

         function resumeCurrentAudio() {
              if (currentAudioElement && currentAudioElement.paused) {
                  currentAudioElement.play().catch(e => console.error("Audio resume failed", e));
                  console.log(`Resumed audio: ${currentAudioElement.id}`);
              }
         }

        // --- Player Control Functions ---

        function playSimulation() {
            if (isPlaying || currentStepIndex >= lessonScript.length -1) return; // Already playing or finished

            if (!simulationStarted) { // First time playing after load
                 simulationStarted = true;
                 // Attempt to unlock audio context
                 const context = new (window.AudioContext || window.webkitAudioContext)();
                 if (context.state === 'suspended') { context.resume(); }
                 Object.values(audioElements).forEach(audio => { audio.load(); audio.play().then(() => audio.pause()).catch(() => {}); });
                 console.log("Audio context unlocked on first play.");
                 // Render step 0 state before starting execution
                 renderStepState(0);
                 consolePane.innerHTML = '<span class="placeholder">Lesson playing...</span>';
            }

            console.log(`Playing from step ${currentStepIndex}`);
            isPlaying = true;
            ideContainer.classList.add('is-playing');
            courseMenuBtnContainer.style.display = 'none'; // Hide menu button when playing
            resumeCurrentAudio(); // Resume audio if it was paused
            executeStep(currentStepIndex); // Start execution loop
        }

        function pauseSimulation() {
            if (!isPlaying) return;
            console.log(`Pausing at step ${currentStepIndex}`);
            isPlaying = false;
            clearTimeout(timeoutId); // Cancel the *next* scheduled step
            timeoutId = null;
            pauseCurrentAudio(); // Pause the currently playing audio
            ideContainer.classList.remove('is-playing');
            courseMenuBtnContainer.style.display = 'block'; // Show menu button when paused
            codeArea.classList.add('idle'); // Ensure cursor is visible and blinking
            codeArea.classList.remove('typing');
            updateStatusBarAndCursor(); // Update cursor position
        }

        function nextStep() {
            pauseSimulation(); // Stop current execution
            if (currentStepIndex < lessonScript.length - 1) { // Don't go past the end
                currentStepIndex++;
                console.log(`Seeking to next step: ${currentStepIndex}`);
                renderStepState(currentStepIndex); // Show state at the START of the new step
            }
            updateButtonStates(); // Update button disabled states
        }

        function prevStep() {
            pauseSimulation(); // Stop current execution
            if (currentStepIndex > 0) { // Don't go before the start
                currentStepIndex--;
                console.log(`Seeking to previous step: ${currentStepIndex}`);
                renderStepState(currentStepIndex); // Show state at the START of the new step
            }
             updateButtonStates(); // Update button disabled states
        }

         function updateButtonStates() {
             playBtn.disabled = isPlaying || currentStepIndex >= lessonScript.length -1;
             pauseBtn.disabled = !isPlaying;
             prevStepBtn.disabled = currentStepIndex === 0;
             nextStepBtn.disabled = currentStepIndex >= lessonScript.length -1; // Disable next on last step
             courseMenuBtnContainer.style.display = isPlaying ? 'none' : 'block'; // Show menu only when paused/ended
         }

        // --- Main Execution Logic ---
        async function executeStep(stepIndex) {
             if (!isPlaying || stepIndex >= lessonScript.length) {
                 if(stepIndex >= lessonScript.length -1) endSimulation(); // Auto-end if finishes
                 return; // Stop if paused or ended
             }

             const step = lessonScript[stepIndex];
              // Add original index for interruption checks during typing
              step.originalIndex = stepIndex;
             // console.log(`Executing Step ${stepIndex}: ${step.type} - ${step.note || ''}`);

             let stepDuration = step.duration || 0; // Default duration if none specified

             // Play audio first if this step defines it
             if (step.type === 'audio' && step.audioId) {
                 const playedAudio = await playAudio(step.audioId);
                 // Use audio duration from map if available
                 const audioKey = step.audioId.split('-').pop().split('.')[0]; // Extract 'aX'
                 stepDuration = audioDurations[audioKey] || step.duration || 1000; // Fallback
                 // Don't await the audio end here, let the timeout handle overall step timing
             }

             let actionCompleted = true; // Track if typing was interrupted

             // Execute visual actions
             switch (step.type) {
                 case 'typeCode':
                     actionCompleted = await simulateTyping(step.content, step.speed || 75);
                     break;
                 case 'runCode':
                     await pause(200);
                     await showOutput(step.output, step.isInfo || false, step.isError || false);
                     break;
                 case 'clearConsole': await clearConsole(); break;
                 case 'clearEditor': await clearEditor(); break;
                 case 'pause':
                      stepDuration = step.duration; // Use explicit pause duration
                     break; // The main timeout below handles the pause
                 case 'audio':
                     // Audio is playing. The stepDuration calculated above handles the wait.
                     break;
                 case 'end':
                     endSimulation(); return; // Stop immediately
                 default:
                     console.warn(`Unknown step type: ${step.type}`); stepDuration = 100;
             }

              // If typing was interrupted (paused/seeked), stop execution for this path
              if (!actionCompleted) {
                 return;
              }

             // Schedule the next step if still playing
             if (isPlaying && stepIndex + 1 < lessonScript.length) {
                 // Calculate delay: use stepDuration (often from audio) minus estimated action time if needed
                 // For simplicity now, just use the calculated stepDuration directly.
                 // Fine-tuning might require subtracting visual action times from stepDuration here.
                 const delay = Math.max(50, stepDuration); // Ensure minimum delay
                 // console.log(`Scheduling next step (${stepIndex + 1}) in ${delay}ms`);
                 timeoutId = setTimeout(() => {
                     executeStep(stepIndex + 1);
                 }, delay);
             } else if (isPlaying && stepIndex + 1 >= lessonScript.length) {
                  // If it was the last step, end simulation after its duration
                  timeoutId = setTimeout(endSimulation, stepDuration);
             }
        }

        function endSimulation() {
            console.log("Simulation ended.");
            isPlaying = false;
            currentStepIndex = lessonScript.length -1; // Ensure index is at end
            clearTimeout(timeoutId);
            timeoutId = null;
            pauseCurrentAudio(); // Ensure audio stops
            currentAudioElement = null;
            ideContainer.classList.remove('is-playing');
            codeArea.classList.add('no-cursor'); // Hide cursor
            codeArea.classList.remove('typing', 'idle');
             updateButtonStates(); // Disable play/pause/next
            finalNavOverlay.classList.add('visible'); // Show final buttons
             courseMenuBtnContainer.style.display = 'block'; // Show menu button at end
        }

        // --- Event Listeners for Controls ---
        playBtn.addEventListener('click', playSimulation);
        pauseBtn.addEventListener('click', pauseSimulation);
        nextStepBtn.addEventListener('click', nextStep);
        prevStepBtn.addEventListener('click', prevStep);

        // --- Pre-calculate Start States for Seeking ---
        function preCalculateStates() {
            let tempEditorHTML = '';
            let tempConsoleLines = [];
            let lines = 1;

            for (let i = 0; i < lessonScript.length; i++) {
                 // Store state *before* this step runs
                 lessonScript[i].startState = {
                     editorHTML: tempEditorHTML,
                     consoleLines: [...tempConsoleLines], // Copy array
                     numLines: lines
                 };

                 // Simulate the effect of the current step to update state for the *next* step
                 const step = lessonScript[i];
                 switch (step.type) {
                     case 'typeCode':
                         // Append HTML carefully - this is complex to do perfectly without rendering
                         // Simplification: just append the raw HTML string. Seeking might look slightly off during typing steps.
                          tempEditorHTML += step.content;
                          lines = tempEditorHTML.split('\n').length; // Update line count
                         break;
                     case 'runCode':
                         // For seeking, assume runCode clears previous output unless we track history differently
                          tempConsoleLines = []; // Clear console on run for simplicity
                         step.output.forEach(line => tempConsoleLines.push({ text: line, isInfo: step.isInfo, isError: step.isError }));
                         break;
                     case 'clearConsole':
                         tempConsoleLines = []; break;
                     case 'clearEditor':
                         tempEditorHTML = ''; lines = 1; break;
                     // Pause, Audio, End don't change visual state directly for the *next* step's start
                 }
            }
             console.log("Pre-calculated states complete.");
        }


        // --- Initial Setup ---
        updateLineNumbers();
        updateStatusBarAndCursor();
        codeArea.classList.add('idle'); // Show cursor initially
        updateButtonStates(); // Disable pause/prev initially
        preCalculateStates(); // Prepare states for seeking


    }); // End DOMContentLoaded
    </script>

</body>
</html>
