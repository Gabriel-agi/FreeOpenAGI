<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Changed Title Slightly -->
    <title>Module 0: Lesson Simulation - Controlled Timed IDE</title>
    <!-- Fonts & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&family=Roboto:wght@400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* --- Base Styles & Variables --- */
        :root {
            --bg-base: #181a1f;         /* Very dark blue/grey base */
            --bg-panel: #21252b;        /* Slightly lighter panels */
            --bg-editor: #282c34;       /* Editor background (Atom One Dark-like) */
            --bg-console: #1f2328;      /* Darker console */
            --text-primary: #abb2bf;    /* Primary light grey text */
            --text-secondary: #5c6370;  /* Dimmer grey for secondary info */
            --text-highlight: #e5c07b;  /* Accent yellow/gold */
            --border-color: #3a3f4b;    /* Subtle borders */
            --cursor-color: #528bff;    /* Accent blue cursor */
            --scrollbar-thumb: #4b5263;
            --scrollbar-track: var(--bg-panel);

            /* Syntax Highlighting Palette (Atom One Dark inspired) */
            --hl-keyword: #c678dd;  /* Purple */
            --hl-string: #98c379;   /* Green */
            --hl-comment: var(--text-secondary); /* Dim grey, italic */
            --hl-function: #61afef;  /* Blue */
            --hl-paren: var(--text-primary); /* Match default text */
            --hl-number: #d19a66;   /* Orange/Brown */
            --hl-output: #a0e8ff;   /* Light cyan for output */
            --hl-error: #e06c75;    /* Red for errors (if needed later) */

            /* UI Elements */
            --sidebar-bg: var(--bg-base);
            --statusbar-bg: #1b1d23;
            --statusbar-text: var(--text-secondary);
            --titlebar-bg: var(--bg-base);
            --titlebar-text: var(--text-secondary);

            --font-code: 'Fira Code', 'Courier New', Courier, monospace;
            --font-ui: 'Roboto', sans-serif;
            --transition-speed: 0.3s;
            --typing-cursor-height: 1.4em;
            --line-height-editor: 1.7;
            --overlay-bg: rgba(0, 0, 0, 0.7); /* Overlay background */
            --border-radius: 8px; /* Added for menu */
        }

        /* --- Reset & Base --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; overflow: hidden; background-color: var(--bg-base); font-family: var(--font-ui); color: var(--text-primary); }

        /* --- IDE Layout --- */
        .ide-container { display: flex; flex-direction: column; width: 100vw; height: 100vh; background-color: var(--bg-base); position: relative; /* For overlay & button */ }

        /* --- Title Bar --- */
        .title-bar { background-color: var(--titlebar-bg); padding: 8px 15px; color: var(--titlebar-text); font-size: 0.9em; text-align: center; border-bottom: 1px solid var(--border-color); flex-shrink: 0; position: relative; }
        .title-bar .file-name { font-weight: 500; color: var(--text-primary); }
        .title-bar-icons { position: absolute; left: 10px; top: 50%; transform: translateY(-50%); display: flex; gap: 8px; }
        .title-bar-icons i { font-size: 0.8em; color: #555; }

        /* --- Main Content Area --- */
        .main-content { display: flex; flex-grow: 1; overflow: hidden; }

        /* --- Sidebar Placeholder --- */
        .sidebar-placeholder { width: 50px; background-color: var(--sidebar-bg); border-right: 1px solid var(--border-color); flex-shrink: 0; display: flex; flex-direction: column; align-items: center; padding-top: 20px; gap: 25px; }
        .sidebar-placeholder i { font-size: 1.4em; color: var(--text-secondary); opacity: 0.6; }
        .sidebar-placeholder i.active { color: var(--text-primary); opacity: 1; }

        /* --- Editor & Console Split --- */
        .editor-console-split { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; }

        /* --- Editor Pane --- */
        .editor-pane { flex-grow: 1; background-color: var(--bg-editor); display: flex; overflow: hidden; position: relative; min-height: 150px; }
        .line-numbers { font-family: var(--font-code); font-size: 1em; line-height: var(--line-height-editor); color: var(--text-secondary); text-align: right; padding: 15px 15px 15px 10px; user-select: none; background-color: var(--bg-editor); border-right: 1px solid var(--border-color); white-space: pre; overflow: hidden; flex-shrink: 0; }
        .code-area-wrapper { flex-grow: 1; overflow-y: auto; padding: 15px; position: relative; }
        .code-area { font-family: var(--font-code); font-size: 1em; line-height: var(--line-height-editor); color: var(--text-primary); white-space: pre; outline: none; min-height: 100%; position: relative; }

        /* --- Minimap --- */
        .minimap-placeholder { position: absolute; top: 0; right: 0; bottom: 0; width: 80px; background-color: rgba(0, 0, 0, 0.1); border-left: 1px solid var(--border-color); flex-shrink: 0; overflow: hidden; opacity: 0.5; pointer-events: none; }
        .minimap-placeholder::before { content: ''; position: absolute; top: 10px; left: 10px; right: 10px; bottom: 10px; background: linear-gradient( rgba(255,255,255,0.08) 1px, transparent 1px ); background-size: 100% 4px; }

        /* --- Cursor --- */
        .code-area::after { content: ''; display: block; width: 2px; height: var(--typing-cursor-height); background-color: var(--cursor-color); position: absolute; top: 0; left: 0; opacity: 0; transition: opacity 0.1s ease-out, top 0.05s linear, left 0.05s linear; border-radius: 1px; box-shadow: 0 0 5px var(--cursor-color); }
        .code-area.typing::after { opacity: 1; animation: none; }
        .code-area.idle::after { opacity: 1; animation: blink 1.1s steps(1) infinite; }
        .code-area.no-cursor::after { opacity: 0; animation: none; }
        @keyframes blink { 50% { opacity: 0; } }

        /* --- Console Pane --- */
        .console-pane { height: 30%; max-height: 350px; min-height: 120px; background-color: var(--bg-console); border-top: 1px solid var(--border-color); color: var(--text-primary); font-family: var(--font-code); font-size: 0.95em; line-height: 1.6; padding: 10px 15px; overflow-y: auto; flex-shrink: 0; white-space: pre-wrap; word-wrap: break-word; }
        .console-pane .output-line { color: var(--hl-output); }
        .console-pane .error-line { color: var(--hl-error); font-weight: bold;}
        .console-pane .placeholder { color: var(--text-secondary); font-style: italic; }
        .console-pane .info-line { color: var(--text-secondary); font-style: italic;}
        .console-prompt { color: var(--text-secondary); margin-right: 8px; user-select: none;}

        /* --- Status Bar --- */
        .status-bar { background-color: var(--statusbar-bg); color: var(--statusbar-text); padding: 5px 15px; font-size: 0.85em; display: flex; justify-content: space-between; align-items: center; border-top: 1px solid var(--border-color); flex-shrink: 0; white-space: nowrap; }
        .status-bar-left, .status-bar-right { display: flex; gap: 15px; align-items: center; }
        .status-bar i { margin-right: 5px; font-size: 1.1em; vertical-align: middle;}
        .status-bar .git-branch i { color: #e8ae59; }
        .status-bar .language i { color: #61afef; }

        /* --- Syntax Highlighting --- */
        .hl-keyword { color: var(--hl-keyword); font-weight: 500; }
        .hl-string { color: var(--hl-string); }
        .hl-comment { color: var(--hl-comment); font-style: italic; }
        .hl-function { color: var(--hl-function); }
        .hl-paren { color: var(--hl-paren); }
        .hl-number { color: var(--hl-number); }

        /* --- Scrollbar Styling --- */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: var(--scrollbar-track); }
        ::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: #5a6375; }
        ::-webkit-scrollbar-corner { background: var(--scrollbar-track); }

        /* --- ADDED: Pause/Play/Restart Button (Top Right, Discreet) --- */
        #control-button {
            position: absolute;
            top: 55px; /* Below title bar, adjust as needed */
            right: 20px; /* Position from right edge */
            z-index: 100; /* Above minimap */
            background-color: rgba(40, 44, 52, 0.7); /* Semi-transparent dark bg */
            color: var(--text-secondary); /* Dimmer icon color */
            border: 1px solid rgba(58, 63, 75, 0.5); /* Subtle border */
            border-radius: 50%;
            width: 36px; /* Smaller size */
            height: 36px;
            font-size: 1em; /* Adjust icon size */
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: none; /* Remove prominent shadow */
            transition: background-color var(--transition-speed), color var(--transition-speed), opacity var(--transition-speed);
            opacity: 0.6; /* Start quite transparent */
        }
        #control-button:hover {
            opacity: 1; /* Fully visible on hover */
            background-color: rgba(40, 44, 52, 0.9);
            color: var(--text-primary);
        }
        #control-button.hidden { display: none; }

        /* --- ADDED: Navigation Overlay & Menu --- */
        #nav-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--overlay-bg); z-index: 90; display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity var(--transition-speed) ease-in-out; }
        #nav-overlay.visible { opacity: 1; pointer-events: auto; }
        .nav-menu { background-color: var(--bg-panel); padding: 25px 35px; border-radius: var(--border-radius); text-align: center; box-shadow: 0 5px 20px rgba(0,0,0,0.5); }
        .nav-menu h3 { color: var(--text-highlight); margin-bottom: 20px; /* Removed font-family: var(--font-title); */ font-size: 1.4em; }
        .nav-menu .button-group { display: flex; flex-direction: column; gap: 15px; margin-top: 0; }
        .nav-menu .action-button { display: block; text-decoration: none; padding: 10px 20px; font-size: 1em; color: white; border: none; border-radius: 5px; cursor: pointer; transition: background-color var(--transition-speed), transform 0.1s ease; text-align: center; }
        .nav-menu .action-button i { margin-right: 8px; }
        .nav-menu .action-button.primary { background-color: var(--hl-output); color: var(--bg-base); }
        .nav-menu .action-button.primary:hover { background-color: #b3f0ff; }
        .nav-menu .action-button.secondary { background-color: var(--text-secondary); }
        .nav-menu .action-button.secondary:hover { background-color: #7a828e; }
        .nav-menu .action-button.tertiary { background-color: var(--border-color); font-size: 0.9em; padding: 8px 15px; }
        .nav-menu .action-button.tertiary:hover { background-color: #4b5263; }
        .nav-menu .action-button:active { transform: scale(0.98); }

    </style>
</head>
<body>

    <div class="ide-container" id="ide-container">
        <!-- Title Bar -->
        <div class="title-bar"> <span class="file-name">module_0_review.py</span> </div>
        <!-- Main Content -->
        <div class="main-content">
            <!-- Sidebar Placeholder -->
            <div class="sidebar-placeholder"> <i class="fas fa-copy active"></i> <i class="fas fa-search"></i> <i class="fas fa-code-branch"></i> <i class="fas fa-bug"></i> <i class="fas fa-puzzle-piece"></i> </div>
            <!-- Editor & Console -->
            <div class="editor-console-split">
                <div class="editor-pane">
                    <div class="line-numbers" id="line-numbers">1</div>
                    <div class="code-area-wrapper" id="code-area-wrapper"> <div class="code-area" id="code-area"></div> </div>
                    <div class="minimap-placeholder"></div>
                     <!-- ADDED: Pause/Play/Restart Button -->
                     <button id="control-button" class="hidden" title="Play/Pause">
                         <i class="fas fa-pause" id="control-icon"></i>
                     </button>
                </div>
                <div class="console-pane" id="console-pane"> <span class="placeholder">Python Console Ready... [Click to Start Lesson]</span> </div>
            </div>
        </div>
        <!-- Status Bar -->
        <div class="status-bar" id="status-bar">
             <div class="status-bar-left"> <span class="git-branch"><i class="fas fa-code-branch"></i> main</span> </div>
             <div class="status-bar-right"> <span id="cursor-pos">Ln 1, Col 1</span> <span>Spaces: 4</span> <span>UTF-8</span> <span class="language"><i class="fab fa-python"></i> Python 3.1x.x</span> </div>
        </div>

         <!-- ADDED: Navigation Overlay (Initially Hidden) -->
         <div id="nav-overlay">
             <div class="nav-menu">
                 <h3 id="nav-menu-title">Lesson Paused</h3>
                 <div class="button-group">
                     <a href="ctp-knowledge-check-0.html" class="action-button primary"><i class="fas fa-question-circle"></i> Knowledge Check</a>
                     <a href="ctp-theory-0.html" class="action-button secondary"><i class="fas fa-book-open"></i> Review Theory</a>
                     <a href="ctp-practice-0.html" class="action-button secondary"><i class="fas fa-undo-alt"></i> Revisit Basic Practice</a>
                     <a href="ctp-advanced-0.html" class="action-button secondary"><i class="fas fa-redo-alt"></i> Revisit Advanced Practice</a>
                     <a href="ctp.html" class="action-button tertiary"><i class="fas fa-list"></i> Course Menu</a>
                 </div>
             </div>
         </div>

    </div>

     <!-- Hidden Audio Elements (Ensure src paths are correct!) -->
     <div style="display: none;">
        <audio id="audio-ctp-0-a1-eng" src="audio/ctp-0-a1-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a2-eng" src="audio/ctp-0-a2-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a3-eng" src="audio/ctp-0-a3-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a4-eng" src="audio/ctp-0-a4-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a5-eng" src="audio/ctp-0-a5-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a6-eng" src="audio/ctp-0-a6-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a7-eng" src="audio/ctp-0-a7-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a8-eng" src="audio/ctp-0-a8-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a9-eng" src="audio/ctp-0-a9-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a10-eng" src="audio/ctp-0-a10-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a11-eng" src="audio/ctp-0-a11-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a12-eng" src="audio/ctp-0-a12-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a13-eng" src="audio/ctp-0-a13-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a14-eng" src="audio/ctp-0-a14-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a15-eng" src="audio/ctp-0-a15-eng.mp3" preload="auto"></audio>
        <audio id="audio-ctp-0-a16-eng" src="audio/ctp-0-a16-eng.mp3" preload="auto"></audio>
     </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- Element References ---
        const ideContainer = document.getElementById('ide-container'); // Added
        const codeArea = document.getElementById('code-area');
        const consolePane = document.getElementById('console-pane');
        const lineNumbersEl = document.getElementById('line-numbers');
        const statusBar = document.getElementById('status-bar');
        const cursorPosEl = document.getElementById('cursor-pos');
        const codeAreaWrapper = document.getElementById('code-area-wrapper');
        const controlButton = document.getElementById('control-button'); // Added
        const controlIcon = document.getElementById('control-icon'); // Added
        const navOverlay = document.getElementById('nav-overlay'); // Added
        const navMenuTitle = document.getElementById('nav-menu-title'); // Added

        // --- State Variables ---
        let currentLineNumber = 1;
        let currentCol = 1;
        let currentContentHTML = '';
        let charWidthEstimate = 9; // Keep estimation simple for now
        let lineHeightEstimate = 27;
        let simulationStarted = false; // Added
        let isPaused = false; // Added
        let isFinished = false; // Added
        let currentStepIndex = 0; // Moved here from executeScript scope
        let currentAudioElement = null; // Added
        let currentTimeoutId = null; // Added - Will store ID for pauses/typing steps
        let stopExecution = false; // Added - Flag to signal loop termination

        // --- Audio Setup ---
        const audioElements = {};
        document.querySelectorAll('audio[id^="audio-ctp-0-a"]').forEach(el => {
            audioElements[el.id] = el;
             el.onerror = () => console.error(`Error loading audio: ${el.src}`);
             // No 'ended' or 'pause' listeners needed for this timing method unless specifically handling external pause
        });

         // --- Helper Functions ---
         function getTextWidth(text, font) {
              const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
              const context = canvas.getContext("2d");
              context.font = font || getComputedStyle(codeArea).font;
              return context.measureText(text).width;
          }

        function updateStatusBarAndCursor() {
            // Unchanged from previous working version
            const lines = codeArea.innerText.split('\n');
            currentLineNumber = lines.length;
            const lastLineText = lines[currentLineNumber - 1] || '';
            currentCol = lastLineText.length + 1;
            cursorPosEl.textContent = `Ln ${currentLineNumber}, Col ${currentCol}`;
            const cursorTop = (currentLineNumber - 1) * lineHeightEstimate;
            const cursorLeft = getTextWidth(lastLineText, getComputedStyle(codeArea).font);
            const cursorPseudoStyle = `
                 .code-area.idle::after, .code-area.typing::after {
                     top: ${cursorTop}px; left: ${cursorLeft}px;
                     height: ${getComputedStyle(codeArea).lineHeight}; }`;
            let styleSheet = document.getElementById('cursor-style');
            if (!styleSheet) { styleSheet = document.createElement('style'); styleSheet.id = 'cursor-style'; document.head.appendChild(styleSheet); }
            styleSheet.textContent = cursorPseudoStyle;
            const wrapperRect = codeAreaWrapper.getBoundingClientRect();
            const cursorAbsoluteTop = codeArea.offsetTop + cursorTop;
            const scrollTop = codeAreaWrapper.scrollTop; const scrollBottom = scrollTop + wrapperRect.height;
            const currentLineHeight = parseFloat(getComputedStyle(codeArea).lineHeight);
            if (cursorAbsoluteTop + currentLineHeight > scrollBottom) { codeAreaWrapper.scrollTop = cursorAbsoluteTop + currentLineHeight - wrapperRect.height + 10; }
            else if (cursorAbsoluteTop < scrollTop) { codeAreaWrapper.scrollTop = Math.max(0, cursorAbsoluteTop - 10); }
        }
        function updateLineNumbers() {
            // Unchanged from previous working version
             const lines = codeArea.innerText.split('\n').length; const maxLines = Math.max(lines, 1);
             let numbersHTML = ''; for (let i = 1; i <= maxLines; i++) { numbersHTML += i + '\n'; }
             lineNumbersEl.textContent = numbersHTML.trimEnd();
         }

        // --- MODIFIED simulateTyping to be INTERRUPTIBLE ---
        function simulateTyping(textToTypeHTML, typingSpeed) {
             return new Promise((resolve, reject) => {
                 clearTimeout(currentTimeoutId); // Clear any previous lingering timeout
                 currentTimeoutId = null;

                 if (isPaused) { // If paused when starting, wait
                     codeArea.classList.add('idle');
                     codeArea.classList.remove('typing', 'no-cursor');
                     updateStatusBarAndCursor();
                     // We resolve immediately, the outer loop will handle the pause wait
                     resolve();
                     return;
                 }
                 if (stopExecution) { reject("stopped"); return; } // If stopped, reject immediately

                 codeArea.classList.add('typing');
                 codeArea.classList.remove('idle', 'no-cursor');
                 let charIndex = 0;
                 let currentHTML = currentContentHTML;

                 function typeStep() {
                     // --- Pause/Stop Check ---
                     if (stopExecution) {
                         console.log("Typing interrupted by stop signal.");
                         codeArea.classList.remove('typing');
                         codeArea.classList.add('idle');
                         clearTimeout(currentTimeoutId);
                         currentTimeoutId = null;
                         reject("stopped");
                         return;
                     }
                     if (isPaused) {
                         console.log("Typing paused...");
                         codeArea.classList.remove('typing');
                         codeArea.classList.add('idle');
                         updateStatusBarAndCursor();
                         // Wait until unpaused or stopped
                         const pauseCheckInterval = setInterval(() => {
                             if (stopExecution) {
                                 clearInterval(pauseCheckInterval);
                                 console.log("Typing stop signal received while paused.");
                                 reject("stopped");
                             } else if (!isPaused) {
                                 clearInterval(pauseCheckInterval);
                                 console.log("Typing resumed...");
                                 codeArea.classList.add('typing');
                                 codeArea.classList.remove('idle');
                                 currentTimeoutId = setTimeout(typeStep, typingSpeed); // Resume typing
                             }
                         }, 100); // Check every 100ms
                         return; // Don't schedule next step yet
                     }
                     // --- End Pause/Stop Check ---

                     if (charIndex >= textToTypeHTML.length) {
                         currentContentHTML = currentHTML;
                         codeArea.classList.remove('typing');
                         codeArea.classList.add('idle');
                         updateLineNumbers();
                         updateStatusBarAndCursor();
                         currentTimeoutId = null;
                         resolve();
                         return;
                     }
                     let nextChar = textToTypeHTML[charIndex];
                     let stepSize = 1;
                     if (nextChar === '<') { // Handle HTML tags
                         const tagEndIndex = textToTypeHTML.indexOf('>', charIndex);
                         if (tagEndIndex !== -1) {
                             stepSize = tagEndIndex - charIndex + 1;
                             nextChar = textToTypeHTML.substring(charIndex, tagEndIndex + 1);
                         }
                     }
                     currentHTML += nextChar;
                     codeArea.innerHTML = currentHTML;
                     updateLineNumbers();
                     updateStatusBarAndCursor();
                     charIndex += stepSize;
                     currentTimeoutId = setTimeout(typeStep, typingSpeed); // Schedule next step
                 }
                 typeStep(); // Start the first step
             });
        }

        function showOutput(outputLines, isInfo = false, isError = false) {
             // Unchanged from previous versions
             return new Promise((resolve) => {
                 // Don't clear if adding info/error after regular output maybe? For now, clear.
                 consolePane.innerHTML = '';
                 outputLines.forEach(line => {
                     const lineEl = document.createElement('div');
                     if (isError) { lineEl.className = 'error-line'; lineEl.textContent = `❌ ${line}`; }
                     else if (isInfo) { lineEl.className = 'info-line'; lineEl.textContent = `ℹ️ ${line}`; }
                     else {
                         lineEl.className = 'output-line';
                         const promptSpan = document.createElement('span'); promptSpan.className = 'console-prompt'; promptSpan.textContent = '>>>';
                         lineEl.appendChild(promptSpan); lineEl.appendChild(document.createTextNode(` ${line}`));
                     }
                     consolePane.appendChild(lineEl);
                 });
                 consolePane.scrollTop = consolePane.scrollHeight;
                 resolve();
             });
        }

        function clearConsole() {
            // Unchanged from previous versions
             return new Promise((resolve) => {
                 consolePane.innerHTML = '<span class="placeholder">Console cleared.</span>';
                 resolve();
             });
        }

        function clearEditor() {
            // Unchanged from previous versions
             return new Promise((resolve) => {
                 currentContentHTML = ''; codeArea.innerHTML = ''; currentLineNumber = 1; currentCol = 1;
                 updateLineNumbers(); updateStatusBarAndCursor();
                 codeArea.classList.add('idle'); codeArea.classList.remove('typing', 'no-cursor');
                 resolve();
             });
        }

        // --- Use SIMPLE playAudio (starts without waiting) ---
        async function playAudio(audioId) {
            // Stop previous audio if any is playing
            if (currentAudioElement && !currentAudioElement.paused) {
                currentAudioElement.pause();
                currentAudioElement.currentTime = 0;
            }

            currentAudioElement = audioElements[audioId];
            if (!currentAudioElement) {
                console.warn(`Audio ${audioId} not found.`);
                return; // Don't throw error, just skip
            }
            try {
                currentAudioElement.currentTime = 0;
                // Don't await the play() call itself, let it run in background
                currentAudioElement.play().catch(error => {
                     // Catch potential play errors (e.g., user interaction needed)
                     console.error(`Error attempting to play ${audioId}:`, error);
                     // Maybe show an error message in the console pane?
                     // showOutput([`Error playing audio: ${audioId}`], true); // Example
                });
                console.log(`Starting audio playback: ${audioId}`);
            } catch (error) {
                // Catch synchronous errors, though play() returning a promise is more common
                console.error(`Unexpected error starting ${audioId}:`, error);
            }
        }

        // --- MODIFIED pause to be INTERRUPTIBLE ---
        async function pause(duration) {
            return new Promise((resolve, reject) => {
                 clearTimeout(currentTimeoutId); // Clear any previous lingering timeout
                 currentTimeoutId = null;

                 if (isPaused) { // If paused when starting, wait
                     codeArea.classList.add('idle');
                     codeArea.classList.remove('typing', 'no-cursor');
                     updateStatusBarAndCursor();
                     // Resolve immediately, the outer loop handles the pause wait
                     resolve();
                     return;
                 }
                 if (stopExecution) { reject("stopped"); return; } // If stopped, reject immediately

                codeArea.classList.add('idle');
                codeArea.classList.remove('typing', 'no-cursor');
                updateStatusBarAndCursor(); // Ensure cursor is positioned correctly

                let intervalCheckId = null;

                const cleanUp = () => {
                    clearTimeout(currentTimeoutId);
                    clearInterval(intervalCheckId);
                    currentTimeoutId = null;
                    intervalCheckId = null;
                };

                // Set the main timeout for the pause duration
                currentTimeoutId = setTimeout(() => {
                    cleanUp();
                    resolve(); // Pause completed successfully
                }, duration);

                // Set an interval to frequently check for pause/stop signals
                intervalCheckId = setInterval(() => {
                    if (stopExecution) {
                        console.log("Pause interrupted by stop signal.");
                        cleanUp();
                        reject("stopped");
                    } else if (isPaused) {
                         console.log("Pause interrupted by user pause.");
                         // When paused during a pause(), we clear the *original* timeout
                         // The outer loop's `while(isPaused)` will handle the actual waiting.
                         cleanUp();
                         resolve(); // Resolve immediately so the outer loop can take over pausing
                    }
                }, 50); // Check every 50ms
            });
         }

        // --- THE LESSON SCRIPT (Using TIMED approach from working version) ---
        const audioDurations = { // Durations in milliseconds
            'a1': 13000, 'a2': 13000, 'a3': 14000, 'a4': 30000, 'a5': 6000,
            'a6': 9000, 'a7': 8000, 'a8': 5000, 'a9': 11000, 'a10': 16000,
            'a11': 2000, 'a12': 18000, 'a13': 8000, 'a14': 8000, 'a15': 15000,
            'a16': 32000
        };

        const lessonScript = [
             // --- Segment 1: Intro (a1) ---
             { type: 'audio', audioId: 'audio-ctp-0-a1-eng', note: "Start a1" },
             { type: 'pause', duration: 1500, note: "Short pause before typing" },
             { type: 'typeCode', content: `<span class="hl-comment"># Module 0 Review: print() and comments</span>\n\n`, speed: 70 },
             { type: 'pause', duration: Math.max(0, audioDurations['a1'] - 1500 - 2000), note: "Wait remainder of a1" }, // Estimate typing time ~2s

             // --- Segment 2: Review Concepts (a2) ---
             { type: 'audio', audioId: 'audio-ctp-0-a2-eng', note: "Start a2" },
             { type: 'pause', duration: audioDurations['a2'], note: "Wait for a2" },

             // --- Segment 3: Introduce print(), basic structure (a3) ---
             { type: 'audio', audioId: 'audio-ctp-0-a3-eng', note: "Start a3" },
             { type: 'pause', duration: 11000, note: "Pause while explaining structure" }, // Wait until speaker says "looks like this:"
             { type: 'typeCode', content: `<span class="hl-keyword">print</span><span class="hl-paren">(</span><span class="hl-string">"..."</span><span class="hl-paren">)</span>`, speed: 90, note: "Type basic structure" },
             { type: 'pause', duration: Math.max(0, audioDurations['a3'] - 11000 - 1000), note: "Wait remainder of a3" }, // Estimate typing ~1s

             // --- Segment 4: Break down print() (a4 - Long) ---
             { type: 'audio', audioId: 'audio-ctp-0-a4-eng', note: "Start a4" },
             { type: 'pause', duration: 5000, note: "Pause while explaining 'print'" },
             { type: 'clearEditor' }, { type: 'pause', duration: 100}, // Short pause after clear
             { type: 'typeCode', content: `<span class="hl-keyword">print</span><span class="hl-paren">(</span><span class="hl-string">"Hello, World!"</span><span class="hl-paren">)</span>`, speed: 80, note: "Type Hello World example" },
             { type: 'pause', duration: Math.max(0, audioDurations['a4'] - 5000 - 100 - 2500), note: "Wait remainder of a4" }, // Estimate typing ~2.5s

             // --- Segment 5: Run code, print different things (a5) ---
             { type: 'audio', audioId: 'audio-ctp-0-a5-eng', note: "Start a5" },
             { type: 'runCode', output: ["Hello, World!"] },
             { type: 'pause', duration: 2000, note: "Pause after run"},
             { type: 'typeCode', content: `\n<span class="hl-keyword">print</span><span class="hl-paren">(</span><span class="hl-string">"Python is powerful."</span><span class="hl-paren">)</span>`, speed: 70, note: "Type next example" },
             { type: 'pause', duration: Math.max(0, audioDurations['a5'] - 2000 - 2000), note: "Wait remainder of a5" }, // Estimate typing ~2s

             // --- Segment 6: Blank line explanation (a6) ---
             { type: 'audio', audioId: 'audio-ctp-0-a6-eng', note: "Start a6" },
             { type: 'typeCode', content: `\n<span class="hl-keyword">print</span><span class="hl-paren">(</span><span class="hl-string">"Practice makes perfect!"</span><span class="hl-paren">)</span>`, speed: 70, note: "Type final example" },
             { type: 'pause', duration: 3000, note: "Pause after typing examples"},
             { type: 'typeCode', content: `\n\n<span class="hl-comment"># Adding a blank line</span>\n`, speed: 60, note: "Type blank comment" },
             { type: 'typeCode', content: `<span class="hl-keyword">print</span><span class="hl-paren">(</span><span class="hl-paren">)</span>`, speed: 95, note: "Type print()" },
             { type: 'pause', duration: Math.max(0, audioDurations['a6'] - 3000 - 2500), note: "Wait remainder of a6" }, // Estimate typing comments/print() ~2.5s

             // --- Segment 7: Multi-line explanation (a7) ---
             { type: 'audio', audioId: 'audio-ctp-0-a7-eng', note: "Start a7" },
             { type: 'runCode', output: ["Hello, World!", "Python is powerful.", "Practice makes perfect!", ""] },
             { type: 'pause', duration: 3000, note: "Show blank line output"},
             { type: 'typeCode', content: `\n<span class="hl-keyword">print</span><span class="hl-paren">(</span><span class="hl-string">"This appears after the space."</span><span class="hl-paren">)</span>`, speed: 70, note: "Type line after space" },
             { type: 'pause', duration: Math.max(0, audioDurations['a7'] - 3000 - 3000), note: "Wait remainder of a7" }, // Estimate typing ~2s, runCode is fast

             // --- Segment 8: Default behavior (new line) (a8) ---
             { type: 'audio', audioId: 'audio-ctp-0-a8-eng', note: "Start a8" },
             { type: 'runCode', output: ["Hello, World!", "Python is powerful.", "Practice makes perfect!", "", "This appears after the space."]},
             { type: 'pause', duration: audioDurations['a8'], note: "Wait for a8" }, // Wait full duration

             // --- Segment 9: Introduce comments (a9) ---
             { type: 'audio', audioId: 'audio-ctp-0-a9-eng', note: "Start a9" },
             { type: 'clearEditor' }, { type: 'clearConsole' }, { type: 'pause', duration: 500 },
             { type: 'typeCode', content: `<span class="hl-comment"># This is a full-line comment.</span>\n`, speed: 60, note: "Type first comment" },
             { type: 'pause', duration: Math.max(0, audioDurations['a9'] - 500 - 3000), note: "Wait remainder of a9" }, // Estimate typing ~3s

             // --- Segment 10: Run comment (no output), explain usefulness, end-of-line (a10) ---
             { type: 'audio', audioId: 'audio-ctp-0-a10-eng', note: "Start a10" },
             { type: 'runCode', output: ["(No output from comments)"], isInfo: true },
             { type: 'pause', duration: 5000, note: "Pause after running comment" },
             { type: 'typeCode', content: `<span class="hl-keyword">print</span><span class="hl-paren">(</span><span class="hl-string">"Processing data..."</span><span class="hl-paren">)</span> `, speed: 70, note: "Type print for end comment" },
             { type: 'typeCode', content: `<span class="hl-comment"># End-of-line comment</span>`, speed: 55, note: "Type end comment" },
             { type: 'pause', duration: Math.max(0, audioDurations['a10'] - 5000 - 4000), note: "Wait remainder of a10" }, // Estimate typing ~4s

             // --- Segment 11: Run code with end-of-line comment (a11) ---
             { type: 'audio', audioId: 'audio-ctp-0-a11-eng', note: "Start a11" },
             { type: 'runCode', output: ["Processing data..."] },
             { type: 'pause', duration: audioDurations['a11'], note: "Wait for a11" },

             // --- Segment 12: Explain end-of-line result, commented-out code (a12) ---
             { type: 'audio', audioId: 'audio-ctp-0-a12-eng', note: "Start a12" },
             { type: 'pause', duration: 10000, note: "Pause during explanation"},
             { type: 'typeCode', content: `\n<span class="hl-comment"># print("Old debug message") # Temporarily disabled</span>`, speed: 55, note: "Type commented-out example" },
             { type: 'pause', duration: Math.max(0, audioDurations['a12'] - 10000 - 4000), note: "Wait remainder of a12" }, // Estimate typing ~4s

             // --- Segment 13: Syntax errors intro (a13) ---
             { type: 'audio', audioId: 'audio-ctp-0-a13-eng', note: "Start a13" },
             { type: 'clearEditor' }, { type: 'clearConsole' }, { type: 'pause', duration: 500 },
             { type: 'typeCode', content: `<span class="hl-comment"># Finally: Syntax is important!</span>\n`, speed: 65, note: "Type syntax intro comment" }, // Changed comment slightly
             { type: 'pause', duration: Math.max(0, audioDurations['a13'] - 500 - 2500), note: "Wait remainder of a13" }, // Estimate typing ~2.5s

             // --- Segment 14: Syntax recap (a14) ---
             { type: 'audio', audioId: 'audio-ctp-0-a14-eng', note: "Start a14" },
             { type: 'typeCode', content: `<span class="hl-comment"># - print (lowercase)</span>\n<span class="hl-comment"># - () Parentheses</span>\n<span class="hl-comment"># - "" or '' Quotes for text</span>`, speed: 65, note: "Type syntax details" },
             { type: 'pause', duration: Math.max(0, audioDurations['a14'] - 5000), note: "Wait remainder of a14" }, // Estimate typing ~5s

             // --- Segment 15: Review wrap-up (a15) ---
             { type: 'audio', audioId: 'audio-ctp-0-a15-eng', note: "Start a15" },
             { type: 'clearEditor' }, { type: 'pause', duration: 300 },
             { type: 'typeCode', content: `<span class="hl-comment"># You've mastered the basics!</span>\n`, speed: 60, note: "Type wrap-up comment" },
             { type: 'pause', duration: 500 },
             { type: 'typeCode', content: `<span class="hl-keyword">print</span><span class="hl-paren">(</span><span class="hl-string">"Module 0 Complete!"</span><span class="hl-paren">)</span>`, speed: 70, note: "Type wrap-up print" },
             { type: 'pause', duration: 1000 },
             { type: 'runCode', output: ["Module 0 Complete!"] },
             { type: 'pause', duration: Math.max(0, audioDurations['a15'] - 300 - 500 - 1000 - 1000 - 2000), note: "Wait remainder of a15" }, // Estimate actions ~5s

             // --- Segment 16: Final conclusion/next steps (a16) ---
             { type: 'audio', audioId: 'audio-ctp-0-a16-eng', note: "Start a16" },
             { type: 'clearConsole'}, { type: 'pause', duration: 500 },
             { type: 'showOutput', output: ["Great job!", "Next: Knowledge Check"], isInfo: true}, // Updated next step
             { type: 'pause', duration: Math.max(0, audioDurations['a16'] - 500), note: "Wait for a16" },

             { type: 'end', note: "End of Simulation" }
        ];


        // --- AUTOPLAY EXECUTION & CONTROL LOGIC ---

        async function executeScript() {
             if (!simulationStarted) return;
             console.log("Starting script execution...");
             consolePane.innerHTML = '<span class="placeholder">Lesson playing...</span>';
             controlButton.classList.remove('hidden');
             setControlButtonState('pause');
             isFinished = false;
             stopExecution = false; // Ensure stop flag is reset at start

             while (currentStepIndex < lessonScript.length && !stopExecution) {
                  // --- Pause Handling ---
                  while (isPaused && !stopExecution) {
                      console.log("Execution paused. Waiting...");
                      await new Promise(resolve => setTimeout(resolve, 200)); // Check every 200ms
                  }
                  if (stopExecution) {
                      console.log("Stop signal received while paused or between steps.");
                      break; // Exit the main loop
                  }
                  // --- End Pause Handling ---

                 const step = lessonScript[currentStepIndex];
                 console.log(`Executing Step ${currentStepIndex}: ${step.type} - ${step.note || ''}`);
                 codeArea.classList.remove('idle', 'typing', 'no-cursor'); // Set state before action

                 try {
                     // --- Execute Action ---
                     switch (step.type) {
                         case 'audio': // Just starts audio, doesn't wait
                             if (step.audioId) { await playAudio(step.audioId); }
                             await pause(10); // Tiny pause to prevent tight loop if audio is only step
                             break;
                         case 'typeCode':
                             await simulateTyping(step.content, step.speed || 75);
                             break;
                         case 'runCode':
                             await pause(100); // Brief visual pause before showing output
                             await showOutput(step.output, step.isInfo || false, step.isError || false);
                             break;
                         case 'clearConsole':
                             await clearConsole();
                             break;
                         case 'clearEditor':
                             await clearEditor();
                             break;
                         case 'pause': // Use the interruptible pause
                             await pause(step.duration || 1000);
                             break;
                         case 'end':
                             isFinished = true;
                             showEndState(); // Update UI for finished state
                             stopExecution = true; // Signal loop to terminate
                             console.log("Script finished normally.");
                             break;
                         default:
                             console.warn(`Unknown step type: ${step.type}`);
                             await pause(100); // Default small pause
                     }
                 } catch (error) {
                      if (error === "stopped") {
                          console.log(`Step ${currentStepIndex} (${step.type}) interrupted.`);
                          // stopExecution is already true or will be set by the calling function (togglePause/restart)
                      } else {
                          // Handle unexpected errors
                          console.error(`Error during step ${currentStepIndex} (${step.type}):`, error);
                          showOutput([`An error occurred: ${error}`], false, true); // Display error in console
                          stopExecution = true; // Stop execution on unexpected errors
                          isFinished = true; // Treat as finished to show restart button
                          showEndState("Error Occurred");
                      }
                 }

                 // --- Post-Step Handling ---
                 if (!stopExecution && step.type !== 'end') {
                      codeArea.classList.add('idle'); // Set cursor to idle unless stopped/ended
                      codeArea.classList.remove('typing', 'no-cursor');
                      updateStatusBarAndCursor();
                      currentStepIndex++; // Move to next step ONLY if not stopped
                 } else if (stopExecution) {
                     console.log("Execution loop terminating due to stop signal.");
                     break; // Ensure loop exits if stopExecution was set mid-step
                 }
             } // End while loop

             // Final state check after loop exit
             if (!isFinished && stopExecution) {
                console.log("Script execution stopped externally.");
                // Ensure UI reflects the stopped state (e.g., if paused when stop was triggered)
                if(isPaused) {
                    setControlButtonState('play');
                    showNavMenu(true, "Lesson Paused");
                    codeArea.classList.add('idle'); // Ensure cursor is visible and idle
                    updateStatusBarAndCursor();
                } else if (!isFinished) {
                    // If stopped but not paused and not finished (e.g., restart mid-action)
                    // It should already be handled by restartSimulation, but as a fallback:
                    setControlButtonState('restart'); // Or maybe keep current state? Restart seems safer.
                }
             } else if (currentStepIndex >= lessonScript.length && !isFinished) {
                 // Should have been handled by 'end' step, but as safety net
                 isFinished = true; showEndState();
                 console.log("Script loop completed (final check).");
             }
        }

        // --- Control/UI Functions ---
        function setControlButtonState(state) {
            // States: 'play', 'pause', 'restart'
            switch(state){
                case 'play':
                    controlIcon.className = 'fas fa-play';
                    controlButton.title = 'Resume';
                    break;
                case 'pause':
                    controlIcon.className = 'fas fa-pause';
                    controlButton.title = 'Pause';
                    break;
                case 'restart':
                    controlIcon.className = 'fas fa-redo-alt';
                    controlButton.title = 'Restart Lesson';
                    break;
            }
        }

        function showNavMenu(show = true, title = "Lesson Paused") {
            navMenuTitle.textContent = title;
            if (show) {
                navOverlay.classList.add('visible');
            } else {
                navOverlay.classList.remove('visible');
            }
        }

        function showEndState(title = "Lesson Finished") {
            console.log("Showing end state");
            isFinished = true; // Ensure state is set
            stopExecution = true; // Ensure any background checks stop
            setControlButtonState('restart');
            codeArea.classList.add('no-cursor'); // Hide cursor
            codeArea.classList.remove('idle', 'typing');
            showNavMenu(true, title);

            // Stop audio and clear timeouts
            if (currentAudioElement) { currentAudioElement.pause(); currentAudioElement.currentTime = 0; }
            currentAudioElement = null;
            clearTimeout(currentTimeoutId); // Cancel any pending pause/typing timeouts
            currentTimeoutId = null;
             // Might need to clear intervals used in interruptible functions too if they weren't cleared on stop signal
        }

        function togglePause() {
            if (isFinished) return; // Don't toggle if finished

            isPaused = !isPaused;
            console.log(isPaused ? "Pausing..." : "Resuming...");

            if (isPaused) {
                // Signal pause
                setControlButtonState('play');
                showNavMenu(true, "Lesson Paused");
                // Stop audio playback
                if (currentAudioElement) { currentAudioElement.pause(); }
                // The interruptible pause/typing functions will detect isPaused
                // and clear their *own* timeouts, then the main loop's while(isPaused) takes over.
                codeArea.classList.remove('typing'); // Ensure typing cursor stops if paused mid-type
                codeArea.classList.add('idle');    // Ensure idle cursor blinks
                updateStatusBarAndCursor();          // Update status bar immediately
            } else {
                // Signal resume
                showNavMenu(false);
                setControlButtonState('pause');
                // Resume audio ONLY if it was playing when paused
                if (currentAudioElement && currentAudioElement.paused && currentAudioElement.currentTime > 0) {
                     currentAudioElement.play().catch(e => console.error("Resume play error", e));
                }
                // The main executeScript loop's while(isPaused) check will naturally continue
            }
        }

        function restartSimulation() {
            console.log("Restarting simulation...");
            stopExecution = true; // Signal current loop/promises/timeouts/intervals to stop

            // Ensure pending operations are cancelled immediately
            clearTimeout(currentTimeoutId);
            currentTimeoutId = null;
            // Need robust way to clear intervals if any are active from pause/typing checks
            // For now, rely on stopExecution flag being checked within intervals

            // Stop and reset audio
            if (currentAudioElement) {
                currentAudioElement.pause();
                currentAudioElement.currentTime = 0;
            }
            currentAudioElement = null;

            // Reset state variables
            currentStepIndex = 0;
            isPaused = false;
            isFinished = false;
            currentContentHTML = '';
            // stopExecution will be reset before restarting executeScript

            // Reset UI immediately
             clearEditor(); // Resets content and cursor state internally
             clearConsole();
             showNavMenu(false);
             // Set initial cursor state
             codeArea.classList.remove('typing', 'no-cursor');
             codeArea.classList.add('idle');
             updateStatusBarAndCursor(); // Set initial cursor position display

             // Start new execution after a very brief delay to allow cleanup
             setTimeout(() => {
                 stopExecution = false; // <<< RESET stop flag for the new execution run
                 simulationStarted = true; // Ensure it's marked as started
                 executeScript(); // Start from the beginning
             }, 100); // Slightly longer delay for restart cleanup
        }


        // --- Event Listeners ---
        controlButton.addEventListener('click', () => {
            if (!simulationStarted) return; // Ignore clicks before start
            if (isFinished) {
                restartSimulation();
            } else {
                togglePause();
            }
        });

        // --- User Interaction Start ---
        function startSimulation() {
             if (simulationStarted) return;
             simulationStarted = true;

            document.body.removeEventListener('click', startSimulation);
            document.body.removeEventListener('keydown', startSimulation);
            console.log("User interaction detected, starting simulation...");
             consolePane.innerHTML = '<span class="placeholder">Starting lesson...</span>';

             // Attempt to unlock audio context
             try {
                const context = new (window.AudioContext || window.webkitAudioContext)();
                if (context.state === 'suspended') { context.resume(); }
                 // Also try the silent play/pause trick for all audio elements
                Object.values(audioElements).forEach(audio => {
                    audio.load(); // Ensure metadata is loaded
                    const promise = audio.play();
                    if (promise !== undefined) {
                       promise.then(_ => { audio.pause(); audio.currentTime = 0; }).catch(error => {
                           // Ignore errors here, usually related to interaction needed, which we got
                       });
                    }
                });
             } catch(e) {
                 console.warn("AudioContext or initial playback trick failed:", e);
             }

            controlButton.classList.remove('hidden'); // Show the button now
            setTimeout(executeScript, 500); // Start the script execution
        }

        document.body.addEventListener('click', startSimulation, { once: true });
        document.body.addEventListener('keydown', startSimulation, { once: true });

        // --- Initial Setup ---
        updateLineNumbers();
        updateStatusBarAndCursor();
        codeArea.classList.add('idle'); // Start with blinking cursor

    }); // End DOMContentLoaded
    </script>

</body>
</html>
