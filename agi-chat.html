<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AGI Chat</title> <!-- V8.1 + Mic + Proxy Default + Layout Fix -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>
    <style>
        /* --- Base Styles --- */
        :root {
            --sb-bg: #f7f7f8; --chat-bg: #fff; --input-bg: #fff; /* Changed input bg */
            --text-pri: #202123; --text-sec: #6e6e73; --accent: #4a90e2;
            --border: #e5e5e5; --hover: #e9e9ea;
            --font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            --sb-width: 260px; --sb-trans: width .2s ease-in-out;
        }
        html { height: 100%; } /* Ensure html takes full height */
        body {
            height: 100%; margin: 0; font-family: var(--font);
            background: var(--chat-bg); color: var(--text-pri);
            overflow: hidden; font-size: 15px;
            display: flex; /* Make body a flex container */
        }
        button { background: 0 0; border: none; cursor: pointer; padding: 0; font-family: inherit; color: inherit; }
        input, select, textarea { font-family: inherit; font-size: inherit; box-sizing: border-box; }
        * { box-sizing: border-box; }

        /* --- App Layout --- */
        .app { display: flex; height: 100%; width: 100%; } /* Occupy full body height/width */

        /* --- Sidebar Styles --- */
        .sidebar {
            width: var(--sb-width); background: var(--sb-bg); border-right: 1px solid var(--border);
            display: flex; flex-direction: column; transition: var(--sb-trans);
            overflow: hidden; position: relative; flex-shrink: 0; height: 100%; /* Ensure sidebar takes full height */
        }
        .app.sidebar-collapsed .sidebar { width: 0; border-right: none; }
        .sidebar-header { padding: 10px 15px; font-size: .85em; color: var(--text-sec); text-transform: uppercase; letter-spacing: .5px; white-space: nowrap; flex-shrink: 0; }
        #hist-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #hist-list::-webkit-scrollbar { display: none; }
        #hist-list { -ms-overflow-style: none; scrollbar-width: none; }
        #hist-list li { padding: 8px 15px 8px 25px; margin: 1px 10px; border-radius: 6px; cursor: pointer; font-size: .9em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; border: 1px solid transparent; position: relative; }
        #hist-list li:hover { background: var(--hover); }
        #hist-list li.active { background: #e0e0e0; font-weight: 500; }
        .sidebar-footer { padding: 10px 15px; font-size: .9em; color: var(--text-sec); text-align: center; border-top: 1px solid var(--border); white-space: nowrap; flex-shrink: 0; display: flex; justify-content: center; gap: 15px; }
        #api-key-btn, #agi-btn { font-size: 1.2em; padding: 5px 8px; border-radius: 4px; }
        #api-key-btn:hover, #agi-btn:hover { background-color: var(--hover); }

        /* --- Chat Area Layout (Flexbox approach) --- */
        .chat-area {
            flex-grow: 1; display: flex; flex-direction: column;
            background: var(--chat-bg); height: 100%; /* Occupy full height within .app */
            position: relative; /* Needed for absolute positioned children like context menus */
            overflow: hidden; /* Prevent chat-area itself from scrolling */
        }
        .chat-header { display: flex; align-items: center; padding: 0 10px 0 0; border-bottom: 1px solid var(--border); height: 41px; flex-shrink: 0; }
        #sidebar-toggle { font-size: 1.6em; padding: 5px 15px; color: var(--text-sec); line-height: 1; }
        .chat-header h2 { margin: 0 auto 0 10px; font-size: 1.1em; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #new-chat { font-size: 1.5em; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; color: var(--text-sec); margin-left: auto; border-radius: 50%; }
        #new-chat:hover, #sidebar-toggle:hover { background: var(--hover); border-radius: 4px; }

        /* Chat Content Area */
        #chat-cont {
            flex-grow: 1; /* Takes up remaining space */
            overflow-y: auto; /* Allows scrolling of messages */
            padding: 20px; /* Padding around messages */
            display: flex; flex-direction: column;
        }
        #chat-cont::-webkit-scrollbar { display: none; }
        #chat-cont { -ms-overflow-style: none; scrollbar-width: none; }
        .init-welcome { margin: auto; text-align: center; color: var(--text-sec); } /* Centered vertically */
        .init-welcome svg, .a-pfp svg, .a-pfp img { width: 40px; height: 40px; fill: var(--accent); border-radius: 50%; }
        .init-welcome h1 { font-size: 1.6em; color: var(--text-pri); margin: 0 0 5px 0; font-weight: 500; }

        /* Message Styles */
        .msg-wrap { display: flex; margin-bottom: 20px; width: 100%; align-items: flex-start; cursor: context-menu; }
        .u-msg-wrap { justify-content: flex-end; }
        .a-pfp { width: 30px; height: 30px; border-radius: 50%; background: var(--accent); flex-shrink: 0; margin-right: 10px; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .a-pfp svg { width: 18px; height: 18px; fill: #fff; margin: 0; }
        .a-pfp img { width: 100%; height: 100%; object-fit: cover; }
        .msg { padding: 10px 14px; border-radius: 15px; max-width: 85%; line-height: 1.5; font-size: 1em; word-wrap: break-word; box-shadow: 0 1px 2px rgba(0,0,0,.05); overflow-wrap: break-word; }
        .u-msg { background: #e3f2fd; color: var(--text-pri); border-bottom-right-radius: 5px; }
        .a-msg { background: var(--sb-bg); border-bottom-left-radius: 5px; }
        .msg > *:first-child { margin-top: 0; } .msg > *:last-child { margin-bottom: 0; }
        .msg i { font-style: italic; color: var(--text-sec); }
        .msg pre { background: #e0e0e0; padding: 10px; border-radius: 5px; font-size: .9em; margin: .5em 0; white-space: pre-wrap; word-break: break-all; overflow-x: auto; }
        .msg code:not(pre code) { font-family: monospace; background: #e0e0e0; padding: .1em .3em; border-radius: 3px; }
        .msg ul, .msg ol { margin: .5em 0 .5em 20px; padding-left: 10px; }

        /* Input Area (Flex Item) */
        .input-area {
            flex-shrink: 0; /* Prevents shrinking */
            padding: 10px 20px 15px 20px;
            background: var(--input-bg); /* Use input background color */
            border-top: 1px solid var(--border); /* Add separator line */
            display: flex; flex-direction: column; align-items: center; gap: 10px;
        }
        .input-wrap { display: flex; align-items: center; width: 100%; max-width: 750px; background: var(--chat-bg); /* Use chat background for input field itself */ border-radius: 24px; padding: 8px 18px; border: 1px solid var(--border); box-shadow: 0 2px 5px rgba(0,0,0,.05); }
        #u-input { flex-grow: 1; border: none; outline: 0; background: 0 0; font-size: 1em; color: var(--text-pri); }
        #u-input::placeholder { color: var(--text-sec); }
        .input-bottom-row { display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 750px; }
        .input-opts { display: flex; gap: 8px; align-items: center; padding-left: 5px; }
        .input-opts button { padding: 5px 12px; border: 1px solid var(--border); border-radius: 15px; font-size: .8em; background: var(--chat-bg); color: var(--text-sec); }
        .input-opts button.active { border-color: var(--accent); color: var(--accent); background-color: #e3f2fd; }
        #mode-proxy { display: none; /* Hide initially, controlled by JS */ }
        .input-action-buttons { display: flex; gap: 8px; align-items: center; position: relative; }
        #helper-ai-btn { font-size: 1.5em; color: var(--text-sec); line-height: 1; padding: 0 5px; }
        #helper-ai-btn.active { color: var(--accent); }
        #send-btn { background: var(--accent); color: #fff; border-radius: 50%; width: 32px; height: 32px; font-size: 1.1em; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        #helper-ai-btn:hover { color: var(--text-pri); }

        /* Mic Button Styles (Unchanged) */
        #mic-transcribe-btn { display: inline-flex; align-items: center; justify-content: center; padding: 5px 8px; font-size: 0.9em; cursor: pointer; background-color: #2ecc71; color: white; border: none; border-radius: 16px; transition: background-color 0.3s ease, box-shadow 0.3s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.1); min-width: 80px; height: 32px; box-sizing: border-box; }
        #mic-transcribe-btn:hover { background-color: #27ae60; box-shadow: 0 2px 5px rgba(0,0,0,0.15); }
        #mic-transcribe-btn.recording { background-color: #e74c3c; }
        #mic-transcribe-btn.recording:hover { background-color: #c0392b; }
        #mic-transcribe-btn svg { margin-right: 5px; vertical-align: middle; width: 16px; height: 16px; stroke: currentColor; }
        #mic-status { font-size: 0.75em; color: var(--text-sec); margin-left: -5px; margin-right: 5px; white-space: nowrap; max-width: 100px; overflow: hidden; text-overflow: ellipsis; vertical-align: middle; display: inline-block; line-height: 1; }
        #mic-status.error { color: #e74c3c; font-weight: bold; }
        #mic-status.success { color: #27ae60; font-weight: bold; }

        /* Context Menus, Modals, Search Modal (Unchanged) */
        .ctx-menu{position:absolute;z-index:1000;background:#fff;border:1px solid var(--border);border-radius:6px;box-shadow:0 2px 10px rgba(0,0,0,.1);padding:5px 0;min-width:120px;display:none}.ctx-menu div{padding:6px 15px;font-size:.9em;cursor:pointer}.ctx-menu div:hover{background:var(--hover)}.ctx-menu div.disabled{opacity:0.5;cursor:not-allowed;background:transparent!important;}
        .modal{display:none;position:fixed;z-index:1001;left:0;top:0;width:100%;height:100%;overflow:auto;background-color:rgba(0,0,0,.4);align-items:center;justify-content:center;}
        .modal-content{background-color:#fefefe;margin:auto;padding:20px;border:1px solid var(--border);width:80%;max-width:600px;border-radius:8px;max-height:85vh;overflow-y:auto;display:flex;flex-direction:column;}
        .modal-content h3{margin-top:0;border-bottom:1px solid var(--border);padding-bottom:10px;flex-shrink:0;display:flex;justify-content:space-between;align-items:center;}
        .modal-actions{margin-top:20px;text-align:right;flex-shrink:0;} .modal-actions button{padding:8px 15px;border-radius:5px;margin-left:10px;}
        #save-keys-btn,#save-agi-btn{background-color:var(--accent);color:#fff;} #close-modal-btn,#close-agi-modal-btn{background-color:var(--sb-bg);color:var(--text-pri);border:1px solid var(--border);}
        #api-key-inputs label{display:block;margin:10px 0 5px 0;font-weight:500;font-size:.9em;}
        #api-key-inputs textarea{width:100%;padding:8px;border:1px solid var(--border);border-radius:4px;margin-bottom:10px;min-height:40px; resize:vertical;}
        #api-key-inputs .checkbox-container { display: flex; align-items: center; margin-top: 15px; padding-top: 10px; border-top: 1px solid var(--border); }
        #api-key-inputs .checkbox-container label { margin: 0 0 0 5px; font-weight: normal; font-size: .95em; }
        #api-key-inputs .checkbox-container input[type="checkbox"] { margin: 0; width: auto; height: auto; }
        #agi-grid{display:grid;grid-template-columns:repeat(auto-fill, minmax(80px, 1fr));gap:15px;margin-bottom:15px;padding-bottom:10px;border-bottom:1px solid var(--border);max-height:25vh;overflow-y:auto;flex-shrink:0;}
        .agi-item{width:80px;height:80px;border-radius:8px;border:3px solid transparent;cursor:pointer;background-size:cover;background-position:center;background-color:var(--hover);transition:border-color .2s;overflow:hidden;display:flex;align-items:center;justify-content:center;font-size:2.5em;}
        .agi-item img{width:100%;height:100%;object-fit:cover;}
        .agi-item:hover{border-color:#ccc;} .agi-item.selected{border-color:var(--accent);box-shadow:0 0 0 3px var(--accent);}
        #agi-edit-area{display:flex;flex-direction:column;gap:10px;flex-grow:1;overflow-y:auto;}
        #agi-edit-area label{font-weight:500;font-size:.9em;margin-bottom:-5px;}
        #agi-name-edit,#pfp-display-area button{padding:8px;border:1px solid var(--border);border-radius:4px;}
        #prompt-text-edit{width:100%;padding:8px;border:1px solid var(--border);border-radius:4px;min-height:80px;resize:vertical;flex-grow:1;}
        #pfp-display-area{display:flex;align-items:center;gap:10px;}
        #current-pfp{width:30px;height:30px;border-radius:50%;flex-shrink:0;background:var(--sb-bg);display:flex;align-items:center;justify-content:center;font-size:1em;overflow:hidden;}
        #current-pfp img{width:100%;height:100%;object-fit:cover;}
        #generate-pfp-btn { font-size: 0.85em; padding: 6px 10px; flex-grow: 1;}
        #delete-agi-btn { background-color: #fdd; color: #c53030; font-size: 0.85em; padding: 6px 10px; } #delete-agi-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        #helper-menu { position: absolute; bottom: 100%; right: 45px; background: #fff; border: 1px solid var(--border); border-radius: 6px; box-shadow: 0 2px 10px rgba(0,0,0,.1); padding: 5px 0; min-width: 140px; z-index: 10; display: none; margin-bottom: 5px; /* Add margin to prevent overlap */ }
        #helper-menu div { padding: 6px 15px; font-size: .9em; cursor: pointer; white-space: nowrap; }
        #helper-menu div:hover { background: var(--hover); }
        #helper-menu div.selected { background-color: #e0e0e0; font-weight: bold; }
        #helper-prompt-wrap { width: 100%; max-width: 750px; margin-top: -5px; margin-bottom: 5px; display: none; }
        #helper-prompt-input { width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 10px; font-size: .9em; min-height: 40px; resize: vertical; }
        #edit-indicator{display:none;font-size:.8em;color:var(--text-sec);background:var(--sb-bg);padding:2px 8px;border-radius:10px;border:1px solid var(--border);margin-bottom:5px;align-self:flex-start;margin-left:5px;}#edit-indicator button{font-size:1.1em;margin-left:5px;color:var(--text-sec);line-height:1;}
        #searchModalOverlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 1002; align-items: center; justify-content: center; padding: 15px; }
        #searchModalContent { background: #fff; width: 100%; height: 100%; max-width: 1200px; max-height: 90vh; display: flex; flex-direction: column; position: relative; padding: 0; box-shadow: 0 5px 15px rgba(0,0,0,0.3); border-radius: 6px; overflow: hidden; border: 1px solid var(--border); }
        #searchModalHeader { padding: 5px 10px; display: flex; justify-content: flex-end; background: var(--sb-bg); border-bottom: 1px solid var(--border); flex-shrink: 0; height: 35px; }
        #closeSearchModalBtn { background: none; border: none; font-size: 1.6em; cursor: pointer; padding: 0 5px; line-height: 1; color: var(--text-sec); }
        #closeSearchModalBtn:hover { color: var(--text-pri); }
        #searchFrameContainer { flex-grow: 1; overflow: auto; padding: 0; background-color: #ccc; }
        #searchFrame { border: none; width: 100%; height: 100%; display: block; }
    </style>
</head>
<body>
    <!-- SVG Icon Definition (Unchanged) -->
    <svg width="0" height="0" style="position:absolute"><symbol id="w-icon" viewBox="0 0 512 512"><path d="M480 169c-27-8-60-4-85 11l-42 25c-19 11-36 25-50 41l-5 5c-13 14-31 23-51 23s-37-8-51-23l-5-5c-14-16-31-30-50-41l-42-25c-25-15-58-19-85-11C-1 177-3 231 24 258l23 24c11 11 26 18 41 19l11 102c1 16 11 29 24 36 7 3 14 5 22 5s16-2 22-6c14-9 23-24 23-40v-85h68v85c0 16 9 31 23 40 7 4 15 6 22 6s15-2 22-5c13-7 23-20 24-36l11-102c16-1 30-8 41-19l24-24C515 231 513 177 480 169zM384 320c-18 0-32-14-32-32s14-32 32-32 32 14 32 32-14 32-32 32zm-256 0c-18 0-32-14-32-32s14-32 32-32 32 14 32 32-14 32-32 32z"/></symbol></svg>

    <div class="app" id="app-cont">
        <!-- Sidebar (Unchanged HTML Structure) -->
        <div class="sidebar">
            <div class="sidebar-header">History</div><ul id="hist-list"></ul>
            <div class="sidebar-footer">
                <button id="agi-btn" onclick="showAgiModal()" title="AGIs">üë§</button>
                <button id="api-key-btn" onclick="showApiKeyModal()" title="API Keys">üîë</button>
            </div>
        </div>
        <!-- Chat Area (Unchanged HTML Structure, CSS modified) -->
        <div class="chat-area">
             <div class="chat-header"><button id="sidebar-toggle" onclick="toggleSidebar()" title="Toggle Sidebar">&#9776;</button><h2 id="chat-title">New Chat</h2><button id="new-chat" onclick="startNewChat()" title="New Chat">+</button></div>
             <div id="chat-cont" oncontextmenu="showMessageCtxMenu(event)"><div class="init-welcome"><svg><use href="#w-icon"/></svg><h1>Ready</h1><p>Select mode & start.</p></div></div>
             <div class="input-area">
                 <div id="edit-indicator">Editing... <button onclick="cancelEdit()">‚úñ</button></div>
                 <div id="helper-prompt-wrap"><textarea id="helper-prompt-input" placeholder="Helper AI System Prompt (applies to selected helper)"></textarea></div>
                 <div class="input-wrap"><input type="text" id="u-input" placeholder="Enter message..."></div>
                 <div class="input-bottom-row">
                    <div class="input-opts">
                        <button id="mode-deepthinking" onclick="selectMode('deepThinking')">üí° DeepThinking</button>
                        <button id="mode-turbo" onclick="selectMode('turbo')">‚ö° Turbo</button>
                        <button id="mode-proxy" onclick="selectMode('proxy')">üåê Proxy</button>
                    </div>
                    <div class="input-action-buttons">
                        <button id="helper-ai-btn" onclick="toggleHelperMenu()" title="Helper AI Settings">+</button>
                        <span id="mic-status"></span>
                        <button id="mic-transcribe-btn" title="Transcribe Audio">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                                <line x1="12" y1="19" x2="12" y2="22"></line>
                            </svg>
                            <span class="mic-btn-text">Record</span>
                        </button>
                        <button id="send-btn" onclick="sendMessage()" title="Send">‚Üë</button>
                        <div id="helper-menu" class="ctx-menu" onclick="handleHelperMenuClick(event)">
                            <div data-key="null">‚õî No Helper</div>
                            <div data-key="set">‚öôÔ∏è Set Prompt</div>
                            <div data-key="DEEPSEEK">ü¶æ DeepSeek Helper</div>
                            <div data-key="SAMBANOVA">‚ö° SambaNova Helper</div>
                            <div data-key="GEMINI">üí° Gemini Helper</div>
                            <hr style="margin: 3px 0; border: none; border-top: 1px solid var(--border);">
                            <div data-key="ai-search">üîé AI Search</div>
                            <div data-key="ai-deep-dive">üß† AI Deep Dive</div>
                        </div>
                    </div>
                 </div>
             </div>
        </div>
    </div>
    <!-- CONTEXT MENUS (Unchanged) -->
    <div id="hist-ctx-menu" class="ctx-menu"><div data-action="rename">Rename</div><div data-action="delete">Delete</div></div>
    <div id="msg-ctx-menu" class="ctx-menu"><div data-action="copy">Copy</div><div data-action="edit">Edit</div><div data-action="regenerate">Regenerate</div></div>
    <!-- MODALS (Unchanged HTML Structure) -->
    <div id="api-key-modal" class="modal"><div class="modal-content"><h3>API Keys</h3><div id="api-key-inputs"></div><div class="modal-actions"><button id="close-modal-btn" onclick="hideApiKeyModal()">Cancel</button><button id="save-keys-btn" onclick="saveApiKeys()">Save Keys</button></div></div></div>
    <div id="agi-modal" class="modal"><div class="modal-content"><h3>AGIs <button onclick="addNewAgi()" title="Add New AGI" style="font-size: 1.2em; padding: 0 5px;">+</button></h3><div id="agi-grid"></div><div id="agi-edit-area"><label for="agi-name-edit">Name:</label><input type="text" id="agi-name-edit"><label for="prompt-text-edit">System Prompt:</label><textarea id="prompt-text-edit"></textarea><label>PFP:</label><div id="pfp-display-area"><span id="current-pfp">‚ùì</span><button id="generate-pfp-btn" onclick="generatePfp()">Generate</button></div><button id="delete-agi-btn" onclick="deleteSelectedAgi()">Delete AGI</button></div><div class="modal-actions"><button id="close-agi-modal-btn" onclick="hideAgiModal()">Cancel</button><button id="save-agi-btn" onclick="saveAgiSelection()">Save & Select</button></div></div></div>
    <div id="searchModalOverlay">
         <div id="searchModalContent">
            <div id="searchModalHeader"><button id="closeSearchModalBtn" title="Close" onclick="closeSearchModal()">&times;</button></div>
            <div id="searchFrameContainer"><iframe id="searchFrame" src="about:blank" title="External App Module"></iframe></div>
         </div>
    </div>

    <script>
        // --- API Config & Call Logic (Unchanged JS) ---
        const PROVIDERS = { BIGMODEL_PROXY: { name: "BigModel (via Proxy)", format: "proxy_compatible", baseURL: "/api/proxy", availableModels: ["glm-4-flash"], defaultModel: "glm-4-flash", apiKeyLocation: "none", supportsSystemPromptInMessages: true, supportsImages: false, }, SAMBANOVA: { name: "SambaNova", format: "openai_compatible", baseURL: "https://api.sambanova.ai/v1/chat/completions", availableModels: ["DeepSeek-V3-0324"], defaultModel: "DeepSeek-V3-0324", apiKeyLocation: "header", authHeaderPrefix: "Bearer ", supportsSystemPromptInMessages: true, supportsImages: false, }, GEMINI: { name: "Gemini", format: "gemini_generateContent", baseURL: "https://generativelanguage.googleapis.com/v1beta/models/", availableModels: ["gemini-2.5-pro-exp-03-25"], defaultModel: "gemini-2.5-pro-exp-03-25", apiKeyLocation: "query", apiKeyQueryParam: "key", supportsSystemPromptInMessages: false, systemInstructionKey: "system_instruction", supportsImages: true, }, DEEPSEEK: { name: "DeepSeek", format: "openai_compatible", baseURL: "https://api.deepseek.com/v1/chat/completions", availableModels: ["deepseek-chat", "deepseek-reasoner"], defaultModel: "deepseek-chat", apiKeyLocation: "header", authHeaderPrefix: "Bearer ", supportsSystemPromptInMessages: true, supportsImages: false, }, };
        const GEMINI_IMG_MODEL="gemini-2.0-flash-exp-image-generation";
        function transformHistoryForGemini(conversationHistory) { const contents = []; let systemInstruction = null; if (conversationHistory.length > 0 && conversationHistory[0].role === 'system') { systemInstruction = conversationHistory[0].content; } const historyToProcess = conversationHistory.slice(systemInstruction ? 1 : 0); historyToProcess.forEach(msg => { if (!msg || !msg.role) { console.warn("[API Provider] Skipping invalid message:", msg); return; } let role = msg.role === 'assistant' ? 'model' : msg.role; let parts = []; if (msg.role === 'user') { if (msg.content && typeof msg.content === 'string' && msg.content.trim() !== '') parts.push({ text: msg.content }); if (Array.isArray(msg.images) && msg.images.length > 0) { msg.images.forEach(img => { if (img && img.mimeType && img.data) parts.push({ inlineData: { mimeType: img.mimeType, data: img.data } }); else console.warn("[API Provider] Skipping invalid image data:", img); }); } } else if (msg.role === 'assistant') { const assistantContent = msg.content || msg.variants?.[msg.selectedIndex ?? 0]; if (assistantContent !== undefined && assistantContent !== null) parts.push({ text: String(assistantContent) }); } if (parts.length > 0) contents.push({ role: role, parts: parts }); else console.warn(`[API Provider] Skipping message with no valid parts (role: ${msg.role}):`, msg); }); return { contents, systemInstruction }; }
        async function getApiResponse(providerName, conversationHistory, apiKey, options = {}) { console.log(`[API Provider] Requesting completion from ${providerName}.`); const providerConfig = PROVIDERS[providerName]; if (!providerConfig) throw new Error(`Config for provider "${providerName}" not found.`); const modelToUse = options.model || providerConfig.defaultModel; if (!modelToUse) throw new Error(`No model specified or defaulted for provider "${providerName}".`); const requiresApiKey = providerConfig.format !== 'proxy_compatible' && providerConfig.apiKeyLocation !== 'none'; if (requiresApiKey && !apiKey) throw new Error(`API Key missing for provider "${providerName}".`); const historyHasImages = conversationHistory.some(msg => msg.role === 'user' && Array.isArray(msg.images) && msg.images.length > 0); if (historyHasImages && !providerConfig.supportsImages) { console.error(`[API Provider] Attempted to send images to provider "${providerName}" which does not support them.`); throw new Error(`Provider "${providerName}" does not support image input.`); } let requestURL; const headers = { 'Content-Type': 'application/json' }; let requestBody; try { let processedHistory; if (providerConfig.format === "gemini_generateContent") { processedHistory = transformHistoryForGemini(conversationHistory); } else { processedHistory = conversationHistory .filter(msg => msg && msg.role && (typeof msg.content === 'string' || (msg.role === 'system' && typeof msg.content === 'string') || msg.role === 'assistant')) .filter(msg => providerConfig.supportsSystemPromptInMessages || msg.role !== 'system') .map(msg => ({ role: msg.role, content: msg.content || "" })); } if (providerConfig.format === "proxy_compatible") { requestURL = providerConfig.baseURL; requestBody = { model: modelToUse, messages: processedHistory, temperature: options.temperature ?? 0.7, stream: options.stream ?? false }; } else if (providerConfig.format === "openai_compatible") { requestURL = providerConfig.baseURL; if (providerConfig.apiKeyLocation === "header") headers['Authorization'] = `${providerConfig.authHeaderPrefix || ''}${apiKey}`; requestBody = { model: modelToUse, messages: processedHistory, stream: options.stream ?? false, temperature: options.temperature ?? 0.7, top_p: options.top_p ?? 0.9 }; } else if (providerConfig.format === "gemini_generateContent") { requestURL = `${providerConfig.baseURL}${modelToUse}:generateContent`; if (providerConfig.apiKeyLocation === "query") requestURL += `?${providerConfig.apiKeyQueryParam}=${apiKey}`; const { contents, systemInstruction } = processedHistory; if (contents.length === 0 && !systemInstruction) throw new Error("Empty history/prompt Gemini"); requestBody = { contents: contents, generationConfig: { temperature: options.temperature ?? 0.7, topP: options.top_p ?? 0.9 } }; if (systemInstruction && providerConfig.systemInstructionKey) requestBody[providerConfig.systemInstructionKey] = { parts: [{ text: systemInstruction }] }; else if (systemInstruction) console.warn(`[API Provider] Sys instruction found but no 'systemInstructionKey' for Gemini.`); } else { throw new Error(`Unsupported provider format: ${providerConfig.format}`); } } catch (error) { console.error(`[API Provider] Error preparing request for ${providerName}:`, error); throw error; } console.log(`[API Provider] Calling URL: ${requestURL}`); try { const response = await fetch(requestURL, { method: 'POST', headers: headers, body: JSON.stringify(requestBody) }); if (!response.ok) { let errorData, errorMessage = `API Error ${response.status}: ${response.statusText}`; try { errorData = await response.json(); console.error(`[API Provider] ${providerName} Error Body:`, errorData); errorMessage = errorData.error?.message || errorData.message || errorData.details?.[0]?.message || errorData.detail || (typeof errorData === 'string' ? errorData : JSON.stringify(errorData)) || errorMessage; } catch (jsonError) { try { const textError = await response.text(); if (textError) errorMessage = textError; } catch(textErr) {} } console.error(`[API Provider] Fetch failed for ${providerName}: Status ${response.status}, Message: ${errorMessage}`); throw new Error(errorMessage); } const data = await response.json(); let messageContent = null; if (providerConfig.format === "openai_compatible" || providerConfig.format === "proxy_compatible") messageContent = data.choices?.[0]?.message?.content; else if (providerConfig.format === "gemini_generateContent") { if (data.promptFeedback?.blockReason) { console.warn(`[API Provider] Gemini request blocked: ${data.promptFeedback.blockReason}`); throw new Error(`Content blocked by API: ${data.promptFeedback.blockReason}`); } if (!data.candidates || data.candidates.length === 0) { const candidateBlockReason = data.candidates?.[0]?.promptFeedback?.blockReason; if(candidateBlockReason) throw new Error(`Content blocked by API: ${candidateBlockReason}`); throw new Error(`Invalid API response from ${providerName}: No candidates.`); } messageContent = data.candidates[0]?.content?.parts?.[0]?.text; const finishReason = data.candidates[0]?.finishReason; if (finishReason && finishReason !== "STOP" && finishReason !== "MAX_TOKENS") { console.warn(`[API Provider] Gemini finished unexpectedly: ${finishReason}`); if (messageContent != null) messageContent += `\n\n(Note: Generation finished due to ${finishReason})`; else throw new Error(`Generation failed/stopped: ${finishReason}`); } } if (messageContent === null || messageContent === undefined) { console.error(`[API Provider] Invalid response structure from ${providerName}. Data:`, data); throw new Error(`Invalid API response from ${providerName}: Could not find message content.`); } if (messageContent === "") console.warn(`[API Provider] Received empty string from ${providerName}.`); console.log(`[API Provider] Received successful response from ${providerName}.`); return messageContent; } catch (error) { console.error(`[API Provider] Error during API call to ${providerName}:`, error); if (error instanceof Error) throw error; else throw new Error(String(error)); } }

        // --- DOM Refs & State ---
        const chatCont=document.getElementById('chat-cont'),uInput=document.getElementById('u-input'),histList=document.getElementById('hist-list'),initWelcome=document.querySelector('.init-welcome'),chatTitle=document.getElementById('chat-title'),histCtxMenu=document.getElementById('hist-ctx-menu'),msgCtxMenu=document.getElementById('msg-ctx-menu'),appCont=document.getElementById('app-cont'),apiKeyModal=document.getElementById('api-key-modal'),keyInputsCont=document.getElementById('api-key-inputs'),btnDT=document.getElementById('mode-deepthinking'),btnTurbo=document.getElementById('mode-turbo'), btnProxy=document.getElementById('mode-proxy');
        const agiModal=document.getElementById('agi-modal'),agiGrid=document.getElementById('agi-grid'),agiNameEdit=document.getElementById('agi-name-edit'),promptEdit=document.getElementById('prompt-text-edit'),currentPfpDisp=document.getElementById('current-pfp'),delAgiBtn=document.getElementById('delete-agi-btn');
        const helperBtn=document.getElementById('helper-ai-btn'),helperMenu=document.getElementById('helper-menu'),helperPromptWrap=document.getElementById('helper-prompt-wrap'),helperPromptInput=document.getElementById('helper-prompt-input');
        const editIndicator = document.getElementById('edit-indicator');
        const searchModalOverlay = document.getElementById('searchModalOverlay');
        const searchFrame = document.getElementById('searchFrame');
        const micTranscribeBtn = document.getElementById('mic-transcribe-btn');
        const micButtonText = micTranscribeBtn.querySelector('.mic-btn-text');
        const micStatusSpan = document.getElementById('mic-status');

        let msgHist=[],currentChatName=null,ctxTargetName=null,ctxTargetMsgIndex=null,currentMode='proxy',currentAgiKey=null,selectedAgiKeyInModal=null; // Default mode to proxy
        let helperAiKey=null, helperAiPrompt='';
        let editingMsgIndex = null;
        let serperApiKey = '';
        let showProxyButton = true; // Default showProxyButton to true

        // --- Storage & Helpers ---
        const CHAT_STORE='chats_v11',KEY_STORE='keys_v7',GOOD_KEY_IDX_STORE='goodKeyIdx_v4',AGI_STORE='agis_v1',ACTIVE_AGI_STORE='activeAgi_v1';
        const SERPER_KEY_STORE = 'serper_key_v1';
        const SHOW_PROXY_STORE = 'showProxy_v1';
        const SEARCH_APP_URL = './ai_search.html';
        const DEEP_DIVE_APP_URL = './ai-deep-dive.html';
        const getChats=()=>JSON.parse(localStorage.getItem(CHAT_STORE)||'{}');const saveChats=(c)=>localStorage.setItem(CHAT_STORE,JSON.stringify(c));const getApiKeys=()=>JSON.parse(localStorage.getItem(KEY_STORE)||'{}');const saveApiKeysToStorage=(k)=>localStorage.setItem(KEY_STORE,JSON.stringify(k));const getGoodKeyIndices=()=>JSON.parse(localStorage.getItem(GOOD_KEY_IDX_STORE)||'{}');const saveGoodKeyIndices=(i)=>localStorage.setItem(GOOD_KEY_IDX_STORE,JSON.stringify(i));
        const getAgis=()=>JSON.parse(localStorage.getItem(AGI_STORE)||'{}');const saveAgis=(p)=>localStorage.setItem(AGI_STORE,JSON.stringify(p));const getActiveAgiKey=()=>localStorage.getItem(ACTIVE_AGI_STORE)||null;const saveActiveAgiKey=(k)=>localStorage.setItem(ACTIVE_AGI_STORE,k);const genName=()=>`c_${Date.now()}`;const genTitle=(h)=>h?.[0]?.role==='user'?h[0].content.substring(0,25)+(h[0].content.length>25?'‚Ä¶':''):"Chat";
        const copyToClipboard=(t)=>{const ta=document.createElement('textarea');ta.value=t;ta.style.position='fixed';ta.style.top='-9999px';ta.style.left='-9999px';ta.style.opacity='0';document.body.appendChild(ta);ta.focus();ta.select();try{document.execCommand('copy')?alert('Copied!'):alert('Copy failed.');}catch(err){console.error('Copy fail:',err);alert('Error copy.');}document.body.removeChild(ta);};

        // --- UI ---
        const updateHistList=()=>{const c=getChats();histList.innerHTML='';Object.keys(c).sort((a,b)=>(c[b].ts||0)-(c[a].ts||0)).forEach(n=>{const li=document.createElement('li');li.textContent=c[n].title||n;li.dataset.name=n;if(n===currentChatName)li.classList.add('active');li.onclick=()=>loadChat(n);li.oncontextmenu=showHistCtxMenu;histList.appendChild(li)})};
        const checkWelcome=()=>{initWelcome.style.display=msgHist.length>0?'none':'flex';chatCont.style.justifyContent=msgHist.length>0?'flex-start':'center';};
        const appendMsg=(ct,r,s=true,t=false,idx=null)=>{const w=document.createElement('div');w.className=`msg-wrap ${r==='user'?'u':'a'}-msg-wrap`;if(idx!==null)w.dataset.msgIndex=idx;w.dataset.rawContent=ct; const m=document.createElement('div');m.className=`msg ${r==='user'?'u':'a'}-msg`;if(r==='assistant'&&!t){const p=document.createElement('div');p.className='a-pfp';const agis=getAgis();const aData=currentAgiKey?agis[currentAgiKey]:null;const pfp=aData?.pfp;if(pfp?.startsWith('data:image')||pfp?.startsWith('http')){p.innerHTML=`<img src="${pfp}" alt="PFP">`;}else if(pfp){p.textContent=pfp;}else{p.innerHTML=`<svg><use href="#w-icon"/></svg>`;}w.appendChild(p);}try{m.innerHTML=t?ct:marked.parse(ct||"");}catch(e){console.warn("Marked err:",e);m.textContent=ct||"";}if(t)m.style.opacity='0.6';w.appendChild(m);chatCont.appendChild(w);if(s)chatCont.scrollTop=chatCont.scrollHeight;checkWelcome();return t?w:null};
        const rerenderChat=()=>{chatCont.innerHTML='';msgHist.forEach((m,i)=>appendMsg(m.content,m.role,false,false,i));checkWelcome();chatCont.scrollTop=chatCont.scrollHeight;};

        // --- Chat Management ---
        const saveUpdateChat=(n,h)=>{if(!n||h.length===0)return;const c=getChats();c[n]={ctx:h,title:genTitle(h),ts:Date.now()};saveChats(c);if(n===currentChatName)updateHistList()};
        const loadChat=(n)=>{
            let chatToLoad = n;
            // If no specific chat requested, find the latest one
            if (!chatToLoad) {
                const sortedChats = Object.entries(getChats()).sort(([,a],[,b])=>(b.ts||0)-(a.ts||0));
                if (sortedChats.length > 0) {
                    chatToLoad = sortedChats[0][0]; // Get the name of the latest chat
                }
            }

            if (!chatToLoad) return startNewChat(); // If still no chat (empty history), start new

            const c=getChats()[chatToLoad];
            if(c?.ctx){
                chatCont.innerHTML=''; msgHist=c.ctx; currentChatName=chatToLoad;
                chatTitle.textContent=c.title||chatToLoad;
                msgHist.forEach((m,i)=>appendMsg(m.content,m.role,false,false,i));
                checkWelcome(); chatCont.scrollTop=chatCont.scrollHeight; updateHistList(); cancelEdit();
            } else {
                startNewChat(); // Fallback if chat data is invalid
            }
        };
        const renameChat=(n)=>{const c=getChats();if(!c[n])return;const t=prompt("Rename:",c[n].title||n)?.trim();if(t){c[n].title=t;c[n].ts=Date.now();saveChats(c);if(n===currentChatName)chatTitle.textContent=t;updateHistList()}};
        const deleteChat=(n)=>{const c=getChats();if(!c[n]||!confirm(`Delete "${c[n].title||n}"?`))return;delete c[n];saveChats(c);if(n===currentChatName)startNewChat();updateHistList()};
        const startNewChat=()=>{
            chatCont.innerHTML='';msgHist=[];currentChatName=null;
            chatTitle.textContent="New Chat";checkWelcome();updateHistList();
            uInput.focus();
            selectMode('proxy', true); // Default to proxy mode on new chat, force selection
            selectHelperAi(null); helperPromptWrap.style.display = 'none'; cancelEdit();
        };

        // --- Proxy Button Visibility ---
        const updateProxyButtonVisibility = () => {
            const storedPreference = localStorage.getItem(SHOW_PROXY_STORE);
            // Default to true if no preference is stored yet
            showProxyButton = storedPreference === null ? true : storedPreference === 'true';
            btnProxy.style.display = showProxyButton ? 'inline-block' : 'none';
            console.log("Proxy button visibility updated:", showProxyButton);
             // If proxy mode was active but button is now hidden, revert to a visible mode
            if (currentMode === 'proxy' && !showProxyButton) {
                 console.log("Proxy button hidden while active, switching mode.");
                 selectMode('deepThinking', true); // Switch to another mode (e.g., DeepThinking)
            }
        };

        // --- API Key Modal Logic ---
        const showApiKeyModal = () => {
            keyInputsCont.innerHTML = '';
            const providerKeys = getApiKeys();
            Object.entries(PROVIDERS).forEach(([pk, pc]) => {
                if (pc.apiKeyLocation !== 'none' && pc.format !== 'proxy_compatible') {
                    const d = document.createElement('div');
                    d.innerHTML = `<label for="k-${pk}">${pc.name}</label><textarea id="k-${pk}" data-provider="${pk}" rows="2" placeholder="One API Key per line">${(providerKeys[pk] || []).join('\n')}</textarea>`;
                    keyInputsCont.appendChild(d);
                }
            });
            const serperDiv = document.createElement('div');
            serperDiv.innerHTML = `<label for="k-serper">Serper (for AI Search)</label><textarea id="k-serper" data-keytype="serper" rows="1" placeholder="Serper.dev API Key">${serperApiKey}</textarea>`;
            keyInputsCont.appendChild(serperDiv);

            // Use the current state of showProxyButton for the checkbox default
            const proxyCheckboxDiv = document.createElement('div');
            proxyCheckboxDiv.className = 'checkbox-container';
            proxyCheckboxDiv.innerHTML = `
                <input type="checkbox" id="show-proxy-checkbox" ${showProxyButton ? 'checked' : ''}>
                <label for="show-proxy-checkbox">Show Proxy Mode Button</label>
            `;
            keyInputsCont.appendChild(proxyCheckboxDiv);

            apiKeyModal.style.display = 'flex';
        };
        const hideApiKeyModal = () => { apiKeyModal.style.display = 'none' };
        const saveApiKeys = () => {
            const tas = keyInputsCont.querySelectorAll('textarea');
            const newProviderKeys = {}; let foundSerperKey = '';
            tas.forEach(ta => {
                const provider = ta.dataset.provider; const keyType = ta.dataset.keytype;
                const keyContent = ta.value.trim();
                if (keyType === 'serper') foundSerperKey = keyContent;
                else if (provider) { const keys = keyContent.split('\n').map(k => k.trim()).filter(Boolean); if (keys.length > 0) newProviderKeys[provider] = keys; }
            });
            saveApiKeysToStorage(newProviderKeys);
            serperApiKey = foundSerperKey;
            if (serperApiKey) localStorage.setItem(SERPER_KEY_STORE, serperApiKey);
            else localStorage.removeItem(SERPER_KEY_STORE);

            const proxyCheckbox = document.getElementById('show-proxy-checkbox');
            // Read the *new* checkbox state to save and update visibility
            const shouldShowProxy = proxyCheckbox.checked;
            localStorage.setItem(SHOW_PROXY_STORE, shouldShowProxy);
            updateProxyButtonVisibility(); // Update button visibility based on saved state

            hideApiKeyModal();
            alert('Keys & Settings saved!');
        };

        // --- AGI Modal Logic (Unchanged) ---
        const populateAgiGrid=()=>{agiGrid.innerHTML='';const agis=getAgis();Object.keys(agis).forEach(k=>{const d=agis[k];const i=document.createElement('div');i.className='agi-item';i.dataset.key=k;const f=d.pfp;if(f?.startsWith('data:image')||f?.startsWith('http'))i.innerHTML=`<img src="${f}" alt="">`;else i.textContent=f||'?';if(k===selectedAgiKeyInModal)i.classList.add('selected');i.onclick=()=>handleAgiItemClick(k);agiGrid.appendChild(i)})};const showAgiModal=()=>{selectedAgiKeyInModal=currentAgiKey||Object.keys(getAgis())[0]||null;populateAgiGrid();updateAgiEditArea(selectedAgiKeyInModal);agiModal.style.display='flex'};const hideAgiModal=()=>{agiModal.style.display='none';selectedAgiKeyInModal=null;};const updateAgiEditArea=(k)=>{const agis=getAgis();const d=k?agis[k]:null;agiNameEdit.value=d?.name||'';promptEdit.value=d?.prompt||'';const f=d?.pfp;if(f?.startsWith('data:image')||f?.startsWith('http'))currentPfpDisp.innerHTML=`<img src="${f}" alt="">`;else currentPfpDisp.textContent=f||'‚ùì';delAgiBtn.disabled=!k;agiNameEdit.disabled=!k;promptEdit.disabled=!k;document.getElementById('generate-pfp-btn').disabled=!k;};const handleAgiItemClick=(key)=>{selectedAgiKeyInModal=key;updateAgiEditArea(key);agiGrid.querySelectorAll('.agi-item').forEach(el=>el.classList.toggle('selected',el.dataset.key===key));};const addNewAgi=()=>{const a=getAgis();const k=`a_${Date.now()}`;a[k]={name:"New",prompt:"",pfp:"‚ùì"};saveAgis(a);selectedAgiKeyInModal=k;populateAgiGrid();updateAgiEditArea(k);agiNameEdit.focus();agiNameEdit.select();};
        const generatePfp=async()=>{const name=agiNameEdit.value.trim();if(!name){alert("Enter AGI name.");return;} const pKey='GEMINI'; const keys=getApiKeys()[pKey]||[]; const cfg=PROVIDERS[pKey]; if(cfg.apiKeyLocation!=='none'&&keys.length===0){alert(`Key missing ${cfg.name}.Use üîë.`);showApiKeyModal();return;} const apiKey=keys[0];if(cfg.apiKeyLocation!=='none'&&!apiKey){alert(`No key for ${cfg.name}.`);return;} const prompt=`Generate a profile picture for "${name}". IMPORTANT: ONLY return the generated image data. DO NOT include ANY text. Style: simple icon, vector art, PNG.`; let url=`${cfg.baseURL}${GEMINI_IMG_MODEL}:generateContent?${cfg.apiKeyQueryParam}=${apiKey}`; currentPfpDisp.textContent='‚è≥'; try{const res=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({contents:[{parts:[{text:prompt}]}],generationConfig:{response_modalities:["IMAGE","TEXT"]}})}); if(!res.ok){let m=`API Err ${res.status}`;try{const d=await res.json();m=d.error?.message||d.message||JSON.stringify(d);}catch{}throw new Error(m);} const data=await res.json();const imgPart=data.candidates?.[0]?.content?.parts?.find(p=>p.inlineData); if(!imgPart?.inlineData?.data){const txtPart=data.candidates?.[0]?.content?.parts?.find(p=>p.text);console.warn("Img gen txt:",txtPart?.text);throw new Error("No image data."+(txtPart?.text?"Txt:"+txtPart.text.substring(0,50)+"...":""));} const imgUrl=`data:${imgPart.inlineData.mimeType};base64,${imgPart.inlineData.data}`;currentPfpDisp.innerHTML=`<img src="${imgUrl}" alt="PFP">`; }catch(err){console.error("PFP Gen fail:",err);alert(`PFP gen failed:${err.message}`);currentPfpDisp.textContent='‚ùì';}};
        const deleteSelectedAgi=()=>{const k=selectedAgiKeyInModal;if(!k||!confirm(`Delete AGI "${getAgis()[k]?.name||k}"?`))return;const a=getAgis();delete a[k];saveAgis(a);if(currentAgiKey===k){currentAgiKey=null;saveActiveAgiKey('');}selectedAgiKeyInModal=currentAgiKey||Object.keys(getAgis())[0]||null;populateAgiGrid();updateAgiEditArea(selectedAgiKeyInModal);};const saveAgiSelection=()=>{console.log("Saving AGI Selection for key:", selectedAgiKeyInModal);const key=selectedAgiKeyInModal;if(!key){hideAgiModal();return};const agis=getAgis();const name=agiNameEdit.value.trim();const prompt=promptEdit.value.trim();const pfpEl=currentPfpDisp.querySelector('img');const pfpVal=pfpEl?pfpEl.src:(currentPfpDisp.textContent.trim()||null);if(!agis[key])agis[key]={};agis[key].name=name||"Unnamed";agis[key].prompt=prompt;agis[key].pfp=(pfpVal==='‚ùì'||pfpVal==='üë§')?null:pfpVal;saveAgis(agis);currentAgiKey=key;saveActiveAgiKey(key);console.log("AGI set:",key);hideAgiModal();};

        // --- Mode Selection (Updated for Defaulting and Forcing) ---
        const selectMode = (m, force = false) => {
            // Don't select proxy if button isn't visible, unless forced (like on init/new chat)
            if (m === 'proxy' && !showProxyButton && !force) {
                console.warn("Attempted to select hidden proxy mode.");
                return;
            }
            // Toggle off if same mode clicked, unless forced
            currentMode = (currentMode === m && !force) ? 'default' : m;

            // Handle 'default' case explicitly - maybe default to proxy if visible?
            if (currentMode === 'default') {
                currentMode = showProxyButton ? 'proxy' : 'deepThinking'; // Fallback if proxy hidden
                console.log("Default mode selected, switching to:", currentMode);
            }

            btnDT.classList.toggle('active', currentMode === 'deepThinking');
            btnTurbo.classList.toggle('active', currentMode === 'turbo');
            // Only toggle proxy active if it's visible OR if it's the current mode being set
            if (showProxyButton || currentMode === 'proxy') {
                 btnProxy.classList.toggle('active', currentMode === 'proxy');
            }
            console.log("Mode set to:", currentMode);
        };


        // --- Helper AI UI (Unchanged) ---
        const toggleHelperMenu = () => { helperMenu.style.display = (helperMenu.style.display === 'block') ? 'none' : 'block'; };
        const handleHelperMenuClick = (event) => { const targetDiv = event.target.closest('div[data-key]'); if (!targetDiv) return; const key = targetDiv.dataset.key; toggleHelperMenu(); if (key === 'set') { toggleHelperPromptInput(); } else if (key === 'ai-search') { openAiSearch(); } else if (key === 'ai-deep-dive') { openAiDeepDive(); } else { selectHelperAi(key === 'null' ? null : key); } };
        const selectHelperAi = (key) => { helperAiKey = key; helperMenu.querySelectorAll('div[data-key]').forEach(div => { if (div.dataset.key !== 'set' && div.dataset.key !== 'ai-search' && div.dataset.key !== 'ai-deep-dive') { div.classList.toggle('selected', div.dataset.key === (key || 'null')); } }); helperBtn.classList.toggle('active', !!key); helperPromptWrap.style.display = 'none'; console.log("Helper AI selected:", key); };
        const toggleHelperPromptInput = () => { const isVisible = helperPromptWrap.style.display === 'block'; helperPromptWrap.style.display = isVisible ? 'none' : 'block'; if (!isVisible) { helperPromptInput.focus(); } };
        const updateHelperPrompt = () => { helperAiPrompt = helperPromptInput.value.trim(); };

        // --- Core API Call Logic (Unchanged) ---
        const callAndProcessMainApi = async (hist, userMsgContentForHist) => { let mainPK; let modelNameForError = ''; if (currentMode === 'deepThinking') { mainPK = 'GEMINI'; modelNameForError = 'DeepThinking (Gemini)'; } else if (currentMode === 'turbo') { mainPK = 'SAMBANOVA'; modelNameForError = 'Turbo (SambaNova)'; } else if (currentMode === 'proxy') { mainPK = 'BIGMODEL_PROXY'; modelNameForError = 'Proxy (BigModel)'; } else { mainPK = 'DEEPSEEK'; modelNameForError = 'Default (DeepSeek)'; } const mainCfg = PROVIDERS[mainPK]; if (!mainCfg) { console.error(`Invalid mode selected, no provider config for ${mainPK}`); return { error: true, reason: 'config' }; } const mainKeys = getApiKeys()[mainPK] || []; if (mainCfg.apiKeyLocation !== 'none' && mainCfg.format !== 'proxy_compatible' && mainKeys.length === 0) { alert(`Key missing for ${mainCfg.name}. Use üîë.`); showApiKeyModal(); return { error: true, reason: 'key' }; } const historyToSend = [...hist]; const agis = getAgis(); const agiData = currentAgiKey ? agis[currentAgiKey] : null; const sysPromptText = agiData?.prompt || "You are a helpful assistant."; if (sysPromptText && sysPromptText !== "You are a helpful assistant." && (mainCfg.supportsSystemPromptInMessages || mainPK === 'GEMINI')) { historyToSend.unshift({ role: "system", content: sysPromptText }); } const mainTk = appendMsg("<i>Thinking...</i>", 'assistant', true, true); let mainResponse = null, mainError = null, mainKeyUsed = null; const mainGoodIdx = getGoodKeyIndices(); const mainStartIdx = mainGoodIdx[mainPK] ?? 0; const numAttempts = (mainCfg.apiKeyLocation !== 'none' && mainCfg.format !== 'proxy_compatible') ? mainKeys.length : 1; for (let i = 0; i < numAttempts; i++) { let cKey = null; if (numAttempts > 1) { const cIdx = (mainStartIdx + i) % mainKeys.length; cKey = mainKeys[cIdx]; mainKeyUsed = cIdx; console.log(`Try Main ${mainPK} key ${cIdx}`); } else { console.log(`Try Main ${mainPK} (no key or single attempt)`); } try { mainResponse = await getApiResponse(mainPK, historyToSend, cKey, { t: 0.7, p: 0.9 }); if (mainKeyUsed !== null) { mainGoodIdx[mainPK] = mainKeyUsed; saveGoodKeyIndices(mainGoodIdx); console.log(`Main OK key ${mainKeyUsed}`); } else { console.log(`Main OK (${mainPK})`); } break; } catch (err) { console.error(`Main Attempt ${i+1} fail ${mainPK}:`, err); mainError = err; if (mainKeyUsed !== null) console.error(`(Key index: ${mainKeyUsed})`); mainKeyUsed = null; } } if (mainTk && mainTk.parentNode === chatCont) chatCont.removeChild(mainTk); if (mainResponse !== null) { if (userMsgContentForHist) { msgHist.push({ role: "user", content: userMsgContentForHist }); } msgHist.push({ role: "assistant", content: mainResponse }); appendMsg(mainResponse, 'assistant', true, false, msgHist.length - 1); saveUpdateChat(currentChatName, msgHist); if (getChats()[currentChatName]) { chatTitle.textContent = getChats()[currentChatName].title; updateHistList(); } return { error: false }; } else { console.error(`All attempts failed for ${mainPK}. Last Error:`, mainError); const errorMsg = `<i>Error: Call failed for ${modelNameForError}. ${mainError?.message || String(mainError)}</i>`; appendMsg(errorMsg, 'assistant'); return { error: true, message: errorMsg }; } };

        // --- Messaging (Unchanged) ---
        const sendMessage = async () => { const rawUserContent = uInput.value.trim(); if (!rawUserContent && editingMsgIndex === null) { alert("Enter msg"); return } if (editingMsgIndex !== null) { console.log(`Editing message index: ${editingMsgIndex}`); const originalMsgHist = [...msgHist]; const targetIndex = editingMsgIndex; if (targetIndex < 0 || targetIndex >= originalMsgHist.length || originalMsgHist[targetIndex].role !== 'user') { console.error("Cannot edit this index"); cancelEdit(); return; } let modifiedHist = [...originalMsgHist]; modifiedHist[targetIndex].content = rawUserContent; modifiedHist = modifiedHist.slice(0, targetIndex + 1); msgHist = modifiedHist; rerenderChat(); let historyForEdit = [...msgHist]; uInput.value = ''; checkWelcome(); const result = await callAndProcessMainApi(historyForEdit, null); if (result.error) { console.log("Edit failed, rolling back history."); msgHist = originalMsgHist; rerenderChat(); } else { saveUpdateChat(currentChatName, msgHist); } cancelEdit(); return; } let finalUserContent = rawUserContent; if (helperAiKey && helperAiPrompt) { console.log(`Using Helper AI: ${helperAiKey} with context and prompt: "${helperAiPrompt}"`); const helperConfig = PROVIDERS[helperAiKey]; const helperKeys = getApiKeys()[helperAiKey] || []; if (!helperConfig) { console.error("Helper AI config not found for key:", helperAiKey); return; } if (helperConfig.apiKeyLocation !== 'none' && helperConfig.format !== 'proxy_compatible' && helperKeys.length === 0) { alert(`Key missing for Helper ${helperConfig.name}. Use üîë.`); showApiKeyModal(); return; } const thinkingMsg = appendMsg("<i>Helper AI processing...</i>", 'assistant', true, true); let helperMessages = [...msgHist]; if (helperAiPrompt) { helperMessages.unshift({ role: "system", content: helperAiPrompt }); } helperMessages.push({ role: "user", content: rawUserContent }); let helperResponse = null, helperApiError = null; const helperGoodIdx = getGoodKeyIndices(); const helperStartIdx = helperGoodIdx[helperAiKey] ?? 0; const numHelperAttempts = (helperConfig.apiKeyLocation !== 'none' && helperConfig.format !== 'proxy_compatible') ? helperKeys.length : 1; for (let i = 0; i < numHelperAttempts; i++) { let currentKey = null; let currentIdx = null; if (numHelperAttempts > 1) { currentIdx = (helperStartIdx + i) % helperKeys.length; currentKey = helperKeys[currentIdx]; } try { helperResponse = await getApiResponse(helperAiKey, helperMessages, currentKey, { t: 0.5, p: 0.9 }); if (currentIdx !== null) { helperGoodIdx[helperAiKey] = currentIdx; saveGoodKeyIndices(helperGoodIdx); } break; } catch (err) { helperApiError = err; } } if (thinkingMsg && thinkingMsg.parentNode === chatCont) chatCont.removeChild(thinkingMsg); if (helperResponse !== null) { finalUserContent = helperResponse; } else { appendMsg(`<i>Helper AI (${helperConfig?.name || helperAiKey}) failed: ${helperApiError?.message || String(helperApiError)}. Sending original.</i>`, 'assistant'); } } uInput.value = ''; checkWelcome(); if (!currentChatName) { currentChatName = genName(); } appendMsg(finalUserContent, 'user', true, false, msgHist.length); const historyForApi = [...msgHist, { role: "user", content: finalUserContent }]; const currentUserMsgIndex = msgHist.length; const result = await callAndProcessMainApi(historyForApi, finalUserContent); if (result.error) { msgHist.pop(); const userMsgElement = chatCont.querySelector(`.msg-wrap[data-msg-index="${currentUserMsgIndex}"]`); if (userMsgElement) chatCont.removeChild(userMsgElement); checkWelcome(); } else if (getChats()[currentChatName]?.title !== chatTitle.textContent) { chatTitle.textContent = getChats()[currentChatName].title; updateHistList(); } };

        // --- Edit/Regenerate/Copy Logic (Unchanged) ---
        const startEditingMessage = (index) => { if (index < 0 || index >= msgHist.length || msgHist[index].role !== 'user') { console.warn("Cannot edit index:", index); return; } editingMsgIndex = index; uInput.value = msgHist[index].content; uInput.focus(); editIndicator.style.display = 'inline-block'; hideCtxMenus(); };
        const cancelEdit = () => { editingMsgIndex = null; uInput.value = ''; editIndicator.style.display = 'none'; };
        const regenerateMessage = async (index) => { hideCtxMenus(); const originalMsgHist = [...msgHist]; if (index <= 0 || index >= originalMsgHist.length || originalMsgHist[index].role !== 'assistant' || originalMsgHist[index-1].role !== 'user') { alert("Can only regenerate an AI response that follows a user message."); return; } let truncatedHist = originalMsgHist.slice(0, index); msgHist = truncatedHist; rerenderChat(); let historyForRegen = [...msgHist]; checkWelcome(); const result = await callAndProcessMainApi(historyForRegen, null); if (result.error) { console.log("Regeneration failed, rolling back history."); msgHist = originalMsgHist; rerenderChat(); } else { saveUpdateChat(currentChatName, msgHist); } };
        const copyMessageContent = (index) => { if (index < 0 || index >= msgHist.length) return; copyToClipboard(msgHist[index].content); hideCtxMenus(); };

        // --- Sidebar & Context Menus (Unchanged) ---
        const toggleSidebar=()=>appCont.classList.toggle('sidebar-collapsed');
        const showHistCtxMenu=(e)=>{e.preventDefault();hideCtxMenus();const li=e.target.closest('li');if(!li)return;ctxTargetName=li.dataset.name;histCtxMenu.style.cssText=`top:${e.clientY}px;left:${e.clientX}px;display:block;`};
        const showMessageCtxMenu=(e)=>{ const msgWrap = e.target.closest('.msg-wrap'); if (!msgWrap) { hideCtxMenus(); return; } e.preventDefault(); hideCtxMenus(); const index = parseInt(msgWrap.dataset.msgIndex, 10); if (isNaN(index) || index < 0 || index >= msgHist.length) return; ctxTargetMsgIndex = index; const msgData = msgHist[index]; const isUser = msgData.role === 'user'; const canRegen = !isUser && index > 0 && msgHist[index-1].role === 'user'; msgCtxMenu.querySelector('[data-action="edit"]').style.display = isUser ? 'block' : 'none'; msgCtxMenu.querySelector('[data-action="regenerate"]').style.display = canRegen ? 'block' : 'none'; msgCtxMenu.querySelector('[data-action="copy"]').style.display = 'block'; msgCtxMenu.style.cssText = `top:${e.clientY}px;left:${e.clientX}px;display:block;`; };
        const hideCtxMenus=()=>{histCtxMenu.style.display='none';msgCtxMenu.style.display='none';ctxTargetName=null;ctxTargetMsgIndex=null;};

        // --- Serper Key Management (Unchanged) ---
        function loadSerperKey() { serperApiKey = localStorage.getItem(SERPER_KEY_STORE) || ''; console.log('Serper key loaded into variable.'); }

        // --- AI Search / Deep Dive Integration (Unchanged) ---
        function getCurrentAiConfig() { console.log("Getting current AI config. Mode:", currentMode); let providerKey; let modelNameForError = ''; let usingProxy = false; if (currentMode === 'deepThinking') { providerKey = 'GEMINI'; modelNameForError = 'DeepThinking (Gemini)'; } else if (currentMode === 'turbo') { providerKey = 'SAMBANOVA'; modelNameForError = 'Turbo (SambaNova)'; } else if (currentMode === 'proxy') { providerKey = 'BIGMODEL_PROXY'; modelNameForError = 'Proxy (BigModel)'; usingProxy = true; } else { providerKey = 'DEEPSEEK'; modelNameForError = 'Default (DeepSeek)'; } const providerConfig = PROVIDERS[providerKey]; if (!providerConfig) { console.error("ERROR: Missing provider config:", providerKey); alert("Internal Error: Missing AI provider config."); return null; } const apiKeyArray = getApiKeys()[providerKey] || []; const firstApiKey = apiKeyArray[0] || null; if (!firstApiKey && providerConfig.apiKeyLocation !== 'none' && providerConfig.format !== 'proxy_compatible') { console.error(`API Key missing for ${modelNameForError}`); alert(`Cannot start external app. API Key missing for ${modelNameForError}. Use üîë.`); showApiKeyModal(); return null; } let config = { aiModel: providerConfig.defaultModel, aiApiUrl: null, aiApiToken: firstApiKey, usingProxy: usingProxy }; if (providerConfig.format === "gemini_generateContent") config.aiApiUrl = `${providerConfig.baseURL}${config.aiModel}:generateContent`; else if (providerConfig.format === "openai_compatible") config.aiApiUrl = providerConfig.baseURL; else if (providerConfig.format === "proxy_compatible") config.aiApiUrl = providerConfig.baseURL; else { console.error("ERROR: Unsupported provider format:", providerConfig.format); alert("Internal Error: Unsupported API format."); return null; } console.log(`Determined AI Config: Model=${config.aiModel}, URL=${config.aiApiUrl}, Token=...${config.aiApiToken ? config.aiApiToken.slice(-4) : 'NONE'}, UsingProxy=${config.usingProxy}`); return config; }
        function openExternalAppModal(appUrl, configPayload, errorMsgPrefix = "Error") { console.log(`Opening Modal iframe: ${appUrl}`); searchFrame.src = appUrl; searchModalOverlay.style.display = 'flex'; searchFrame.onload = () => { console.log(`Frame loaded for ${appUrl}. Sending config:`, configPayload); try { searchFrame.contentWindow.postMessage({ type: 'config', payload: configPayload }, '*'); } catch (error) { console.error("Error sending postMessage:", error); alert(`${errorMsgPrefix}: Error communicating with external window.`); closeSearchModal(); } searchFrame.onload = null; }; searchFrame.onerror = () => { console.error(`Failed to load iframe: ${appUrl}`); alert(`${errorMsgPrefix}: Error loading the application.`); closeSearchModal(); searchFrame.onerror = null; } }
        function openAiSearch() { if (!serperApiKey) { alert('AI Search requires a Serper API key. Please set it using the üîë icon first.'); showApiKeyModal(); return; } const currentAi = getCurrentAiConfig(); if (!currentAi) { return; } const configPayload = { serperApiKey: serperApiKey, ...currentAi }; openExternalAppModal(SEARCH_APP_URL, configPayload, "AI Search Error"); }
        function openAiDeepDive() { const currentAi = getCurrentAiConfig(); if (!currentAi) { return; } const configPayload = { ...currentAi }; openExternalAppModal(DEEP_DIVE_APP_URL, configPayload, "AI Deep Dive Error"); }
        function closeSearchModal() { searchModalOverlay.style.display = 'none'; searchFrame.src = 'about:blank'; console.log('External App Modal closed.'); }

        // --- Microphone Transcription Logic (Unchanged) ---
        let mic_mediaRecorder; let mic_audioChunks = []; let mic_isRecording = false; let mic_stream; let mic_recordedMimeType = 'audio/webm;codecs=opus';
        function mic_updateStatus(message, type = 'info') { if (!micStatusSpan) return; micStatusSpan.textContent = message; micStatusSpan.className = type; }
        function mic_resetButton() { mic_isRecording = false; micTranscribeBtn.classList.remove('recording'); micButtonText.textContent = 'Record'; mic_updateStatus(''); console.log("Mic button reset."); }
        function mic_stopMicTracks() { if (mic_stream) { mic_stream.getTracks().forEach(track => track.stop()); console.log("Mic tracks stopped."); mic_stream = null; } }
        async function mic_startRecording() { if (mic_isRecording) return; const geminiProviderKey = 'GEMINI'; const geminiKeys = getApiKeys()[geminiProviderKey] || []; const geminiApiKey = geminiKeys[0]; if (!geminiApiKey && PROVIDERS[geminiProviderKey]?.apiKeyLocation !== 'none') { mic_updateStatus('Gemini Key Missing!', 'error'); alert(`Transcription requires a Gemini API Key (${PROVIDERS[geminiProviderKey].name}). Use üîë.`); showApiKeyModal(); return; } mic_updateStatus('Req. Mic...'); uInput.value = '[Recording...]'; try { mic_stream = await navigator.mediaDevices.getUserMedia({ audio: true }); mic_updateStatus('Init Rec...'); const options = {}; if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) options.mimeType = 'audio/webm;codecs=opus'; else if (MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) options.mimeType = 'audio/ogg;codecs=opus'; else if (MediaRecorder.isTypeSupported('audio/webm')) options.mimeType = 'audio/webm'; else if (MediaRecorder.isTypeSupported('audio/ogg')) options.mimeType = 'audio/ogg'; mic_mediaRecorder = new MediaRecorder(mic_stream, options); mic_recordedMimeType = mic_mediaRecorder.mimeType; console.log("Using MIME type:", mic_recordedMimeType); mic_audioChunks = []; mic_mediaRecorder.ondataavailable = (event) => { if (event.data.size > 0) mic_audioChunks.push(event.data); }; mic_mediaRecorder.onstop = async () => { console.log("Mic stopped. Chunks:", mic_audioChunks.length); mic_updateStatus('Processing...'); const audioBlob = new Blob(mic_audioChunks, { type: mic_recordedMimeType }); mic_audioChunks = []; mic_stopMicTracks(); if (audioBlob.size === 0) { console.error("Audio Blob empty."); mic_updateStatus('No audio.', 'error'); uInput.value = ''; mic_resetButton(); return; } console.log("Blob size:", audioBlob.size, "type:", audioBlob.type); await mic_sendAudioToGemini(audioBlob, geminiApiKey, mic_recordedMimeType); }; mic_mediaRecorder.onerror = (event) => { console.error("Recorder error:", event.error); mic_updateStatus(`Rec Error: ${event.error.name}`, 'error'); uInput.value = ''; mic_stopMicTracks(); mic_resetButton(); }; mic_mediaRecorder.start(); mic_isRecording = true; mic_updateStatus('üî¥ Recording'); micTranscribeBtn.classList.add('recording'); micButtonText.textContent = 'Stop'; } catch (err) { console.error('Mic/Recorder start error:', err); let errorMsg = `Error: ${err.message}`; if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") errorMsg = "Mic denied."; else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError") errorMsg = "No mic found."; else errorMsg = `Start Err: ${err.name}`; mic_updateStatus(errorMsg, 'error'); uInput.value = ''; mic_stopMicTracks(); mic_resetButton(); } }
        function mic_stopRecording() { if (!mic_isRecording || !mic_mediaRecorder) { console.log("Not recording/init."); if(mic_isRecording) mic_resetButton(); return; } if (mic_mediaRecorder.state === 'inactive') { console.log("Recorder already stopped."); mic_resetButton(); return; } console.log("Stopping mic..."); mic_updateStatus('Stopping...'); mic_mediaRecorder.stop(); }
        async function mic_sendAudioToGemini(audioBlob, apiKey, mimeType) { mic_updateStatus('Converting...'); const reader = new FileReader(); reader.readAsDataURL(audioBlob); reader.onloadend = async () => { const base64Audio = reader.result.split(',')[1]; if (!base64Audio) { console.error("Base64 fail."); mic_updateStatus('Audio Err', 'error'); uInput.value = ''; mic_resetButton(); return; } console.log(`Base64 ok. Approx size: ${Math.round(base64Audio.length * 3/4)} bytes`); const MODEL_NAME = "gemini-2.0-flash"; const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`; const requestBody = { contents: [{ parts: [ { "text": "Transcribe the following audio accurately:" }, { "inlineData": { "mimeType": mimeType, "data": base64Audio } } ] }] }; mic_updateStatus('Sending API...'); console.log(`Sending to Gemini (${MODEL_NAME})...`); try { const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) }); const responseData = await response.json(); if (!response.ok) { console.error("Gemini API Error:", responseData); let errorMsg = `API Error: ${response.status}`; if (responseData.error?.message) errorMsg = `API Err: ${responseData.error.message.substring(0, 50)}...`; throw new Error(errorMsg); } console.log("Gemini Success:", responseData); let transcription = "[Not found]"; let blockReason = responseData.promptFeedback?.blockReason; if (blockReason) { transcription = `Blocked: ${blockReason}`; mic_updateStatus('Blocked', 'error'); } else if (responseData.candidates?.[0]?.content?.parts?.[0]?.text) { transcription = responseData.candidates[0].content.parts[0].text.trim(); mic_updateStatus('Done!', 'success'); uInput.value = transcription; uInput.focus(); } else if (responseData.candidates?.[0]?.finishReason && responseData.candidates[0].finishReason !== 'STOP') { transcription = `[Stopped: ${responseData.candidates[0].finishReason}]`; mic_updateStatus('Stopped', 'error'); } else { console.warn("No transcription text:", responseData); transcription = "[Parse Error]"; mic_updateStatus('Parse Err', 'error'); } if (transcription.startsWith('[') || transcription.startsWith('Blocked')) uInput.value = transcription; } catch (error) { console.error('Gemini API call/process error:', error); mic_updateStatus(`${error.message}`, 'error'); uInput.value = `[Transcription Error]`; } finally { mic_resetButton(); setTimeout(() => { if (micStatusSpan.className !== 'error') mic_updateStatus(''); }, 3000); } }; reader.onerror = (error) => { console.error("FileReader error:", error); mic_updateStatus('Read Error', 'error'); uInput.value = ''; mic_resetButton(); }; }

        // --- Event Listeners ---
        uInput.onkeypress=(e)=>{if(e.key==='Enter'&&!e.shiftKey){e.preventDefault();sendMessage()}};
        document.onclick=(e)=>{ const t=e.target; if (!helperMenu.contains(t) && !t.closest('#helper-ai-btn')) helperMenu.style.display = 'none'; if (!t.closest('.ctx-menu')) hideCtxMenus(); const isApiKeyModalClick = t.closest('#api-key-modal .modal-content') || t.closest('#api-key-btn'); const isAgiModalClick = t.closest('#agi-modal .modal-content') || t.closest('#agi-btn'); if (!isApiKeyModalClick && apiKeyModal.style.display === 'flex') hideApiKeyModal(); if (!isAgiModalClick && agiModal.style.display === 'flex') hideAgiModal(); if (searchModalOverlay.style.display === 'flex' && t === searchModalOverlay) closeSearchModal(); };
        histCtxMenu.onclick=(e)=>{const a=e.target.dataset.action;if(!ctxTargetName||!a)return;if(a==='rename')renameChat(ctxTargetName);if(a==='delete')deleteChat(ctxTargetName);hideCtxMenus()};
        msgCtxMenu.onclick=(e)=>{const a=e.target.dataset.action;if(ctxTargetMsgIndex===null||!a)return;if(a==='copy')copyMessageContent(ctxTargetMsgIndex);if(a==='edit')startEditingMessage(ctxTargetMsgIndex);if(a==='regenerate')regenerateMessage(ctxTargetMsgIndex);hideCtxMenus()};
        helperPromptInput.addEventListener('input', updateHelperPrompt);
        document.addEventListener('keydown', (event) => { if (event.key === 'Escape' && searchModalOverlay.style.display === 'flex') { closeSearchModal(); } });
        micTranscribeBtn.addEventListener('click', () => { if (mic_isRecording) mic_stopRecording(); else mic_startRecording(); });

        // --- Init ---
        loadSerperKey();
        currentAgiKey=getActiveAgiKey();
        updateProxyButtonVisibility(); // Set initial proxy button state based on storage or default true
        loadChat(); // Load latest chat or start new (startNewChat will set proxy mode)
        if (!currentChatName) { // If loadChat resulted in a new chat, ensure proxy is selected
             selectMode('proxy', true);
        } else { // If an existing chat was loaded, reflect the currentMode state in the UI
             selectMode(currentMode, true); // Force selection of the loaded mode
        }
        selectHelperAi(null); // Reset helper AI

    </script>
</body>
</html>
