<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AGI Chat</title> <!-- V8.1 + Mic + Proxy (Concise) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>
    <style>
        :root { --sb-bg: #f7f7f8; --chat-bg: #fff; --input-bg: #fff; --text-pri: #202123; --text-sec: #6e6e73; --accent: #4a90e2; --border: #e5e5e5; --hover: #e9e9ea; --font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; --sb-width: 260px; --sb-trans: width .2s ease-in-out; }
        html { height: 100%; }
        body { height: 100%; margin: 0; font-family: var(--font); background: var(--chat-bg); color: var(--text-pri); overflow: hidden; font-size: 15px; display: flex; }
        button { background: 0 0; border: none; cursor: pointer; padding: 0; font-family: inherit; color: inherit; }
        input, select, textarea { font-family: inherit; font-size: inherit; box-sizing: border-box; }
        * { box-sizing: border-box; }
        .app { display: flex; height: 100%; width: 100%; }
        .sidebar { width: var(--sb-width); background: var(--sb-bg); border-right: 1px solid var(--border); display: flex; flex-direction: column; transition: var(--sb-trans); overflow: hidden; position: relative; flex-shrink: 0; height: 100%; }
        .app.sidebar-collapsed .sidebar { width: 0; border-right: none; }
        .sidebar-header { padding: 10px 15px; font-size: .85em; color: var(--text-sec); text-transform: uppercase; letter-spacing: .5px; white-space: nowrap; flex-shrink: 0; }
        #hist-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #hist-list::-webkit-scrollbar { display: none; }
        #hist-list { -ms-overflow-style: none; scrollbar-width: none; }
        #hist-list li { padding: 8px 15px 8px 25px; margin: 1px 10px; border-radius: 6px; cursor: pointer; font-size: .9em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; border: 1px solid transparent; position: relative; }
        #hist-list li:hover { background: var(--hover); }
        #hist-list li.active { background: #e0e0e0; font-weight: 500; }
        .sidebar-footer { padding: 10px 15px; font-size: .9em; color: var(--text-sec); text-align: center; border-top: 1px solid var(--border); white-space: nowrap; flex-shrink: 0; display: flex; justify-content: center; gap: 15px; }
        #api-key-btn, #agi-btn { font-size: 1.2em; padding: 5px 8px; border-radius: 4px; }
        #api-key-btn:hover, #agi-btn:hover { background-color: var(--hover); }
        .chat-area { flex-grow: 1; display: flex; flex-direction: column; background: var(--chat-bg); height: 100%; position: relative; overflow: hidden; }
        .chat-header { display: flex; align-items: center; padding: 0 10px 0 0; border-bottom: 1px solid var(--border); height: 41px; flex-shrink: 0; }
        #sidebar-toggle { font-size: 1.6em; padding: 5px 15px; color: var(--text-sec); line-height: 1; }
        .chat-header h2 { margin: 0 auto 0 10px; font-size: 1.1em; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #new-chat { font-size: 1.5em; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; color: var(--text-sec); margin-left: auto; border-radius: 50%; }
        #new-chat:hover, #sidebar-toggle:hover { background: var(--hover); border-radius: 4px; }
        #chat-cont { flex-grow: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; }
        #chat-cont::-webkit-scrollbar { display: none; }
        #chat-cont { -ms-overflow-style: none; scrollbar-width: none; }
        .init-welcome { margin: auto; text-align: center; color: var(--text-sec); }
        .init-welcome svg, .a-pfp svg, .a-pfp img { width: 40px; height: 40px; fill: var(--accent); border-radius: 50%; }
        .init-welcome h1 { font-size: 1.6em; color: var(--text-pri); margin: 0 0 5px 0; font-weight: 500; }
        .msg-wrap { display: flex; margin-bottom: 20px; width: 100%; align-items: flex-start; cursor: context-menu; }
        .u-msg-wrap { justify-content: flex-end; }
        .a-pfp { width: 30px; height: 30px; border-radius: 50%; background: var(--accent); flex-shrink: 0; margin-right: 10px; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .a-pfp svg { width: 18px; height: 18px; fill: #fff; margin: 0; }
        .a-pfp img { width: 100%; height: 100%; object-fit: cover; }
        .msg { padding: 10px 14px; border-radius: 15px; max-width: 85%; line-height: 1.5; font-size: 1em; word-wrap: break-word; box-shadow: 0 1px 2px rgba(0,0,0,.05); overflow-wrap: break-word; }
        .u-msg { background: #e3f2fd; color: var(--text-pri); border-bottom-right-radius: 5px; }
        .a-msg { background: var(--sb-bg); border-bottom-left-radius: 5px; }
        .msg > *:first-child { margin-top: 0; } .msg > *:last-child { margin-bottom: 0; }
        .msg i { font-style: italic; color: var(--text-sec); }
        .msg pre { background: #e0e0e0; padding: 10px; border-radius: 5px; font-size: .9em; margin: .5em 0; white-space: pre-wrap; word-break: break-all; overflow-x: auto; }
        .msg code:not(pre code) { font-family: monospace; background: #e0e0e0; padding: .1em .3em; border-radius: 3px; }
        .msg ul, .msg ol { margin: .5em 0 .5em 20px; padding-left: 10px; }
        .input-area { flex-shrink: 0; padding: 10px 20px 15px 20px; background: var(--input-bg); border-top: 1px solid var(--border); display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .input-wrap { display: flex; align-items: center; width: 100%; max-width: 750px; background: var(--chat-bg); border-radius: 24px; padding: 8px 18px; border: 1px solid var(--border); box-shadow: 0 2px 5px rgba(0,0,0,.05); }
        #u-input { flex-grow: 1; border: none; outline: 0; background: 0 0; font-size: 1em; color: var(--text-pri); }
        #u-input::placeholder { color: var(--text-sec); }
        .input-bottom-row { display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 750px; }
        .input-opts { display: flex; gap: 8px; align-items: center; padding-left: 5px; }
        .input-opts button { padding: 5px 12px; border: 1px solid var(--border); border-radius: 15px; font-size: .8em; background: var(--chat-bg); color: var(--text-sec); }
        .input-opts button.active { border-color: var(--accent); color: var(--accent); background-color: #e3f2fd; }
        #mode-proxy { display: none; }
        .input-action-buttons { display: flex; gap: 8px; align-items: center; position: relative; }
        #helper-ai-btn { font-size: 1.5em; color: var(--text-sec); line-height: 1; padding: 0 5px; }
        #helper-ai-btn.active { color: var(--accent); }
        #send-btn { background: var(--accent); color: #fff; border-radius: 50%; width: 32px; height: 32px; font-size: 1.1em; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        #helper-ai-btn:hover { color: var(--text-pri); }
        #mic-transcribe-btn { display: inline-flex; align-items: center; justify-content: center; padding: 5px 8px; font-size: 0.9em; cursor: pointer; background-color: #2ecc71; color: white; border: none; border-radius: 16px; transition: background-color 0.3s ease, box-shadow 0.3s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.1); min-width: 80px; height: 32px; box-sizing: border-box; }
        #mic-transcribe-btn:hover { background-color: #27ae60; box-shadow: 0 2px 5px rgba(0,0,0,0.15); }
        #mic-transcribe-btn.recording { background-color: #e74c3c; }
        #mic-transcribe-btn.recording:hover { background-color: #c0392b; }
        #mic-transcribe-btn svg { margin-right: 5px; vertical-align: middle; width: 16px; height: 16px; stroke: currentColor; }
        #mic-status { font-size: 0.75em; color: var(--text-sec); margin-left: -5px; margin-right: 5px; white-space: nowrap; max-width: 100px; overflow: hidden; text-overflow: ellipsis; vertical-align: middle; display: inline-block; line-height: 1; }
        #mic-status.error { color: #e74c3c; font-weight: bold; }
        #mic-status.success { color: #27ae60; font-weight: bold; }
        .ctx-menu{position:absolute;z-index:1000;background:#fff;border:1px solid var(--border);border-radius:6px;box-shadow:0 2px 10px rgba(0,0,0,.1);padding:5px 0;min-width:120px;display:none}.ctx-menu div{padding:6px 15px;font-size:.9em;cursor:pointer}.ctx-menu div:hover{background:var(--hover)}.ctx-menu div.disabled{opacity:0.5;cursor:not-allowed;background:transparent!important;}
        .modal{display:none;position:fixed;z-index:1001;left:0;top:0;width:100%;height:100%;overflow:auto;background-color:rgba(0,0,0,.4);align-items:center;justify-content:center;}
        .modal-content{background-color:#fefefe;margin:auto;padding:20px;border:1px solid var(--border);width:80%;max-width:600px;border-radius:8px;max-height:85vh;overflow-y:auto;display:flex;flex-direction:column;}
        .modal-content h3{margin-top:0;border-bottom:1px solid var(--border);padding-bottom:10px;flex-shrink:0;display:flex;justify-content:space-between;align-items:center;}
        .modal-actions{margin-top:20px;text-align:right;flex-shrink:0;} .modal-actions button{padding:8px 15px;border-radius:5px;margin-left:10px;}
        #save-keys-btn,#save-agi-btn{background-color:var(--accent);color:#fff;} #close-modal-btn,#close-agi-modal-btn{background-color:var(--sb-bg);color:var(--text-pri);border:1px solid var(--border);}
        #api-key-inputs label{display:block;margin:10px 0 5px 0;font-weight:500;font-size:.9em;}
        #api-key-inputs textarea{width:100%;padding:8px;border:1px solid var(--border);border-radius:4px;margin-bottom:10px;min-height:40px; resize:vertical;}
        #api-key-inputs .checkbox-container { display: flex; align-items: center; margin-top: 15px; padding-top: 10px; border-top: 1px solid var(--border); }
        #api-key-inputs .checkbox-container label { margin: 0 0 0 5px; font-weight: normal; font-size: .95em; }
        #api-key-inputs .checkbox-container input[type="checkbox"] { margin: 0; width: auto; height: auto; }
        #agi-grid{display:grid;grid-template-columns:repeat(auto-fill, minmax(80px, 1fr));gap:15px;margin-bottom:15px;padding-bottom:10px;border-bottom:1px solid var(--border);max-height:25vh;overflow-y:auto;flex-shrink:0;}
        .agi-item{width:80px;height:80px;border-radius:8px;border:3px solid transparent;cursor:pointer;background-size:cover;background-position:center;background-color:var(--hover);transition:border-color .2s;overflow:hidden;display:flex;align-items:center;justify-content:center;font-size:2.5em;}
        .agi-item img{width:100%;height:100%;object-fit:cover;}
        .agi-item:hover{border-color:#ccc;} .agi-item.selected{border-color:var(--accent);box-shadow:0 0 0 3px var(--accent);}
        #agi-edit-area{display:flex;flex-direction:column;gap:10px;flex-grow:1;overflow-y:auto;}
        #agi-edit-area label{font-weight:500;font-size:.9em;margin-bottom:-5px;}
        #agi-name-edit,#pfp-display-area button{padding:8px;border:1px solid var(--border);border-radius:4px;}
        #prompt-text-edit{width:100%;padding:8px;border:1px solid var(--border);border-radius:4px;min-height:80px;resize:vertical;flex-grow:1;}
        #pfp-display-area{display:flex;align-items:center;gap:10px;}
        #current-pfp{width:30px;height:30px;border-radius:50%;flex-shrink:0;background:var(--sb-bg);display:flex;align-items:center;justify-content:center;font-size:1em;overflow:hidden;}
        #current-pfp img{width:100%;height:100%;object-fit:cover;}
        #generate-pfp-btn { font-size: 0.85em; padding: 6px 10px; flex-grow: 1;}
        #delete-agi-btn { background-color: #fdd; color: #c53030; font-size: 0.85em; padding: 6px 10px; } #delete-agi-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        #helper-menu { position: absolute; bottom: 100%; right: 45px; background: #fff; border: 1px solid var(--border); border-radius: 6px; box-shadow: 0 2px 10px rgba(0,0,0,.1); padding: 5px 0; min-width: 140px; z-index: 10; display: none; margin-bottom: 5px; }
        #helper-menu div { padding: 6px 15px; font-size: .9em; cursor: pointer; white-space: nowrap; }
        #helper-menu div:hover { background: var(--hover); }
        #helper-menu div.selected { background-color: #e0e0e0; font-weight: bold; }
        #helper-prompt-wrap { width: 100%; max-width: 750px; margin-top: -5px; margin-bottom: 5px; display: none; }
        #helper-prompt-input { width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 10px; font-size: .9em; min-height: 40px; resize: vertical; }
        #edit-indicator{display:none;font-size:.8em;color:var(--text-sec);background:var(--sb-bg);padding:2px 8px;border-radius:10px;border:1px solid var(--border);margin-bottom:5px;align-self:flex-start;margin-left:5px;}#edit-indicator button{font-size:1.1em;margin-left:5px;color:var(--text-sec);line-height:1;}
        #searchModalOverlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 1002; align-items: center; justify-content: center; padding: 15px; }
        #searchModalContent { background: #fff; width: 100%; height: 100%; max-width: 1200px; max-height: 90vh; display: flex; flex-direction: column; position: relative; padding: 0; box-shadow: 0 5px 15px rgba(0,0,0,0.3); border-radius: 6px; overflow: hidden; border: 1px solid var(--border); }
        #searchModalHeader { padding: 5px 10px; display: flex; justify-content: flex-end; background: var(--sb-bg); border-bottom: 1px solid var(--border); flex-shrink: 0; height: 35px; }
        #closeSearchModalBtn { background: none; border: none; font-size: 1.6em; cursor: pointer; padding: 0 5px; line-height: 1; color: var(--text-sec); }
        #closeSearchModalBtn:hover { color: var(--text-pri); }
        #searchFrameContainer { flex-grow: 1; overflow: auto; padding: 0; background-color: #ccc; }
        #searchFrame { border: none; width: 100%; height: 100%; display: block; }
    </style>
</head>
<body>
    <svg width="0" height="0" style="position:absolute"><symbol id="w-icon" viewBox="0 0 512 512"><path d="M480 169c-27-8-60-4-85 11l-42 25c-19 11-36 25-50 41l-5 5c-13 14-31 23-51 23s-37-8-51-23l-5-5c-14-16-31-30-50-41l-42-25c-25-15-58-19-85-11C-1 177-3 231 24 258l23 24c11 11 26 18 41 19l11 102c1 16 11 29 24 36 7 3 14 5 22 5s16-2 22-6c14-9 23-24 23-40v-85h68v85c0 16 9 31 23 40 7 4 15 6 22 6s15-2 22-5c13-7 23-20 24-36l11-102c16-1 30-8 41-19l24-24C515 231 513 177 480 169zM384 320c-18 0-32-14-32-32s14-32 32-32 32 14 32 32-14 32-32 32zm-256 0c-18 0-32-14-32-32s14-32 32-32 32 14 32 32-14 32-32 32z"/></symbol></svg>

<div class="app" id="app-cont">
    <div class="sidebar">
        <div class="sidebar-header">History</div><ul id="hist-list"></ul>
        <div class="sidebar-footer">
            <button id="agi-btn" onclick="showAgiModal()" title="AGIs">👤</button>
            <button id="api-key-btn" onclick="showApiKeyModal()" title="API Keys">🔑</button>
        </div>
    </div>
    <div class="chat-area">
         <div class="chat-header"><button id="sidebar-toggle" onclick="toggleSidebar()" title="Toggle Sidebar">☰</button><h2 id="chat-title">New Chat</h2><button id="new-chat" onclick="startNewChat()" title="New Chat">+</button></div>
         <div id="chat-cont" oncontextmenu="showMessageCtxMenu(event)"><div class="init-welcome"><svg><use href="#w-icon"/></svg><h1>Ready</h1><p>Select mode & start.</p></div></div>
         <div class="input-area">
             <div id="edit-indicator">Editing... <button onclick="cancelEdit()">✖</button></div>
             <div id="helper-prompt-wrap"><textarea id="helper-prompt-input" placeholder="Helper AI System Prompt (applies to selected helper)"></textarea></div>
             <div class="input-wrap"><input type="text" id="u-input" placeholder="Enter message..."></div>
             <div class="input-bottom-row">
                <div class="input-opts">
                    <button id="mode-deepthinking" onclick="selectMode('deepThinking')">💡 DeepThinking</button>
                    <button id="mode-turbo" onclick="selectMode('turbo')">⚡ Turbo</button>
                    <button id="mode-proxy" onclick="selectMode('proxy')">🌐 Proxy</button>
                </div>
                <div class="input-action-buttons">
                    <button id="helper-ai-btn" onclick="toggleHelperMenu()" title="Helper AI Settings">+</button>
                    <span id="mic-status"></span>
                    <button id="mic-transcribe-btn" title="Transcribe Audio">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                            <line x1="12" y1="19" x2="12" y2="22"></line>
                        </svg>
                        <span class="mic-btn-text">Record</span>
                    </button>
                    <button id="send-btn" onclick="sendMessage()" title="Send">↑</button>
                    <div id="helper-menu" class="ctx-menu" onclick="handleHelperMenuClick(event)">
                        <div data-key="null">⛔ No Helper</div>
                        <div data-key="set">⚙️ Set Prompt</div>
                        <div data-key="DEEPSEEK">🦾 DeepSeek Helper</div>
                        <div data-key="SAMBANOVA">⚡ SambaNova Helper</div>
                        <div data-key="GEMINI">💡 Gemini Helper</div>
                        <hr style="margin: 3px 0; border: none; border-top: 1px solid var(--border);">
                        <div data-key="ai-search">🔎 AI Search</div>
                        <div data-key="ai-deep-dive">🧠 AI Deep Dive</div>
                    </div>
                </div>
             </div>
         </div>
    </div>
</div>
<div id="hist-ctx-menu" class="ctx-menu"><div data-action="rename">Rename</div><div data-action="delete">Delete</div></div>
<div id="msg-ctx-menu" class="ctx-menu"><div data-action="copy">Copy</div><div data-action="edit">Edit</div><div data-action="regenerate">Regenerate</div></div>
<div id="api-key-modal" class="modal"><div class="modal-content"><h3>API Keys</h3><div id="api-key-inputs"></div><div class="modal-actions"><button id="close-modal-btn" onclick="hideApiKeyModal()">Cancel</button><button id="save-keys-btn" onclick="saveApiKeys()">Save Keys</button></div></div></div>
<div id="agi-modal" class="modal"><div class="modal-content"><h3>AGIs <button onclick="addNewAgi()" title="Add New AGI" style="font-size: 1.2em; padding: 0 5px;">+</button></h3><div id="agi-grid"></div><div id="agi-edit-area"><label for="agi-name-edit">Name:</label><input type="text" id="agi-name-edit"><label for="prompt-text-edit">System Prompt:</label><textarea id="prompt-text-edit"></textarea><label>PFP:</label><div id="pfp-display-area"><span id="current-pfp">❓</span><button id="generate-pfp-btn" onclick="generatePfp()">Generate</button></div><button id="delete-agi-btn" onclick="deleteSelectedAgi()">Delete AGI</button></div><div class="modal-actions"><button id="close-agi-modal-btn" onclick="hideAgiModal()">Cancel</button><button id="save-agi-btn" onclick="saveAgiSelection()">Save & Select</button></div></div></div>
<div id="searchModalOverlay">
     <div id="searchModalContent">
        <div id="searchModalHeader"><button id="closeSearchModalBtn" title="Close" onclick="closeSearchModal()">×</button></div>
        <div id="searchFrameContainer"><iframe id="searchFrame" src="about:blank" title="External App Module"></iframe></div>
     </div>
</div>

<script>
    const PROVIDERS = {
        BIGMODEL_PROXY: { name: "BigModel (Proxy)", format: "proxy_compatible", baseURL: "/api/proxy", availableModels: ["glm-4-flash"], defaultModel: "glm-4-flash", apiKeyLocation: "none", supportsSystemPromptInMessages: true, supportsImages: false, },
        SAMBANOVA: { name: "SambaNova", format: "openai_compatible", baseURL: "https://api.sambanova.ai/v1/chat/completions", availableModels: ["DeepSeek-V3-0324"], defaultModel: "DeepSeek-V3-0324", apiKeyLocation: "header", authHeaderPrefix: "Bearer ", supportsSystemPromptInMessages: true, supportsImages: false, },
        GEMINI: { name: "Gemini", format: "gemini_generateContent", baseURL: "https://generativelanguage.googleapis.com/v1beta/models/", availableModels: ["gemini-2.5-pro-exp-03-25"], defaultModel: "gemini-2.5-pro-exp-03-25", apiKeyLocation: "query", apiKeyQueryParam: "key", supportsSystemPromptInMessages: false, systemInstructionKey: "system_instruction", supportsImages: true, },
        DEEPSEEK: { name: "DeepSeek", format: "openai_compatible", baseURL: "https://api.deepseek.com/v1/chat/completions", availableModels: ["deepseek-chat", "deepseek-reasoner"], defaultModel: "deepseek-chat", apiKeyLocation: "header", authHeaderPrefix: "Bearer ", supportsSystemPromptInMessages: true, supportsImages: false, },
    };
    const GEMINI_IMG_MODEL="gemini-2.0-flash-exp-image-generation";

    function transformHistoryForGemini(h) {
        const c = []; let sI = null;
        if (h.length > 0 && h[0].role === 'system') sI = h[0].content;
        const hP = h.slice(sI ? 1 : 0);
        hP.forEach(m => {
            if (!m || !m.role) return;
            let r = m.role === 'assistant' ? 'model' : m.role; let p = [];
            if (m.role === 'user') {
                if (m.content && typeof m.content === 'string' && m.content.trim() !== '') p.push({ text: m.content });
                if (Array.isArray(m.images) && m.images.length > 0) m.images.forEach(i => { if (i && i.mimeType && i.data) p.push({ inlineData: { mimeType: i.mimeType, data: i.data } }); });
            } else if (m.role === 'assistant') { const aC = m.content || m.variants?.[m.selectedIndex ?? 0]; if (aC !== undefined && aC !== null) p.push({ text: String(aC) }); }
            if (p.length > 0) c.push({ role: r, parts: p });
        });
        return { contents: c, systemInstruction: sI };
    }

    async function getApiResponse(pN, cH, aK, o = {}) {
        console.log(`API Req: ${pN}`); const pC = PROVIDERS[pN]; if (!pC) throw new Error(`Config missing: ${pN}`);
        const mTUse = o.model || pC.defaultModel; if (!mTUse) throw new Error(`No model: ${pN}`);
        const rAK = pC.format !== 'proxy_compatible' && pC.apiKeyLocation !== 'none'; if (rAK && !aK) throw new Error(`API Key missing: ${pN}`);
        const hHI = cH.some(m => m.role === 'user' && Array.isArray(m.images) && m.images.length > 0); if (hHI && !pC.supportsImages) throw new Error(`Provider ${pN} no img support.`);
        let rURL; const h = { 'Content-Type': 'application/json' }; let rB;
        try {
            let pH; if (pC.format === "gemini_generateContent") pH = transformHistoryForGemini(cH);
            else pH = cH.filter(m => m?.role && (typeof m.content === 'string' || (m.role === 'system' && typeof m.content === 'string') || m.role === 'assistant')).filter(m => pC.supportsSystemPromptInMessages || m.role !== 'system').map(m => ({ role: m.role, content: m.content || "" }));
            if (pC.format === "proxy_compatible") { rURL = pC.baseURL; rB = { model: mTUse, messages: pH, temperature: o.temperature ?? 0.7, stream: o.stream ?? false }; }
            else if (pC.format === "openai_compatible") { rURL = pC.baseURL; if (pC.apiKeyLocation === "header") h['Authorization'] = `${pC.authHeaderPrefix || ''}${aK}`; rB = { model: mTUse, messages: pH, stream: o.stream ?? false, temperature: o.temperature ?? 0.7, top_p: o.top_p ?? 0.9 }; }
            else if (pC.format === "gemini_generateContent") { rURL = `${pC.baseURL}${mTUse}:generateContent`; if (pC.apiKeyLocation === "query") rURL += `?${pC.apiKeyQueryParam}=${aK}`; const { contents: ct, systemInstruction: sI } = pH; if (ct.length === 0 && !sI) throw new Error("Empty hist/prompt Gemini"); rB = { contents: ct, generationConfig: { temperature: o.temperature ?? 0.7, topP: o.top_p ?? 0.9 } }; if (sI && pC.systemInstructionKey) rB[pC.systemInstructionKey] = { parts: [{ text: sI }] }; else if (sI) console.warn(`Sys instruct present but no key for Gemini.`); }
            else throw new Error(`Unsupported format: ${pC.format}`);
        } catch (e) { console.error(`API Prep Err: ${pN}`, e); throw e; }
        console.log(`API Call: ${rURL}`); try {
            const rsp = await fetch(rURL, { method: 'POST', headers: h, body: JSON.stringify(rB) });
            if (!rsp.ok) { let eD, eM = `API Err ${rsp.status}: ${rsp.statusText}`; try { eD = await rsp.json(); console.error(`API Err Body ${pN}:`, eD); eM = eD.error?.message || eD.message || eD.details?.[0]?.message || eD.detail || (typeof eD === 'string' ? eD : JSON.stringify(eD)) || eM; } catch (jE) { try { const tE = await rsp.text(); if (tE) eM = tE; } catch(tErr) {} } console.error(`API Fetch Fail ${pN}: ${rsp.status}, Msg: ${eM}`); throw new Error(eM); }
            const d = await rsp.json(); let mC = null;
            if (pC.format === "openai_compatible" || pC.format === "proxy_compatible") mC = d.choices?.[0]?.message?.content;
            else if (pC.format === "gemini_generateContent") { if (d.promptFeedback?.blockReason) throw new Error(`Content blocked (prompt): ${d.promptFeedback.blockReason}`); if (!d.candidates || d.candidates.length === 0) { const cBR = d.candidates?.[0]?.promptFeedback?.blockReason; if(cBR) throw new Error(`Content blocked (response): ${cBR}`); throw new Error(`Invalid resp ${pN}: No candidates.`); } const cBR = d.candidates[0]?.safetyRatings?.find(r => r.blocked)?.category || d.candidates[0]?.promptFeedback?.blockReason; if (cBR) throw new Error(`Content blocked (response): ${cBR}`); mC = d.candidates[0]?.content?.parts?.[0]?.text; const fR = d.candidates[0]?.finishReason; if (fR && fR !== "STOP" && fR !== "MAX_TOKENS") { if (mC != null) mC += `\n\n*(Finish: ${fR})*`; else throw new Error(`Generation fail/stop: ${fR}`); } }
            if (mC === null || mC === undefined) { console.error(`Invalid resp structure ${pN}:`, d); throw new Error(`Invalid API resp ${pN}.`); } if (mC === "") console.warn(`Empty resp ${pN}.`);
            console.log(`API OK: ${pN}`); return mC;
        } catch (e) { console.error(`API Exec Err ${pN}:`, e); if (e instanceof Error) throw e; else throw new Error(String(e)); }
    }

    const chatCont=document.getElementById('chat-cont'),uInput=document.getElementById('u-input'),histList=document.getElementById('hist-list'),initWelcome=document.querySelector('.init-welcome'),chatTitle=document.getElementById('chat-title'),histCtxMenu=document.getElementById('hist-ctx-menu'),msgCtxMenu=document.getElementById('msg-ctx-menu'),appCont=document.getElementById('app-cont'),apiKeyModal=document.getElementById('api-key-modal'),keyInputsCont=document.getElementById('api-key-inputs');
    const btnDT=document.getElementById('mode-deepthinking'),btnTurbo=document.getElementById('mode-turbo'), btnProxy=document.getElementById('mode-proxy');
    const agiModal=document.getElementById('agi-modal'),agiGrid=document.getElementById('agi-grid'),agiNameEdit=document.getElementById('agi-name-edit'),promptEdit=document.getElementById('prompt-text-edit'),currentPfpDisp=document.getElementById('current-pfp'),delAgiBtn=document.getElementById('delete-agi-btn');
    const helperBtn=document.getElementById('helper-ai-btn'),helperMenu=document.getElementById('helper-menu'),helperPromptWrap=document.getElementById('helper-prompt-wrap'),helperPromptInput=document.getElementById('helper-prompt-input');
    const editIndicator = document.getElementById('edit-indicator');
    const searchModalOverlay = document.getElementById('searchModalOverlay'),searchFrame = document.getElementById('searchFrame');
    const micTranscribeBtn = document.getElementById('mic-transcribe-btn'),micButtonText = micTranscribeBtn.querySelector('.mic-btn-text'),micStatusSpan = document.getElementById('mic-status');

    let msgHist=[],currentChatName=null,ctxTargetName=null,ctxTargetMsgIndex=null,currentMode=null,currentAgiKey=null,selectedAgiKeyInModal=null,helperAiKey=null, helperAiPrompt='',editingMsgIndex = null,serperApiKey = '',showProxyButton = true;

    const CHAT_STORE='chats_v11',KEY_STORE='keys_v7',GOOD_KEY_IDX_STORE='goodKeyIdx_v4',AGI_STORE='agis_v1',ACTIVE_AGI_STORE='activeAgi_v1',SERPER_KEY_STORE = 'serper_key_v1',SHOW_PROXY_STORE = 'showProxy_v1';
    const SEARCH_APP_URL = './ai_search.html',DEEP_DIVE_APP_URL = './ai-deep-dive.html';
    const getChats=()=>JSON.parse(localStorage.getItem(CHAT_STORE)||'{}');const saveChats=(c)=>localStorage.setItem(CHAT_STORE,JSON.stringify(c));const getApiKeys=()=>JSON.parse(localStorage.getItem(KEY_STORE)||'{}');const saveApiKeysToStorage=(k)=>localStorage.setItem(KEY_STORE,JSON.stringify(k));const getGoodKeyIndices=()=>JSON.parse(localStorage.getItem(GOOD_KEY_IDX_STORE)||'{}');const saveGoodKeyIndices=(i)=>localStorage.setItem(GOOD_KEY_IDX_STORE,JSON.stringify(i)); const getAgis=()=>JSON.parse(localStorage.getItem(AGI_STORE)||'{}');const saveAgis=(p)=>localStorage.setItem(AGI_STORE,JSON.stringify(p));const getActiveAgiKey=()=>localStorage.getItem(ACTIVE_AGI_STORE)||null;const saveActiveAgiKey=(k)=>localStorage.setItem(ACTIVE_AGI_STORE,k);const genName=()=>`c_${Date.now()}`;const genTitle=(h)=>h?.[0]?.role==='user'?h[0].content.substring(0,25)+(h[0].content.length>25?'…':''):"Chat";
    const copyToClipboard=(t)=>{const ta=document.createElement('textarea');ta.value=t;ta.style.position='fixed';ta.style.top='-9999px';ta.style.left='-9999px';ta.style.opacity='0';document.body.appendChild(ta);ta.focus();ta.select();try{document.execCommand('copy')?alert('Copied!'):alert('Copy failed.');}catch(err){console.error('Copy fail:',err);alert('Error copy.');}document.body.removeChild(ta);};

    const updateHistList=()=>{const c=getChats();histList.innerHTML='';Object.keys(c).sort((a,b)=>(c[b].ts||0)-(c[a].ts||0)).forEach(n=>{const li=document.createElement('li');li.textContent=c[n].title||n;li.dataset.name=n;if(n===currentChatName)li.classList.add('active');li.onclick=()=>loadChat(n);li.oncontextmenu=showHistCtxMenu;histList.appendChild(li)})};
    const checkWelcome=()=>{initWelcome.style.display=msgHist.length>0?'none':'flex';chatCont.style.justifyContent=msgHist.length>0?'flex-start':'center';};
    const appendMsg=(ct,r,s=true,t=false,idx=null)=>{const w=document.createElement('div');w.className=`msg-wrap ${r==='user'?'u':'a'}-msg-wrap`;if(idx!==null)w.dataset.msgIndex=idx;w.dataset.rawContent=ct; const m=document.createElement('div');m.className=`msg ${r==='user'?'u':'a'}-msg`;if(r==='assistant'&&!t){const p=document.createElement('div');p.className='a-pfp';const agis=getAgis();const aData=currentAgiKey?agis[currentAgiKey]:null;const pfp=aData?.pfp;if(pfp?.startsWith('data:image')||pfp?.startsWith('http')){p.innerHTML=`<img src="${pfp}" alt="PFP">`;}else if(pfp){p.textContent=pfp;}else{p.innerHTML=`<svg><use href="#w-icon"/></svg>`;}w.appendChild(p);}try{m.innerHTML=t?ct:marked.parse(ct||"");}catch(e){console.warn("Marked err:",e);m.textContent=ct||"";}if(t)m.style.opacity='0.6';w.appendChild(m);chatCont.appendChild(w);if(s)chatCont.scrollTop=chatCont.scrollHeight;checkWelcome();return t?w:null};
    const rerenderChat=()=>{chatCont.innerHTML='';msgHist.forEach((m,i)=>appendMsg(m.content,m.role,false,false,i));checkWelcome();chatCont.scrollTop=chatCont.scrollHeight;};

    const saveUpdateChat=(n,h)=>{if(!n||h.length===0)return;const c=getChats();c[n]={ctx:h,title:genTitle(h),ts:Date.now()};saveChats(c);if(n===currentChatName)updateHistList()};
    const loadChat=(n)=>{ let cTL = n; if (!cTL) { const sC = Object.entries(getChats()).sort(([,a],[,b])=>(b.ts||0)-(a.ts||0)); if (sC.length > 0) cTL = sC[0][0]; } if (!cTL) { startNewChat(); return; } const c=getChats()[cTL]; if(c?.ctx){ chatCont.innerHTML=''; msgHist=c.ctx; currentChatName=cTL; chatTitle.textContent=c.title||cTL; msgHist.forEach((m,i)=>appendMsg(m.content,m.role,false,false,i)); checkWelcome(); chatCont.scrollTop=chatCont.scrollHeight; updateHistList(); cancelEdit(); const iM = showProxyButton ? 'proxy' : 'deepThinking'; selectMode(iM, true); } else { console.warn(`Chat data invalid ${cTL}. Starting new.`); startNewChat(); } };
    const renameChat=(n)=>{const c=getChats();if(!c[n])return;const t=prompt("Rename:",c[n].title||n)?.trim();if(t){c[n].title=t;c[n].ts=Date.now();saveChats(c);if(n===currentChatName)chatTitle.textContent=t;updateHistList()}};
    const deleteChat=(n)=>{const c=getChats();if(!c[n]||!confirm(`Delete "${c[n].title||n}"?`))return;delete c[n];saveChats(c);if(n===currentChatName)startNewChat();updateHistList()};
    const startNewChat=()=>{ chatCont.innerHTML='';msgHist=[];currentChatName=null; chatTitle.textContent="New Chat";checkWelcome();updateHistList(); uInput.focus(); const dM = showProxyButton ? 'proxy' : 'deepThinking'; selectMode(dM, true); selectHelperAi(null); helperPromptWrap.style.display = 'none'; cancelEdit(); };

    const updateProxyButtonVisibility = () => { const sP = localStorage.getItem(SHOW_PROXY_STORE); showProxyButton = sP === null ? true : sP === 'true'; btnProxy.style.display = showProxyButton ? 'inline-block' : 'none'; console.log("Proxy btn visible:", showProxyButton); if (currentMode === 'proxy' && !showProxyButton) { console.log("Proxy hidden while active, switching mode."); selectMode('deepThinking', true); } };
    const showApiKeyModal = () => { keyInputsCont.innerHTML = ''; const pK = getApiKeys(); Object.entries(PROVIDERS).forEach(([pk, pc]) => { if (pc.apiKeyLocation !== 'none' && pc.format !== 'proxy_compatible') { const d = document.createElement('div'); d.innerHTML = `<label for="k-${pk}">${pc.name}</label><textarea id="k-${pk}" data-provider="${pk}" rows="2" placeholder="One API Key per line">${(pK[pk] || []).join('\n')}</textarea>`; keyInputsCont.appendChild(d); } }); const sD = document.createElement('div'); sD.innerHTML = `<label for="k-serper">Serper (AI Search)</label><textarea id="k-serper" data-keytype="serper" rows="1" placeholder="Serper.dev API Key">${serperApiKey}</textarea>`; keyInputsCont.appendChild(sD); const pCD = document.createElement('div'); pCD.className = 'checkbox-container'; pCD.innerHTML = `<input type="checkbox" id="show-proxy-checkbox" ${showProxyButton ? 'checked' : ''}><label for="show-proxy-checkbox">Show Proxy Mode Button</label>`; keyInputsCont.appendChild(pCD); apiKeyModal.style.display = 'flex'; };
    const hideApiKeyModal = () => { apiKeyModal.style.display = 'none' };
    const saveApiKeys = () => { const tas = keyInputsCont.querySelectorAll('textarea'); const nPK = {}; let fSK = ''; tas.forEach(ta => { const p = ta.dataset.provider; const kT = ta.dataset.keytype; const kC = ta.value.trim(); if (kT === 'serper') { fSK = kC; } else if (p) { const k = kC.split('\n').map(k => k.trim()).filter(Boolean); if (k.length > 0) { nPK[p] = k; } } }); saveApiKeysToStorage(nPK); serperApiKey = fSK; if (serperApiKey) localStorage.setItem(SERPER_KEY_STORE, serperApiKey); else localStorage.removeItem(SERPER_KEY_STORE); const pC = document.getElementById('show-proxy-checkbox'); const sSP = pC.checked; localStorage.setItem(SHOW_PROXY_STORE, sSP); updateProxyButtonVisibility(); hideApiKeyModal(); alert('Keys & Settings saved!'); };

    const populateAgiGrid=()=>{agiGrid.innerHTML='';const agis=getAgis();Object.keys(agis).forEach(k=>{const d=agis[k];const i=document.createElement('div');i.className='agi-item';i.dataset.key=k;const f=d.pfp;if(f?.startsWith('data:image')||f?.startsWith('http'))i.innerHTML=`<img src="${f}" alt="">`;else i.textContent=f||'?';if(k===selectedAgiKeyInModal)i.classList.add('selected');i.onclick=()=>handleAgiItemClick(k);agiGrid.appendChild(i)})};const showAgiModal=()=>{selectedAgiKeyInModal=currentAgiKey||Object.keys(getAgis())[0]||null;populateAgiGrid();updateAgiEditArea(selectedAgiKeyInModal);agiModal.style.display='flex'};const hideAgiModal=()=>{agiModal.style.display='none';selectedAgiKeyInModal=null;};const updateAgiEditArea=(k)=>{const agis=getAgis();const d=k?agis[k]:null;agiNameEdit.value=d?.name||'';promptEdit.value=d?.prompt||'';const f=d?.pfp;if(f?.startsWith('data:image')||f?.startsWith('http'))currentPfpDisp.innerHTML=`<img src="${f}" alt="">`;else currentPfpDisp.textContent=f||'❓';delAgiBtn.disabled=!k;agiNameEdit.disabled=!k;promptEdit.disabled=!k;document.getElementById('generate-pfp-btn').disabled=!k;};const handleAgiItemClick=(key)=>{selectedAgiKeyInModal=key;updateAgiEditArea(key);agiGrid.querySelectorAll('.agi-item').forEach(el=>el.classList.toggle('selected',el.dataset.key===key));};const addNewAgi=()=>{const a=getAgis();const k=`a_${Date.now()}`;a[k]={name:"New",prompt:"",pfp:"❓"};saveAgis(a);selectedAgiKeyInModal=k;populateAgiGrid();updateAgiEditArea(k);agiNameEdit.focus();agiNameEdit.select();};
    const generatePfp=async()=>{const n=agiNameEdit.value.trim();if(!n){alert("Enter AGI name.");return;} const pK='GEMINI'; const k=getApiKeys()[pK]||[]; const c=PROVIDERS[pK]; if(!c||!c.baseURL){alert(`Gemini cfg err.`); return;} if(c.apiKeyLocation!=='none'&&k.length===0){alert(`Key missing ${c.name}. Use 🔑.`);showApiKeyModal();return;} const aK=k[0];if(c.apiKeyLocation!=='none'&&!aK){alert(`No key for ${c.name}.`);return;} const p=`Gen PFP for "${n}". ONLY return img data. NO text. Style: simple icon, vector, PNG.`; let u=`${c.baseURL}${GEMINI_IMG_MODEL}:generateContent?${c.apiKeyQueryParam}=${aK}`; currentPfpDisp.textContent='⏳'; try{const r=await fetch(u,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({contents:[{parts:[{text:p}]}],generationConfig:{response_modalities:["IMAGE","TEXT"]}})}); if(!r.ok){let m=`API Err ${r.status}`;try{const d=await r.json();m=d.error?.message||d.message||JSON.stringify(d);}catch{}throw new Error(m);} const d=await r.json();const iP=d.candidates?.[0]?.content?.parts?.find(p=>p.inlineData); if(!iP?.inlineData?.data){const tP=d.candidates?.[0]?.content?.parts?.find(p=>p.text);console.warn("Img gen txt:",tP?.text);throw new Error("No img data."+(tP?.text?"Txt:"+tP.text.substring(0,50)+"...":""));} const iU=`data:${iP.inlineData.mimeType};base64,${iP.inlineData.data}`;currentPfpDisp.innerHTML=`<img src="${iU}" alt="PFP">`; }catch(err){console.error("PFP Gen fail:",err);alert(`PFP gen fail:${err.message}`);currentPfpDisp.textContent='❓';}};
    const deleteSelectedAgi=()=>{const k=selectedAgiKeyInModal;if(!k||!confirm(`Delete AGI "${getAgis()[k]?.name||k}"?`))return;const a=getAgis();delete a[k];saveAgis(a);if(currentAgiKey===k){currentAgiKey=null;saveActiveAgiKey('');}selectedAgiKeyInModal=currentAgiKey||Object.keys(getAgis())[0]||null;populateAgiGrid();updateAgiEditArea(selectedAgiKeyInModal);};const saveAgiSelection=()=>{console.log("Saving AGI:", selectedAgiKeyInModal);const k=selectedAgiKeyInModal;if(!k){hideAgiModal();return};const a=getAgis();const n=agiNameEdit.value.trim();const p=promptEdit.value.trim();const pE=currentPfpDisp.querySelector('img');const pV=pE?pE.src:(currentPfpDisp.textContent.trim()||null);if(!a[k])a[k]={};a[k].name=n||"Unnamed";a[k].prompt=p;a[k].pfp=(pV==='❓'||pV==='👤')?null:pV;saveAgis(a);currentAgiKey=k;saveActiveAgiKey(k);console.log("AGI set:",k);hideAgiModal();};

    const selectMode = (m, force = false) => { if (m === 'proxy' && !showProxyButton && !force) { console.warn("Ignore select hidden proxy."); return; } if (currentMode === m && !force) { currentMode = null; console.log("Mode deselected."); } else { currentMode = m; console.log("Mode set:", currentMode); } btnDT.classList.toggle('active', currentMode === 'deepThinking'); btnTurbo.classList.toggle('active', currentMode === 'turbo'); if (showProxyButton || currentMode === 'proxy') btnProxy.classList.toggle('active', currentMode === 'proxy'); else btnProxy.classList.remove('active'); };

    const toggleHelperMenu = () => { helperMenu.style.display = (helperMenu.style.display === 'block') ? 'none' : 'block'; };
    const handleHelperMenuClick = (e) => { const tD = e.target.closest('div[data-key]'); if (!tD) return; const k = tD.dataset.key; toggleHelperMenu(); if (k === 'set') toggleHelperPromptInput(); else if (k === 'ai-search') openAiSearch(); else if (k === 'ai-deep-dive') openAiDeepDive(); else selectHelperAi(k === 'null' ? null : k); };
    const selectHelperAi = (k) => { helperAiKey = k; helperMenu.querySelectorAll('div[data-key]').forEach(div => { if (div.dataset.key !== 'set' && div.dataset.key !== 'ai-search' && div.dataset.key !== 'ai-deep-dive') div.classList.toggle('selected', div.dataset.key === (k || 'null')); }); helperBtn.classList.toggle('active', !!k); helperPromptWrap.style.display = 'none'; console.log("Helper AI:", k); };
    const toggleHelperPromptInput = () => { const iV = helperPromptWrap.style.display === 'block'; helperPromptWrap.style.display = iV ? 'none' : 'block'; if (!iV) helperPromptInput.focus(); };
    const updateHelperPrompt = () => { helperAiPrompt = helperPromptInput.value.trim(); };

    const callAndProcessMainApi = async (hist, userMsgContentForHist) => {
        let mainPK, modelNameForError = '';
        if (currentMode === 'deepThinking') { mainPK = 'GEMINI'; modelNameForError = 'DeepThinking (Gemini)'; }
        else if (currentMode === 'turbo') { mainPK = 'SAMBANOVA'; modelNameForError = 'Turbo (SambaNova)'; }
        else if (currentMode === 'proxy') { mainPK = 'BIGMODEL_PROXY'; modelNameForError = 'Proxy (BigModel)'; }
        else { mainPK = 'DEEPSEEK'; modelNameForError = 'Default (DeepSeek)'; if (currentMode !== null) console.warn(`Unrec mode ${currentMode}, -> DeepSeek.`); else if (msgHist.length === 0) { alert("Select mode (💡, ⚡, 🌐)."); return { error: true, reason: 'mode_not_selected' }; } }
        const mainCfg = PROVIDERS[mainPK]; if (!mainCfg) { console.error(`Internal Err: Provider cfg miss ${mainPK} (mode: ${currentMode})`); appendMsg(`<i>Internal Error: Invalid mode cfg.</i>`, 'assistant'); return { error: true, reason: 'config' }; }
        const mainKeys = getApiKeys()[mainPK] || []; if (mainCfg.apiKeyLocation !== 'none' && mainCfg.format !== 'proxy_compatible' && mainKeys.length === 0) { alert(`API Key missing for ${modelNameForError}. Use 🔑.`); showApiKeyModal(); return { error: true, reason: 'key' }; }
        const historyToSend = [...hist]; const agis = getAgis(); const agiData = currentAgiKey ? agis[currentAgiKey] : null; const sysPromptText = agiData?.prompt || "You are a helpful assistant.";
        if (sysPromptText && sysPromptText !== "You are a helpful assistant." && (mainCfg.supportsSystemPromptInMessages || mainPK === 'GEMINI')) { if (historyToSend.length > 0 && historyToSend[0].role === 'system') historyToSend[0].content = sysPromptText; else historyToSend.unshift({ role: "system", content: sysPromptText }); }
        else if (historyToSend.length > 0 && historyToSend[0].role === 'system' && !(mainCfg.supportsSystemPromptInMessages || mainPK === 'GEMINI')) { historyToSend.shift(); console.warn(`Removed sys prompt for ${mainPK} (unsupported).`); }
        const mainTk = appendMsg("<i>Thinking...</i>", 'assistant', true, true); let mainResponse = null, mainError = null, mainKeyUsed = null; const mainGoodIdx = getGoodKeyIndices(); const mainStartIdx = mainGoodIdx[mainPK] ?? 0; const numAttempts = (mainCfg.apiKeyLocation !== 'none' && mainCfg.format !== 'proxy_compatible') ? mainKeys.length : 1;
        for (let i = 0; i < numAttempts; i++) {
            let cKey = null;
            if (numAttempts > 1) { const cIdx = (mainStartIdx + i) % mainKeys.length; cKey = mainKeys[cIdx]; mainKeyUsed = cIdx; console.log(`Try Main ${mainPK} key ${cIdx}`); }
            else if (mainCfg.apiKeyLocation !== 'none' && mainCfg.format !== 'proxy_compatible') { cKey = mainKeys[0]; mainKeyUsed = 0; console.log(`Try Main ${mainPK} only key 0`); }
            else console.log(`Try Main ${mainPK} (no key/single attempt)`);
            try { mainResponse = await getApiResponse(mainPK, historyToSend, cKey, { temperature: 0.7, top_p: 0.9 }); if (mainKeyUsed !== null) { mainGoodIdx[mainPK] = mainKeyUsed; saveGoodKeyIndices(mainGoodIdx); console.log(`Main OK ${mainPK} key ${mainKeyUsed}`); } else console.log(`Main OK ${mainPK}`); break; }
            catch (err) { console.error(`Main Attempt ${i+1} fail ${mainPK}:`, err); mainError = err; if (mainKeyUsed !== null) console.error(`(Key idx: ${mainKeyUsed})`); mainKeyUsed = null; }
        }
        if (mainTk && mainTk.parentNode === chatCont) chatCont.removeChild(mainTk);
        if (mainResponse !== null) { if (userMsgContentForHist) msgHist.push({ role: "user", content: userMsgContentForHist }); msgHist.push({ role: "assistant", content: mainResponse }); appendMsg(mainResponse, 'assistant', true, false, msgHist.length - 1); saveUpdateChat(currentChatName, msgHist); const currentChatData = getChats()[currentChatName]; if (currentChatData && currentChatData.title !== chatTitle.textContent) { chatTitle.textContent = currentChatData.title; updateHistList(); } return { error: false }; }
        else { console.error(`All API attempts failed ${mainPK}. Last:`, mainError); const errorMsg = `<i>Error: API call fail ${modelNameForError}. ${mainError?.message || String(mainError)}</i>`; appendMsg(errorMsg, 'assistant'); return { error: true, message: errorMsg }; }
    };

    const sendMessage = async () => {
        const rawUserContent = uInput.value.trim(); if (!rawUserContent && editingMsgIndex === null) { if (currentMode === null) alert("Select mode (💡, ⚡, 🌐) first."); else alert("Enter message."); return; } if (currentMode === null && editingMsgIndex === null) { alert("Select mode (💡, ⚡, 🌐)."); return; }
        if (editingMsgIndex !== null) {
            console.log(`Editing msg idx: ${editingMsgIndex}`); const originalMsgHist = [...msgHist]; const targetIndex = editingMsgIndex; if (targetIndex < 0 || targetIndex >= originalMsgHist.length || originalMsgHist[targetIndex].role !== 'user') { console.error("Invalid edit idx:", targetIndex); cancelEdit(); return; }
            let modifiedHist = [...originalMsgHist]; modifiedHist[targetIndex].content = rawUserContent; modifiedHist = modifiedHist.slice(0, targetIndex + 1); msgHist = modifiedHist; rerenderChat(); uInput.value = ''; checkWelcome();
            const result = await callAndProcessMainApi(modifiedHist, null);
            if (result.error) { console.log("Edit fail, rolling back."); msgHist = originalMsgHist; rerenderChat(); appendMsg(`<i>Edit fail. ${result.message || ""}</i>`, 'assistant'); } else { saveUpdateChat(currentChatName, msgHist); console.log("Edit OK."); } cancelEdit(); return;
        }
        let finalUserContent = rawUserContent;
        if (helperAiKey && helperAiPrompt && PROVIDERS[helperAiKey]) {
            console.log(`Using Helper ${helperAiKey} w/ prompt.`); const hCfg = PROVIDERS[helperAiKey]; const hK = getApiKeys()[helperAiKey] || []; if (hCfg.apiKeyLocation !== 'none' && hCfg.format !== 'proxy_compatible' && hK.length === 0) { alert(`Key missing Helper ${hCfg.name}. Use 🔑.`); showApiKeyModal(); return; }
            const tM = appendMsg("<i>Helper AI...</i>", 'assistant', true, true); let hM = [...msgHist]; if (helperAiPrompt) hM.unshift({ role: "system", content: helperAiPrompt }); hM.push({ role: "user", content: rawUserContent });
            let hR = null, hAE = null; const hGI = getGoodKeyIndices(); const hSI = hGI[helperAiKey] ?? 0; const nHA = (hCfg.apiKeyLocation !== 'none' && hCfg.format !== 'proxy_compatible') ? hK.length : 1;
            for (let i = 0; i < nHA; i++) {
                let cK = null, cI = null; if (nHA > 1) { cI = (hSI + i) % hK.length; cK = hK[cI]; console.log(`Try Helper ${helperAiKey} key ${cI}`); } else if (nHA === 1 && hCfg.apiKeyLocation !== 'none' && hCfg.format !== 'proxy_compatible') { cI = 0; cK = hK[0]; console.log(`Try Helper ${helperAiKey} only key`); } else console.log(`Try Helper ${helperAiKey} (no key/single)`);
                try { hR = await getApiResponse(helperAiKey, hM, cK, { temperature: 0.5, top_p: 0.9 }); if (cI !== null) { hGI[helperAiKey] = cI; saveGoodKeyIndices(hGI); console.log(`Helper ${helperAiKey} OK key ${cI}`); } else console.log(`Helper ${helperAiKey} OK`); break; }
                catch (err) { console.error(`Helper Attempt ${i+1} fail ${helperAiKey}:`, err); hAE = err; if (cI !== null) console.error(`(Helper key idx: ${cI})`); }
            }
            if (tM && tM.parentNode === chatCont) chatCont.removeChild(tM);
            if (hR !== null) { finalUserContent = hR; console.log("Helper OK. Use response."); } else { appendMsg(`<i>Helper ${hCfg?.name || helperAiKey} fail: ${hAE?.message || String(hAE)}. Sending original.</i>`, 'assistant'); console.error("Helper fail. Send original."); }
        }
        uInput.value = ''; checkWelcome(); if (!currentChatName) { currentChatName = genName(); console.log("New chat:", currentChatName); }
        const tempUserMsgIndex = msgHist.length; appendMsg(finalUserContent, 'user', true, false, tempUserMsgIndex);
        const historyForApi = [...msgHist];
        const result = await callAndProcessMainApi(historyForApi, finalUserContent);
        if (result.error && result.reason !== 'mode_not_selected') { console.error("Main API fail post-send."); const uME = chatCont.querySelector(`.msg-wrap[data-msg-index="${tempUserMsgIndex}"]`); if (uME) chatCont.removeChild(uME); checkWelcome(); uInput.value = rawUserContent; }
        else if (!result.error) console.log("Main API OK.");
    };

    const startEditingMessage = (idx) => { if (idx < 0 || idx >= msgHist.length || msgHist[idx].role !== 'user') { console.warn("Cannot edit idx:", idx); return; } editingMsgIndex = idx; uInput.value = msgHist[idx].content; uInput.focus(); editIndicator.style.display = 'inline-block'; hideCtxMenus(); };
    const cancelEdit = () => { editingMsgIndex = null; uInput.value = ''; editIndicator.style.display = 'none'; };
    const regenerateMessage = async (idx) => { hideCtxMenus(); const oMH = [...msgHist]; if (idx <= 0 || idx >= oMH.length || oMH[idx].role !== 'assistant' || oMH[idx-1].role !== 'user') { alert("Can only regen AI response after user msg."); return; } let tH = oMH.slice(0, idx); msgHist = tH; rerenderChat(); let hFG = [...msgHist]; checkWelcome(); const res = await callAndProcessMainApi(hFG, null); if (res.error) { console.log("Regen fail, rollback."); msgHist = oMH; rerenderChat(); appendMsg(`<i>Regen fail. ${res.message || ""}</i>`, 'assistant');} else { saveUpdateChat(currentChatName, msgHist); console.log("Regen OK.");} };
    const copyMessageContent = (idx) => { if (idx < 0 || idx >= msgHist.length) return; copyToClipboard(msgHist[idx].content); hideCtxMenus(); };

    const toggleSidebar=()=>appCont.classList.toggle('sidebar-collapsed');
    const showHistCtxMenu=(e)=>{e.preventDefault();hideCtxMenus();const li=e.target.closest('li');if(!li)return;ctxTargetName=li.dataset.name;histCtxMenu.style.cssText=`top:${e.clientY}px;left:${e.clientX}px;display:block;`};
    const showMessageCtxMenu=(e)=>{ const mW = e.target.closest('.msg-wrap'); if (!mW) { hideCtxMenus(); return; } e.preventDefault(); hideCtxMenus(); const idx = parseInt(mW.dataset.msgIndex, 10); if (isNaN(idx) || idx < 0 || idx >= msgHist.length) return; ctxTargetMsgIndex = idx; const mD = msgHist[idx]; const iU = mD.role === 'user'; const cR = !iU && idx > 0 && msgHist[idx-1].role === 'user'; msgCtxMenu.querySelector('[data-action="edit"]').style.display = iU ? 'block' : 'none'; msgCtxMenu.querySelector('[data-action="regenerate"]').style.display = cR ? 'block' : 'none'; msgCtxMenu.querySelector('[data-action="copy"]').style.display = 'block'; msgCtxMenu.style.cssText = `top:${e.clientY}px;left:${e.clientX}px;display:block;`; };
    const hideCtxMenus=()=>{histCtxMenu.style.display='none';msgCtxMenu.style.display='none';ctxTargetName=null;ctxTargetMsgIndex=null;};

    function loadSerperKey() { serperApiKey = localStorage.getItem(SERPER_KEY_STORE) || ''; }
    function getCurrentAiConfig() {
        console.log("Get AI cfg for ext app. Mode:", currentMode); let pK, mNFE = '', uP = false;
        if (currentMode === 'deepThinking') { pK = 'GEMINI'; mNFE = 'DeepThinking'; }
        else if (currentMode === 'turbo') { pK = 'SAMBANOVA'; mNFE = 'Turbo'; }
        else if (currentMode === 'proxy') { pK = 'BIGMODEL_PROXY'; mNFE = 'Proxy'; uP = true; }
        else { pK = 'DEEPSEEK'; mNFE = 'Default'; if (currentMode !== null) console.warn(`Unrec mode ${currentMode} for ext app -> DeepSeek.`); else { alert("Select mode (💡, ⚡, 🌐) for AI Search/Deep Dive."); return null; } }
        const pC = PROVIDERS[pK]; if (!pC) { console.error("ERR: Miss provider cfg ext:", pK); alert("Internal Err: Miss AI provider cfg."); return null; }
        const aKA = getApiKeys()[pK] || []; const fAK = aKA[0] || null;
        if (!fAK && pC.apiKeyLocation !== 'none' && pC.format !== 'proxy_compatible') { console.error(`Key miss ${mNFE} for ext app.`); alert(`Cannot start ext app. Key miss ${mNFE}. Use 🔑.`); showApiKeyModal(); return null; }
        let cfg = { aiModel: pC.defaultModel, aiApiUrl: null, aiApiToken: fAK, usingProxy: uP, providerFormat: pC.format, apiKeyLocation: pC.apiKeyLocation, authHeaderPrefix: pC.authHeaderPrefix, apiKeyQueryParam: pC.apiKeyQueryParam };
        if (pC.format === "gemini_generateContent") cfg.aiApiUrl = pC.baseURL;
        else if (pC.format === "openai_compatible") cfg.aiApiUrl = pC.baseURL;
        else if (pC.format === "proxy_compatible") cfg.aiApiUrl = pC.baseURL;
        else { console.error("ERR: Unsupp format ext app:", pC.format); alert("Internal Err: Cannot cfg ext app format."); return null; }
        console.log(`AI Cfg Ext: M=${cfg.aiModel}, URL=${cfg.aiApiUrl}, Tkn=...${cfg.aiApiToken ? cfg.aiApiToken.slice(-4) : 'NONE'}, Proxy=${cfg.usingProxy}, Fmt=${cfg.providerFormat}`); return cfg;
    }
    function openExternalAppModal(aU, cP, eMP = "Error") { console.log(`Open Modal iframe: ${aU}`); searchFrame.src = aU; searchModalOverlay.style.display = 'flex'; searchFrame.onload = () => { console.log(`Frame loaded ${aU}. Send cfg:`, cP); try { searchFrame.contentWindow.postMessage({ type: 'config', payload: cP }, '*'); } catch (e) { console.error("postMessage err:", e); alert(`${eMP}: Err comm ext win.`); closeSearchModal(); } searchFrame.onload = null; }; searchFrame.onerror = () => { console.error(`Fail load iframe: ${aU}`); alert(`${eMP}: Err load app.`); closeSearchModal(); searchFrame.onerror = null; } }
    function openAiSearch() { if (!serperApiKey) { alert('AI Search needs Serper key. Use 🔑.'); showApiKeyModal(); return; } const cA = getCurrentAiConfig(); if (!cA) return; const cP = { serperApiKey: serperApiKey, ...cA }; openExternalAppModal(SEARCH_APP_URL, cP, "AI Search Error"); }
    function openAiDeepDive() { const cA = getCurrentAiConfig(); if (!cA) return; const cP = { ...cA }; openExternalAppModal(DEEP_DIVE_APP_URL, cP, "AI Deep Dive Error"); }
    function closeSearchModal() { searchModalOverlay.style.display = 'none'; searchFrame.src = 'about:blank'; }

    let mic_mediaRecorder; let mic_audioChunks = []; let mic_isRecording = false; let mic_stream; let mic_recordedMimeType = 'audio/webm;codecs=opus';
    function mic_updateStatus(m, t = 'info') { if (!micStatusSpan) return; micStatusSpan.textContent = m; micStatusSpan.className = t; }
    function mic_resetButton() { mic_isRecording = false; micTranscribeBtn.classList.remove('recording'); micButtonText.textContent = 'Record'; mic_updateStatus(''); }
    function mic_stopMicTracks() { if (mic_stream) { mic_stream.getTracks().forEach(t => t.stop()); mic_stream = null; } }
    async function mic_startRecording() { if (mic_isRecording) return; const gPK = 'GEMINI'; const gK = getApiKeys()[gPK] || []; const gAK = gK[0]; const gPC = PROVIDERS[gPK]; if (!gPC) { alert("Gemini cfg missing."); return; } if (!gAK && gPC.apiKeyLocation !== 'none') { mic_updateStatus('Gemini Key!', 'error'); alert(`Transcribe needs Gemini Key (${gPC.name}). Use 🔑.`); showApiKeyModal(); return; } mic_updateStatus('Req. Mic...'); uInput.value = '[Recording...]'; try { mic_stream = await navigator.mediaDevices.getUserMedia({ audio: true }); mic_updateStatus('Init Rec...'); const o = {}; if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) o.mimeType = 'audio/webm;codecs=opus'; else if (MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) o.mimeType = 'audio/ogg;codecs=opus'; else if (MediaRecorder.isTypeSupported('audio/webm')) o.mimeType = 'audio/webm'; else if (MediaRecorder.isTypeSupported('audio/ogg')) o.mimeType = 'audio/ogg'; mic_mediaRecorder = new MediaRecorder(mic_stream, o); mic_recordedMimeType = mic_mediaRecorder.mimeType; mic_audioChunks = []; mic_mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) mic_audioChunks.push(e.data); }; mic_mediaRecorder.onstop = async () => { mic_updateStatus('Processing...'); const aB = new Blob(mic_audioChunks, { type: mic_recordedMimeType }); mic_audioChunks = []; mic_stopMicTracks(); if (aB.size === 0) { console.error("Audio Blob empty."); mic_updateStatus('No audio.', 'error'); uInput.value = ''; mic_resetButton(); return; } await mic_sendAudioToGemini(aB, gAK, mic_recordedMimeType, gPC); }; mic_mediaRecorder.onerror = (e) => { console.error("Recorder err:", e.error); mic_updateStatus(`Rec Err: ${e.error.name}`, 'error'); uInput.value = ''; mic_stopMicTracks(); mic_resetButton(); }; mic_mediaRecorder.start(); mic_isRecording = true; mic_updateStatus('🔴 Recording'); micTranscribeBtn.classList.add('recording'); micButtonText.textContent = 'Stop'; } catch (err) { console.error('Mic/Rec start err:', err); let eM = `Err: ${err.message}`; if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") eM = "Mic denied."; else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError") eM = "No mic."; else eM = `Start Err: ${err.name}`; mic_updateStatus(eM, 'error'); uInput.value = ''; mic_stopMicTracks(); mic_resetButton(); } }
    function mic_stopRecording() { if (!mic_isRecording || !mic_mediaRecorder || mic_mediaRecorder.state === 'inactive') { if(mic_isRecording || mic_mediaRecorder?.state !== 'inactive') mic_resetButton(); return; } mic_updateStatus('Stopping...'); mic_mediaRecorder.stop(); }
    async function mic_sendAudioToGemini(aB, aK, mT, pC) { mic_updateStatus('Converting...'); const r = new FileReader(); r.readAsDataURL(aB); r.onloadend = async () => { const b64A = r.result.split(',')[1]; if (!b64A) { console.error("Base64 fail."); mic_updateStatus('Audio Err', 'error'); uInput.value = ''; mic_resetButton(); return; } const mN = "gemini-2.0-flash"; let API_URL = `${pC.baseURL}${mN}:generateContent`; if (pC.apiKeyLocation === "query" && pC.apiKeyQueryParam && aK) API_URL += `?${pC.apiKeyQueryParam}=${aK}`; else if (pC.apiKeyLocation !== "none" && !aK) { console.error("Gemini Key missing trans."); mic_updateStatus('Key Error', 'error'); mic_resetButton(); return; } const rB = { contents: [{ parts: [ { "text": "Transcribe accurately:" }, { "inlineData": { "mimeType": mT, "data": b64A } } ] }] }; mic_updateStatus('Sending API...'); try { const rsp = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(rB) }); const d = await rsp.json(); if (!rsp.ok) { console.error("Gemini API Err:", d); let eM = `API Err: ${rsp.status}`; if (d.error?.message) eM = `API Err: ${d.error.message.substring(0, 50)}...`; throw new Error(eM); } let t = "[Not found]"; let bR = d.promptFeedback?.blockReason; if (bR) { t = `Blocked: ${bR}`; mic_updateStatus('Blocked', 'error'); } else if (d.candidates?.[0]?.content?.parts?.[0]?.text) { t = d.candidates[0].content.parts[0].text.trim(); mic_updateStatus('Done!', 'success'); uInput.value = t; uInput.focus(); } else if (d.candidates?.[0]?.finishReason && d.candidates[0].finishReason !== 'STOP') { t = `[Stop: ${d.candidates[0].finishReason}]`; mic_updateStatus('Stopped', 'error'); } else { t = "[Parse Err]"; mic_updateStatus('Parse Err', 'error'); } if (t.startsWith('[') || t.startsWith('Blocked')) uInput.value = t; } catch (e) { console.error('Gemini API call err:', e); mic_updateStatus(`${e.message}`, 'error'); uInput.value = `[Transcribe Error]`; } finally { mic_resetButton(); setTimeout(() => { if (micStatusSpan.className !== 'error') mic_updateStatus(''); }, 3000); } }; r.onerror = (e) => { console.error("FileReader err:", e); mic_updateStatus('Read Err', 'error'); uInput.value = ''; mic_resetButton(); }; }

    uInput.onkeypress=(e)=>{if(e.key==='Enter'&&!e.shiftKey){e.preventDefault();sendMessage()}};
    document.onclick=(e)=>{ const t=e.target; if (!helperMenu.contains(t) && !t.closest('#helper-ai-btn')) helperMenu.style.display = 'none'; if (!t.closest('.ctx-menu')) hideCtxMenus(); const iAKMC = t.closest('#api-key-modal .modal-content') || t.closest('#api-key-btn'); const iAMC = t.closest('#agi-modal .modal-content') || t.closest('#agi-btn'); if (!iAKMC && apiKeyModal.style.display === 'flex') hideApiKeyModal(); if (!iAMC && agiModal.style.display === 'flex') hideAgiModal(); if (searchModalOverlay.style.display === 'flex' && t === searchModalOverlay) closeSearchModal(); };
    histCtxMenu.onclick=(e)=>{const a=e.target.dataset.action;if(!ctxTargetName||!a)return;if(a==='rename')renameChat(ctxTargetName);if(a==='delete')deleteChat(ctxTargetName);hideCtxMenus()};
    msgCtxMenu.onclick=(e)=>{const a=e.target.dataset.action;if(ctxTargetMsgIndex===null||!a)return;if(a==='copy')copyMessageContent(ctxTargetMsgIndex);if(a==='edit')startEditingMessage(ctxTargetMsgIndex);if(a==='regenerate')regenerateMessage(ctxTargetMsgIndex);hideCtxMenus()};
    helperPromptInput.addEventListener('input', updateHelperPrompt);
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && searchModalOverlay.style.display === 'flex') closeSearchModal(); });
    micTranscribeBtn.addEventListener('click', () => { if (mic_isRecording) mic_stopRecording(); else mic_startRecording(); });

    loadSerperKey();
    currentAgiKey=getActiveAgiKey();
    updateProxyButtonVisibility();
    const lastChatName = Object.keys(getChats()).sort((a, b) => (getChats()[b].ts || 0) - (getChats()[a].ts || 0))[0];
    if (lastChatName) loadChat(lastChatName); else startNewChat();
    selectHelperAi(null);
    console.log("App Init. Mode:", currentMode);
</script>
</body>
</html>
